var $protobuf = window.protobuf;
$protobuf.roots.default=window;
// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.luck = (function() {

    /**
     * Namespace luck.
     * @exports luck
     * @namespace
     */
    var luck = {};

    luck.protobuf = (function() {

        /**
         * Namespace protobuf.
         * @memberof luck
         * @namespace
         */
        var protobuf = {};

        protobuf.PlayerPB = (function() {

            /**
             * Properties of a PlayerPB.
             * @memberof luck.protobuf
             * @interface IPlayerPB
             * @property {luck.protobuf.IPlayerBasePB} playerBasePB PlayerPB playerBasePB
             * @property {Array.<luck.protobuf.IWeaponPB>|null} [weaponList] PlayerPB weaponList
             * @property {Array.<luck.protobuf.ICardPB>|null} [cardList] PlayerPB cardList
             * @property {Array.<luck.protobuf.IClothesPB>|null} [clothesList] PlayerPB clothesList
             * @property {luck.protobuf.IItemBagPB} itemBag PlayerPB itemBag
             * @property {Array.<luck.protobuf.ICheckNode>|null} [checkNodeList] PlayerPB checkNodeList
             * @property {luck.protobuf.IPlayerExtraPB} playerExtraPB PlayerPB playerExtraPB
             * @property {Array.<luck.protobuf.IMainTaskPB>|null} [mainTaskList] PlayerPB mainTaskList
             * @property {Array.<luck.protobuf.IDailyTaskPB>|null} [dailyTaskList] PlayerPB dailyTaskList
             * @property {Array.<luck.protobuf.IWeekTaskPB>|null} [weekTaskList] PlayerPB weekTaskList
             * @property {Array.<luck.protobuf.IRewardTaskPB>|null} [rewardTaskList] PlayerPB rewardTaskList
             * @property {number} dailyTaskActivity PlayerPB dailyTaskActivity
             * @property {Array.<number>|null} [dailyVitalityRewardList] PlayerPB dailyVitalityRewardList
             * @property {number|Long} havePVETeamId PlayerPB havePVETeamId
             * @property {Array.<luck.protobuf.IAchievementTaskPB>|null} [achievementTaskList] PlayerPB achievementTaskList
             * @property {number|Long} achievementPoint PlayerPB achievementPoint
             * @property {Array.<luck.protobuf.IAchievementTypePB>|null} [achievementType1List] PlayerPB achievementType1List
             * @property {Array.<luck.protobuf.IAchievementTypePB>|null} [achievementType2List] PlayerPB achievementType2List
             * @property {Array.<luck.protobuf.IActivityTaskPB>|null} [activityTaskList] PlayerPB activityTaskList
             * @property {luck.protobuf.IGameSystemPB} gameSystem PlayerPB gameSystem
             * @property {Array.<luck.protobuf.IactivityTaskRewardPB>|null} [activityTaskRewardList] PlayerPB activityTaskRewardList
             * @property {Array.<luck.protobuf.ISpecialTaskPB>|null} [specialTaskList] PlayerPB specialTaskList
             * @property {Array.<luck.protobuf.IRolePB>|null} [roleList] PlayerPB roleList
             * @property {number} gangTaskActivity PlayerPB gangTaskActivity
             * @property {Array.<number>|null} [gangVitalityRewardList] PlayerPB gangVitalityRewardList
             * @property {Array.<luck.protobuf.IGangTaskPB>|null} [gangTaskList] PlayerPB gangTaskList
             */

            /**
             * Constructs a new PlayerPB.
             * @memberof luck.protobuf
             * @classdesc Represents a PlayerPB.
             * @implements IPlayerPB
             * @constructor
             * @param {luck.protobuf.IPlayerPB=} [properties] Properties to set
             */
            function PlayerPB(properties) {
                this.weaponList = [];
                this.cardList = [];
                this.clothesList = [];
                this.checkNodeList = [];
                this.mainTaskList = [];
                this.dailyTaskList = [];
                this.weekTaskList = [];
                this.rewardTaskList = [];
                this.dailyVitalityRewardList = [];
                this.achievementTaskList = [];
                this.achievementType1List = [];
                this.achievementType2List = [];
                this.activityTaskList = [];
                this.activityTaskRewardList = [];
                this.specialTaskList = [];
                this.roleList = [];
                this.gangVitalityRewardList = [];
                this.gangTaskList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PlayerPB playerBasePB.
             * @member {luck.protobuf.IPlayerBasePB} playerBasePB
             * @memberof luck.protobuf.PlayerPB
             * @instance
             */
            PlayerPB.prototype.playerBasePB = null;

            /**
             * PlayerPB weaponList.
             * @member {Array.<luck.protobuf.IWeaponPB>} weaponList
             * @memberof luck.protobuf.PlayerPB
             * @instance
             */
            PlayerPB.prototype.weaponList = $util.emptyArray;

            /**
             * PlayerPB cardList.
             * @member {Array.<luck.protobuf.ICardPB>} cardList
             * @memberof luck.protobuf.PlayerPB
             * @instance
             */
            PlayerPB.prototype.cardList = $util.emptyArray;

            /**
             * PlayerPB clothesList.
             * @member {Array.<luck.protobuf.IClothesPB>} clothesList
             * @memberof luck.protobuf.PlayerPB
             * @instance
             */
            PlayerPB.prototype.clothesList = $util.emptyArray;

            /**
             * PlayerPB itemBag.
             * @member {luck.protobuf.IItemBagPB} itemBag
             * @memberof luck.protobuf.PlayerPB
             * @instance
             */
            PlayerPB.prototype.itemBag = null;

            /**
             * PlayerPB checkNodeList.
             * @member {Array.<luck.protobuf.ICheckNode>} checkNodeList
             * @memberof luck.protobuf.PlayerPB
             * @instance
             */
            PlayerPB.prototype.checkNodeList = $util.emptyArray;

            /**
             * PlayerPB playerExtraPB.
             * @member {luck.protobuf.IPlayerExtraPB} playerExtraPB
             * @memberof luck.protobuf.PlayerPB
             * @instance
             */
            PlayerPB.prototype.playerExtraPB = null;

            /**
             * PlayerPB mainTaskList.
             * @member {Array.<luck.protobuf.IMainTaskPB>} mainTaskList
             * @memberof luck.protobuf.PlayerPB
             * @instance
             */
            PlayerPB.prototype.mainTaskList = $util.emptyArray;

            /**
             * PlayerPB dailyTaskList.
             * @member {Array.<luck.protobuf.IDailyTaskPB>} dailyTaskList
             * @memberof luck.protobuf.PlayerPB
             * @instance
             */
            PlayerPB.prototype.dailyTaskList = $util.emptyArray;

            /**
             * PlayerPB weekTaskList.
             * @member {Array.<luck.protobuf.IWeekTaskPB>} weekTaskList
             * @memberof luck.protobuf.PlayerPB
             * @instance
             */
            PlayerPB.prototype.weekTaskList = $util.emptyArray;

            /**
             * PlayerPB rewardTaskList.
             * @member {Array.<luck.protobuf.IRewardTaskPB>} rewardTaskList
             * @memberof luck.protobuf.PlayerPB
             * @instance
             */
            PlayerPB.prototype.rewardTaskList = $util.emptyArray;

            /**
             * PlayerPB dailyTaskActivity.
             * @member {number} dailyTaskActivity
             * @memberof luck.protobuf.PlayerPB
             * @instance
             */
            PlayerPB.prototype.dailyTaskActivity = 0;

            /**
             * PlayerPB dailyVitalityRewardList.
             * @member {Array.<number>} dailyVitalityRewardList
             * @memberof luck.protobuf.PlayerPB
             * @instance
             */
            PlayerPB.prototype.dailyVitalityRewardList = $util.emptyArray;

            /**
             * PlayerPB havePVETeamId.
             * @member {number|Long} havePVETeamId
             * @memberof luck.protobuf.PlayerPB
             * @instance
             */
            PlayerPB.prototype.havePVETeamId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PlayerPB achievementTaskList.
             * @member {Array.<luck.protobuf.IAchievementTaskPB>} achievementTaskList
             * @memberof luck.protobuf.PlayerPB
             * @instance
             */
            PlayerPB.prototype.achievementTaskList = $util.emptyArray;

            /**
             * PlayerPB achievementPoint.
             * @member {number|Long} achievementPoint
             * @memberof luck.protobuf.PlayerPB
             * @instance
             */
            PlayerPB.prototype.achievementPoint = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PlayerPB achievementType1List.
             * @member {Array.<luck.protobuf.IAchievementTypePB>} achievementType1List
             * @memberof luck.protobuf.PlayerPB
             * @instance
             */
            PlayerPB.prototype.achievementType1List = $util.emptyArray;

            /**
             * PlayerPB achievementType2List.
             * @member {Array.<luck.protobuf.IAchievementTypePB>} achievementType2List
             * @memberof luck.protobuf.PlayerPB
             * @instance
             */
            PlayerPB.prototype.achievementType2List = $util.emptyArray;

            /**
             * PlayerPB activityTaskList.
             * @member {Array.<luck.protobuf.IActivityTaskPB>} activityTaskList
             * @memberof luck.protobuf.PlayerPB
             * @instance
             */
            PlayerPB.prototype.activityTaskList = $util.emptyArray;

            /**
             * PlayerPB gameSystem.
             * @member {luck.protobuf.IGameSystemPB} gameSystem
             * @memberof luck.protobuf.PlayerPB
             * @instance
             */
            PlayerPB.prototype.gameSystem = null;

            /**
             * PlayerPB activityTaskRewardList.
             * @member {Array.<luck.protobuf.IactivityTaskRewardPB>} activityTaskRewardList
             * @memberof luck.protobuf.PlayerPB
             * @instance
             */
            PlayerPB.prototype.activityTaskRewardList = $util.emptyArray;

            /**
             * PlayerPB specialTaskList.
             * @member {Array.<luck.protobuf.ISpecialTaskPB>} specialTaskList
             * @memberof luck.protobuf.PlayerPB
             * @instance
             */
            PlayerPB.prototype.specialTaskList = $util.emptyArray;

            /**
             * PlayerPB roleList.
             * @member {Array.<luck.protobuf.IRolePB>} roleList
             * @memberof luck.protobuf.PlayerPB
             * @instance
             */
            PlayerPB.prototype.roleList = $util.emptyArray;

            /**
             * PlayerPB gangTaskActivity.
             * @member {number} gangTaskActivity
             * @memberof luck.protobuf.PlayerPB
             * @instance
             */
            PlayerPB.prototype.gangTaskActivity = 0;

            /**
             * PlayerPB gangVitalityRewardList.
             * @member {Array.<number>} gangVitalityRewardList
             * @memberof luck.protobuf.PlayerPB
             * @instance
             */
            PlayerPB.prototype.gangVitalityRewardList = $util.emptyArray;

            /**
             * PlayerPB gangTaskList.
             * @member {Array.<luck.protobuf.IGangTaskPB>} gangTaskList
             * @memberof luck.protobuf.PlayerPB
             * @instance
             */
            PlayerPB.prototype.gangTaskList = $util.emptyArray;

            /**
             * Creates a new PlayerPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.PlayerPB
             * @static
             * @param {luck.protobuf.IPlayerPB=} [properties] Properties to set
             * @returns {luck.protobuf.PlayerPB} PlayerPB instance
             */
            PlayerPB.create = function create(properties) {
                return new PlayerPB(properties);
            };

            /**
             * Encodes the specified PlayerPB message. Does not implicitly {@link luck.protobuf.PlayerPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.PlayerPB
             * @static
             * @param {luck.protobuf.IPlayerPB} message PlayerPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PlayerPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                $root.luck.protobuf.PlayerBasePB.encode(message.playerBasePB, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.weaponList != null && message.weaponList.length)
                    for (var i = 0; i < message.weaponList.length; ++i)
                        $root.luck.protobuf.WeaponPB.encode(message.weaponList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.cardList != null && message.cardList.length)
                    for (var i = 0; i < message.cardList.length; ++i)
                        $root.luck.protobuf.CardPB.encode(message.cardList[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.clothesList != null && message.clothesList.length)
                    for (var i = 0; i < message.clothesList.length; ++i)
                        $root.luck.protobuf.ClothesPB.encode(message.clothesList[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                $root.luck.protobuf.ItemBagPB.encode(message.itemBag, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.checkNodeList != null && message.checkNodeList.length)
                    for (var i = 0; i < message.checkNodeList.length; ++i)
                        $root.luck.protobuf.CheckNode.encode(message.checkNodeList[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                $root.luck.protobuf.PlayerExtraPB.encode(message.playerExtraPB, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.mainTaskList != null && message.mainTaskList.length)
                    for (var i = 0; i < message.mainTaskList.length; ++i)
                        $root.luck.protobuf.MainTaskPB.encode(message.mainTaskList[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.dailyTaskList != null && message.dailyTaskList.length)
                    for (var i = 0; i < message.dailyTaskList.length; ++i)
                        $root.luck.protobuf.DailyTaskPB.encode(message.dailyTaskList[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.weekTaskList != null && message.weekTaskList.length)
                    for (var i = 0; i < message.weekTaskList.length; ++i)
                        $root.luck.protobuf.WeekTaskPB.encode(message.weekTaskList[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.rewardTaskList != null && message.rewardTaskList.length)
                    for (var i = 0; i < message.rewardTaskList.length; ++i)
                        $root.luck.protobuf.RewardTaskPB.encode(message.rewardTaskList[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.dailyTaskActivity);
                if (message.dailyVitalityRewardList != null && message.dailyVitalityRewardList.length)
                    for (var i = 0; i < message.dailyVitalityRewardList.length; ++i)
                        writer.uint32(/* id 13, wireType 0 =*/104).int32(message.dailyVitalityRewardList[i]);
                writer.uint32(/* id 14, wireType 0 =*/112).int64(message.havePVETeamId);
                if (message.achievementTaskList != null && message.achievementTaskList.length)
                    for (var i = 0; i < message.achievementTaskList.length; ++i)
                        $root.luck.protobuf.AchievementTaskPB.encode(message.achievementTaskList[i], writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                writer.uint32(/* id 16, wireType 0 =*/128).int64(message.achievementPoint);
                if (message.achievementType1List != null && message.achievementType1List.length)
                    for (var i = 0; i < message.achievementType1List.length; ++i)
                        $root.luck.protobuf.AchievementTypePB.encode(message.achievementType1List[i], writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                if (message.achievementType2List != null && message.achievementType2List.length)
                    for (var i = 0; i < message.achievementType2List.length; ++i)
                        $root.luck.protobuf.AchievementTypePB.encode(message.achievementType2List[i], writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
                if (message.activityTaskList != null && message.activityTaskList.length)
                    for (var i = 0; i < message.activityTaskList.length; ++i)
                        $root.luck.protobuf.ActivityTaskPB.encode(message.activityTaskList[i], writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
                $root.luck.protobuf.GameSystemPB.encode(message.gameSystem, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
                if (message.activityTaskRewardList != null && message.activityTaskRewardList.length)
                    for (var i = 0; i < message.activityTaskRewardList.length; ++i)
                        $root.luck.protobuf.activityTaskRewardPB.encode(message.activityTaskRewardList[i], writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
                if (message.specialTaskList != null && message.specialTaskList.length)
                    for (var i = 0; i < message.specialTaskList.length; ++i)
                        $root.luck.protobuf.SpecialTaskPB.encode(message.specialTaskList[i], writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
                if (message.roleList != null && message.roleList.length)
                    for (var i = 0; i < message.roleList.length; ++i)
                        $root.luck.protobuf.RolePB.encode(message.roleList[i], writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();
                writer.uint32(/* id 24, wireType 0 =*/192).int32(message.gangTaskActivity);
                if (message.gangVitalityRewardList != null && message.gangVitalityRewardList.length)
                    for (var i = 0; i < message.gangVitalityRewardList.length; ++i)
                        writer.uint32(/* id 25, wireType 0 =*/200).int32(message.gangVitalityRewardList[i]);
                if (message.gangTaskList != null && message.gangTaskList.length)
                    for (var i = 0; i < message.gangTaskList.length; ++i)
                        $root.luck.protobuf.GangTaskPB.encode(message.gangTaskList[i], writer.uint32(/* id 26, wireType 2 =*/210).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified PlayerPB message, length delimited. Does not implicitly {@link luck.protobuf.PlayerPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.PlayerPB
             * @static
             * @param {luck.protobuf.IPlayerPB} message PlayerPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PlayerPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PlayerPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.PlayerPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.PlayerPB} PlayerPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PlayerPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.PlayerPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.playerBasePB = $root.luck.protobuf.PlayerBasePB.decode(reader, reader.uint32());
                        break;
                    case 2:
                        if (!(message.weaponList && message.weaponList.length))
                            message.weaponList = [];
                        message.weaponList.push($root.luck.protobuf.WeaponPB.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.cardList && message.cardList.length))
                            message.cardList = [];
                        message.cardList.push($root.luck.protobuf.CardPB.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        if (!(message.clothesList && message.clothesList.length))
                            message.clothesList = [];
                        message.clothesList.push($root.luck.protobuf.ClothesPB.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        message.itemBag = $root.luck.protobuf.ItemBagPB.decode(reader, reader.uint32());
                        break;
                    case 6:
                        if (!(message.checkNodeList && message.checkNodeList.length))
                            message.checkNodeList = [];
                        message.checkNodeList.push($root.luck.protobuf.CheckNode.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        message.playerExtraPB = $root.luck.protobuf.PlayerExtraPB.decode(reader, reader.uint32());
                        break;
                    case 8:
                        if (!(message.mainTaskList && message.mainTaskList.length))
                            message.mainTaskList = [];
                        message.mainTaskList.push($root.luck.protobuf.MainTaskPB.decode(reader, reader.uint32()));
                        break;
                    case 9:
                        if (!(message.dailyTaskList && message.dailyTaskList.length))
                            message.dailyTaskList = [];
                        message.dailyTaskList.push($root.luck.protobuf.DailyTaskPB.decode(reader, reader.uint32()));
                        break;
                    case 10:
                        if (!(message.weekTaskList && message.weekTaskList.length))
                            message.weekTaskList = [];
                        message.weekTaskList.push($root.luck.protobuf.WeekTaskPB.decode(reader, reader.uint32()));
                        break;
                    case 11:
                        if (!(message.rewardTaskList && message.rewardTaskList.length))
                            message.rewardTaskList = [];
                        message.rewardTaskList.push($root.luck.protobuf.RewardTaskPB.decode(reader, reader.uint32()));
                        break;
                    case 12:
                        message.dailyTaskActivity = reader.int32();
                        break;
                    case 13:
                        if (!(message.dailyVitalityRewardList && message.dailyVitalityRewardList.length))
                            message.dailyVitalityRewardList = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.dailyVitalityRewardList.push(reader.int32());
                        } else
                            message.dailyVitalityRewardList.push(reader.int32());
                        break;
                    case 14:
                        message.havePVETeamId = reader.int64();
                        break;
                    case 15:
                        if (!(message.achievementTaskList && message.achievementTaskList.length))
                            message.achievementTaskList = [];
                        message.achievementTaskList.push($root.luck.protobuf.AchievementTaskPB.decode(reader, reader.uint32()));
                        break;
                    case 16:
                        message.achievementPoint = reader.int64();
                        break;
                    case 17:
                        if (!(message.achievementType1List && message.achievementType1List.length))
                            message.achievementType1List = [];
                        message.achievementType1List.push($root.luck.protobuf.AchievementTypePB.decode(reader, reader.uint32()));
                        break;
                    case 18:
                        if (!(message.achievementType2List && message.achievementType2List.length))
                            message.achievementType2List = [];
                        message.achievementType2List.push($root.luck.protobuf.AchievementTypePB.decode(reader, reader.uint32()));
                        break;
                    case 19:
                        if (!(message.activityTaskList && message.activityTaskList.length))
                            message.activityTaskList = [];
                        message.activityTaskList.push($root.luck.protobuf.ActivityTaskPB.decode(reader, reader.uint32()));
                        break;
                    case 20:
                        message.gameSystem = $root.luck.protobuf.GameSystemPB.decode(reader, reader.uint32());
                        break;
                    case 21:
                        if (!(message.activityTaskRewardList && message.activityTaskRewardList.length))
                            message.activityTaskRewardList = [];
                        message.activityTaskRewardList.push($root.luck.protobuf.activityTaskRewardPB.decode(reader, reader.uint32()));
                        break;
                    case 22:
                        if (!(message.specialTaskList && message.specialTaskList.length))
                            message.specialTaskList = [];
                        message.specialTaskList.push($root.luck.protobuf.SpecialTaskPB.decode(reader, reader.uint32()));
                        break;
                    case 23:
                        if (!(message.roleList && message.roleList.length))
                            message.roleList = [];
                        message.roleList.push($root.luck.protobuf.RolePB.decode(reader, reader.uint32()));
                        break;
                    case 24:
                        message.gangTaskActivity = reader.int32();
                        break;
                    case 25:
                        if (!(message.gangVitalityRewardList && message.gangVitalityRewardList.length))
                            message.gangVitalityRewardList = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.gangVitalityRewardList.push(reader.int32());
                        } else
                            message.gangVitalityRewardList.push(reader.int32());
                        break;
                    case 26:
                        if (!(message.gangTaskList && message.gangTaskList.length))
                            message.gangTaskList = [];
                        message.gangTaskList.push($root.luck.protobuf.GangTaskPB.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("playerBasePB"))
                    throw $util.ProtocolError("missing required 'playerBasePB'", { instance: message });
                if (!message.hasOwnProperty("itemBag"))
                    throw $util.ProtocolError("missing required 'itemBag'", { instance: message });
                if (!message.hasOwnProperty("playerExtraPB"))
                    throw $util.ProtocolError("missing required 'playerExtraPB'", { instance: message });
                if (!message.hasOwnProperty("dailyTaskActivity"))
                    throw $util.ProtocolError("missing required 'dailyTaskActivity'", { instance: message });
                if (!message.hasOwnProperty("havePVETeamId"))
                    throw $util.ProtocolError("missing required 'havePVETeamId'", { instance: message });
                if (!message.hasOwnProperty("achievementPoint"))
                    throw $util.ProtocolError("missing required 'achievementPoint'", { instance: message });
                if (!message.hasOwnProperty("gameSystem"))
                    throw $util.ProtocolError("missing required 'gameSystem'", { instance: message });
                if (!message.hasOwnProperty("gangTaskActivity"))
                    throw $util.ProtocolError("missing required 'gangTaskActivity'", { instance: message });
                return message;
            };

            /**
             * Decodes a PlayerPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.PlayerPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.PlayerPB} PlayerPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PlayerPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PlayerPB message.
             * @function verify
             * @memberof luck.protobuf.PlayerPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PlayerPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                {
                    var error = $root.luck.protobuf.PlayerBasePB.verify(message.playerBasePB);
                    if (error)
                        return "playerBasePB." + error;
                }
                if (message.weaponList != null && message.hasOwnProperty("weaponList")) {
                    if (!Array.isArray(message.weaponList))
                        return "weaponList: array expected";
                    for (var i = 0; i < message.weaponList.length; ++i) {
                        var error = $root.luck.protobuf.WeaponPB.verify(message.weaponList[i]);
                        if (error)
                            return "weaponList." + error;
                    }
                }
                if (message.cardList != null && message.hasOwnProperty("cardList")) {
                    if (!Array.isArray(message.cardList))
                        return "cardList: array expected";
                    for (var i = 0; i < message.cardList.length; ++i) {
                        var error = $root.luck.protobuf.CardPB.verify(message.cardList[i]);
                        if (error)
                            return "cardList." + error;
                    }
                }
                if (message.clothesList != null && message.hasOwnProperty("clothesList")) {
                    if (!Array.isArray(message.clothesList))
                        return "clothesList: array expected";
                    for (var i = 0; i < message.clothesList.length; ++i) {
                        var error = $root.luck.protobuf.ClothesPB.verify(message.clothesList[i]);
                        if (error)
                            return "clothesList." + error;
                    }
                }
                {
                    var error = $root.luck.protobuf.ItemBagPB.verify(message.itemBag);
                    if (error)
                        return "itemBag." + error;
                }
                if (message.checkNodeList != null && message.hasOwnProperty("checkNodeList")) {
                    if (!Array.isArray(message.checkNodeList))
                        return "checkNodeList: array expected";
                    for (var i = 0; i < message.checkNodeList.length; ++i) {
                        var error = $root.luck.protobuf.CheckNode.verify(message.checkNodeList[i]);
                        if (error)
                            return "checkNodeList." + error;
                    }
                }
                {
                    var error = $root.luck.protobuf.PlayerExtraPB.verify(message.playerExtraPB);
                    if (error)
                        return "playerExtraPB." + error;
                }
                if (message.mainTaskList != null && message.hasOwnProperty("mainTaskList")) {
                    if (!Array.isArray(message.mainTaskList))
                        return "mainTaskList: array expected";
                    for (var i = 0; i < message.mainTaskList.length; ++i) {
                        var error = $root.luck.protobuf.MainTaskPB.verify(message.mainTaskList[i]);
                        if (error)
                            return "mainTaskList." + error;
                    }
                }
                if (message.dailyTaskList != null && message.hasOwnProperty("dailyTaskList")) {
                    if (!Array.isArray(message.dailyTaskList))
                        return "dailyTaskList: array expected";
                    for (var i = 0; i < message.dailyTaskList.length; ++i) {
                        var error = $root.luck.protobuf.DailyTaskPB.verify(message.dailyTaskList[i]);
                        if (error)
                            return "dailyTaskList." + error;
                    }
                }
                if (message.weekTaskList != null && message.hasOwnProperty("weekTaskList")) {
                    if (!Array.isArray(message.weekTaskList))
                        return "weekTaskList: array expected";
                    for (var i = 0; i < message.weekTaskList.length; ++i) {
                        var error = $root.luck.protobuf.WeekTaskPB.verify(message.weekTaskList[i]);
                        if (error)
                            return "weekTaskList." + error;
                    }
                }
                if (message.rewardTaskList != null && message.hasOwnProperty("rewardTaskList")) {
                    if (!Array.isArray(message.rewardTaskList))
                        return "rewardTaskList: array expected";
                    for (var i = 0; i < message.rewardTaskList.length; ++i) {
                        var error = $root.luck.protobuf.RewardTaskPB.verify(message.rewardTaskList[i]);
                        if (error)
                            return "rewardTaskList." + error;
                    }
                }
                if (!$util.isInteger(message.dailyTaskActivity))
                    return "dailyTaskActivity: integer expected";
                if (message.dailyVitalityRewardList != null && message.hasOwnProperty("dailyVitalityRewardList")) {
                    if (!Array.isArray(message.dailyVitalityRewardList))
                        return "dailyVitalityRewardList: array expected";
                    for (var i = 0; i < message.dailyVitalityRewardList.length; ++i)
                        if (!$util.isInteger(message.dailyVitalityRewardList[i]))
                            return "dailyVitalityRewardList: integer[] expected";
                }
                if (!$util.isInteger(message.havePVETeamId) && !(message.havePVETeamId && $util.isInteger(message.havePVETeamId.low) && $util.isInteger(message.havePVETeamId.high)))
                    return "havePVETeamId: integer|Long expected";
                if (message.achievementTaskList != null && message.hasOwnProperty("achievementTaskList")) {
                    if (!Array.isArray(message.achievementTaskList))
                        return "achievementTaskList: array expected";
                    for (var i = 0; i < message.achievementTaskList.length; ++i) {
                        var error = $root.luck.protobuf.AchievementTaskPB.verify(message.achievementTaskList[i]);
                        if (error)
                            return "achievementTaskList." + error;
                    }
                }
                if (!$util.isInteger(message.achievementPoint) && !(message.achievementPoint && $util.isInteger(message.achievementPoint.low) && $util.isInteger(message.achievementPoint.high)))
                    return "achievementPoint: integer|Long expected";
                if (message.achievementType1List != null && message.hasOwnProperty("achievementType1List")) {
                    if (!Array.isArray(message.achievementType1List))
                        return "achievementType1List: array expected";
                    for (var i = 0; i < message.achievementType1List.length; ++i) {
                        var error = $root.luck.protobuf.AchievementTypePB.verify(message.achievementType1List[i]);
                        if (error)
                            return "achievementType1List." + error;
                    }
                }
                if (message.achievementType2List != null && message.hasOwnProperty("achievementType2List")) {
                    if (!Array.isArray(message.achievementType2List))
                        return "achievementType2List: array expected";
                    for (var i = 0; i < message.achievementType2List.length; ++i) {
                        var error = $root.luck.protobuf.AchievementTypePB.verify(message.achievementType2List[i]);
                        if (error)
                            return "achievementType2List." + error;
                    }
                }
                if (message.activityTaskList != null && message.hasOwnProperty("activityTaskList")) {
                    if (!Array.isArray(message.activityTaskList))
                        return "activityTaskList: array expected";
                    for (var i = 0; i < message.activityTaskList.length; ++i) {
                        var error = $root.luck.protobuf.ActivityTaskPB.verify(message.activityTaskList[i]);
                        if (error)
                            return "activityTaskList." + error;
                    }
                }
                {
                    var error = $root.luck.protobuf.GameSystemPB.verify(message.gameSystem);
                    if (error)
                        return "gameSystem." + error;
                }
                if (message.activityTaskRewardList != null && message.hasOwnProperty("activityTaskRewardList")) {
                    if (!Array.isArray(message.activityTaskRewardList))
                        return "activityTaskRewardList: array expected";
                    for (var i = 0; i < message.activityTaskRewardList.length; ++i) {
                        var error = $root.luck.protobuf.activityTaskRewardPB.verify(message.activityTaskRewardList[i]);
                        if (error)
                            return "activityTaskRewardList." + error;
                    }
                }
                if (message.specialTaskList != null && message.hasOwnProperty("specialTaskList")) {
                    if (!Array.isArray(message.specialTaskList))
                        return "specialTaskList: array expected";
                    for (var i = 0; i < message.specialTaskList.length; ++i) {
                        var error = $root.luck.protobuf.SpecialTaskPB.verify(message.specialTaskList[i]);
                        if (error)
                            return "specialTaskList." + error;
                    }
                }
                if (message.roleList != null && message.hasOwnProperty("roleList")) {
                    if (!Array.isArray(message.roleList))
                        return "roleList: array expected";
                    for (var i = 0; i < message.roleList.length; ++i) {
                        var error = $root.luck.protobuf.RolePB.verify(message.roleList[i]);
                        if (error)
                            return "roleList." + error;
                    }
                }
                if (!$util.isInteger(message.gangTaskActivity))
                    return "gangTaskActivity: integer expected";
                if (message.gangVitalityRewardList != null && message.hasOwnProperty("gangVitalityRewardList")) {
                    if (!Array.isArray(message.gangVitalityRewardList))
                        return "gangVitalityRewardList: array expected";
                    for (var i = 0; i < message.gangVitalityRewardList.length; ++i)
                        if (!$util.isInteger(message.gangVitalityRewardList[i]))
                            return "gangVitalityRewardList: integer[] expected";
                }
                if (message.gangTaskList != null && message.hasOwnProperty("gangTaskList")) {
                    if (!Array.isArray(message.gangTaskList))
                        return "gangTaskList: array expected";
                    for (var i = 0; i < message.gangTaskList.length; ++i) {
                        var error = $root.luck.protobuf.GangTaskPB.verify(message.gangTaskList[i]);
                        if (error)
                            return "gangTaskList." + error;
                    }
                }
                return null;
            };

            return PlayerPB;
        })();

        protobuf.PlayerBasePB = (function() {

            /**
             * Properties of a PlayerBasePB.
             * @memberof luck.protobuf
             * @interface IPlayerBasePB
             * @property {number|Long} playerId PlayerBasePB playerId
             * @property {string} name PlayerBasePB name
             * @property {number|Long} gold PlayerBasePB gold
             * @property {number} lv PlayerBasePB lv
             * @property {number} exp PlayerBasePB exp
             * @property {number} vipLv PlayerBasePB vipLv
             * @property {number} vipExp PlayerBasePB vipExp
             * @property {number} body PlayerBasePB body
             * @property {number|Long} diamond PlayerBasePB diamond
             * @property {number} pvpStep PlayerBasePB pvpStep
             * @property {number} pvpWinNum PlayerBasePB pvpWinNum
             * @property {number} pvpNum PlayerBasePB pvpNum
             * @property {number|Long} guildId PlayerBasePB guildId
             * @property {number|Long} dressUid PlayerBasePB dressUid
             * @property {number|Long} weapon1Uid PlayerBasePB weapon1Uid
             * @property {number|Long} weapon2Uid PlayerBasePB weapon2Uid
             * @property {number|Long} weapon3Uid PlayerBasePB weapon3Uid
             * @property {number|Long} card1Uid PlayerBasePB card1Uid
             * @property {number|Long} card2Uid PlayerBasePB card2Uid
             * @property {number|Long} card3Uid PlayerBasePB card3Uid
             * @property {number} roleId PlayerBasePB roleId
             * @property {Array.<number>|null} [roleList] PlayerBasePB roleList
             * @property {Array.<number>|null} [weaponList] PlayerBasePB weaponList
             * @property {Array.<number>|null} [cardList] PlayerBasePB cardList
             * @property {Array.<number>|null} [clothesList] PlayerBasePB clothesList
             * @property {number|Long} bodyRefreshTime PlayerBasePB bodyRefreshTime
             * @property {number|Long} gangContribute PlayerBasePB gangContribute
             * @property {number|Long} rechargeRmb PlayerBasePB rechargeRmb
             * @property {number|Long} registerTime PlayerBasePB registerTime
             * @property {string|null} [personManifesto] PlayerBasePB personManifesto
             */

            /**
             * Constructs a new PlayerBasePB.
             * @memberof luck.protobuf
             * @classdesc Represents a PlayerBasePB.
             * @implements IPlayerBasePB
             * @constructor
             * @param {luck.protobuf.IPlayerBasePB=} [properties] Properties to set
             */
            function PlayerBasePB(properties) {
                this.roleList = [];
                this.weaponList = [];
                this.cardList = [];
                this.clothesList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PlayerBasePB playerId.
             * @member {number|Long} playerId
             * @memberof luck.protobuf.PlayerBasePB
             * @instance
             */
            PlayerBasePB.prototype.playerId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PlayerBasePB name.
             * @member {string} name
             * @memberof luck.protobuf.PlayerBasePB
             * @instance
             */
            PlayerBasePB.prototype.name = "";

            /**
             * PlayerBasePB gold.
             * @member {number|Long} gold
             * @memberof luck.protobuf.PlayerBasePB
             * @instance
             */
            PlayerBasePB.prototype.gold = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PlayerBasePB lv.
             * @member {number} lv
             * @memberof luck.protobuf.PlayerBasePB
             * @instance
             */
            PlayerBasePB.prototype.lv = 0;

            /**
             * PlayerBasePB exp.
             * @member {number} exp
             * @memberof luck.protobuf.PlayerBasePB
             * @instance
             */
            PlayerBasePB.prototype.exp = 0;

            /**
             * PlayerBasePB vipLv.
             * @member {number} vipLv
             * @memberof luck.protobuf.PlayerBasePB
             * @instance
             */
            PlayerBasePB.prototype.vipLv = 0;

            /**
             * PlayerBasePB vipExp.
             * @member {number} vipExp
             * @memberof luck.protobuf.PlayerBasePB
             * @instance
             */
            PlayerBasePB.prototype.vipExp = 0;

            /**
             * PlayerBasePB body.
             * @member {number} body
             * @memberof luck.protobuf.PlayerBasePB
             * @instance
             */
            PlayerBasePB.prototype.body = 0;

            /**
             * PlayerBasePB diamond.
             * @member {number|Long} diamond
             * @memberof luck.protobuf.PlayerBasePB
             * @instance
             */
            PlayerBasePB.prototype.diamond = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PlayerBasePB pvpStep.
             * @member {number} pvpStep
             * @memberof luck.protobuf.PlayerBasePB
             * @instance
             */
            PlayerBasePB.prototype.pvpStep = 0;

            /**
             * PlayerBasePB pvpWinNum.
             * @member {number} pvpWinNum
             * @memberof luck.protobuf.PlayerBasePB
             * @instance
             */
            PlayerBasePB.prototype.pvpWinNum = 0;

            /**
             * PlayerBasePB pvpNum.
             * @member {number} pvpNum
             * @memberof luck.protobuf.PlayerBasePB
             * @instance
             */
            PlayerBasePB.prototype.pvpNum = 0;

            /**
             * PlayerBasePB guildId.
             * @member {number|Long} guildId
             * @memberof luck.protobuf.PlayerBasePB
             * @instance
             */
            PlayerBasePB.prototype.guildId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PlayerBasePB dressUid.
             * @member {number|Long} dressUid
             * @memberof luck.protobuf.PlayerBasePB
             * @instance
             */
            PlayerBasePB.prototype.dressUid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PlayerBasePB weapon1Uid.
             * @member {number|Long} weapon1Uid
             * @memberof luck.protobuf.PlayerBasePB
             * @instance
             */
            PlayerBasePB.prototype.weapon1Uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PlayerBasePB weapon2Uid.
             * @member {number|Long} weapon2Uid
             * @memberof luck.protobuf.PlayerBasePB
             * @instance
             */
            PlayerBasePB.prototype.weapon2Uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PlayerBasePB weapon3Uid.
             * @member {number|Long} weapon3Uid
             * @memberof luck.protobuf.PlayerBasePB
             * @instance
             */
            PlayerBasePB.prototype.weapon3Uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PlayerBasePB card1Uid.
             * @member {number|Long} card1Uid
             * @memberof luck.protobuf.PlayerBasePB
             * @instance
             */
            PlayerBasePB.prototype.card1Uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PlayerBasePB card2Uid.
             * @member {number|Long} card2Uid
             * @memberof luck.protobuf.PlayerBasePB
             * @instance
             */
            PlayerBasePB.prototype.card2Uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PlayerBasePB card3Uid.
             * @member {number|Long} card3Uid
             * @memberof luck.protobuf.PlayerBasePB
             * @instance
             */
            PlayerBasePB.prototype.card3Uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PlayerBasePB roleId.
             * @member {number} roleId
             * @memberof luck.protobuf.PlayerBasePB
             * @instance
             */
            PlayerBasePB.prototype.roleId = 0;

            /**
             * PlayerBasePB roleList.
             * @member {Array.<number>} roleList
             * @memberof luck.protobuf.PlayerBasePB
             * @instance
             */
            PlayerBasePB.prototype.roleList = $util.emptyArray;

            /**
             * PlayerBasePB weaponList.
             * @member {Array.<number>} weaponList
             * @memberof luck.protobuf.PlayerBasePB
             * @instance
             */
            PlayerBasePB.prototype.weaponList = $util.emptyArray;

            /**
             * PlayerBasePB cardList.
             * @member {Array.<number>} cardList
             * @memberof luck.protobuf.PlayerBasePB
             * @instance
             */
            PlayerBasePB.prototype.cardList = $util.emptyArray;

            /**
             * PlayerBasePB clothesList.
             * @member {Array.<number>} clothesList
             * @memberof luck.protobuf.PlayerBasePB
             * @instance
             */
            PlayerBasePB.prototype.clothesList = $util.emptyArray;

            /**
             * PlayerBasePB bodyRefreshTime.
             * @member {number|Long} bodyRefreshTime
             * @memberof luck.protobuf.PlayerBasePB
             * @instance
             */
            PlayerBasePB.prototype.bodyRefreshTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PlayerBasePB gangContribute.
             * @member {number|Long} gangContribute
             * @memberof luck.protobuf.PlayerBasePB
             * @instance
             */
            PlayerBasePB.prototype.gangContribute = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PlayerBasePB rechargeRmb.
             * @member {number|Long} rechargeRmb
             * @memberof luck.protobuf.PlayerBasePB
             * @instance
             */
            PlayerBasePB.prototype.rechargeRmb = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PlayerBasePB registerTime.
             * @member {number|Long} registerTime
             * @memberof luck.protobuf.PlayerBasePB
             * @instance
             */
            PlayerBasePB.prototype.registerTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PlayerBasePB personManifesto.
             * @member {string} personManifesto
             * @memberof luck.protobuf.PlayerBasePB
             * @instance
             */
            PlayerBasePB.prototype.personManifesto = "";

            /**
             * Creates a new PlayerBasePB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.PlayerBasePB
             * @static
             * @param {luck.protobuf.IPlayerBasePB=} [properties] Properties to set
             * @returns {luck.protobuf.PlayerBasePB} PlayerBasePB instance
             */
            PlayerBasePB.create = function create(properties) {
                return new PlayerBasePB(properties);
            };

            /**
             * Encodes the specified PlayerBasePB message. Does not implicitly {@link luck.protobuf.PlayerBasePB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.PlayerBasePB
             * @static
             * @param {luck.protobuf.IPlayerBasePB} message PlayerBasePB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PlayerBasePB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.playerId);
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.gold);
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.lv);
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.exp);
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.vipLv);
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.vipExp);
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.body);
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.diamond);
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.pvpStep);
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.pvpWinNum);
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.pvpNum);
                writer.uint32(/* id 13, wireType 0 =*/104).int64(message.guildId);
                writer.uint32(/* id 14, wireType 0 =*/112).int64(message.dressUid);
                writer.uint32(/* id 15, wireType 0 =*/120).int64(message.weapon1Uid);
                writer.uint32(/* id 16, wireType 0 =*/128).int64(message.weapon2Uid);
                writer.uint32(/* id 17, wireType 0 =*/136).int64(message.weapon3Uid);
                writer.uint32(/* id 18, wireType 0 =*/144).int64(message.card1Uid);
                writer.uint32(/* id 19, wireType 0 =*/152).int64(message.card2Uid);
                writer.uint32(/* id 20, wireType 0 =*/160).int64(message.card3Uid);
                writer.uint32(/* id 21, wireType 0 =*/168).int32(message.roleId);
                if (message.roleList != null && message.roleList.length)
                    for (var i = 0; i < message.roleList.length; ++i)
                        writer.uint32(/* id 22, wireType 0 =*/176).int32(message.roleList[i]);
                if (message.weaponList != null && message.weaponList.length)
                    for (var i = 0; i < message.weaponList.length; ++i)
                        writer.uint32(/* id 23, wireType 0 =*/184).int32(message.weaponList[i]);
                if (message.cardList != null && message.cardList.length)
                    for (var i = 0; i < message.cardList.length; ++i)
                        writer.uint32(/* id 24, wireType 0 =*/192).int32(message.cardList[i]);
                if (message.clothesList != null && message.clothesList.length)
                    for (var i = 0; i < message.clothesList.length; ++i)
                        writer.uint32(/* id 25, wireType 0 =*/200).int32(message.clothesList[i]);
                writer.uint32(/* id 26, wireType 0 =*/208).int64(message.bodyRefreshTime);
                writer.uint32(/* id 27, wireType 0 =*/216).int64(message.gangContribute);
                writer.uint32(/* id 28, wireType 0 =*/224).int64(message.rechargeRmb);
                writer.uint32(/* id 29, wireType 0 =*/232).int64(message.registerTime);
                if (message.personManifesto != null && message.hasOwnProperty("personManifesto"))
                    writer.uint32(/* id 30, wireType 2 =*/242).string(message.personManifesto);
                return writer;
            };

            /**
             * Encodes the specified PlayerBasePB message, length delimited. Does not implicitly {@link luck.protobuf.PlayerBasePB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.PlayerBasePB
             * @static
             * @param {luck.protobuf.IPlayerBasePB} message PlayerBasePB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PlayerBasePB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PlayerBasePB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.PlayerBasePB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.PlayerBasePB} PlayerBasePB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PlayerBasePB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.PlayerBasePB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.playerId = reader.int64();
                        break;
                    case 2:
                        message.name = reader.string();
                        break;
                    case 3:
                        message.gold = reader.int64();
                        break;
                    case 4:
                        message.lv = reader.int32();
                        break;
                    case 5:
                        message.exp = reader.int32();
                        break;
                    case 6:
                        message.vipLv = reader.int32();
                        break;
                    case 7:
                        message.vipExp = reader.int32();
                        break;
                    case 8:
                        message.body = reader.int32();
                        break;
                    case 9:
                        message.diamond = reader.int64();
                        break;
                    case 10:
                        message.pvpStep = reader.int32();
                        break;
                    case 11:
                        message.pvpWinNum = reader.int32();
                        break;
                    case 12:
                        message.pvpNum = reader.int32();
                        break;
                    case 13:
                        message.guildId = reader.int64();
                        break;
                    case 14:
                        message.dressUid = reader.int64();
                        break;
                    case 15:
                        message.weapon1Uid = reader.int64();
                        break;
                    case 16:
                        message.weapon2Uid = reader.int64();
                        break;
                    case 17:
                        message.weapon3Uid = reader.int64();
                        break;
                    case 18:
                        message.card1Uid = reader.int64();
                        break;
                    case 19:
                        message.card2Uid = reader.int64();
                        break;
                    case 20:
                        message.card3Uid = reader.int64();
                        break;
                    case 21:
                        message.roleId = reader.int32();
                        break;
                    case 22:
                        if (!(message.roleList && message.roleList.length))
                            message.roleList = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.roleList.push(reader.int32());
                        } else
                            message.roleList.push(reader.int32());
                        break;
                    case 23:
                        if (!(message.weaponList && message.weaponList.length))
                            message.weaponList = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.weaponList.push(reader.int32());
                        } else
                            message.weaponList.push(reader.int32());
                        break;
                    case 24:
                        if (!(message.cardList && message.cardList.length))
                            message.cardList = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.cardList.push(reader.int32());
                        } else
                            message.cardList.push(reader.int32());
                        break;
                    case 25:
                        if (!(message.clothesList && message.clothesList.length))
                            message.clothesList = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.clothesList.push(reader.int32());
                        } else
                            message.clothesList.push(reader.int32());
                        break;
                    case 26:
                        message.bodyRefreshTime = reader.int64();
                        break;
                    case 27:
                        message.gangContribute = reader.int64();
                        break;
                    case 28:
                        message.rechargeRmb = reader.int64();
                        break;
                    case 29:
                        message.registerTime = reader.int64();
                        break;
                    case 30:
                        message.personManifesto = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("playerId"))
                    throw $util.ProtocolError("missing required 'playerId'", { instance: message });
                if (!message.hasOwnProperty("name"))
                    throw $util.ProtocolError("missing required 'name'", { instance: message });
                if (!message.hasOwnProperty("gold"))
                    throw $util.ProtocolError("missing required 'gold'", { instance: message });
                if (!message.hasOwnProperty("lv"))
                    throw $util.ProtocolError("missing required 'lv'", { instance: message });
                if (!message.hasOwnProperty("exp"))
                    throw $util.ProtocolError("missing required 'exp'", { instance: message });
                if (!message.hasOwnProperty("vipLv"))
                    throw $util.ProtocolError("missing required 'vipLv'", { instance: message });
                if (!message.hasOwnProperty("vipExp"))
                    throw $util.ProtocolError("missing required 'vipExp'", { instance: message });
                if (!message.hasOwnProperty("body"))
                    throw $util.ProtocolError("missing required 'body'", { instance: message });
                if (!message.hasOwnProperty("diamond"))
                    throw $util.ProtocolError("missing required 'diamond'", { instance: message });
                if (!message.hasOwnProperty("pvpStep"))
                    throw $util.ProtocolError("missing required 'pvpStep'", { instance: message });
                if (!message.hasOwnProperty("pvpWinNum"))
                    throw $util.ProtocolError("missing required 'pvpWinNum'", { instance: message });
                if (!message.hasOwnProperty("pvpNum"))
                    throw $util.ProtocolError("missing required 'pvpNum'", { instance: message });
                if (!message.hasOwnProperty("guildId"))
                    throw $util.ProtocolError("missing required 'guildId'", { instance: message });
                if (!message.hasOwnProperty("dressUid"))
                    throw $util.ProtocolError("missing required 'dressUid'", { instance: message });
                if (!message.hasOwnProperty("weapon1Uid"))
                    throw $util.ProtocolError("missing required 'weapon1Uid'", { instance: message });
                if (!message.hasOwnProperty("weapon2Uid"))
                    throw $util.ProtocolError("missing required 'weapon2Uid'", { instance: message });
                if (!message.hasOwnProperty("weapon3Uid"))
                    throw $util.ProtocolError("missing required 'weapon3Uid'", { instance: message });
                if (!message.hasOwnProperty("card1Uid"))
                    throw $util.ProtocolError("missing required 'card1Uid'", { instance: message });
                if (!message.hasOwnProperty("card2Uid"))
                    throw $util.ProtocolError("missing required 'card2Uid'", { instance: message });
                if (!message.hasOwnProperty("card3Uid"))
                    throw $util.ProtocolError("missing required 'card3Uid'", { instance: message });
                if (!message.hasOwnProperty("roleId"))
                    throw $util.ProtocolError("missing required 'roleId'", { instance: message });
                if (!message.hasOwnProperty("bodyRefreshTime"))
                    throw $util.ProtocolError("missing required 'bodyRefreshTime'", { instance: message });
                if (!message.hasOwnProperty("gangContribute"))
                    throw $util.ProtocolError("missing required 'gangContribute'", { instance: message });
                if (!message.hasOwnProperty("rechargeRmb"))
                    throw $util.ProtocolError("missing required 'rechargeRmb'", { instance: message });
                if (!message.hasOwnProperty("registerTime"))
                    throw $util.ProtocolError("missing required 'registerTime'", { instance: message });
                return message;
            };

            /**
             * Decodes a PlayerBasePB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.PlayerBasePB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.PlayerBasePB} PlayerBasePB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PlayerBasePB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PlayerBasePB message.
             * @function verify
             * @memberof luck.protobuf.PlayerBasePB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PlayerBasePB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.playerId) && !(message.playerId && $util.isInteger(message.playerId.low) && $util.isInteger(message.playerId.high)))
                    return "playerId: integer|Long expected";
                if (!$util.isString(message.name))
                    return "name: string expected";
                if (!$util.isInteger(message.gold) && !(message.gold && $util.isInteger(message.gold.low) && $util.isInteger(message.gold.high)))
                    return "gold: integer|Long expected";
                if (!$util.isInteger(message.lv))
                    return "lv: integer expected";
                if (!$util.isInteger(message.exp))
                    return "exp: integer expected";
                if (!$util.isInteger(message.vipLv))
                    return "vipLv: integer expected";
                if (!$util.isInteger(message.vipExp))
                    return "vipExp: integer expected";
                if (!$util.isInteger(message.body))
                    return "body: integer expected";
                if (!$util.isInteger(message.diamond) && !(message.diamond && $util.isInteger(message.diamond.low) && $util.isInteger(message.diamond.high)))
                    return "diamond: integer|Long expected";
                if (!$util.isInteger(message.pvpStep))
                    return "pvpStep: integer expected";
                if (!$util.isInteger(message.pvpWinNum))
                    return "pvpWinNum: integer expected";
                if (!$util.isInteger(message.pvpNum))
                    return "pvpNum: integer expected";
                if (!$util.isInteger(message.guildId) && !(message.guildId && $util.isInteger(message.guildId.low) && $util.isInteger(message.guildId.high)))
                    return "guildId: integer|Long expected";
                if (!$util.isInteger(message.dressUid) && !(message.dressUid && $util.isInteger(message.dressUid.low) && $util.isInteger(message.dressUid.high)))
                    return "dressUid: integer|Long expected";
                if (!$util.isInteger(message.weapon1Uid) && !(message.weapon1Uid && $util.isInteger(message.weapon1Uid.low) && $util.isInteger(message.weapon1Uid.high)))
                    return "weapon1Uid: integer|Long expected";
                if (!$util.isInteger(message.weapon2Uid) && !(message.weapon2Uid && $util.isInteger(message.weapon2Uid.low) && $util.isInteger(message.weapon2Uid.high)))
                    return "weapon2Uid: integer|Long expected";
                if (!$util.isInteger(message.weapon3Uid) && !(message.weapon3Uid && $util.isInteger(message.weapon3Uid.low) && $util.isInteger(message.weapon3Uid.high)))
                    return "weapon3Uid: integer|Long expected";
                if (!$util.isInteger(message.card1Uid) && !(message.card1Uid && $util.isInteger(message.card1Uid.low) && $util.isInteger(message.card1Uid.high)))
                    return "card1Uid: integer|Long expected";
                if (!$util.isInteger(message.card2Uid) && !(message.card2Uid && $util.isInteger(message.card2Uid.low) && $util.isInteger(message.card2Uid.high)))
                    return "card2Uid: integer|Long expected";
                if (!$util.isInteger(message.card3Uid) && !(message.card3Uid && $util.isInteger(message.card3Uid.low) && $util.isInteger(message.card3Uid.high)))
                    return "card3Uid: integer|Long expected";
                if (!$util.isInteger(message.roleId))
                    return "roleId: integer expected";
                if (message.roleList != null && message.hasOwnProperty("roleList")) {
                    if (!Array.isArray(message.roleList))
                        return "roleList: array expected";
                    for (var i = 0; i < message.roleList.length; ++i)
                        if (!$util.isInteger(message.roleList[i]))
                            return "roleList: integer[] expected";
                }
                if (message.weaponList != null && message.hasOwnProperty("weaponList")) {
                    if (!Array.isArray(message.weaponList))
                        return "weaponList: array expected";
                    for (var i = 0; i < message.weaponList.length; ++i)
                        if (!$util.isInteger(message.weaponList[i]))
                            return "weaponList: integer[] expected";
                }
                if (message.cardList != null && message.hasOwnProperty("cardList")) {
                    if (!Array.isArray(message.cardList))
                        return "cardList: array expected";
                    for (var i = 0; i < message.cardList.length; ++i)
                        if (!$util.isInteger(message.cardList[i]))
                            return "cardList: integer[] expected";
                }
                if (message.clothesList != null && message.hasOwnProperty("clothesList")) {
                    if (!Array.isArray(message.clothesList))
                        return "clothesList: array expected";
                    for (var i = 0; i < message.clothesList.length; ++i)
                        if (!$util.isInteger(message.clothesList[i]))
                            return "clothesList: integer[] expected";
                }
                if (!$util.isInteger(message.bodyRefreshTime) && !(message.bodyRefreshTime && $util.isInteger(message.bodyRefreshTime.low) && $util.isInteger(message.bodyRefreshTime.high)))
                    return "bodyRefreshTime: integer|Long expected";
                if (!$util.isInteger(message.gangContribute) && !(message.gangContribute && $util.isInteger(message.gangContribute.low) && $util.isInteger(message.gangContribute.high)))
                    return "gangContribute: integer|Long expected";
                if (!$util.isInteger(message.rechargeRmb) && !(message.rechargeRmb && $util.isInteger(message.rechargeRmb.low) && $util.isInteger(message.rechargeRmb.high)))
                    return "rechargeRmb: integer|Long expected";
                if (!$util.isInteger(message.registerTime) && !(message.registerTime && $util.isInteger(message.registerTime.low) && $util.isInteger(message.registerTime.high)))
                    return "registerTime: integer|Long expected";
                if (message.personManifesto != null && message.hasOwnProperty("personManifesto"))
                    if (!$util.isString(message.personManifesto))
                        return "personManifesto: string expected";
                return null;
            };

            return PlayerBasePB;
        })();

        protobuf.WeaponPB = (function() {

            /**
             * Properties of a WeaponPB.
             * @memberof luck.protobuf
             * @interface IWeaponPB
             * @property {number|Long} uid WeaponPB uid
             * @property {number} id WeaponPB id
             * @property {number} lv WeaponPB lv
             * @property {Array.<luck.protobuf.IPropertyIntPB>|null} [attackList] WeaponPB attackList
             * @property {Array.<luck.protobuf.IPropertyFloatPB>|null} [strengthenList] WeaponPB strengthenList
             * @property {Array.<luck.protobuf.IPropertyIntPB>|null} [hurtList] WeaponPB hurtList
             * @property {number} baptizeNum WeaponPB baptizeNum
             * @property {number} holeCountMax WeaponPB holeCountMax
             * @property {number} advancedCount WeaponPB advancedCount
             * @property {Array.<luck.protobuf.IWeaponInlayPB>|null} [inlayList] WeaponPB inlayList
             * @property {number} isRecast WeaponPB isRecast
             * @property {Array.<luck.protobuf.IPropertyIntPB>|null} [recastAttackList] WeaponPB recastAttackList
             * @property {Array.<luck.protobuf.IPropertyFloatPB>|null} [recastStrengthenList] WeaponPB recastStrengthenList
             * @property {Array.<luck.protobuf.IPropertyIntPB>|null} [recastHurtList] WeaponPB recastHurtList
             * @property {number} exp WeaponPB exp
             * @property {Array.<luck.protobuf.IPropertyIntPB>|null} [baptizePropertyList] WeaponPB baptizePropertyList
             * @property {number} isBaptize WeaponPB isBaptize
             * @property {Array.<luck.protobuf.IPropertyIntPB>|null} [baptizeMedianList] WeaponPB baptizeMedianList
             */

            /**
             * Constructs a new WeaponPB.
             * @memberof luck.protobuf
             * @classdesc Represents a WeaponPB.
             * @implements IWeaponPB
             * @constructor
             * @param {luck.protobuf.IWeaponPB=} [properties] Properties to set
             */
            function WeaponPB(properties) {
                this.attackList = [];
                this.strengthenList = [];
                this.hurtList = [];
                this.inlayList = [];
                this.recastAttackList = [];
                this.recastStrengthenList = [];
                this.recastHurtList = [];
                this.baptizePropertyList = [];
                this.baptizeMedianList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WeaponPB uid.
             * @member {number|Long} uid
             * @memberof luck.protobuf.WeaponPB
             * @instance
             */
            WeaponPB.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * WeaponPB id.
             * @member {number} id
             * @memberof luck.protobuf.WeaponPB
             * @instance
             */
            WeaponPB.prototype.id = 0;

            /**
             * WeaponPB lv.
             * @member {number} lv
             * @memberof luck.protobuf.WeaponPB
             * @instance
             */
            WeaponPB.prototype.lv = 0;

            /**
             * WeaponPB attackList.
             * @member {Array.<luck.protobuf.IPropertyIntPB>} attackList
             * @memberof luck.protobuf.WeaponPB
             * @instance
             */
            WeaponPB.prototype.attackList = $util.emptyArray;

            /**
             * WeaponPB strengthenList.
             * @member {Array.<luck.protobuf.IPropertyFloatPB>} strengthenList
             * @memberof luck.protobuf.WeaponPB
             * @instance
             */
            WeaponPB.prototype.strengthenList = $util.emptyArray;

            /**
             * WeaponPB hurtList.
             * @member {Array.<luck.protobuf.IPropertyIntPB>} hurtList
             * @memberof luck.protobuf.WeaponPB
             * @instance
             */
            WeaponPB.prototype.hurtList = $util.emptyArray;

            /**
             * WeaponPB baptizeNum.
             * @member {number} baptizeNum
             * @memberof luck.protobuf.WeaponPB
             * @instance
             */
            WeaponPB.prototype.baptizeNum = 0;

            /**
             * WeaponPB holeCountMax.
             * @member {number} holeCountMax
             * @memberof luck.protobuf.WeaponPB
             * @instance
             */
            WeaponPB.prototype.holeCountMax = 0;

            /**
             * WeaponPB advancedCount.
             * @member {number} advancedCount
             * @memberof luck.protobuf.WeaponPB
             * @instance
             */
            WeaponPB.prototype.advancedCount = 0;

            /**
             * WeaponPB inlayList.
             * @member {Array.<luck.protobuf.IWeaponInlayPB>} inlayList
             * @memberof luck.protobuf.WeaponPB
             * @instance
             */
            WeaponPB.prototype.inlayList = $util.emptyArray;

            /**
             * WeaponPB isRecast.
             * @member {number} isRecast
             * @memberof luck.protobuf.WeaponPB
             * @instance
             */
            WeaponPB.prototype.isRecast = 0;

            /**
             * WeaponPB recastAttackList.
             * @member {Array.<luck.protobuf.IPropertyIntPB>} recastAttackList
             * @memberof luck.protobuf.WeaponPB
             * @instance
             */
            WeaponPB.prototype.recastAttackList = $util.emptyArray;

            /**
             * WeaponPB recastStrengthenList.
             * @member {Array.<luck.protobuf.IPropertyFloatPB>} recastStrengthenList
             * @memberof luck.protobuf.WeaponPB
             * @instance
             */
            WeaponPB.prototype.recastStrengthenList = $util.emptyArray;

            /**
             * WeaponPB recastHurtList.
             * @member {Array.<luck.protobuf.IPropertyIntPB>} recastHurtList
             * @memberof luck.protobuf.WeaponPB
             * @instance
             */
            WeaponPB.prototype.recastHurtList = $util.emptyArray;

            /**
             * WeaponPB exp.
             * @member {number} exp
             * @memberof luck.protobuf.WeaponPB
             * @instance
             */
            WeaponPB.prototype.exp = 0;

            /**
             * WeaponPB baptizePropertyList.
             * @member {Array.<luck.protobuf.IPropertyIntPB>} baptizePropertyList
             * @memberof luck.protobuf.WeaponPB
             * @instance
             */
            WeaponPB.prototype.baptizePropertyList = $util.emptyArray;

            /**
             * WeaponPB isBaptize.
             * @member {number} isBaptize
             * @memberof luck.protobuf.WeaponPB
             * @instance
             */
            WeaponPB.prototype.isBaptize = 0;

            /**
             * WeaponPB baptizeMedianList.
             * @member {Array.<luck.protobuf.IPropertyIntPB>} baptizeMedianList
             * @memberof luck.protobuf.WeaponPB
             * @instance
             */
            WeaponPB.prototype.baptizeMedianList = $util.emptyArray;

            /**
             * Creates a new WeaponPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.WeaponPB
             * @static
             * @param {luck.protobuf.IWeaponPB=} [properties] Properties to set
             * @returns {luck.protobuf.WeaponPB} WeaponPB instance
             */
            WeaponPB.create = function create(properties) {
                return new WeaponPB(properties);
            };

            /**
             * Encodes the specified WeaponPB message. Does not implicitly {@link luck.protobuf.WeaponPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.WeaponPB
             * @static
             * @param {luck.protobuf.IWeaponPB} message WeaponPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WeaponPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.uid);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.id);
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.lv);
                if (message.attackList != null && message.attackList.length)
                    for (var i = 0; i < message.attackList.length; ++i)
                        $root.luck.protobuf.PropertyIntPB.encode(message.attackList[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.strengthenList != null && message.strengthenList.length)
                    for (var i = 0; i < message.strengthenList.length; ++i)
                        $root.luck.protobuf.PropertyFloatPB.encode(message.strengthenList[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.hurtList != null && message.hurtList.length)
                    for (var i = 0; i < message.hurtList.length; ++i)
                        $root.luck.protobuf.PropertyIntPB.encode(message.hurtList[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.baptizeNum);
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.holeCountMax);
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.advancedCount);
                if (message.inlayList != null && message.inlayList.length)
                    for (var i = 0; i < message.inlayList.length; ++i)
                        $root.luck.protobuf.WeaponInlayPB.encode(message.inlayList[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.isRecast);
                if (message.recastAttackList != null && message.recastAttackList.length)
                    for (var i = 0; i < message.recastAttackList.length; ++i)
                        $root.luck.protobuf.PropertyIntPB.encode(message.recastAttackList[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                if (message.recastStrengthenList != null && message.recastStrengthenList.length)
                    for (var i = 0; i < message.recastStrengthenList.length; ++i)
                        $root.luck.protobuf.PropertyFloatPB.encode(message.recastStrengthenList[i], writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                if (message.recastHurtList != null && message.recastHurtList.length)
                    for (var i = 0; i < message.recastHurtList.length; ++i)
                        $root.luck.protobuf.PropertyIntPB.encode(message.recastHurtList[i], writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                writer.uint32(/* id 15, wireType 0 =*/120).int32(message.exp);
                if (message.baptizePropertyList != null && message.baptizePropertyList.length)
                    for (var i = 0; i < message.baptizePropertyList.length; ++i)
                        $root.luck.protobuf.PropertyIntPB.encode(message.baptizePropertyList[i], writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                writer.uint32(/* id 17, wireType 0 =*/136).int32(message.isBaptize);
                if (message.baptizeMedianList != null && message.baptizeMedianList.length)
                    for (var i = 0; i < message.baptizeMedianList.length; ++i)
                        $root.luck.protobuf.PropertyIntPB.encode(message.baptizeMedianList[i], writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WeaponPB message, length delimited. Does not implicitly {@link luck.protobuf.WeaponPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.WeaponPB
             * @static
             * @param {luck.protobuf.IWeaponPB} message WeaponPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WeaponPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WeaponPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.WeaponPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.WeaponPB} WeaponPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WeaponPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.WeaponPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.uid = reader.int64();
                        break;
                    case 2:
                        message.id = reader.int32();
                        break;
                    case 3:
                        message.lv = reader.int32();
                        break;
                    case 4:
                        if (!(message.attackList && message.attackList.length))
                            message.attackList = [];
                        message.attackList.push($root.luck.protobuf.PropertyIntPB.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.strengthenList && message.strengthenList.length))
                            message.strengthenList = [];
                        message.strengthenList.push($root.luck.protobuf.PropertyFloatPB.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.hurtList && message.hurtList.length))
                            message.hurtList = [];
                        message.hurtList.push($root.luck.protobuf.PropertyIntPB.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        message.baptizeNum = reader.int32();
                        break;
                    case 8:
                        message.holeCountMax = reader.int32();
                        break;
                    case 9:
                        message.advancedCount = reader.int32();
                        break;
                    case 10:
                        if (!(message.inlayList && message.inlayList.length))
                            message.inlayList = [];
                        message.inlayList.push($root.luck.protobuf.WeaponInlayPB.decode(reader, reader.uint32()));
                        break;
                    case 11:
                        message.isRecast = reader.int32();
                        break;
                    case 12:
                        if (!(message.recastAttackList && message.recastAttackList.length))
                            message.recastAttackList = [];
                        message.recastAttackList.push($root.luck.protobuf.PropertyIntPB.decode(reader, reader.uint32()));
                        break;
                    case 13:
                        if (!(message.recastStrengthenList && message.recastStrengthenList.length))
                            message.recastStrengthenList = [];
                        message.recastStrengthenList.push($root.luck.protobuf.PropertyFloatPB.decode(reader, reader.uint32()));
                        break;
                    case 14:
                        if (!(message.recastHurtList && message.recastHurtList.length))
                            message.recastHurtList = [];
                        message.recastHurtList.push($root.luck.protobuf.PropertyIntPB.decode(reader, reader.uint32()));
                        break;
                    case 15:
                        message.exp = reader.int32();
                        break;
                    case 16:
                        if (!(message.baptizePropertyList && message.baptizePropertyList.length))
                            message.baptizePropertyList = [];
                        message.baptizePropertyList.push($root.luck.protobuf.PropertyIntPB.decode(reader, reader.uint32()));
                        break;
                    case 17:
                        message.isBaptize = reader.int32();
                        break;
                    case 18:
                        if (!(message.baptizeMedianList && message.baptizeMedianList.length))
                            message.baptizeMedianList = [];
                        message.baptizeMedianList.push($root.luck.protobuf.PropertyIntPB.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("uid"))
                    throw $util.ProtocolError("missing required 'uid'", { instance: message });
                if (!message.hasOwnProperty("id"))
                    throw $util.ProtocolError("missing required 'id'", { instance: message });
                if (!message.hasOwnProperty("lv"))
                    throw $util.ProtocolError("missing required 'lv'", { instance: message });
                if (!message.hasOwnProperty("baptizeNum"))
                    throw $util.ProtocolError("missing required 'baptizeNum'", { instance: message });
                if (!message.hasOwnProperty("holeCountMax"))
                    throw $util.ProtocolError("missing required 'holeCountMax'", { instance: message });
                if (!message.hasOwnProperty("advancedCount"))
                    throw $util.ProtocolError("missing required 'advancedCount'", { instance: message });
                if (!message.hasOwnProperty("isRecast"))
                    throw $util.ProtocolError("missing required 'isRecast'", { instance: message });
                if (!message.hasOwnProperty("exp"))
                    throw $util.ProtocolError("missing required 'exp'", { instance: message });
                if (!message.hasOwnProperty("isBaptize"))
                    throw $util.ProtocolError("missing required 'isBaptize'", { instance: message });
                return message;
            };

            /**
             * Decodes a WeaponPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.WeaponPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.WeaponPB} WeaponPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WeaponPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WeaponPB message.
             * @function verify
             * @memberof luck.protobuf.WeaponPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WeaponPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
                if (!$util.isInteger(message.lv))
                    return "lv: integer expected";
                if (message.attackList != null && message.hasOwnProperty("attackList")) {
                    if (!Array.isArray(message.attackList))
                        return "attackList: array expected";
                    for (var i = 0; i < message.attackList.length; ++i) {
                        var error = $root.luck.protobuf.PropertyIntPB.verify(message.attackList[i]);
                        if (error)
                            return "attackList." + error;
                    }
                }
                if (message.strengthenList != null && message.hasOwnProperty("strengthenList")) {
                    if (!Array.isArray(message.strengthenList))
                        return "strengthenList: array expected";
                    for (var i = 0; i < message.strengthenList.length; ++i) {
                        var error = $root.luck.protobuf.PropertyFloatPB.verify(message.strengthenList[i]);
                        if (error)
                            return "strengthenList." + error;
                    }
                }
                if (message.hurtList != null && message.hasOwnProperty("hurtList")) {
                    if (!Array.isArray(message.hurtList))
                        return "hurtList: array expected";
                    for (var i = 0; i < message.hurtList.length; ++i) {
                        var error = $root.luck.protobuf.PropertyIntPB.verify(message.hurtList[i]);
                        if (error)
                            return "hurtList." + error;
                    }
                }
                if (!$util.isInteger(message.baptizeNum))
                    return "baptizeNum: integer expected";
                if (!$util.isInteger(message.holeCountMax))
                    return "holeCountMax: integer expected";
                if (!$util.isInteger(message.advancedCount))
                    return "advancedCount: integer expected";
                if (message.inlayList != null && message.hasOwnProperty("inlayList")) {
                    if (!Array.isArray(message.inlayList))
                        return "inlayList: array expected";
                    for (var i = 0; i < message.inlayList.length; ++i) {
                        var error = $root.luck.protobuf.WeaponInlayPB.verify(message.inlayList[i]);
                        if (error)
                            return "inlayList." + error;
                    }
                }
                if (!$util.isInteger(message.isRecast))
                    return "isRecast: integer expected";
                if (message.recastAttackList != null && message.hasOwnProperty("recastAttackList")) {
                    if (!Array.isArray(message.recastAttackList))
                        return "recastAttackList: array expected";
                    for (var i = 0; i < message.recastAttackList.length; ++i) {
                        var error = $root.luck.protobuf.PropertyIntPB.verify(message.recastAttackList[i]);
                        if (error)
                            return "recastAttackList." + error;
                    }
                }
                if (message.recastStrengthenList != null && message.hasOwnProperty("recastStrengthenList")) {
                    if (!Array.isArray(message.recastStrengthenList))
                        return "recastStrengthenList: array expected";
                    for (var i = 0; i < message.recastStrengthenList.length; ++i) {
                        var error = $root.luck.protobuf.PropertyFloatPB.verify(message.recastStrengthenList[i]);
                        if (error)
                            return "recastStrengthenList." + error;
                    }
                }
                if (message.recastHurtList != null && message.hasOwnProperty("recastHurtList")) {
                    if (!Array.isArray(message.recastHurtList))
                        return "recastHurtList: array expected";
                    for (var i = 0; i < message.recastHurtList.length; ++i) {
                        var error = $root.luck.protobuf.PropertyIntPB.verify(message.recastHurtList[i]);
                        if (error)
                            return "recastHurtList." + error;
                    }
                }
                if (!$util.isInteger(message.exp))
                    return "exp: integer expected";
                if (message.baptizePropertyList != null && message.hasOwnProperty("baptizePropertyList")) {
                    if (!Array.isArray(message.baptizePropertyList))
                        return "baptizePropertyList: array expected";
                    for (var i = 0; i < message.baptizePropertyList.length; ++i) {
                        var error = $root.luck.protobuf.PropertyIntPB.verify(message.baptizePropertyList[i]);
                        if (error)
                            return "baptizePropertyList." + error;
                    }
                }
                if (!$util.isInteger(message.isBaptize))
                    return "isBaptize: integer expected";
                if (message.baptizeMedianList != null && message.hasOwnProperty("baptizeMedianList")) {
                    if (!Array.isArray(message.baptizeMedianList))
                        return "baptizeMedianList: array expected";
                    for (var i = 0; i < message.baptizeMedianList.length; ++i) {
                        var error = $root.luck.protobuf.PropertyIntPB.verify(message.baptizeMedianList[i]);
                        if (error)
                            return "baptizeMedianList." + error;
                    }
                }
                return null;
            };

            return WeaponPB;
        })();

        protobuf.CardPB = (function() {

            /**
             * Properties of a CardPB.
             * @memberof luck.protobuf
             * @interface ICardPB
             * @property {number|Long} uid CardPB uid
             * @property {number} id CardPB id
             * @property {number} lv CardPB lv
             * @property {Array.<luck.protobuf.IPropertyFloatPB>|null} [propertyTypeList] CardPB propertyTypeList
             * @property {number} baptizeNum CardPB baptizeNum
             * @property {number} holeCountMax CardPB holeCountMax
             * @property {number} advancedCount CardPB advancedCount
             * @property {Array.<number>|null} [inlayList] CardPB inlayList
             * @property {number} exp CardPB exp
             * @property {Array.<luck.protobuf.IPropertyIntPB>|null} [baptizePropertyList] CardPB baptizePropertyList
             * @property {number} isBaptize CardPB isBaptize
             * @property {Array.<luck.protobuf.IPropertyIntPB>|null} [baptizeMedianList] CardPB baptizeMedianList
             */

            /**
             * Constructs a new CardPB.
             * @memberof luck.protobuf
             * @classdesc Represents a CardPB.
             * @implements ICardPB
             * @constructor
             * @param {luck.protobuf.ICardPB=} [properties] Properties to set
             */
            function CardPB(properties) {
                this.propertyTypeList = [];
                this.inlayList = [];
                this.baptizePropertyList = [];
                this.baptizeMedianList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CardPB uid.
             * @member {number|Long} uid
             * @memberof luck.protobuf.CardPB
             * @instance
             */
            CardPB.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * CardPB id.
             * @member {number} id
             * @memberof luck.protobuf.CardPB
             * @instance
             */
            CardPB.prototype.id = 0;

            /**
             * CardPB lv.
             * @member {number} lv
             * @memberof luck.protobuf.CardPB
             * @instance
             */
            CardPB.prototype.lv = 0;

            /**
             * CardPB propertyTypeList.
             * @member {Array.<luck.protobuf.IPropertyFloatPB>} propertyTypeList
             * @memberof luck.protobuf.CardPB
             * @instance
             */
            CardPB.prototype.propertyTypeList = $util.emptyArray;

            /**
             * CardPB baptizeNum.
             * @member {number} baptizeNum
             * @memberof luck.protobuf.CardPB
             * @instance
             */
            CardPB.prototype.baptizeNum = 0;

            /**
             * CardPB holeCountMax.
             * @member {number} holeCountMax
             * @memberof luck.protobuf.CardPB
             * @instance
             */
            CardPB.prototype.holeCountMax = 0;

            /**
             * CardPB advancedCount.
             * @member {number} advancedCount
             * @memberof luck.protobuf.CardPB
             * @instance
             */
            CardPB.prototype.advancedCount = 0;

            /**
             * CardPB inlayList.
             * @member {Array.<number>} inlayList
             * @memberof luck.protobuf.CardPB
             * @instance
             */
            CardPB.prototype.inlayList = $util.emptyArray;

            /**
             * CardPB exp.
             * @member {number} exp
             * @memberof luck.protobuf.CardPB
             * @instance
             */
            CardPB.prototype.exp = 0;

            /**
             * CardPB baptizePropertyList.
             * @member {Array.<luck.protobuf.IPropertyIntPB>} baptizePropertyList
             * @memberof luck.protobuf.CardPB
             * @instance
             */
            CardPB.prototype.baptizePropertyList = $util.emptyArray;

            /**
             * CardPB isBaptize.
             * @member {number} isBaptize
             * @memberof luck.protobuf.CardPB
             * @instance
             */
            CardPB.prototype.isBaptize = 0;

            /**
             * CardPB baptizeMedianList.
             * @member {Array.<luck.protobuf.IPropertyIntPB>} baptizeMedianList
             * @memberof luck.protobuf.CardPB
             * @instance
             */
            CardPB.prototype.baptizeMedianList = $util.emptyArray;

            /**
             * Creates a new CardPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.CardPB
             * @static
             * @param {luck.protobuf.ICardPB=} [properties] Properties to set
             * @returns {luck.protobuf.CardPB} CardPB instance
             */
            CardPB.create = function create(properties) {
                return new CardPB(properties);
            };

            /**
             * Encodes the specified CardPB message. Does not implicitly {@link luck.protobuf.CardPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.CardPB
             * @static
             * @param {luck.protobuf.ICardPB} message CardPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CardPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.uid);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.id);
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.lv);
                if (message.propertyTypeList != null && message.propertyTypeList.length)
                    for (var i = 0; i < message.propertyTypeList.length; ++i)
                        $root.luck.protobuf.PropertyFloatPB.encode(message.propertyTypeList[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.baptizeNum);
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.holeCountMax);
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.advancedCount);
                if (message.inlayList != null && message.inlayList.length)
                    for (var i = 0; i < message.inlayList.length; ++i)
                        writer.uint32(/* id 8, wireType 0 =*/64).int32(message.inlayList[i]);
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.exp);
                if (message.baptizePropertyList != null && message.baptizePropertyList.length)
                    for (var i = 0; i < message.baptizePropertyList.length; ++i)
                        $root.luck.protobuf.PropertyIntPB.encode(message.baptizePropertyList[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.isBaptize);
                if (message.baptizeMedianList != null && message.baptizeMedianList.length)
                    for (var i = 0; i < message.baptizeMedianList.length; ++i)
                        $root.luck.protobuf.PropertyIntPB.encode(message.baptizeMedianList[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CardPB message, length delimited. Does not implicitly {@link luck.protobuf.CardPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.CardPB
             * @static
             * @param {luck.protobuf.ICardPB} message CardPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CardPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CardPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.CardPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.CardPB} CardPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CardPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.CardPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.uid = reader.int64();
                        break;
                    case 2:
                        message.id = reader.int32();
                        break;
                    case 3:
                        message.lv = reader.int32();
                        break;
                    case 4:
                        if (!(message.propertyTypeList && message.propertyTypeList.length))
                            message.propertyTypeList = [];
                        message.propertyTypeList.push($root.luck.protobuf.PropertyFloatPB.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        message.baptizeNum = reader.int32();
                        break;
                    case 6:
                        message.holeCountMax = reader.int32();
                        break;
                    case 7:
                        message.advancedCount = reader.int32();
                        break;
                    case 8:
                        if (!(message.inlayList && message.inlayList.length))
                            message.inlayList = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.inlayList.push(reader.int32());
                        } else
                            message.inlayList.push(reader.int32());
                        break;
                    case 9:
                        message.exp = reader.int32();
                        break;
                    case 10:
                        if (!(message.baptizePropertyList && message.baptizePropertyList.length))
                            message.baptizePropertyList = [];
                        message.baptizePropertyList.push($root.luck.protobuf.PropertyIntPB.decode(reader, reader.uint32()));
                        break;
                    case 11:
                        message.isBaptize = reader.int32();
                        break;
                    case 12:
                        if (!(message.baptizeMedianList && message.baptizeMedianList.length))
                            message.baptizeMedianList = [];
                        message.baptizeMedianList.push($root.luck.protobuf.PropertyIntPB.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("uid"))
                    throw $util.ProtocolError("missing required 'uid'", { instance: message });
                if (!message.hasOwnProperty("id"))
                    throw $util.ProtocolError("missing required 'id'", { instance: message });
                if (!message.hasOwnProperty("lv"))
                    throw $util.ProtocolError("missing required 'lv'", { instance: message });
                if (!message.hasOwnProperty("baptizeNum"))
                    throw $util.ProtocolError("missing required 'baptizeNum'", { instance: message });
                if (!message.hasOwnProperty("holeCountMax"))
                    throw $util.ProtocolError("missing required 'holeCountMax'", { instance: message });
                if (!message.hasOwnProperty("advancedCount"))
                    throw $util.ProtocolError("missing required 'advancedCount'", { instance: message });
                if (!message.hasOwnProperty("exp"))
                    throw $util.ProtocolError("missing required 'exp'", { instance: message });
                if (!message.hasOwnProperty("isBaptize"))
                    throw $util.ProtocolError("missing required 'isBaptize'", { instance: message });
                return message;
            };

            /**
             * Decodes a CardPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.CardPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.CardPB} CardPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CardPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CardPB message.
             * @function verify
             * @memberof luck.protobuf.CardPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CardPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
                if (!$util.isInteger(message.lv))
                    return "lv: integer expected";
                if (message.propertyTypeList != null && message.hasOwnProperty("propertyTypeList")) {
                    if (!Array.isArray(message.propertyTypeList))
                        return "propertyTypeList: array expected";
                    for (var i = 0; i < message.propertyTypeList.length; ++i) {
                        var error = $root.luck.protobuf.PropertyFloatPB.verify(message.propertyTypeList[i]);
                        if (error)
                            return "propertyTypeList." + error;
                    }
                }
                if (!$util.isInteger(message.baptizeNum))
                    return "baptizeNum: integer expected";
                if (!$util.isInteger(message.holeCountMax))
                    return "holeCountMax: integer expected";
                if (!$util.isInteger(message.advancedCount))
                    return "advancedCount: integer expected";
                if (message.inlayList != null && message.hasOwnProperty("inlayList")) {
                    if (!Array.isArray(message.inlayList))
                        return "inlayList: array expected";
                    for (var i = 0; i < message.inlayList.length; ++i)
                        if (!$util.isInteger(message.inlayList[i]))
                            return "inlayList: integer[] expected";
                }
                if (!$util.isInteger(message.exp))
                    return "exp: integer expected";
                if (message.baptizePropertyList != null && message.hasOwnProperty("baptizePropertyList")) {
                    if (!Array.isArray(message.baptizePropertyList))
                        return "baptizePropertyList: array expected";
                    for (var i = 0; i < message.baptizePropertyList.length; ++i) {
                        var error = $root.luck.protobuf.PropertyIntPB.verify(message.baptizePropertyList[i]);
                        if (error)
                            return "baptizePropertyList." + error;
                    }
                }
                if (!$util.isInteger(message.isBaptize))
                    return "isBaptize: integer expected";
                if (message.baptizeMedianList != null && message.hasOwnProperty("baptizeMedianList")) {
                    if (!Array.isArray(message.baptizeMedianList))
                        return "baptizeMedianList: array expected";
                    for (var i = 0; i < message.baptizeMedianList.length; ++i) {
                        var error = $root.luck.protobuf.PropertyIntPB.verify(message.baptizeMedianList[i]);
                        if (error)
                            return "baptizeMedianList." + error;
                    }
                }
                return null;
            };

            return CardPB;
        })();

        protobuf.ClothesPB = (function() {

            /**
             * Properties of a ClothesPB.
             * @memberof luck.protobuf
             * @interface IClothesPB
             * @property {number|Long} uid ClothesPB uid
             * @property {number} id ClothesPB id
             * @property {number} lv ClothesPB lv
             * @property {number} HpMax ClothesPB HpMax
             * @property {Array.<luck.protobuf.IPropertyFloatPB>|null} [resistanceList] ClothesPB resistanceList
             * @property {Array.<luck.protobuf.IPropertyIntPB>|null} [reductionList] ClothesPB reductionList
             * @property {number} baptizeNum ClothesPB baptizeNum
             * @property {number} holeCountMax ClothesPB holeCountMax
             * @property {number} advancedCount ClothesPB advancedCount
             * @property {Array.<luck.protobuf.IClothesInlayPB>|null} [inlayList] ClothesPB inlayList
             * @property {number} isRecast ClothesPB isRecast
             * @property {number} recastHpMax ClothesPB recastHpMax
             * @property {Array.<luck.protobuf.IPropertyFloatPB>|null} [recastResistanceList] ClothesPB recastResistanceList
             * @property {Array.<luck.protobuf.IPropertyIntPB>|null} [recastReductionList] ClothesPB recastReductionList
             * @property {number} exp ClothesPB exp
             * @property {Array.<luck.protobuf.IPropertyIntPB>|null} [baptizePropertyList] ClothesPB baptizePropertyList
             * @property {number} isBaptize ClothesPB isBaptize
             * @property {Array.<luck.protobuf.IPropertyIntPB>|null} [baptizeMedianList] ClothesPB baptizeMedianList
             */

            /**
             * Constructs a new ClothesPB.
             * @memberof luck.protobuf
             * @classdesc Represents a ClothesPB.
             * @implements IClothesPB
             * @constructor
             * @param {luck.protobuf.IClothesPB=} [properties] Properties to set
             */
            function ClothesPB(properties) {
                this.resistanceList = [];
                this.reductionList = [];
                this.inlayList = [];
                this.recastResistanceList = [];
                this.recastReductionList = [];
                this.baptizePropertyList = [];
                this.baptizeMedianList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ClothesPB uid.
             * @member {number|Long} uid
             * @memberof luck.protobuf.ClothesPB
             * @instance
             */
            ClothesPB.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * ClothesPB id.
             * @member {number} id
             * @memberof luck.protobuf.ClothesPB
             * @instance
             */
            ClothesPB.prototype.id = 0;

            /**
             * ClothesPB lv.
             * @member {number} lv
             * @memberof luck.protobuf.ClothesPB
             * @instance
             */
            ClothesPB.prototype.lv = 0;

            /**
             * ClothesPB HpMax.
             * @member {number} HpMax
             * @memberof luck.protobuf.ClothesPB
             * @instance
             */
            ClothesPB.prototype.HpMax = 0;

            /**
             * ClothesPB resistanceList.
             * @member {Array.<luck.protobuf.IPropertyFloatPB>} resistanceList
             * @memberof luck.protobuf.ClothesPB
             * @instance
             */
            ClothesPB.prototype.resistanceList = $util.emptyArray;

            /**
             * ClothesPB reductionList.
             * @member {Array.<luck.protobuf.IPropertyIntPB>} reductionList
             * @memberof luck.protobuf.ClothesPB
             * @instance
             */
            ClothesPB.prototype.reductionList = $util.emptyArray;

            /**
             * ClothesPB baptizeNum.
             * @member {number} baptizeNum
             * @memberof luck.protobuf.ClothesPB
             * @instance
             */
            ClothesPB.prototype.baptizeNum = 0;

            /**
             * ClothesPB holeCountMax.
             * @member {number} holeCountMax
             * @memberof luck.protobuf.ClothesPB
             * @instance
             */
            ClothesPB.prototype.holeCountMax = 0;

            /**
             * ClothesPB advancedCount.
             * @member {number} advancedCount
             * @memberof luck.protobuf.ClothesPB
             * @instance
             */
            ClothesPB.prototype.advancedCount = 0;

            /**
             * ClothesPB inlayList.
             * @member {Array.<luck.protobuf.IClothesInlayPB>} inlayList
             * @memberof luck.protobuf.ClothesPB
             * @instance
             */
            ClothesPB.prototype.inlayList = $util.emptyArray;

            /**
             * ClothesPB isRecast.
             * @member {number} isRecast
             * @memberof luck.protobuf.ClothesPB
             * @instance
             */
            ClothesPB.prototype.isRecast = 0;

            /**
             * ClothesPB recastHpMax.
             * @member {number} recastHpMax
             * @memberof luck.protobuf.ClothesPB
             * @instance
             */
            ClothesPB.prototype.recastHpMax = 0;

            /**
             * ClothesPB recastResistanceList.
             * @member {Array.<luck.protobuf.IPropertyFloatPB>} recastResistanceList
             * @memberof luck.protobuf.ClothesPB
             * @instance
             */
            ClothesPB.prototype.recastResistanceList = $util.emptyArray;

            /**
             * ClothesPB recastReductionList.
             * @member {Array.<luck.protobuf.IPropertyIntPB>} recastReductionList
             * @memberof luck.protobuf.ClothesPB
             * @instance
             */
            ClothesPB.prototype.recastReductionList = $util.emptyArray;

            /**
             * ClothesPB exp.
             * @member {number} exp
             * @memberof luck.protobuf.ClothesPB
             * @instance
             */
            ClothesPB.prototype.exp = 0;

            /**
             * ClothesPB baptizePropertyList.
             * @member {Array.<luck.protobuf.IPropertyIntPB>} baptizePropertyList
             * @memberof luck.protobuf.ClothesPB
             * @instance
             */
            ClothesPB.prototype.baptizePropertyList = $util.emptyArray;

            /**
             * ClothesPB isBaptize.
             * @member {number} isBaptize
             * @memberof luck.protobuf.ClothesPB
             * @instance
             */
            ClothesPB.prototype.isBaptize = 0;

            /**
             * ClothesPB baptizeMedianList.
             * @member {Array.<luck.protobuf.IPropertyIntPB>} baptizeMedianList
             * @memberof luck.protobuf.ClothesPB
             * @instance
             */
            ClothesPB.prototype.baptizeMedianList = $util.emptyArray;

            /**
             * Creates a new ClothesPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.ClothesPB
             * @static
             * @param {luck.protobuf.IClothesPB=} [properties] Properties to set
             * @returns {luck.protobuf.ClothesPB} ClothesPB instance
             */
            ClothesPB.create = function create(properties) {
                return new ClothesPB(properties);
            };

            /**
             * Encodes the specified ClothesPB message. Does not implicitly {@link luck.protobuf.ClothesPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.ClothesPB
             * @static
             * @param {luck.protobuf.IClothesPB} message ClothesPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ClothesPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.uid);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.id);
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.lv);
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.HpMax);
                if (message.resistanceList != null && message.resistanceList.length)
                    for (var i = 0; i < message.resistanceList.length; ++i)
                        $root.luck.protobuf.PropertyFloatPB.encode(message.resistanceList[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.reductionList != null && message.reductionList.length)
                    for (var i = 0; i < message.reductionList.length; ++i)
                        $root.luck.protobuf.PropertyIntPB.encode(message.reductionList[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.baptizeNum);
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.holeCountMax);
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.advancedCount);
                if (message.inlayList != null && message.inlayList.length)
                    for (var i = 0; i < message.inlayList.length; ++i)
                        $root.luck.protobuf.ClothesInlayPB.encode(message.inlayList[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.isRecast);
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.recastHpMax);
                if (message.recastResistanceList != null && message.recastResistanceList.length)
                    for (var i = 0; i < message.recastResistanceList.length; ++i)
                        $root.luck.protobuf.PropertyFloatPB.encode(message.recastResistanceList[i], writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                if (message.recastReductionList != null && message.recastReductionList.length)
                    for (var i = 0; i < message.recastReductionList.length; ++i)
                        $root.luck.protobuf.PropertyIntPB.encode(message.recastReductionList[i], writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                writer.uint32(/* id 15, wireType 0 =*/120).int32(message.exp);
                if (message.baptizePropertyList != null && message.baptizePropertyList.length)
                    for (var i = 0; i < message.baptizePropertyList.length; ++i)
                        $root.luck.protobuf.PropertyIntPB.encode(message.baptizePropertyList[i], writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                writer.uint32(/* id 17, wireType 0 =*/136).int32(message.isBaptize);
                if (message.baptizeMedianList != null && message.baptizeMedianList.length)
                    for (var i = 0; i < message.baptizeMedianList.length; ++i)
                        $root.luck.protobuf.PropertyIntPB.encode(message.baptizeMedianList[i], writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ClothesPB message, length delimited. Does not implicitly {@link luck.protobuf.ClothesPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.ClothesPB
             * @static
             * @param {luck.protobuf.IClothesPB} message ClothesPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ClothesPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ClothesPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.ClothesPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.ClothesPB} ClothesPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ClothesPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.ClothesPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.uid = reader.int64();
                        break;
                    case 2:
                        message.id = reader.int32();
                        break;
                    case 3:
                        message.lv = reader.int32();
                        break;
                    case 4:
                        message.HpMax = reader.int32();
                        break;
                    case 5:
                        if (!(message.resistanceList && message.resistanceList.length))
                            message.resistanceList = [];
                        message.resistanceList.push($root.luck.protobuf.PropertyFloatPB.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.reductionList && message.reductionList.length))
                            message.reductionList = [];
                        message.reductionList.push($root.luck.protobuf.PropertyIntPB.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        message.baptizeNum = reader.int32();
                        break;
                    case 8:
                        message.holeCountMax = reader.int32();
                        break;
                    case 9:
                        message.advancedCount = reader.int32();
                        break;
                    case 10:
                        if (!(message.inlayList && message.inlayList.length))
                            message.inlayList = [];
                        message.inlayList.push($root.luck.protobuf.ClothesInlayPB.decode(reader, reader.uint32()));
                        break;
                    case 11:
                        message.isRecast = reader.int32();
                        break;
                    case 12:
                        message.recastHpMax = reader.int32();
                        break;
                    case 13:
                        if (!(message.recastResistanceList && message.recastResistanceList.length))
                            message.recastResistanceList = [];
                        message.recastResistanceList.push($root.luck.protobuf.PropertyFloatPB.decode(reader, reader.uint32()));
                        break;
                    case 14:
                        if (!(message.recastReductionList && message.recastReductionList.length))
                            message.recastReductionList = [];
                        message.recastReductionList.push($root.luck.protobuf.PropertyIntPB.decode(reader, reader.uint32()));
                        break;
                    case 15:
                        message.exp = reader.int32();
                        break;
                    case 16:
                        if (!(message.baptizePropertyList && message.baptizePropertyList.length))
                            message.baptizePropertyList = [];
                        message.baptizePropertyList.push($root.luck.protobuf.PropertyIntPB.decode(reader, reader.uint32()));
                        break;
                    case 17:
                        message.isBaptize = reader.int32();
                        break;
                    case 18:
                        if (!(message.baptizeMedianList && message.baptizeMedianList.length))
                            message.baptizeMedianList = [];
                        message.baptizeMedianList.push($root.luck.protobuf.PropertyIntPB.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("uid"))
                    throw $util.ProtocolError("missing required 'uid'", { instance: message });
                if (!message.hasOwnProperty("id"))
                    throw $util.ProtocolError("missing required 'id'", { instance: message });
                if (!message.hasOwnProperty("lv"))
                    throw $util.ProtocolError("missing required 'lv'", { instance: message });
                if (!message.hasOwnProperty("HpMax"))
                    throw $util.ProtocolError("missing required 'HpMax'", { instance: message });
                if (!message.hasOwnProperty("baptizeNum"))
                    throw $util.ProtocolError("missing required 'baptizeNum'", { instance: message });
                if (!message.hasOwnProperty("holeCountMax"))
                    throw $util.ProtocolError("missing required 'holeCountMax'", { instance: message });
                if (!message.hasOwnProperty("advancedCount"))
                    throw $util.ProtocolError("missing required 'advancedCount'", { instance: message });
                if (!message.hasOwnProperty("isRecast"))
                    throw $util.ProtocolError("missing required 'isRecast'", { instance: message });
                if (!message.hasOwnProperty("recastHpMax"))
                    throw $util.ProtocolError("missing required 'recastHpMax'", { instance: message });
                if (!message.hasOwnProperty("exp"))
                    throw $util.ProtocolError("missing required 'exp'", { instance: message });
                if (!message.hasOwnProperty("isBaptize"))
                    throw $util.ProtocolError("missing required 'isBaptize'", { instance: message });
                return message;
            };

            /**
             * Decodes a ClothesPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.ClothesPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.ClothesPB} ClothesPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ClothesPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ClothesPB message.
             * @function verify
             * @memberof luck.protobuf.ClothesPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ClothesPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
                if (!$util.isInteger(message.lv))
                    return "lv: integer expected";
                if (!$util.isInteger(message.HpMax))
                    return "HpMax: integer expected";
                if (message.resistanceList != null && message.hasOwnProperty("resistanceList")) {
                    if (!Array.isArray(message.resistanceList))
                        return "resistanceList: array expected";
                    for (var i = 0; i < message.resistanceList.length; ++i) {
                        var error = $root.luck.protobuf.PropertyFloatPB.verify(message.resistanceList[i]);
                        if (error)
                            return "resistanceList." + error;
                    }
                }
                if (message.reductionList != null && message.hasOwnProperty("reductionList")) {
                    if (!Array.isArray(message.reductionList))
                        return "reductionList: array expected";
                    for (var i = 0; i < message.reductionList.length; ++i) {
                        var error = $root.luck.protobuf.PropertyIntPB.verify(message.reductionList[i]);
                        if (error)
                            return "reductionList." + error;
                    }
                }
                if (!$util.isInteger(message.baptizeNum))
                    return "baptizeNum: integer expected";
                if (!$util.isInteger(message.holeCountMax))
                    return "holeCountMax: integer expected";
                if (!$util.isInteger(message.advancedCount))
                    return "advancedCount: integer expected";
                if (message.inlayList != null && message.hasOwnProperty("inlayList")) {
                    if (!Array.isArray(message.inlayList))
                        return "inlayList: array expected";
                    for (var i = 0; i < message.inlayList.length; ++i) {
                        var error = $root.luck.protobuf.ClothesInlayPB.verify(message.inlayList[i]);
                        if (error)
                            return "inlayList." + error;
                    }
                }
                if (!$util.isInteger(message.isRecast))
                    return "isRecast: integer expected";
                if (!$util.isInteger(message.recastHpMax))
                    return "recastHpMax: integer expected";
                if (message.recastResistanceList != null && message.hasOwnProperty("recastResistanceList")) {
                    if (!Array.isArray(message.recastResistanceList))
                        return "recastResistanceList: array expected";
                    for (var i = 0; i < message.recastResistanceList.length; ++i) {
                        var error = $root.luck.protobuf.PropertyFloatPB.verify(message.recastResistanceList[i]);
                        if (error)
                            return "recastResistanceList." + error;
                    }
                }
                if (message.recastReductionList != null && message.hasOwnProperty("recastReductionList")) {
                    if (!Array.isArray(message.recastReductionList))
                        return "recastReductionList: array expected";
                    for (var i = 0; i < message.recastReductionList.length; ++i) {
                        var error = $root.luck.protobuf.PropertyIntPB.verify(message.recastReductionList[i]);
                        if (error)
                            return "recastReductionList." + error;
                    }
                }
                if (!$util.isInteger(message.exp))
                    return "exp: integer expected";
                if (message.baptizePropertyList != null && message.hasOwnProperty("baptizePropertyList")) {
                    if (!Array.isArray(message.baptizePropertyList))
                        return "baptizePropertyList: array expected";
                    for (var i = 0; i < message.baptizePropertyList.length; ++i) {
                        var error = $root.luck.protobuf.PropertyIntPB.verify(message.baptizePropertyList[i]);
                        if (error)
                            return "baptizePropertyList." + error;
                    }
                }
                if (!$util.isInteger(message.isBaptize))
                    return "isBaptize: integer expected";
                if (message.baptizeMedianList != null && message.hasOwnProperty("baptizeMedianList")) {
                    if (!Array.isArray(message.baptizeMedianList))
                        return "baptizeMedianList: array expected";
                    for (var i = 0; i < message.baptizeMedianList.length; ++i) {
                        var error = $root.luck.protobuf.PropertyIntPB.verify(message.baptizeMedianList[i]);
                        if (error)
                            return "baptizeMedianList." + error;
                    }
                }
                return null;
            };

            return ClothesPB;
        })();

        protobuf.PropertyIntPB = (function() {

            /**
             * Properties of a PropertyIntPB.
             * @memberof luck.protobuf
             * @interface IPropertyIntPB
             * @property {number} type PropertyIntPB type
             * @property {number} value PropertyIntPB value
             */

            /**
             * Constructs a new PropertyIntPB.
             * @memberof luck.protobuf
             * @classdesc Represents a PropertyIntPB.
             * @implements IPropertyIntPB
             * @constructor
             * @param {luck.protobuf.IPropertyIntPB=} [properties] Properties to set
             */
            function PropertyIntPB(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PropertyIntPB type.
             * @member {number} type
             * @memberof luck.protobuf.PropertyIntPB
             * @instance
             */
            PropertyIntPB.prototype.type = 0;

            /**
             * PropertyIntPB value.
             * @member {number} value
             * @memberof luck.protobuf.PropertyIntPB
             * @instance
             */
            PropertyIntPB.prototype.value = 0;

            /**
             * Creates a new PropertyIntPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.PropertyIntPB
             * @static
             * @param {luck.protobuf.IPropertyIntPB=} [properties] Properties to set
             * @returns {luck.protobuf.PropertyIntPB} PropertyIntPB instance
             */
            PropertyIntPB.create = function create(properties) {
                return new PropertyIntPB(properties);
            };

            /**
             * Encodes the specified PropertyIntPB message. Does not implicitly {@link luck.protobuf.PropertyIntPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.PropertyIntPB
             * @static
             * @param {luck.protobuf.IPropertyIntPB} message PropertyIntPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PropertyIntPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.value);
                return writer;
            };

            /**
             * Encodes the specified PropertyIntPB message, length delimited. Does not implicitly {@link luck.protobuf.PropertyIntPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.PropertyIntPB
             * @static
             * @param {luck.protobuf.IPropertyIntPB} message PropertyIntPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PropertyIntPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PropertyIntPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.PropertyIntPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.PropertyIntPB} PropertyIntPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PropertyIntPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.PropertyIntPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.value = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("type"))
                    throw $util.ProtocolError("missing required 'type'", { instance: message });
                if (!message.hasOwnProperty("value"))
                    throw $util.ProtocolError("missing required 'value'", { instance: message });
                return message;
            };

            /**
             * Decodes a PropertyIntPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.PropertyIntPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.PropertyIntPB} PropertyIntPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PropertyIntPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PropertyIntPB message.
             * @function verify
             * @memberof luck.protobuf.PropertyIntPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PropertyIntPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
                if (!$util.isInteger(message.value))
                    return "value: integer expected";
                return null;
            };

            return PropertyIntPB;
        })();

        protobuf.PropertyFloatPB = (function() {

            /**
             * Properties of a PropertyFloatPB.
             * @memberof luck.protobuf
             * @interface IPropertyFloatPB
             * @property {number} type PropertyFloatPB type
             * @property {number} value PropertyFloatPB value
             */

            /**
             * Constructs a new PropertyFloatPB.
             * @memberof luck.protobuf
             * @classdesc Represents a PropertyFloatPB.
             * @implements IPropertyFloatPB
             * @constructor
             * @param {luck.protobuf.IPropertyFloatPB=} [properties] Properties to set
             */
            function PropertyFloatPB(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PropertyFloatPB type.
             * @member {number} type
             * @memberof luck.protobuf.PropertyFloatPB
             * @instance
             */
            PropertyFloatPB.prototype.type = 0;

            /**
             * PropertyFloatPB value.
             * @member {number} value
             * @memberof luck.protobuf.PropertyFloatPB
             * @instance
             */
            PropertyFloatPB.prototype.value = 0;

            /**
             * Creates a new PropertyFloatPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.PropertyFloatPB
             * @static
             * @param {luck.protobuf.IPropertyFloatPB=} [properties] Properties to set
             * @returns {luck.protobuf.PropertyFloatPB} PropertyFloatPB instance
             */
            PropertyFloatPB.create = function create(properties) {
                return new PropertyFloatPB(properties);
            };

            /**
             * Encodes the specified PropertyFloatPB message. Does not implicitly {@link luck.protobuf.PropertyFloatPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.PropertyFloatPB
             * @static
             * @param {luck.protobuf.IPropertyFloatPB} message PropertyFloatPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PropertyFloatPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.value);
                return writer;
            };

            /**
             * Encodes the specified PropertyFloatPB message, length delimited. Does not implicitly {@link luck.protobuf.PropertyFloatPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.PropertyFloatPB
             * @static
             * @param {luck.protobuf.IPropertyFloatPB} message PropertyFloatPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PropertyFloatPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PropertyFloatPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.PropertyFloatPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.PropertyFloatPB} PropertyFloatPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PropertyFloatPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.PropertyFloatPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.value = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("type"))
                    throw $util.ProtocolError("missing required 'type'", { instance: message });
                if (!message.hasOwnProperty("value"))
                    throw $util.ProtocolError("missing required 'value'", { instance: message });
                return message;
            };

            /**
             * Decodes a PropertyFloatPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.PropertyFloatPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.PropertyFloatPB} PropertyFloatPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PropertyFloatPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PropertyFloatPB message.
             * @function verify
             * @memberof luck.protobuf.PropertyFloatPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PropertyFloatPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
                if (typeof message.value !== "number")
                    return "value: number expected";
                return null;
            };

            return PropertyFloatPB;
        })();

        protobuf.PropPB = (function() {

            /**
             * Properties of a PropPB.
             * @memberof luck.protobuf
             * @interface IPropPB
             * @property {number} id PropPB id
             * @property {number} num PropPB num
             */

            /**
             * Constructs a new PropPB.
             * @memberof luck.protobuf
             * @classdesc Represents a PropPB.
             * @implements IPropPB
             * @constructor
             * @param {luck.protobuf.IPropPB=} [properties] Properties to set
             */
            function PropPB(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PropPB id.
             * @member {number} id
             * @memberof luck.protobuf.PropPB
             * @instance
             */
            PropPB.prototype.id = 0;

            /**
             * PropPB num.
             * @member {number} num
             * @memberof luck.protobuf.PropPB
             * @instance
             */
            PropPB.prototype.num = 0;

            /**
             * Creates a new PropPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.PropPB
             * @static
             * @param {luck.protobuf.IPropPB=} [properties] Properties to set
             * @returns {luck.protobuf.PropPB} PropPB instance
             */
            PropPB.create = function create(properties) {
                return new PropPB(properties);
            };

            /**
             * Encodes the specified PropPB message. Does not implicitly {@link luck.protobuf.PropPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.PropPB
             * @static
             * @param {luck.protobuf.IPropPB} message PropPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PropPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.num);
                return writer;
            };

            /**
             * Encodes the specified PropPB message, length delimited. Does not implicitly {@link luck.protobuf.PropPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.PropPB
             * @static
             * @param {luck.protobuf.IPropPB} message PropPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PropPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PropPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.PropPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.PropPB} PropPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PropPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.PropPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.int32();
                        break;
                    case 2:
                        message.num = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("id"))
                    throw $util.ProtocolError("missing required 'id'", { instance: message });
                if (!message.hasOwnProperty("num"))
                    throw $util.ProtocolError("missing required 'num'", { instance: message });
                return message;
            };

            /**
             * Decodes a PropPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.PropPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.PropPB} PropPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PropPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PropPB message.
             * @function verify
             * @memberof luck.protobuf.PropPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PropPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
                if (!$util.isInteger(message.num))
                    return "num: integer expected";
                return null;
            };

            return PropPB;
        })();

        protobuf.MaterialsPB = (function() {

            /**
             * Properties of a MaterialsPB.
             * @memberof luck.protobuf
             * @interface IMaterialsPB
             * @property {number} id MaterialsPB id
             * @property {number} num MaterialsPB num
             */

            /**
             * Constructs a new MaterialsPB.
             * @memberof luck.protobuf
             * @classdesc Represents a MaterialsPB.
             * @implements IMaterialsPB
             * @constructor
             * @param {luck.protobuf.IMaterialsPB=} [properties] Properties to set
             */
            function MaterialsPB(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MaterialsPB id.
             * @member {number} id
             * @memberof luck.protobuf.MaterialsPB
             * @instance
             */
            MaterialsPB.prototype.id = 0;

            /**
             * MaterialsPB num.
             * @member {number} num
             * @memberof luck.protobuf.MaterialsPB
             * @instance
             */
            MaterialsPB.prototype.num = 0;

            /**
             * Creates a new MaterialsPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.MaterialsPB
             * @static
             * @param {luck.protobuf.IMaterialsPB=} [properties] Properties to set
             * @returns {luck.protobuf.MaterialsPB} MaterialsPB instance
             */
            MaterialsPB.create = function create(properties) {
                return new MaterialsPB(properties);
            };

            /**
             * Encodes the specified MaterialsPB message. Does not implicitly {@link luck.protobuf.MaterialsPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.MaterialsPB
             * @static
             * @param {luck.protobuf.IMaterialsPB} message MaterialsPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MaterialsPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.num);
                return writer;
            };

            /**
             * Encodes the specified MaterialsPB message, length delimited. Does not implicitly {@link luck.protobuf.MaterialsPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.MaterialsPB
             * @static
             * @param {luck.protobuf.IMaterialsPB} message MaterialsPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MaterialsPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MaterialsPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.MaterialsPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.MaterialsPB} MaterialsPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MaterialsPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.MaterialsPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.int32();
                        break;
                    case 2:
                        message.num = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("id"))
                    throw $util.ProtocolError("missing required 'id'", { instance: message });
                if (!message.hasOwnProperty("num"))
                    throw $util.ProtocolError("missing required 'num'", { instance: message });
                return message;
            };

            /**
             * Decodes a MaterialsPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.MaterialsPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.MaterialsPB} MaterialsPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MaterialsPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MaterialsPB message.
             * @function verify
             * @memberof luck.protobuf.MaterialsPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MaterialsPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
                if (!$util.isInteger(message.num))
                    return "num: integer expected";
                return null;
            };

            return MaterialsPB;
        })();

        protobuf.ItemBagPB = (function() {

            /**
             * Properties of an ItemBagPB.
             * @memberof luck.protobuf
             * @interface IItemBagPB
             * @property {Array.<luck.protobuf.IPropPB>|null} [propList] ItemBagPB propList
             * @property {Array.<luck.protobuf.IMaterialsPB>|null} [materialsList] ItemBagPB materialsList
             */

            /**
             * Constructs a new ItemBagPB.
             * @memberof luck.protobuf
             * @classdesc Represents an ItemBagPB.
             * @implements IItemBagPB
             * @constructor
             * @param {luck.protobuf.IItemBagPB=} [properties] Properties to set
             */
            function ItemBagPB(properties) {
                this.propList = [];
                this.materialsList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ItemBagPB propList.
             * @member {Array.<luck.protobuf.IPropPB>} propList
             * @memberof luck.protobuf.ItemBagPB
             * @instance
             */
            ItemBagPB.prototype.propList = $util.emptyArray;

            /**
             * ItemBagPB materialsList.
             * @member {Array.<luck.protobuf.IMaterialsPB>} materialsList
             * @memberof luck.protobuf.ItemBagPB
             * @instance
             */
            ItemBagPB.prototype.materialsList = $util.emptyArray;

            /**
             * Creates a new ItemBagPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.ItemBagPB
             * @static
             * @param {luck.protobuf.IItemBagPB=} [properties] Properties to set
             * @returns {luck.protobuf.ItemBagPB} ItemBagPB instance
             */
            ItemBagPB.create = function create(properties) {
                return new ItemBagPB(properties);
            };

            /**
             * Encodes the specified ItemBagPB message. Does not implicitly {@link luck.protobuf.ItemBagPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.ItemBagPB
             * @static
             * @param {luck.protobuf.IItemBagPB} message ItemBagPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ItemBagPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.propList != null && message.propList.length)
                    for (var i = 0; i < message.propList.length; ++i)
                        $root.luck.protobuf.PropPB.encode(message.propList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.materialsList != null && message.materialsList.length)
                    for (var i = 0; i < message.materialsList.length; ++i)
                        $root.luck.protobuf.MaterialsPB.encode(message.materialsList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ItemBagPB message, length delimited. Does not implicitly {@link luck.protobuf.ItemBagPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.ItemBagPB
             * @static
             * @param {luck.protobuf.IItemBagPB} message ItemBagPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ItemBagPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ItemBagPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.ItemBagPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.ItemBagPB} ItemBagPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ItemBagPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.ItemBagPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.propList && message.propList.length))
                            message.propList = [];
                        message.propList.push($root.luck.protobuf.PropPB.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        if (!(message.materialsList && message.materialsList.length))
                            message.materialsList = [];
                        message.materialsList.push($root.luck.protobuf.MaterialsPB.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ItemBagPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.ItemBagPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.ItemBagPB} ItemBagPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ItemBagPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ItemBagPB message.
             * @function verify
             * @memberof luck.protobuf.ItemBagPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ItemBagPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.propList != null && message.hasOwnProperty("propList")) {
                    if (!Array.isArray(message.propList))
                        return "propList: array expected";
                    for (var i = 0; i < message.propList.length; ++i) {
                        var error = $root.luck.protobuf.PropPB.verify(message.propList[i]);
                        if (error)
                            return "propList." + error;
                    }
                }
                if (message.materialsList != null && message.hasOwnProperty("materialsList")) {
                    if (!Array.isArray(message.materialsList))
                        return "materialsList: array expected";
                    for (var i = 0; i < message.materialsList.length; ++i) {
                        var error = $root.luck.protobuf.MaterialsPB.verify(message.materialsList[i]);
                        if (error)
                            return "materialsList." + error;
                    }
                }
                return null;
            };

            return ItemBagPB;
        })();

        protobuf.OperationPB = (function() {

            /**
             * Properties of an OperationPB.
             * @memberof luck.protobuf
             * @interface IOperationPB
             * @property {number|Long} pid OperationPB pid
             * @property {number} operationType OperationPB operationType
             * @property {luck.protobuf.IVectorPB|null} [rocker] OperationPB rocker
             */

            /**
             * Constructs a new OperationPB.
             * @memberof luck.protobuf
             * @classdesc Represents an OperationPB.
             * @implements IOperationPB
             * @constructor
             * @param {luck.protobuf.IOperationPB=} [properties] Properties to set
             */
            function OperationPB(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OperationPB pid.
             * @member {number|Long} pid
             * @memberof luck.protobuf.OperationPB
             * @instance
             */
            OperationPB.prototype.pid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * OperationPB operationType.
             * @member {number} operationType
             * @memberof luck.protobuf.OperationPB
             * @instance
             */
            OperationPB.prototype.operationType = 0;

            /**
             * OperationPB rocker.
             * @member {luck.protobuf.IVectorPB|null|undefined} rocker
             * @memberof luck.protobuf.OperationPB
             * @instance
             */
            OperationPB.prototype.rocker = null;

            /**
             * Creates a new OperationPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.OperationPB
             * @static
             * @param {luck.protobuf.IOperationPB=} [properties] Properties to set
             * @returns {luck.protobuf.OperationPB} OperationPB instance
             */
            OperationPB.create = function create(properties) {
                return new OperationPB(properties);
            };

            /**
             * Encodes the specified OperationPB message. Does not implicitly {@link luck.protobuf.OperationPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.OperationPB
             * @static
             * @param {luck.protobuf.IOperationPB} message OperationPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OperationPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.pid);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.operationType);
                if (message.rocker != null && message.hasOwnProperty("rocker"))
                    $root.luck.protobuf.VectorPB.encode(message.rocker, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified OperationPB message, length delimited. Does not implicitly {@link luck.protobuf.OperationPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.OperationPB
             * @static
             * @param {luck.protobuf.IOperationPB} message OperationPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OperationPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an OperationPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.OperationPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.OperationPB} OperationPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OperationPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.OperationPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.pid = reader.int64();
                        break;
                    case 2:
                        message.operationType = reader.int32();
                        break;
                    case 3:
                        message.rocker = $root.luck.protobuf.VectorPB.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("pid"))
                    throw $util.ProtocolError("missing required 'pid'", { instance: message });
                if (!message.hasOwnProperty("operationType"))
                    throw $util.ProtocolError("missing required 'operationType'", { instance: message });
                return message;
            };

            /**
             * Decodes an OperationPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.OperationPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.OperationPB} OperationPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OperationPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an OperationPB message.
             * @function verify
             * @memberof luck.protobuf.OperationPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OperationPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.pid) && !(message.pid && $util.isInteger(message.pid.low) && $util.isInteger(message.pid.high)))
                    return "pid: integer|Long expected";
                if (!$util.isInteger(message.operationType))
                    return "operationType: integer expected";
                if (message.rocker != null && message.hasOwnProperty("rocker")) {
                    var error = $root.luck.protobuf.VectorPB.verify(message.rocker);
                    if (error)
                        return "rocker." + error;
                }
                return null;
            };

            return OperationPB;
        })();

        protobuf.VectorPB = (function() {

            /**
             * Properties of a VectorPB.
             * @memberof luck.protobuf
             * @interface IVectorPB
             * @property {number} X VectorPB X
             * @property {number} Y VectorPB Y
             */

            /**
             * Constructs a new VectorPB.
             * @memberof luck.protobuf
             * @classdesc Represents a VectorPB.
             * @implements IVectorPB
             * @constructor
             * @param {luck.protobuf.IVectorPB=} [properties] Properties to set
             */
            function VectorPB(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * VectorPB X.
             * @member {number} X
             * @memberof luck.protobuf.VectorPB
             * @instance
             */
            VectorPB.prototype.X = 0;

            /**
             * VectorPB Y.
             * @member {number} Y
             * @memberof luck.protobuf.VectorPB
             * @instance
             */
            VectorPB.prototype.Y = 0;

            /**
             * Creates a new VectorPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.VectorPB
             * @static
             * @param {luck.protobuf.IVectorPB=} [properties] Properties to set
             * @returns {luck.protobuf.VectorPB} VectorPB instance
             */
            VectorPB.create = function create(properties) {
                return new VectorPB(properties);
            };

            /**
             * Encodes the specified VectorPB message. Does not implicitly {@link luck.protobuf.VectorPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.VectorPB
             * @static
             * @param {luck.protobuf.IVectorPB} message VectorPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VectorPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.X);
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.Y);
                return writer;
            };

            /**
             * Encodes the specified VectorPB message, length delimited. Does not implicitly {@link luck.protobuf.VectorPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.VectorPB
             * @static
             * @param {luck.protobuf.IVectorPB} message VectorPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VectorPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a VectorPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.VectorPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.VectorPB} VectorPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VectorPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.VectorPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.X = reader.float();
                        break;
                    case 2:
                        message.Y = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("X"))
                    throw $util.ProtocolError("missing required 'X'", { instance: message });
                if (!message.hasOwnProperty("Y"))
                    throw $util.ProtocolError("missing required 'Y'", { instance: message });
                return message;
            };

            /**
             * Decodes a VectorPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.VectorPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.VectorPB} VectorPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VectorPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a VectorPB message.
             * @function verify
             * @memberof luck.protobuf.VectorPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            VectorPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (typeof message.X !== "number")
                    return "X: number expected";
                if (typeof message.Y !== "number")
                    return "Y: number expected";
                return null;
            };

            return VectorPB;
        })();

        protobuf.RoomPB = (function() {

            /**
             * Properties of a RoomPB.
             * @memberof luck.protobuf
             * @interface IRoomPB
             * @property {Array.<number|Long>|null} [playerIdList] RoomPB playerIdList
             * @property {number|Long} roomId RoomPB roomId
             * @property {string} roomName RoomPB roomName
             * @property {number} seed RoomPB seed
             */

            /**
             * Constructs a new RoomPB.
             * @memberof luck.protobuf
             * @classdesc Represents a RoomPB.
             * @implements IRoomPB
             * @constructor
             * @param {luck.protobuf.IRoomPB=} [properties] Properties to set
             */
            function RoomPB(properties) {
                this.playerIdList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RoomPB playerIdList.
             * @member {Array.<number|Long>} playerIdList
             * @memberof luck.protobuf.RoomPB
             * @instance
             */
            RoomPB.prototype.playerIdList = $util.emptyArray;

            /**
             * RoomPB roomId.
             * @member {number|Long} roomId
             * @memberof luck.protobuf.RoomPB
             * @instance
             */
            RoomPB.prototype.roomId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * RoomPB roomName.
             * @member {string} roomName
             * @memberof luck.protobuf.RoomPB
             * @instance
             */
            RoomPB.prototype.roomName = "";

            /**
             * RoomPB seed.
             * @member {number} seed
             * @memberof luck.protobuf.RoomPB
             * @instance
             */
            RoomPB.prototype.seed = 0;

            /**
             * Creates a new RoomPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.RoomPB
             * @static
             * @param {luck.protobuf.IRoomPB=} [properties] Properties to set
             * @returns {luck.protobuf.RoomPB} RoomPB instance
             */
            RoomPB.create = function create(properties) {
                return new RoomPB(properties);
            };

            /**
             * Encodes the specified RoomPB message. Does not implicitly {@link luck.protobuf.RoomPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.RoomPB
             * @static
             * @param {luck.protobuf.IRoomPB} message RoomPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RoomPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.playerIdList != null && message.playerIdList.length)
                    for (var i = 0; i < message.playerIdList.length; ++i)
                        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.playerIdList[i]);
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.roomId);
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.roomName);
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.seed);
                return writer;
            };

            /**
             * Encodes the specified RoomPB message, length delimited. Does not implicitly {@link luck.protobuf.RoomPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.RoomPB
             * @static
             * @param {luck.protobuf.IRoomPB} message RoomPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RoomPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RoomPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.RoomPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.RoomPB} RoomPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RoomPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.RoomPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.playerIdList && message.playerIdList.length))
                            message.playerIdList = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.playerIdList.push(reader.int64());
                        } else
                            message.playerIdList.push(reader.int64());
                        break;
                    case 2:
                        message.roomId = reader.int64();
                        break;
                    case 3:
                        message.roomName = reader.string();
                        break;
                    case 4:
                        message.seed = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("roomId"))
                    throw $util.ProtocolError("missing required 'roomId'", { instance: message });
                if (!message.hasOwnProperty("roomName"))
                    throw $util.ProtocolError("missing required 'roomName'", { instance: message });
                if (!message.hasOwnProperty("seed"))
                    throw $util.ProtocolError("missing required 'seed'", { instance: message });
                return message;
            };

            /**
             * Decodes a RoomPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.RoomPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.RoomPB} RoomPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RoomPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RoomPB message.
             * @function verify
             * @memberof luck.protobuf.RoomPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RoomPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.playerIdList != null && message.hasOwnProperty("playerIdList")) {
                    if (!Array.isArray(message.playerIdList))
                        return "playerIdList: array expected";
                    for (var i = 0; i < message.playerIdList.length; ++i)
                        if (!$util.isInteger(message.playerIdList[i]) && !(message.playerIdList[i] && $util.isInteger(message.playerIdList[i].low) && $util.isInteger(message.playerIdList[i].high)))
                            return "playerIdList: integer|Long[] expected";
                }
                if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high)))
                    return "roomId: integer|Long expected";
                if (!$util.isString(message.roomName))
                    return "roomName: string expected";
                if (!$util.isInteger(message.seed))
                    return "seed: integer expected";
                return null;
            };

            return RoomPB;
        })();

        protobuf.CheckNode = (function() {

            /**
             * Properties of a CheckNode.
             * @memberof luck.protobuf
             * @interface ICheckNode
             * @property {number} nodeId CheckNode nodeId
             * @property {number} firstPass CheckNode firstPass
             * @property {number} passNum CheckNode passNum
             */

            /**
             * Constructs a new CheckNode.
             * @memberof luck.protobuf
             * @classdesc Represents a CheckNode.
             * @implements ICheckNode
             * @constructor
             * @param {luck.protobuf.ICheckNode=} [properties] Properties to set
             */
            function CheckNode(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CheckNode nodeId.
             * @member {number} nodeId
             * @memberof luck.protobuf.CheckNode
             * @instance
             */
            CheckNode.prototype.nodeId = 0;

            /**
             * CheckNode firstPass.
             * @member {number} firstPass
             * @memberof luck.protobuf.CheckNode
             * @instance
             */
            CheckNode.prototype.firstPass = 0;

            /**
             * CheckNode passNum.
             * @member {number} passNum
             * @memberof luck.protobuf.CheckNode
             * @instance
             */
            CheckNode.prototype.passNum = 0;

            /**
             * Creates a new CheckNode instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.CheckNode
             * @static
             * @param {luck.protobuf.ICheckNode=} [properties] Properties to set
             * @returns {luck.protobuf.CheckNode} CheckNode instance
             */
            CheckNode.create = function create(properties) {
                return new CheckNode(properties);
            };

            /**
             * Encodes the specified CheckNode message. Does not implicitly {@link luck.protobuf.CheckNode.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.CheckNode
             * @static
             * @param {luck.protobuf.ICheckNode} message CheckNode message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CheckNode.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.nodeId);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.firstPass);
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.passNum);
                return writer;
            };

            /**
             * Encodes the specified CheckNode message, length delimited. Does not implicitly {@link luck.protobuf.CheckNode.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.CheckNode
             * @static
             * @param {luck.protobuf.ICheckNode} message CheckNode message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CheckNode.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CheckNode message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.CheckNode
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.CheckNode} CheckNode
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CheckNode.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.CheckNode();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.nodeId = reader.int32();
                        break;
                    case 2:
                        message.firstPass = reader.int32();
                        break;
                    case 3:
                        message.passNum = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("nodeId"))
                    throw $util.ProtocolError("missing required 'nodeId'", { instance: message });
                if (!message.hasOwnProperty("firstPass"))
                    throw $util.ProtocolError("missing required 'firstPass'", { instance: message });
                if (!message.hasOwnProperty("passNum"))
                    throw $util.ProtocolError("missing required 'passNum'", { instance: message });
                return message;
            };

            /**
             * Decodes a CheckNode message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.CheckNode
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.CheckNode} CheckNode
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CheckNode.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CheckNode message.
             * @function verify
             * @memberof luck.protobuf.CheckNode
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CheckNode.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.nodeId))
                    return "nodeId: integer expected";
                if (!$util.isInteger(message.firstPass))
                    return "firstPass: integer expected";
                if (!$util.isInteger(message.passNum))
                    return "passNum: integer expected";
                return null;
            };

            return CheckNode;
        })();

        protobuf.PlayerExtraPB = (function() {

            /**
             * Properties of a PlayerExtraPB.
             * @memberof luck.protobuf
             * @interface IPlayerExtraPB
             * @property {number|Long} sginInTime PlayerExtraPB sginInTime
             * @property {number} sginCount PlayerExtraPB sginCount
             * @property {number|Long} serverTime PlayerExtraPB serverTime
             * @property {number} allCount PlayerExtraPB allCount
             * @property {string} telePhone PlayerExtraPB telePhone
             * @property {string} email PlayerExtraPB email
             * @property {number} isCheckName PlayerExtraPB isCheckName
             * @property {number} refuseFriendReq PlayerExtraPB refuseFriendReq
             * @property {number} refuseStrangerNews PlayerExtraPB refuseStrangerNews
             * @property {number} refuseClubInvite PlayerExtraPB refuseClubInvite
             * @property {number} refuseSysInfo PlayerExtraPB refuseSysInfo
             * @property {number} refuseTeamInvite PlayerExtraPB refuseTeamInvite
             * @property {number} refuseBattleInvite PlayerExtraPB refuseBattleInvite
             * @property {number} closeBarrage PlayerExtraPB closeBarrage
             * @property {number|Long} lastEmailTime PlayerExtraPB lastEmailTime
             * @property {number} packGrid PlayerExtraPB packGrid
             * @property {Array.<luck.protobuf.IShopGoodsPB>|null} [shopGoodsList] PlayerExtraPB shopGoodsList
             * @property {Array.<luck.protobuf.IActivityTollgatePB>|null} [activityTollgateList] PlayerExtraPB activityTollgateList
             * @property {Array.<luck.protobuf.IActivityChapterPB>|null} [activityChapterList] PlayerExtraPB activityChapterList
             * @property {luck.protobuf.ILoveBentoPB} loveBento PlayerExtraPB loveBento
             * @property {Array.<luck.protobuf.IShopGoodsPB>|null} [gangShopGoodsList] PlayerExtraPB gangShopGoodsList
             * @property {Array.<luck.protobuf.IVipRewardPB>|null} [vipRewardList] PlayerExtraPB vipRewardList
             * @property {number} staminaBuyTimes PlayerExtraPB staminaBuyTimes
             * @property {number|Long} lastRefreshStaminaTime PlayerExtraPB lastRefreshStaminaTime
             * @property {number|Long} lastWorldChatTime PlayerExtraPB lastWorldChatTime
             * @property {Array.<luck.protobuf.IMonthCardPB>|null} [monthCardList] PlayerExtraPB monthCardList
             * @property {number} growthCapital PlayerExtraPB growthCapital
             * @property {number} totalLoginTimes PlayerExtraPB totalLoginTimes
             * @property {number} greenWeaponCollect PlayerExtraPB greenWeaponCollect
             * @property {number} blueWeaponCollect PlayerExtraPB blueWeaponCollect
             * @property {number} purpleWeaponCollect PlayerExtraPB purpleWeaponCollect
             * @property {number} orangeWeaponCollect PlayerExtraPB orangeWeaponCollect
             * @property {number} redWeaponCollect PlayerExtraPB redWeaponCollect
             * @property {number|Long} lastLoginTime PlayerExtraPB lastLoginTime
             * @property {luck.protobuf.IDiggingPB} digging PlayerExtraPB digging
             * @property {Array.<luck.protobuf.IShopGoodsPB>|null} [activityShopList] PlayerExtraPB activityShopList
             * @property {Array.<luck.protobuf.IActivityLotteryPB>|null} [activityLottery] PlayerExtraPB activityLottery
             * @property {Array.<luck.protobuf.IGainBuffPB>|null} [gainBuffList] PlayerExtraPB gainBuffList
             * @property {number} noviceGuideNum PlayerExtraPB noviceGuideNum
             * @property {number} isFirstLotteryTwo PlayerExtraPB isFirstLotteryTwo
             * @property {number} headPortraitId PlayerExtraPB headPortraitId
             * @property {Array.<number>|null} [headPortraitList] PlayerExtraPB headPortraitList
             * @property {number} rahmenId PlayerExtraPB rahmenId
             * @property {Array.<number>|null} [rahmenList] PlayerExtraPB rahmenList
             * @property {number|Long} lastGangSginInTime PlayerExtraPB lastGangSginInTime
             */

            /**
             * Constructs a new PlayerExtraPB.
             * @memberof luck.protobuf
             * @classdesc Represents a PlayerExtraPB.
             * @implements IPlayerExtraPB
             * @constructor
             * @param {luck.protobuf.IPlayerExtraPB=} [properties] Properties to set
             */
            function PlayerExtraPB(properties) {
                this.shopGoodsList = [];
                this.activityTollgateList = [];
                this.activityChapterList = [];
                this.gangShopGoodsList = [];
                this.vipRewardList = [];
                this.monthCardList = [];
                this.activityShopList = [];
                this.activityLottery = [];
                this.gainBuffList = [];
                this.headPortraitList = [];
                this.rahmenList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PlayerExtraPB sginInTime.
             * @member {number|Long} sginInTime
             * @memberof luck.protobuf.PlayerExtraPB
             * @instance
             */
            PlayerExtraPB.prototype.sginInTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PlayerExtraPB sginCount.
             * @member {number} sginCount
             * @memberof luck.protobuf.PlayerExtraPB
             * @instance
             */
            PlayerExtraPB.prototype.sginCount = 0;

            /**
             * PlayerExtraPB serverTime.
             * @member {number|Long} serverTime
             * @memberof luck.protobuf.PlayerExtraPB
             * @instance
             */
            PlayerExtraPB.prototype.serverTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PlayerExtraPB allCount.
             * @member {number} allCount
             * @memberof luck.protobuf.PlayerExtraPB
             * @instance
             */
            PlayerExtraPB.prototype.allCount = 0;

            /**
             * PlayerExtraPB telePhone.
             * @member {string} telePhone
             * @memberof luck.protobuf.PlayerExtraPB
             * @instance
             */
            PlayerExtraPB.prototype.telePhone = "";

            /**
             * PlayerExtraPB email.
             * @member {string} email
             * @memberof luck.protobuf.PlayerExtraPB
             * @instance
             */
            PlayerExtraPB.prototype.email = "";

            /**
             * PlayerExtraPB isCheckName.
             * @member {number} isCheckName
             * @memberof luck.protobuf.PlayerExtraPB
             * @instance
             */
            PlayerExtraPB.prototype.isCheckName = 0;

            /**
             * PlayerExtraPB refuseFriendReq.
             * @member {number} refuseFriendReq
             * @memberof luck.protobuf.PlayerExtraPB
             * @instance
             */
            PlayerExtraPB.prototype.refuseFriendReq = 0;

            /**
             * PlayerExtraPB refuseStrangerNews.
             * @member {number} refuseStrangerNews
             * @memberof luck.protobuf.PlayerExtraPB
             * @instance
             */
            PlayerExtraPB.prototype.refuseStrangerNews = 0;

            /**
             * PlayerExtraPB refuseClubInvite.
             * @member {number} refuseClubInvite
             * @memberof luck.protobuf.PlayerExtraPB
             * @instance
             */
            PlayerExtraPB.prototype.refuseClubInvite = 0;

            /**
             * PlayerExtraPB refuseSysInfo.
             * @member {number} refuseSysInfo
             * @memberof luck.protobuf.PlayerExtraPB
             * @instance
             */
            PlayerExtraPB.prototype.refuseSysInfo = 0;

            /**
             * PlayerExtraPB refuseTeamInvite.
             * @member {number} refuseTeamInvite
             * @memberof luck.protobuf.PlayerExtraPB
             * @instance
             */
            PlayerExtraPB.prototype.refuseTeamInvite = 0;

            /**
             * PlayerExtraPB refuseBattleInvite.
             * @member {number} refuseBattleInvite
             * @memberof luck.protobuf.PlayerExtraPB
             * @instance
             */
            PlayerExtraPB.prototype.refuseBattleInvite = 0;

            /**
             * PlayerExtraPB closeBarrage.
             * @member {number} closeBarrage
             * @memberof luck.protobuf.PlayerExtraPB
             * @instance
             */
            PlayerExtraPB.prototype.closeBarrage = 0;

            /**
             * PlayerExtraPB lastEmailTime.
             * @member {number|Long} lastEmailTime
             * @memberof luck.protobuf.PlayerExtraPB
             * @instance
             */
            PlayerExtraPB.prototype.lastEmailTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PlayerExtraPB packGrid.
             * @member {number} packGrid
             * @memberof luck.protobuf.PlayerExtraPB
             * @instance
             */
            PlayerExtraPB.prototype.packGrid = 0;

            /**
             * PlayerExtraPB shopGoodsList.
             * @member {Array.<luck.protobuf.IShopGoodsPB>} shopGoodsList
             * @memberof luck.protobuf.PlayerExtraPB
             * @instance
             */
            PlayerExtraPB.prototype.shopGoodsList = $util.emptyArray;

            /**
             * PlayerExtraPB activityTollgateList.
             * @member {Array.<luck.protobuf.IActivityTollgatePB>} activityTollgateList
             * @memberof luck.protobuf.PlayerExtraPB
             * @instance
             */
            PlayerExtraPB.prototype.activityTollgateList = $util.emptyArray;

            /**
             * PlayerExtraPB activityChapterList.
             * @member {Array.<luck.protobuf.IActivityChapterPB>} activityChapterList
             * @memberof luck.protobuf.PlayerExtraPB
             * @instance
             */
            PlayerExtraPB.prototype.activityChapterList = $util.emptyArray;

            /**
             * PlayerExtraPB loveBento.
             * @member {luck.protobuf.ILoveBentoPB} loveBento
             * @memberof luck.protobuf.PlayerExtraPB
             * @instance
             */
            PlayerExtraPB.prototype.loveBento = null;

            /**
             * PlayerExtraPB gangShopGoodsList.
             * @member {Array.<luck.protobuf.IShopGoodsPB>} gangShopGoodsList
             * @memberof luck.protobuf.PlayerExtraPB
             * @instance
             */
            PlayerExtraPB.prototype.gangShopGoodsList = $util.emptyArray;

            /**
             * PlayerExtraPB vipRewardList.
             * @member {Array.<luck.protobuf.IVipRewardPB>} vipRewardList
             * @memberof luck.protobuf.PlayerExtraPB
             * @instance
             */
            PlayerExtraPB.prototype.vipRewardList = $util.emptyArray;

            /**
             * PlayerExtraPB staminaBuyTimes.
             * @member {number} staminaBuyTimes
             * @memberof luck.protobuf.PlayerExtraPB
             * @instance
             */
            PlayerExtraPB.prototype.staminaBuyTimes = 0;

            /**
             * PlayerExtraPB lastRefreshStaminaTime.
             * @member {number|Long} lastRefreshStaminaTime
             * @memberof luck.protobuf.PlayerExtraPB
             * @instance
             */
            PlayerExtraPB.prototype.lastRefreshStaminaTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PlayerExtraPB lastWorldChatTime.
             * @member {number|Long} lastWorldChatTime
             * @memberof luck.protobuf.PlayerExtraPB
             * @instance
             */
            PlayerExtraPB.prototype.lastWorldChatTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PlayerExtraPB monthCardList.
             * @member {Array.<luck.protobuf.IMonthCardPB>} monthCardList
             * @memberof luck.protobuf.PlayerExtraPB
             * @instance
             */
            PlayerExtraPB.prototype.monthCardList = $util.emptyArray;

            /**
             * PlayerExtraPB growthCapital.
             * @member {number} growthCapital
             * @memberof luck.protobuf.PlayerExtraPB
             * @instance
             */
            PlayerExtraPB.prototype.growthCapital = 0;

            /**
             * PlayerExtraPB totalLoginTimes.
             * @member {number} totalLoginTimes
             * @memberof luck.protobuf.PlayerExtraPB
             * @instance
             */
            PlayerExtraPB.prototype.totalLoginTimes = 0;

            /**
             * PlayerExtraPB greenWeaponCollect.
             * @member {number} greenWeaponCollect
             * @memberof luck.protobuf.PlayerExtraPB
             * @instance
             */
            PlayerExtraPB.prototype.greenWeaponCollect = 0;

            /**
             * PlayerExtraPB blueWeaponCollect.
             * @member {number} blueWeaponCollect
             * @memberof luck.protobuf.PlayerExtraPB
             * @instance
             */
            PlayerExtraPB.prototype.blueWeaponCollect = 0;

            /**
             * PlayerExtraPB purpleWeaponCollect.
             * @member {number} purpleWeaponCollect
             * @memberof luck.protobuf.PlayerExtraPB
             * @instance
             */
            PlayerExtraPB.prototype.purpleWeaponCollect = 0;

            /**
             * PlayerExtraPB orangeWeaponCollect.
             * @member {number} orangeWeaponCollect
             * @memberof luck.protobuf.PlayerExtraPB
             * @instance
             */
            PlayerExtraPB.prototype.orangeWeaponCollect = 0;

            /**
             * PlayerExtraPB redWeaponCollect.
             * @member {number} redWeaponCollect
             * @memberof luck.protobuf.PlayerExtraPB
             * @instance
             */
            PlayerExtraPB.prototype.redWeaponCollect = 0;

            /**
             * PlayerExtraPB lastLoginTime.
             * @member {number|Long} lastLoginTime
             * @memberof luck.protobuf.PlayerExtraPB
             * @instance
             */
            PlayerExtraPB.prototype.lastLoginTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PlayerExtraPB digging.
             * @member {luck.protobuf.IDiggingPB} digging
             * @memberof luck.protobuf.PlayerExtraPB
             * @instance
             */
            PlayerExtraPB.prototype.digging = null;

            /**
             * PlayerExtraPB activityShopList.
             * @member {Array.<luck.protobuf.IShopGoodsPB>} activityShopList
             * @memberof luck.protobuf.PlayerExtraPB
             * @instance
             */
            PlayerExtraPB.prototype.activityShopList = $util.emptyArray;

            /**
             * PlayerExtraPB activityLottery.
             * @member {Array.<luck.protobuf.IActivityLotteryPB>} activityLottery
             * @memberof luck.protobuf.PlayerExtraPB
             * @instance
             */
            PlayerExtraPB.prototype.activityLottery = $util.emptyArray;

            /**
             * PlayerExtraPB gainBuffList.
             * @member {Array.<luck.protobuf.IGainBuffPB>} gainBuffList
             * @memberof luck.protobuf.PlayerExtraPB
             * @instance
             */
            PlayerExtraPB.prototype.gainBuffList = $util.emptyArray;

            /**
             * PlayerExtraPB noviceGuideNum.
             * @member {number} noviceGuideNum
             * @memberof luck.protobuf.PlayerExtraPB
             * @instance
             */
            PlayerExtraPB.prototype.noviceGuideNum = 0;

            /**
             * PlayerExtraPB isFirstLotteryTwo.
             * @member {number} isFirstLotteryTwo
             * @memberof luck.protobuf.PlayerExtraPB
             * @instance
             */
            PlayerExtraPB.prototype.isFirstLotteryTwo = 0;

            /**
             * PlayerExtraPB headPortraitId.
             * @member {number} headPortraitId
             * @memberof luck.protobuf.PlayerExtraPB
             * @instance
             */
            PlayerExtraPB.prototype.headPortraitId = 0;

            /**
             * PlayerExtraPB headPortraitList.
             * @member {Array.<number>} headPortraitList
             * @memberof luck.protobuf.PlayerExtraPB
             * @instance
             */
            PlayerExtraPB.prototype.headPortraitList = $util.emptyArray;

            /**
             * PlayerExtraPB rahmenId.
             * @member {number} rahmenId
             * @memberof luck.protobuf.PlayerExtraPB
             * @instance
             */
            PlayerExtraPB.prototype.rahmenId = 0;

            /**
             * PlayerExtraPB rahmenList.
             * @member {Array.<number>} rahmenList
             * @memberof luck.protobuf.PlayerExtraPB
             * @instance
             */
            PlayerExtraPB.prototype.rahmenList = $util.emptyArray;

            /**
             * PlayerExtraPB lastGangSginInTime.
             * @member {number|Long} lastGangSginInTime
             * @memberof luck.protobuf.PlayerExtraPB
             * @instance
             */
            PlayerExtraPB.prototype.lastGangSginInTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new PlayerExtraPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.PlayerExtraPB
             * @static
             * @param {luck.protobuf.IPlayerExtraPB=} [properties] Properties to set
             * @returns {luck.protobuf.PlayerExtraPB} PlayerExtraPB instance
             */
            PlayerExtraPB.create = function create(properties) {
                return new PlayerExtraPB(properties);
            };

            /**
             * Encodes the specified PlayerExtraPB message. Does not implicitly {@link luck.protobuf.PlayerExtraPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.PlayerExtraPB
             * @static
             * @param {luck.protobuf.IPlayerExtraPB} message PlayerExtraPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PlayerExtraPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.sginInTime);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.sginCount);
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.serverTime);
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.allCount);
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.telePhone);
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.email);
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.isCheckName);
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.refuseFriendReq);
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.refuseStrangerNews);
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.refuseClubInvite);
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.refuseSysInfo);
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.refuseTeamInvite);
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.refuseBattleInvite);
                writer.uint32(/* id 14, wireType 0 =*/112).int32(message.closeBarrage);
                writer.uint32(/* id 15, wireType 0 =*/120).int64(message.lastEmailTime);
                writer.uint32(/* id 16, wireType 0 =*/128).int32(message.packGrid);
                if (message.shopGoodsList != null && message.shopGoodsList.length)
                    for (var i = 0; i < message.shopGoodsList.length; ++i)
                        $root.luck.protobuf.ShopGoodsPB.encode(message.shopGoodsList[i], writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                if (message.activityTollgateList != null && message.activityTollgateList.length)
                    for (var i = 0; i < message.activityTollgateList.length; ++i)
                        $root.luck.protobuf.ActivityTollgatePB.encode(message.activityTollgateList[i], writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
                if (message.activityChapterList != null && message.activityChapterList.length)
                    for (var i = 0; i < message.activityChapterList.length; ++i)
                        $root.luck.protobuf.ActivityChapterPB.encode(message.activityChapterList[i], writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
                $root.luck.protobuf.LoveBentoPB.encode(message.loveBento, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
                if (message.gangShopGoodsList != null && message.gangShopGoodsList.length)
                    for (var i = 0; i < message.gangShopGoodsList.length; ++i)
                        $root.luck.protobuf.ShopGoodsPB.encode(message.gangShopGoodsList[i], writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
                if (message.vipRewardList != null && message.vipRewardList.length)
                    for (var i = 0; i < message.vipRewardList.length; ++i)
                        $root.luck.protobuf.VipRewardPB.encode(message.vipRewardList[i], writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
                writer.uint32(/* id 23, wireType 0 =*/184).int32(message.staminaBuyTimes);
                writer.uint32(/* id 24, wireType 0 =*/192).int64(message.lastRefreshStaminaTime);
                writer.uint32(/* id 25, wireType 0 =*/200).int64(message.lastWorldChatTime);
                if (message.monthCardList != null && message.monthCardList.length)
                    for (var i = 0; i < message.monthCardList.length; ++i)
                        $root.luck.protobuf.MonthCardPB.encode(message.monthCardList[i], writer.uint32(/* id 26, wireType 2 =*/210).fork()).ldelim();
                writer.uint32(/* id 27, wireType 0 =*/216).int32(message.growthCapital);
                writer.uint32(/* id 28, wireType 0 =*/224).int32(message.totalLoginTimes);
                writer.uint32(/* id 29, wireType 0 =*/232).int32(message.greenWeaponCollect);
                writer.uint32(/* id 30, wireType 0 =*/240).int32(message.blueWeaponCollect);
                writer.uint32(/* id 31, wireType 0 =*/248).int32(message.purpleWeaponCollect);
                writer.uint32(/* id 32, wireType 0 =*/256).int32(message.orangeWeaponCollect);
                writer.uint32(/* id 33, wireType 0 =*/264).int32(message.redWeaponCollect);
                writer.uint32(/* id 34, wireType 0 =*/272).int64(message.lastLoginTime);
                $root.luck.protobuf.DiggingPB.encode(message.digging, writer.uint32(/* id 35, wireType 2 =*/282).fork()).ldelim();
                if (message.activityShopList != null && message.activityShopList.length)
                    for (var i = 0; i < message.activityShopList.length; ++i)
                        $root.luck.protobuf.ShopGoodsPB.encode(message.activityShopList[i], writer.uint32(/* id 36, wireType 2 =*/290).fork()).ldelim();
                if (message.activityLottery != null && message.activityLottery.length)
                    for (var i = 0; i < message.activityLottery.length; ++i)
                        $root.luck.protobuf.ActivityLotteryPB.encode(message.activityLottery[i], writer.uint32(/* id 37, wireType 2 =*/298).fork()).ldelim();
                if (message.gainBuffList != null && message.gainBuffList.length)
                    for (var i = 0; i < message.gainBuffList.length; ++i)
                        $root.luck.protobuf.GainBuffPB.encode(message.gainBuffList[i], writer.uint32(/* id 38, wireType 2 =*/306).fork()).ldelim();
                writer.uint32(/* id 39, wireType 0 =*/312).int32(message.noviceGuideNum);
                writer.uint32(/* id 40, wireType 0 =*/320).int32(message.isFirstLotteryTwo);
                writer.uint32(/* id 41, wireType 0 =*/328).int32(message.headPortraitId);
                if (message.headPortraitList != null && message.headPortraitList.length)
                    for (var i = 0; i < message.headPortraitList.length; ++i)
                        writer.uint32(/* id 42, wireType 0 =*/336).int32(message.headPortraitList[i]);
                writer.uint32(/* id 43, wireType 0 =*/344).int32(message.rahmenId);
                if (message.rahmenList != null && message.rahmenList.length)
                    for (var i = 0; i < message.rahmenList.length; ++i)
                        writer.uint32(/* id 44, wireType 0 =*/352).int32(message.rahmenList[i]);
                writer.uint32(/* id 45, wireType 0 =*/360).int64(message.lastGangSginInTime);
                return writer;
            };

            /**
             * Encodes the specified PlayerExtraPB message, length delimited. Does not implicitly {@link luck.protobuf.PlayerExtraPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.PlayerExtraPB
             * @static
             * @param {luck.protobuf.IPlayerExtraPB} message PlayerExtraPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PlayerExtraPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PlayerExtraPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.PlayerExtraPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.PlayerExtraPB} PlayerExtraPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PlayerExtraPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.PlayerExtraPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sginInTime = reader.int64();
                        break;
                    case 2:
                        message.sginCount = reader.int32();
                        break;
                    case 3:
                        message.serverTime = reader.int64();
                        break;
                    case 4:
                        message.allCount = reader.int32();
                        break;
                    case 5:
                        message.telePhone = reader.string();
                        break;
                    case 6:
                        message.email = reader.string();
                        break;
                    case 7:
                        message.isCheckName = reader.int32();
                        break;
                    case 8:
                        message.refuseFriendReq = reader.int32();
                        break;
                    case 9:
                        message.refuseStrangerNews = reader.int32();
                        break;
                    case 10:
                        message.refuseClubInvite = reader.int32();
                        break;
                    case 11:
                        message.refuseSysInfo = reader.int32();
                        break;
                    case 12:
                        message.refuseTeamInvite = reader.int32();
                        break;
                    case 13:
                        message.refuseBattleInvite = reader.int32();
                        break;
                    case 14:
                        message.closeBarrage = reader.int32();
                        break;
                    case 15:
                        message.lastEmailTime = reader.int64();
                        break;
                    case 16:
                        message.packGrid = reader.int32();
                        break;
                    case 17:
                        if (!(message.shopGoodsList && message.shopGoodsList.length))
                            message.shopGoodsList = [];
                        message.shopGoodsList.push($root.luck.protobuf.ShopGoodsPB.decode(reader, reader.uint32()));
                        break;
                    case 18:
                        if (!(message.activityTollgateList && message.activityTollgateList.length))
                            message.activityTollgateList = [];
                        message.activityTollgateList.push($root.luck.protobuf.ActivityTollgatePB.decode(reader, reader.uint32()));
                        break;
                    case 19:
                        if (!(message.activityChapterList && message.activityChapterList.length))
                            message.activityChapterList = [];
                        message.activityChapterList.push($root.luck.protobuf.ActivityChapterPB.decode(reader, reader.uint32()));
                        break;
                    case 20:
                        message.loveBento = $root.luck.protobuf.LoveBentoPB.decode(reader, reader.uint32());
                        break;
                    case 21:
                        if (!(message.gangShopGoodsList && message.gangShopGoodsList.length))
                            message.gangShopGoodsList = [];
                        message.gangShopGoodsList.push($root.luck.protobuf.ShopGoodsPB.decode(reader, reader.uint32()));
                        break;
                    case 22:
                        if (!(message.vipRewardList && message.vipRewardList.length))
                            message.vipRewardList = [];
                        message.vipRewardList.push($root.luck.protobuf.VipRewardPB.decode(reader, reader.uint32()));
                        break;
                    case 23:
                        message.staminaBuyTimes = reader.int32();
                        break;
                    case 24:
                        message.lastRefreshStaminaTime = reader.int64();
                        break;
                    case 25:
                        message.lastWorldChatTime = reader.int64();
                        break;
                    case 26:
                        if (!(message.monthCardList && message.monthCardList.length))
                            message.monthCardList = [];
                        message.monthCardList.push($root.luck.protobuf.MonthCardPB.decode(reader, reader.uint32()));
                        break;
                    case 27:
                        message.growthCapital = reader.int32();
                        break;
                    case 28:
                        message.totalLoginTimes = reader.int32();
                        break;
                    case 29:
                        message.greenWeaponCollect = reader.int32();
                        break;
                    case 30:
                        message.blueWeaponCollect = reader.int32();
                        break;
                    case 31:
                        message.purpleWeaponCollect = reader.int32();
                        break;
                    case 32:
                        message.orangeWeaponCollect = reader.int32();
                        break;
                    case 33:
                        message.redWeaponCollect = reader.int32();
                        break;
                    case 34:
                        message.lastLoginTime = reader.int64();
                        break;
                    case 35:
                        message.digging = $root.luck.protobuf.DiggingPB.decode(reader, reader.uint32());
                        break;
                    case 36:
                        if (!(message.activityShopList && message.activityShopList.length))
                            message.activityShopList = [];
                        message.activityShopList.push($root.luck.protobuf.ShopGoodsPB.decode(reader, reader.uint32()));
                        break;
                    case 37:
                        if (!(message.activityLottery && message.activityLottery.length))
                            message.activityLottery = [];
                        message.activityLottery.push($root.luck.protobuf.ActivityLotteryPB.decode(reader, reader.uint32()));
                        break;
                    case 38:
                        if (!(message.gainBuffList && message.gainBuffList.length))
                            message.gainBuffList = [];
                        message.gainBuffList.push($root.luck.protobuf.GainBuffPB.decode(reader, reader.uint32()));
                        break;
                    case 39:
                        message.noviceGuideNum = reader.int32();
                        break;
                    case 40:
                        message.isFirstLotteryTwo = reader.int32();
                        break;
                    case 41:
                        message.headPortraitId = reader.int32();
                        break;
                    case 42:
                        if (!(message.headPortraitList && message.headPortraitList.length))
                            message.headPortraitList = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.headPortraitList.push(reader.int32());
                        } else
                            message.headPortraitList.push(reader.int32());
                        break;
                    case 43:
                        message.rahmenId = reader.int32();
                        break;
                    case 44:
                        if (!(message.rahmenList && message.rahmenList.length))
                            message.rahmenList = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.rahmenList.push(reader.int32());
                        } else
                            message.rahmenList.push(reader.int32());
                        break;
                    case 45:
                        message.lastGangSginInTime = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("sginInTime"))
                    throw $util.ProtocolError("missing required 'sginInTime'", { instance: message });
                if (!message.hasOwnProperty("sginCount"))
                    throw $util.ProtocolError("missing required 'sginCount'", { instance: message });
                if (!message.hasOwnProperty("serverTime"))
                    throw $util.ProtocolError("missing required 'serverTime'", { instance: message });
                if (!message.hasOwnProperty("allCount"))
                    throw $util.ProtocolError("missing required 'allCount'", { instance: message });
                if (!message.hasOwnProperty("telePhone"))
                    throw $util.ProtocolError("missing required 'telePhone'", { instance: message });
                if (!message.hasOwnProperty("email"))
                    throw $util.ProtocolError("missing required 'email'", { instance: message });
                if (!message.hasOwnProperty("isCheckName"))
                    throw $util.ProtocolError("missing required 'isCheckName'", { instance: message });
                if (!message.hasOwnProperty("refuseFriendReq"))
                    throw $util.ProtocolError("missing required 'refuseFriendReq'", { instance: message });
                if (!message.hasOwnProperty("refuseStrangerNews"))
                    throw $util.ProtocolError("missing required 'refuseStrangerNews'", { instance: message });
                if (!message.hasOwnProperty("refuseClubInvite"))
                    throw $util.ProtocolError("missing required 'refuseClubInvite'", { instance: message });
                if (!message.hasOwnProperty("refuseSysInfo"))
                    throw $util.ProtocolError("missing required 'refuseSysInfo'", { instance: message });
                if (!message.hasOwnProperty("refuseTeamInvite"))
                    throw $util.ProtocolError("missing required 'refuseTeamInvite'", { instance: message });
                if (!message.hasOwnProperty("refuseBattleInvite"))
                    throw $util.ProtocolError("missing required 'refuseBattleInvite'", { instance: message });
                if (!message.hasOwnProperty("closeBarrage"))
                    throw $util.ProtocolError("missing required 'closeBarrage'", { instance: message });
                if (!message.hasOwnProperty("lastEmailTime"))
                    throw $util.ProtocolError("missing required 'lastEmailTime'", { instance: message });
                if (!message.hasOwnProperty("packGrid"))
                    throw $util.ProtocolError("missing required 'packGrid'", { instance: message });
                if (!message.hasOwnProperty("loveBento"))
                    throw $util.ProtocolError("missing required 'loveBento'", { instance: message });
                if (!message.hasOwnProperty("staminaBuyTimes"))
                    throw $util.ProtocolError("missing required 'staminaBuyTimes'", { instance: message });
                if (!message.hasOwnProperty("lastRefreshStaminaTime"))
                    throw $util.ProtocolError("missing required 'lastRefreshStaminaTime'", { instance: message });
                if (!message.hasOwnProperty("lastWorldChatTime"))
                    throw $util.ProtocolError("missing required 'lastWorldChatTime'", { instance: message });
                if (!message.hasOwnProperty("growthCapital"))
                    throw $util.ProtocolError("missing required 'growthCapital'", { instance: message });
                if (!message.hasOwnProperty("totalLoginTimes"))
                    throw $util.ProtocolError("missing required 'totalLoginTimes'", { instance: message });
                if (!message.hasOwnProperty("greenWeaponCollect"))
                    throw $util.ProtocolError("missing required 'greenWeaponCollect'", { instance: message });
                if (!message.hasOwnProperty("blueWeaponCollect"))
                    throw $util.ProtocolError("missing required 'blueWeaponCollect'", { instance: message });
                if (!message.hasOwnProperty("purpleWeaponCollect"))
                    throw $util.ProtocolError("missing required 'purpleWeaponCollect'", { instance: message });
                if (!message.hasOwnProperty("orangeWeaponCollect"))
                    throw $util.ProtocolError("missing required 'orangeWeaponCollect'", { instance: message });
                if (!message.hasOwnProperty("redWeaponCollect"))
                    throw $util.ProtocolError("missing required 'redWeaponCollect'", { instance: message });
                if (!message.hasOwnProperty("lastLoginTime"))
                    throw $util.ProtocolError("missing required 'lastLoginTime'", { instance: message });
                if (!message.hasOwnProperty("digging"))
                    throw $util.ProtocolError("missing required 'digging'", { instance: message });
                if (!message.hasOwnProperty("noviceGuideNum"))
                    throw $util.ProtocolError("missing required 'noviceGuideNum'", { instance: message });
                if (!message.hasOwnProperty("isFirstLotteryTwo"))
                    throw $util.ProtocolError("missing required 'isFirstLotteryTwo'", { instance: message });
                if (!message.hasOwnProperty("headPortraitId"))
                    throw $util.ProtocolError("missing required 'headPortraitId'", { instance: message });
                if (!message.hasOwnProperty("rahmenId"))
                    throw $util.ProtocolError("missing required 'rahmenId'", { instance: message });
                if (!message.hasOwnProperty("lastGangSginInTime"))
                    throw $util.ProtocolError("missing required 'lastGangSginInTime'", { instance: message });
                return message;
            };

            /**
             * Decodes a PlayerExtraPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.PlayerExtraPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.PlayerExtraPB} PlayerExtraPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PlayerExtraPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PlayerExtraPB message.
             * @function verify
             * @memberof luck.protobuf.PlayerExtraPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PlayerExtraPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.sginInTime) && !(message.sginInTime && $util.isInteger(message.sginInTime.low) && $util.isInteger(message.sginInTime.high)))
                    return "sginInTime: integer|Long expected";
                if (!$util.isInteger(message.sginCount))
                    return "sginCount: integer expected";
                if (!$util.isInteger(message.serverTime) && !(message.serverTime && $util.isInteger(message.serverTime.low) && $util.isInteger(message.serverTime.high)))
                    return "serverTime: integer|Long expected";
                if (!$util.isInteger(message.allCount))
                    return "allCount: integer expected";
                if (!$util.isString(message.telePhone))
                    return "telePhone: string expected";
                if (!$util.isString(message.email))
                    return "email: string expected";
                if (!$util.isInteger(message.isCheckName))
                    return "isCheckName: integer expected";
                if (!$util.isInteger(message.refuseFriendReq))
                    return "refuseFriendReq: integer expected";
                if (!$util.isInteger(message.refuseStrangerNews))
                    return "refuseStrangerNews: integer expected";
                if (!$util.isInteger(message.refuseClubInvite))
                    return "refuseClubInvite: integer expected";
                if (!$util.isInteger(message.refuseSysInfo))
                    return "refuseSysInfo: integer expected";
                if (!$util.isInteger(message.refuseTeamInvite))
                    return "refuseTeamInvite: integer expected";
                if (!$util.isInteger(message.refuseBattleInvite))
                    return "refuseBattleInvite: integer expected";
                if (!$util.isInteger(message.closeBarrage))
                    return "closeBarrage: integer expected";
                if (!$util.isInteger(message.lastEmailTime) && !(message.lastEmailTime && $util.isInteger(message.lastEmailTime.low) && $util.isInteger(message.lastEmailTime.high)))
                    return "lastEmailTime: integer|Long expected";
                if (!$util.isInteger(message.packGrid))
                    return "packGrid: integer expected";
                if (message.shopGoodsList != null && message.hasOwnProperty("shopGoodsList")) {
                    if (!Array.isArray(message.shopGoodsList))
                        return "shopGoodsList: array expected";
                    for (var i = 0; i < message.shopGoodsList.length; ++i) {
                        var error = $root.luck.protobuf.ShopGoodsPB.verify(message.shopGoodsList[i]);
                        if (error)
                            return "shopGoodsList." + error;
                    }
                }
                if (message.activityTollgateList != null && message.hasOwnProperty("activityTollgateList")) {
                    if (!Array.isArray(message.activityTollgateList))
                        return "activityTollgateList: array expected";
                    for (var i = 0; i < message.activityTollgateList.length; ++i) {
                        var error = $root.luck.protobuf.ActivityTollgatePB.verify(message.activityTollgateList[i]);
                        if (error)
                            return "activityTollgateList." + error;
                    }
                }
                if (message.activityChapterList != null && message.hasOwnProperty("activityChapterList")) {
                    if (!Array.isArray(message.activityChapterList))
                        return "activityChapterList: array expected";
                    for (var i = 0; i < message.activityChapterList.length; ++i) {
                        var error = $root.luck.protobuf.ActivityChapterPB.verify(message.activityChapterList[i]);
                        if (error)
                            return "activityChapterList." + error;
                    }
                }
                {
                    var error = $root.luck.protobuf.LoveBentoPB.verify(message.loveBento);
                    if (error)
                        return "loveBento." + error;
                }
                if (message.gangShopGoodsList != null && message.hasOwnProperty("gangShopGoodsList")) {
                    if (!Array.isArray(message.gangShopGoodsList))
                        return "gangShopGoodsList: array expected";
                    for (var i = 0; i < message.gangShopGoodsList.length; ++i) {
                        var error = $root.luck.protobuf.ShopGoodsPB.verify(message.gangShopGoodsList[i]);
                        if (error)
                            return "gangShopGoodsList." + error;
                    }
                }
                if (message.vipRewardList != null && message.hasOwnProperty("vipRewardList")) {
                    if (!Array.isArray(message.vipRewardList))
                        return "vipRewardList: array expected";
                    for (var i = 0; i < message.vipRewardList.length; ++i) {
                        var error = $root.luck.protobuf.VipRewardPB.verify(message.vipRewardList[i]);
                        if (error)
                            return "vipRewardList." + error;
                    }
                }
                if (!$util.isInteger(message.staminaBuyTimes))
                    return "staminaBuyTimes: integer expected";
                if (!$util.isInteger(message.lastRefreshStaminaTime) && !(message.lastRefreshStaminaTime && $util.isInteger(message.lastRefreshStaminaTime.low) && $util.isInteger(message.lastRefreshStaminaTime.high)))
                    return "lastRefreshStaminaTime: integer|Long expected";
                if (!$util.isInteger(message.lastWorldChatTime) && !(message.lastWorldChatTime && $util.isInteger(message.lastWorldChatTime.low) && $util.isInteger(message.lastWorldChatTime.high)))
                    return "lastWorldChatTime: integer|Long expected";
                if (message.monthCardList != null && message.hasOwnProperty("monthCardList")) {
                    if (!Array.isArray(message.monthCardList))
                        return "monthCardList: array expected";
                    for (var i = 0; i < message.monthCardList.length; ++i) {
                        var error = $root.luck.protobuf.MonthCardPB.verify(message.monthCardList[i]);
                        if (error)
                            return "monthCardList." + error;
                    }
                }
                if (!$util.isInteger(message.growthCapital))
                    return "growthCapital: integer expected";
                if (!$util.isInteger(message.totalLoginTimes))
                    return "totalLoginTimes: integer expected";
                if (!$util.isInteger(message.greenWeaponCollect))
                    return "greenWeaponCollect: integer expected";
                if (!$util.isInteger(message.blueWeaponCollect))
                    return "blueWeaponCollect: integer expected";
                if (!$util.isInteger(message.purpleWeaponCollect))
                    return "purpleWeaponCollect: integer expected";
                if (!$util.isInteger(message.orangeWeaponCollect))
                    return "orangeWeaponCollect: integer expected";
                if (!$util.isInteger(message.redWeaponCollect))
                    return "redWeaponCollect: integer expected";
                if (!$util.isInteger(message.lastLoginTime) && !(message.lastLoginTime && $util.isInteger(message.lastLoginTime.low) && $util.isInteger(message.lastLoginTime.high)))
                    return "lastLoginTime: integer|Long expected";
                {
                    var error = $root.luck.protobuf.DiggingPB.verify(message.digging);
                    if (error)
                        return "digging." + error;
                }
                if (message.activityShopList != null && message.hasOwnProperty("activityShopList")) {
                    if (!Array.isArray(message.activityShopList))
                        return "activityShopList: array expected";
                    for (var i = 0; i < message.activityShopList.length; ++i) {
                        var error = $root.luck.protobuf.ShopGoodsPB.verify(message.activityShopList[i]);
                        if (error)
                            return "activityShopList." + error;
                    }
                }
                if (message.activityLottery != null && message.hasOwnProperty("activityLottery")) {
                    if (!Array.isArray(message.activityLottery))
                        return "activityLottery: array expected";
                    for (var i = 0; i < message.activityLottery.length; ++i) {
                        var error = $root.luck.protobuf.ActivityLotteryPB.verify(message.activityLottery[i]);
                        if (error)
                            return "activityLottery." + error;
                    }
                }
                if (message.gainBuffList != null && message.hasOwnProperty("gainBuffList")) {
                    if (!Array.isArray(message.gainBuffList))
                        return "gainBuffList: array expected";
                    for (var i = 0; i < message.gainBuffList.length; ++i) {
                        var error = $root.luck.protobuf.GainBuffPB.verify(message.gainBuffList[i]);
                        if (error)
                            return "gainBuffList." + error;
                    }
                }
                if (!$util.isInteger(message.noviceGuideNum))
                    return "noviceGuideNum: integer expected";
                if (!$util.isInteger(message.isFirstLotteryTwo))
                    return "isFirstLotteryTwo: integer expected";
                if (!$util.isInteger(message.headPortraitId))
                    return "headPortraitId: integer expected";
                if (message.headPortraitList != null && message.hasOwnProperty("headPortraitList")) {
                    if (!Array.isArray(message.headPortraitList))
                        return "headPortraitList: array expected";
                    for (var i = 0; i < message.headPortraitList.length; ++i)
                        if (!$util.isInteger(message.headPortraitList[i]))
                            return "headPortraitList: integer[] expected";
                }
                if (!$util.isInteger(message.rahmenId))
                    return "rahmenId: integer expected";
                if (message.rahmenList != null && message.hasOwnProperty("rahmenList")) {
                    if (!Array.isArray(message.rahmenList))
                        return "rahmenList: array expected";
                    for (var i = 0; i < message.rahmenList.length; ++i)
                        if (!$util.isInteger(message.rahmenList[i]))
                            return "rahmenList: integer[] expected";
                }
                if (!$util.isInteger(message.lastGangSginInTime) && !(message.lastGangSginInTime && $util.isInteger(message.lastGangSginInTime.low) && $util.isInteger(message.lastGangSginInTime.high)))
                    return "lastGangSginInTime: integer|Long expected";
                return null;
            };

            return PlayerExtraPB;
        })();

        protobuf.EmailPB = (function() {

            /**
             * Properties of an EmailPB.
             * @memberof luck.protobuf
             * @interface IEmailPB
             * @property {number|Long} uid EmailPB uid
             * @property {number|Long} playerId EmailPB playerId
             * @property {number|Long} senderId EmailPB senderId
             * @property {number} contentId EmailPB contentId
             * @property {number|Long} sendTime EmailPB sendTime
             * @property {number|Long} endTime EmailPB endTime
             * @property {number} status EmailPB status
             * @property {number} type EmailPB type
             * @property {number|Long|null} [gold] EmailPB gold
             * @property {number|Long|null} [diamond] EmailPB diamond
             * @property {Array.<luck.protobuf.IWeaponPB>|null} [weaponList] EmailPB weaponList
             * @property {Array.<luck.protobuf.ICardPB>|null} [cardList] EmailPB cardList
             * @property {Array.<luck.protobuf.IClothesPB>|null} [clothesList] EmailPB clothesList
             * @property {Array.<luck.protobuf.IPropPB>|null} [propList] EmailPB propList
             * @property {Array.<luck.protobuf.IMaterialsPB>|null} [materialsList] EmailPB materialsList
             */

            /**
             * Constructs a new EmailPB.
             * @memberof luck.protobuf
             * @classdesc Represents an EmailPB.
             * @implements IEmailPB
             * @constructor
             * @param {luck.protobuf.IEmailPB=} [properties] Properties to set
             */
            function EmailPB(properties) {
                this.weaponList = [];
                this.cardList = [];
                this.clothesList = [];
                this.propList = [];
                this.materialsList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EmailPB uid.
             * @member {number|Long} uid
             * @memberof luck.protobuf.EmailPB
             * @instance
             */
            EmailPB.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * EmailPB playerId.
             * @member {number|Long} playerId
             * @memberof luck.protobuf.EmailPB
             * @instance
             */
            EmailPB.prototype.playerId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * EmailPB senderId.
             * @member {number|Long} senderId
             * @memberof luck.protobuf.EmailPB
             * @instance
             */
            EmailPB.prototype.senderId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * EmailPB contentId.
             * @member {number} contentId
             * @memberof luck.protobuf.EmailPB
             * @instance
             */
            EmailPB.prototype.contentId = 0;

            /**
             * EmailPB sendTime.
             * @member {number|Long} sendTime
             * @memberof luck.protobuf.EmailPB
             * @instance
             */
            EmailPB.prototype.sendTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * EmailPB endTime.
             * @member {number|Long} endTime
             * @memberof luck.protobuf.EmailPB
             * @instance
             */
            EmailPB.prototype.endTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * EmailPB status.
             * @member {number} status
             * @memberof luck.protobuf.EmailPB
             * @instance
             */
            EmailPB.prototype.status = 0;

            /**
             * EmailPB type.
             * @member {number} type
             * @memberof luck.protobuf.EmailPB
             * @instance
             */
            EmailPB.prototype.type = 0;

            /**
             * EmailPB gold.
             * @member {number|Long} gold
             * @memberof luck.protobuf.EmailPB
             * @instance
             */
            EmailPB.prototype.gold = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * EmailPB diamond.
             * @member {number|Long} diamond
             * @memberof luck.protobuf.EmailPB
             * @instance
             */
            EmailPB.prototype.diamond = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * EmailPB weaponList.
             * @member {Array.<luck.protobuf.IWeaponPB>} weaponList
             * @memberof luck.protobuf.EmailPB
             * @instance
             */
            EmailPB.prototype.weaponList = $util.emptyArray;

            /**
             * EmailPB cardList.
             * @member {Array.<luck.protobuf.ICardPB>} cardList
             * @memberof luck.protobuf.EmailPB
             * @instance
             */
            EmailPB.prototype.cardList = $util.emptyArray;

            /**
             * EmailPB clothesList.
             * @member {Array.<luck.protobuf.IClothesPB>} clothesList
             * @memberof luck.protobuf.EmailPB
             * @instance
             */
            EmailPB.prototype.clothesList = $util.emptyArray;

            /**
             * EmailPB propList.
             * @member {Array.<luck.protobuf.IPropPB>} propList
             * @memberof luck.protobuf.EmailPB
             * @instance
             */
            EmailPB.prototype.propList = $util.emptyArray;

            /**
             * EmailPB materialsList.
             * @member {Array.<luck.protobuf.IMaterialsPB>} materialsList
             * @memberof luck.protobuf.EmailPB
             * @instance
             */
            EmailPB.prototype.materialsList = $util.emptyArray;

            /**
             * Creates a new EmailPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.EmailPB
             * @static
             * @param {luck.protobuf.IEmailPB=} [properties] Properties to set
             * @returns {luck.protobuf.EmailPB} EmailPB instance
             */
            EmailPB.create = function create(properties) {
                return new EmailPB(properties);
            };

            /**
             * Encodes the specified EmailPB message. Does not implicitly {@link luck.protobuf.EmailPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.EmailPB
             * @static
             * @param {luck.protobuf.IEmailPB} message EmailPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EmailPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.uid);
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.playerId);
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.senderId);
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.contentId);
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.sendTime);
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.endTime);
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.status);
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.type);
                if (message.gold != null && message.hasOwnProperty("gold"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int64(message.gold);
                if (message.diamond != null && message.hasOwnProperty("diamond"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int64(message.diamond);
                if (message.weaponList != null && message.weaponList.length)
                    for (var i = 0; i < message.weaponList.length; ++i)
                        $root.luck.protobuf.WeaponPB.encode(message.weaponList[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.cardList != null && message.cardList.length)
                    for (var i = 0; i < message.cardList.length; ++i)
                        $root.luck.protobuf.CardPB.encode(message.cardList[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                if (message.clothesList != null && message.clothesList.length)
                    for (var i = 0; i < message.clothesList.length; ++i)
                        $root.luck.protobuf.ClothesPB.encode(message.clothesList[i], writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                if (message.propList != null && message.propList.length)
                    for (var i = 0; i < message.propList.length; ++i)
                        $root.luck.protobuf.PropPB.encode(message.propList[i], writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                if (message.materialsList != null && message.materialsList.length)
                    for (var i = 0; i < message.materialsList.length; ++i)
                        $root.luck.protobuf.MaterialsPB.encode(message.materialsList[i], writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EmailPB message, length delimited. Does not implicitly {@link luck.protobuf.EmailPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.EmailPB
             * @static
             * @param {luck.protobuf.IEmailPB} message EmailPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EmailPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EmailPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.EmailPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.EmailPB} EmailPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EmailPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.EmailPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.uid = reader.int64();
                        break;
                    case 2:
                        message.playerId = reader.int64();
                        break;
                    case 3:
                        message.senderId = reader.int64();
                        break;
                    case 4:
                        message.contentId = reader.int32();
                        break;
                    case 5:
                        message.sendTime = reader.int64();
                        break;
                    case 6:
                        message.endTime = reader.int64();
                        break;
                    case 7:
                        message.status = reader.int32();
                        break;
                    case 8:
                        message.type = reader.int32();
                        break;
                    case 9:
                        message.gold = reader.int64();
                        break;
                    case 10:
                        message.diamond = reader.int64();
                        break;
                    case 11:
                        if (!(message.weaponList && message.weaponList.length))
                            message.weaponList = [];
                        message.weaponList.push($root.luck.protobuf.WeaponPB.decode(reader, reader.uint32()));
                        break;
                    case 12:
                        if (!(message.cardList && message.cardList.length))
                            message.cardList = [];
                        message.cardList.push($root.luck.protobuf.CardPB.decode(reader, reader.uint32()));
                        break;
                    case 13:
                        if (!(message.clothesList && message.clothesList.length))
                            message.clothesList = [];
                        message.clothesList.push($root.luck.protobuf.ClothesPB.decode(reader, reader.uint32()));
                        break;
                    case 14:
                        if (!(message.propList && message.propList.length))
                            message.propList = [];
                        message.propList.push($root.luck.protobuf.PropPB.decode(reader, reader.uint32()));
                        break;
                    case 15:
                        if (!(message.materialsList && message.materialsList.length))
                            message.materialsList = [];
                        message.materialsList.push($root.luck.protobuf.MaterialsPB.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("uid"))
                    throw $util.ProtocolError("missing required 'uid'", { instance: message });
                if (!message.hasOwnProperty("playerId"))
                    throw $util.ProtocolError("missing required 'playerId'", { instance: message });
                if (!message.hasOwnProperty("senderId"))
                    throw $util.ProtocolError("missing required 'senderId'", { instance: message });
                if (!message.hasOwnProperty("contentId"))
                    throw $util.ProtocolError("missing required 'contentId'", { instance: message });
                if (!message.hasOwnProperty("sendTime"))
                    throw $util.ProtocolError("missing required 'sendTime'", { instance: message });
                if (!message.hasOwnProperty("endTime"))
                    throw $util.ProtocolError("missing required 'endTime'", { instance: message });
                if (!message.hasOwnProperty("status"))
                    throw $util.ProtocolError("missing required 'status'", { instance: message });
                if (!message.hasOwnProperty("type"))
                    throw $util.ProtocolError("missing required 'type'", { instance: message });
                return message;
            };

            /**
             * Decodes an EmailPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.EmailPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.EmailPB} EmailPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EmailPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EmailPB message.
             * @function verify
             * @memberof luck.protobuf.EmailPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EmailPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
                if (!$util.isInteger(message.playerId) && !(message.playerId && $util.isInteger(message.playerId.low) && $util.isInteger(message.playerId.high)))
                    return "playerId: integer|Long expected";
                if (!$util.isInteger(message.senderId) && !(message.senderId && $util.isInteger(message.senderId.low) && $util.isInteger(message.senderId.high)))
                    return "senderId: integer|Long expected";
                if (!$util.isInteger(message.contentId))
                    return "contentId: integer expected";
                if (!$util.isInteger(message.sendTime) && !(message.sendTime && $util.isInteger(message.sendTime.low) && $util.isInteger(message.sendTime.high)))
                    return "sendTime: integer|Long expected";
                if (!$util.isInteger(message.endTime) && !(message.endTime && $util.isInteger(message.endTime.low) && $util.isInteger(message.endTime.high)))
                    return "endTime: integer|Long expected";
                if (!$util.isInteger(message.status))
                    return "status: integer expected";
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
                if (message.gold != null && message.hasOwnProperty("gold"))
                    if (!$util.isInteger(message.gold) && !(message.gold && $util.isInteger(message.gold.low) && $util.isInteger(message.gold.high)))
                        return "gold: integer|Long expected";
                if (message.diamond != null && message.hasOwnProperty("diamond"))
                    if (!$util.isInteger(message.diamond) && !(message.diamond && $util.isInteger(message.diamond.low) && $util.isInteger(message.diamond.high)))
                        return "diamond: integer|Long expected";
                if (message.weaponList != null && message.hasOwnProperty("weaponList")) {
                    if (!Array.isArray(message.weaponList))
                        return "weaponList: array expected";
                    for (var i = 0; i < message.weaponList.length; ++i) {
                        var error = $root.luck.protobuf.WeaponPB.verify(message.weaponList[i]);
                        if (error)
                            return "weaponList." + error;
                    }
                }
                if (message.cardList != null && message.hasOwnProperty("cardList")) {
                    if (!Array.isArray(message.cardList))
                        return "cardList: array expected";
                    for (var i = 0; i < message.cardList.length; ++i) {
                        var error = $root.luck.protobuf.CardPB.verify(message.cardList[i]);
                        if (error)
                            return "cardList." + error;
                    }
                }
                if (message.clothesList != null && message.hasOwnProperty("clothesList")) {
                    if (!Array.isArray(message.clothesList))
                        return "clothesList: array expected";
                    for (var i = 0; i < message.clothesList.length; ++i) {
                        var error = $root.luck.protobuf.ClothesPB.verify(message.clothesList[i]);
                        if (error)
                            return "clothesList." + error;
                    }
                }
                if (message.propList != null && message.hasOwnProperty("propList")) {
                    if (!Array.isArray(message.propList))
                        return "propList: array expected";
                    for (var i = 0; i < message.propList.length; ++i) {
                        var error = $root.luck.protobuf.PropPB.verify(message.propList[i]);
                        if (error)
                            return "propList." + error;
                    }
                }
                if (message.materialsList != null && message.hasOwnProperty("materialsList")) {
                    if (!Array.isArray(message.materialsList))
                        return "materialsList: array expected";
                    for (var i = 0; i < message.materialsList.length; ++i) {
                        var error = $root.luck.protobuf.MaterialsPB.verify(message.materialsList[i]);
                        if (error)
                            return "materialsList." + error;
                    }
                }
                return null;
            };

            return EmailPB;
        })();

        protobuf.WeaponInlayPB = (function() {

            /**
             * Properties of a WeaponInlayPB.
             * @memberof luck.protobuf
             * @interface IWeaponInlayPB
             * @property {number} allPropertyAttack WeaponInlayPB allPropertyAttack
             * @property {number} shootSpeed WeaponInlayPB shootSpeed
             * @property {number} bombLoad WeaponInlayPB bombLoad
             */

            /**
             * Constructs a new WeaponInlayPB.
             * @memberof luck.protobuf
             * @classdesc Represents a WeaponInlayPB.
             * @implements IWeaponInlayPB
             * @constructor
             * @param {luck.protobuf.IWeaponInlayPB=} [properties] Properties to set
             */
            function WeaponInlayPB(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WeaponInlayPB allPropertyAttack.
             * @member {number} allPropertyAttack
             * @memberof luck.protobuf.WeaponInlayPB
             * @instance
             */
            WeaponInlayPB.prototype.allPropertyAttack = 0;

            /**
             * WeaponInlayPB shootSpeed.
             * @member {number} shootSpeed
             * @memberof luck.protobuf.WeaponInlayPB
             * @instance
             */
            WeaponInlayPB.prototype.shootSpeed = 0;

            /**
             * WeaponInlayPB bombLoad.
             * @member {number} bombLoad
             * @memberof luck.protobuf.WeaponInlayPB
             * @instance
             */
            WeaponInlayPB.prototype.bombLoad = 0;

            /**
             * Creates a new WeaponInlayPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.WeaponInlayPB
             * @static
             * @param {luck.protobuf.IWeaponInlayPB=} [properties] Properties to set
             * @returns {luck.protobuf.WeaponInlayPB} WeaponInlayPB instance
             */
            WeaponInlayPB.create = function create(properties) {
                return new WeaponInlayPB(properties);
            };

            /**
             * Encodes the specified WeaponInlayPB message. Does not implicitly {@link luck.protobuf.WeaponInlayPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.WeaponInlayPB
             * @static
             * @param {luck.protobuf.IWeaponInlayPB} message WeaponInlayPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WeaponInlayPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 1 =*/9).double(message.allPropertyAttack);
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.shootSpeed);
                writer.uint32(/* id 3, wireType 1 =*/25).double(message.bombLoad);
                return writer;
            };

            /**
             * Encodes the specified WeaponInlayPB message, length delimited. Does not implicitly {@link luck.protobuf.WeaponInlayPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.WeaponInlayPB
             * @static
             * @param {luck.protobuf.IWeaponInlayPB} message WeaponInlayPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WeaponInlayPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WeaponInlayPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.WeaponInlayPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.WeaponInlayPB} WeaponInlayPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WeaponInlayPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.WeaponInlayPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.allPropertyAttack = reader.double();
                        break;
                    case 2:
                        message.shootSpeed = reader.double();
                        break;
                    case 3:
                        message.bombLoad = reader.double();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("allPropertyAttack"))
                    throw $util.ProtocolError("missing required 'allPropertyAttack'", { instance: message });
                if (!message.hasOwnProperty("shootSpeed"))
                    throw $util.ProtocolError("missing required 'shootSpeed'", { instance: message });
                if (!message.hasOwnProperty("bombLoad"))
                    throw $util.ProtocolError("missing required 'bombLoad'", { instance: message });
                return message;
            };

            /**
             * Decodes a WeaponInlayPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.WeaponInlayPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.WeaponInlayPB} WeaponInlayPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WeaponInlayPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WeaponInlayPB message.
             * @function verify
             * @memberof luck.protobuf.WeaponInlayPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WeaponInlayPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (typeof message.allPropertyAttack !== "number")
                    return "allPropertyAttack: number expected";
                if (typeof message.shootSpeed !== "number")
                    return "shootSpeed: number expected";
                if (typeof message.bombLoad !== "number")
                    return "bombLoad: number expected";
                return null;
            };

            return WeaponInlayPB;
        })();

        protobuf.ClothesInlayPB = (function() {

            /**
             * Properties of a ClothesInlayPB.
             * @memberof luck.protobuf
             * @interface IClothesInlayPB
             * @property {number} HpUpLimit ClothesInlayPB HpUpLimit
             * @property {number} propertyImmune ClothesInlayPB propertyImmune
             */

            /**
             * Constructs a new ClothesInlayPB.
             * @memberof luck.protobuf
             * @classdesc Represents a ClothesInlayPB.
             * @implements IClothesInlayPB
             * @constructor
             * @param {luck.protobuf.IClothesInlayPB=} [properties] Properties to set
             */
            function ClothesInlayPB(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ClothesInlayPB HpUpLimit.
             * @member {number} HpUpLimit
             * @memberof luck.protobuf.ClothesInlayPB
             * @instance
             */
            ClothesInlayPB.prototype.HpUpLimit = 0;

            /**
             * ClothesInlayPB propertyImmune.
             * @member {number} propertyImmune
             * @memberof luck.protobuf.ClothesInlayPB
             * @instance
             */
            ClothesInlayPB.prototype.propertyImmune = 0;

            /**
             * Creates a new ClothesInlayPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.ClothesInlayPB
             * @static
             * @param {luck.protobuf.IClothesInlayPB=} [properties] Properties to set
             * @returns {luck.protobuf.ClothesInlayPB} ClothesInlayPB instance
             */
            ClothesInlayPB.create = function create(properties) {
                return new ClothesInlayPB(properties);
            };

            /**
             * Encodes the specified ClothesInlayPB message. Does not implicitly {@link luck.protobuf.ClothesInlayPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.ClothesInlayPB
             * @static
             * @param {luck.protobuf.IClothesInlayPB} message ClothesInlayPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ClothesInlayPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 1 =*/9).double(message.HpUpLimit);
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.propertyImmune);
                return writer;
            };

            /**
             * Encodes the specified ClothesInlayPB message, length delimited. Does not implicitly {@link luck.protobuf.ClothesInlayPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.ClothesInlayPB
             * @static
             * @param {luck.protobuf.IClothesInlayPB} message ClothesInlayPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ClothesInlayPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ClothesInlayPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.ClothesInlayPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.ClothesInlayPB} ClothesInlayPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ClothesInlayPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.ClothesInlayPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.HpUpLimit = reader.double();
                        break;
                    case 2:
                        message.propertyImmune = reader.double();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("HpUpLimit"))
                    throw $util.ProtocolError("missing required 'HpUpLimit'", { instance: message });
                if (!message.hasOwnProperty("propertyImmune"))
                    throw $util.ProtocolError("missing required 'propertyImmune'", { instance: message });
                return message;
            };

            /**
             * Decodes a ClothesInlayPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.ClothesInlayPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.ClothesInlayPB} ClothesInlayPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ClothesInlayPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ClothesInlayPB message.
             * @function verify
             * @memberof luck.protobuf.ClothesInlayPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ClothesInlayPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (typeof message.HpUpLimit !== "number")
                    return "HpUpLimit: number expected";
                if (typeof message.propertyImmune !== "number")
                    return "propertyImmune: number expected";
                return null;
            };

            return ClothesInlayPB;
        })();

        protobuf.SimplePlayerPB = (function() {

            /**
             * Properties of a SimplePlayerPB.
             * @memberof luck.protobuf
             * @interface ISimplePlayerPB
             * @property {number|Long} playerId SimplePlayerPB playerId
             * @property {number} roleId SimplePlayerPB roleId
             * @property {number} lv SimplePlayerPB lv
             * @property {number} vipLv SimplePlayerPB vipLv
             * @property {string} name SimplePlayerPB name
             * @property {number|Long} gangId SimplePlayerPB gangId
             * @property {string} gangName SimplePlayerPB gangName
             * @property {number} gangJob SimplePlayerPB gangJob
             * @property {boolean} isOnline SimplePlayerPB isOnline
             * @property {number|Long} gangContribute SimplePlayerPB gangContribute
             */

            /**
             * Constructs a new SimplePlayerPB.
             * @memberof luck.protobuf
             * @classdesc Represents a SimplePlayerPB.
             * @implements ISimplePlayerPB
             * @constructor
             * @param {luck.protobuf.ISimplePlayerPB=} [properties] Properties to set
             */
            function SimplePlayerPB(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SimplePlayerPB playerId.
             * @member {number|Long} playerId
             * @memberof luck.protobuf.SimplePlayerPB
             * @instance
             */
            SimplePlayerPB.prototype.playerId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * SimplePlayerPB roleId.
             * @member {number} roleId
             * @memberof luck.protobuf.SimplePlayerPB
             * @instance
             */
            SimplePlayerPB.prototype.roleId = 0;

            /**
             * SimplePlayerPB lv.
             * @member {number} lv
             * @memberof luck.protobuf.SimplePlayerPB
             * @instance
             */
            SimplePlayerPB.prototype.lv = 0;

            /**
             * SimplePlayerPB vipLv.
             * @member {number} vipLv
             * @memberof luck.protobuf.SimplePlayerPB
             * @instance
             */
            SimplePlayerPB.prototype.vipLv = 0;

            /**
             * SimplePlayerPB name.
             * @member {string} name
             * @memberof luck.protobuf.SimplePlayerPB
             * @instance
             */
            SimplePlayerPB.prototype.name = "";

            /**
             * SimplePlayerPB gangId.
             * @member {number|Long} gangId
             * @memberof luck.protobuf.SimplePlayerPB
             * @instance
             */
            SimplePlayerPB.prototype.gangId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * SimplePlayerPB gangName.
             * @member {string} gangName
             * @memberof luck.protobuf.SimplePlayerPB
             * @instance
             */
            SimplePlayerPB.prototype.gangName = "";

            /**
             * SimplePlayerPB gangJob.
             * @member {number} gangJob
             * @memberof luck.protobuf.SimplePlayerPB
             * @instance
             */
            SimplePlayerPB.prototype.gangJob = 0;

            /**
             * SimplePlayerPB isOnline.
             * @member {boolean} isOnline
             * @memberof luck.protobuf.SimplePlayerPB
             * @instance
             */
            SimplePlayerPB.prototype.isOnline = false;

            /**
             * SimplePlayerPB gangContribute.
             * @member {number|Long} gangContribute
             * @memberof luck.protobuf.SimplePlayerPB
             * @instance
             */
            SimplePlayerPB.prototype.gangContribute = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new SimplePlayerPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.SimplePlayerPB
             * @static
             * @param {luck.protobuf.ISimplePlayerPB=} [properties] Properties to set
             * @returns {luck.protobuf.SimplePlayerPB} SimplePlayerPB instance
             */
            SimplePlayerPB.create = function create(properties) {
                return new SimplePlayerPB(properties);
            };

            /**
             * Encodes the specified SimplePlayerPB message. Does not implicitly {@link luck.protobuf.SimplePlayerPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.SimplePlayerPB
             * @static
             * @param {luck.protobuf.ISimplePlayerPB} message SimplePlayerPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SimplePlayerPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.playerId);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.roleId);
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.lv);
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.vipLv);
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.name);
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.gangId);
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.gangName);
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.gangJob);
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.isOnline);
                writer.uint32(/* id 10, wireType 0 =*/80).int64(message.gangContribute);
                return writer;
            };

            /**
             * Encodes the specified SimplePlayerPB message, length delimited. Does not implicitly {@link luck.protobuf.SimplePlayerPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.SimplePlayerPB
             * @static
             * @param {luck.protobuf.ISimplePlayerPB} message SimplePlayerPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SimplePlayerPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SimplePlayerPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.SimplePlayerPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.SimplePlayerPB} SimplePlayerPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SimplePlayerPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.SimplePlayerPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.playerId = reader.int64();
                        break;
                    case 2:
                        message.roleId = reader.int32();
                        break;
                    case 3:
                        message.lv = reader.int32();
                        break;
                    case 4:
                        message.vipLv = reader.int32();
                        break;
                    case 5:
                        message.name = reader.string();
                        break;
                    case 6:
                        message.gangId = reader.int64();
                        break;
                    case 7:
                        message.gangName = reader.string();
                        break;
                    case 8:
                        message.gangJob = reader.int32();
                        break;
                    case 9:
                        message.isOnline = reader.bool();
                        break;
                    case 10:
                        message.gangContribute = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("playerId"))
                    throw $util.ProtocolError("missing required 'playerId'", { instance: message });
                if (!message.hasOwnProperty("roleId"))
                    throw $util.ProtocolError("missing required 'roleId'", { instance: message });
                if (!message.hasOwnProperty("lv"))
                    throw $util.ProtocolError("missing required 'lv'", { instance: message });
                if (!message.hasOwnProperty("vipLv"))
                    throw $util.ProtocolError("missing required 'vipLv'", { instance: message });
                if (!message.hasOwnProperty("name"))
                    throw $util.ProtocolError("missing required 'name'", { instance: message });
                if (!message.hasOwnProperty("gangId"))
                    throw $util.ProtocolError("missing required 'gangId'", { instance: message });
                if (!message.hasOwnProperty("gangName"))
                    throw $util.ProtocolError("missing required 'gangName'", { instance: message });
                if (!message.hasOwnProperty("gangJob"))
                    throw $util.ProtocolError("missing required 'gangJob'", { instance: message });
                if (!message.hasOwnProperty("isOnline"))
                    throw $util.ProtocolError("missing required 'isOnline'", { instance: message });
                if (!message.hasOwnProperty("gangContribute"))
                    throw $util.ProtocolError("missing required 'gangContribute'", { instance: message });
                return message;
            };

            /**
             * Decodes a SimplePlayerPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.SimplePlayerPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.SimplePlayerPB} SimplePlayerPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SimplePlayerPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SimplePlayerPB message.
             * @function verify
             * @memberof luck.protobuf.SimplePlayerPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SimplePlayerPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.playerId) && !(message.playerId && $util.isInteger(message.playerId.low) && $util.isInteger(message.playerId.high)))
                    return "playerId: integer|Long expected";
                if (!$util.isInteger(message.roleId))
                    return "roleId: integer expected";
                if (!$util.isInteger(message.lv))
                    return "lv: integer expected";
                if (!$util.isInteger(message.vipLv))
                    return "vipLv: integer expected";
                if (!$util.isString(message.name))
                    return "name: string expected";
                if (!$util.isInteger(message.gangId) && !(message.gangId && $util.isInteger(message.gangId.low) && $util.isInteger(message.gangId.high)))
                    return "gangId: integer|Long expected";
                if (!$util.isString(message.gangName))
                    return "gangName: string expected";
                if (!$util.isInteger(message.gangJob))
                    return "gangJob: integer expected";
                if (typeof message.isOnline !== "boolean")
                    return "isOnline: boolean expected";
                if (!$util.isInteger(message.gangContribute) && !(message.gangContribute && $util.isInteger(message.gangContribute.low) && $util.isInteger(message.gangContribute.high)))
                    return "gangContribute: integer|Long expected";
                return null;
            };

            return SimplePlayerPB;
        })();

        protobuf.ShopGoodsPB = (function() {

            /**
             * Properties of a ShopGoodsPB.
             * @memberof luck.protobuf
             * @interface IShopGoodsPB
             * @property {number} goodsId ShopGoodsPB goodsId
             * @property {number} haveBuyNum ShopGoodsPB haveBuyNum
             * @property {number} disCount ShopGoodsPB disCount
             * @property {number} timeLimit ShopGoodsPB timeLimit
             * @property {number|Long} lastBuyTime ShopGoodsPB lastBuyTime
             */

            /**
             * Constructs a new ShopGoodsPB.
             * @memberof luck.protobuf
             * @classdesc Represents a ShopGoodsPB.
             * @implements IShopGoodsPB
             * @constructor
             * @param {luck.protobuf.IShopGoodsPB=} [properties] Properties to set
             */
            function ShopGoodsPB(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ShopGoodsPB goodsId.
             * @member {number} goodsId
             * @memberof luck.protobuf.ShopGoodsPB
             * @instance
             */
            ShopGoodsPB.prototype.goodsId = 0;

            /**
             * ShopGoodsPB haveBuyNum.
             * @member {number} haveBuyNum
             * @memberof luck.protobuf.ShopGoodsPB
             * @instance
             */
            ShopGoodsPB.prototype.haveBuyNum = 0;

            /**
             * ShopGoodsPB disCount.
             * @member {number} disCount
             * @memberof luck.protobuf.ShopGoodsPB
             * @instance
             */
            ShopGoodsPB.prototype.disCount = 0;

            /**
             * ShopGoodsPB timeLimit.
             * @member {number} timeLimit
             * @memberof luck.protobuf.ShopGoodsPB
             * @instance
             */
            ShopGoodsPB.prototype.timeLimit = 0;

            /**
             * ShopGoodsPB lastBuyTime.
             * @member {number|Long} lastBuyTime
             * @memberof luck.protobuf.ShopGoodsPB
             * @instance
             */
            ShopGoodsPB.prototype.lastBuyTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new ShopGoodsPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.ShopGoodsPB
             * @static
             * @param {luck.protobuf.IShopGoodsPB=} [properties] Properties to set
             * @returns {luck.protobuf.ShopGoodsPB} ShopGoodsPB instance
             */
            ShopGoodsPB.create = function create(properties) {
                return new ShopGoodsPB(properties);
            };

            /**
             * Encodes the specified ShopGoodsPB message. Does not implicitly {@link luck.protobuf.ShopGoodsPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.ShopGoodsPB
             * @static
             * @param {luck.protobuf.IShopGoodsPB} message ShopGoodsPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ShopGoodsPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.goodsId);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.haveBuyNum);
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.disCount);
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.timeLimit);
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.lastBuyTime);
                return writer;
            };

            /**
             * Encodes the specified ShopGoodsPB message, length delimited. Does not implicitly {@link luck.protobuf.ShopGoodsPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.ShopGoodsPB
             * @static
             * @param {luck.protobuf.IShopGoodsPB} message ShopGoodsPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ShopGoodsPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ShopGoodsPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.ShopGoodsPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.ShopGoodsPB} ShopGoodsPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ShopGoodsPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.ShopGoodsPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.goodsId = reader.int32();
                        break;
                    case 2:
                        message.haveBuyNum = reader.int32();
                        break;
                    case 3:
                        message.disCount = reader.int32();
                        break;
                    case 4:
                        message.timeLimit = reader.int32();
                        break;
                    case 5:
                        message.lastBuyTime = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("goodsId"))
                    throw $util.ProtocolError("missing required 'goodsId'", { instance: message });
                if (!message.hasOwnProperty("haveBuyNum"))
                    throw $util.ProtocolError("missing required 'haveBuyNum'", { instance: message });
                if (!message.hasOwnProperty("disCount"))
                    throw $util.ProtocolError("missing required 'disCount'", { instance: message });
                if (!message.hasOwnProperty("timeLimit"))
                    throw $util.ProtocolError("missing required 'timeLimit'", { instance: message });
                if (!message.hasOwnProperty("lastBuyTime"))
                    throw $util.ProtocolError("missing required 'lastBuyTime'", { instance: message });
                return message;
            };

            /**
             * Decodes a ShopGoodsPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.ShopGoodsPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.ShopGoodsPB} ShopGoodsPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ShopGoodsPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ShopGoodsPB message.
             * @function verify
             * @memberof luck.protobuf.ShopGoodsPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ShopGoodsPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.goodsId))
                    return "goodsId: integer expected";
                if (!$util.isInteger(message.haveBuyNum))
                    return "haveBuyNum: integer expected";
                if (!$util.isInteger(message.disCount))
                    return "disCount: integer expected";
                if (!$util.isInteger(message.timeLimit))
                    return "timeLimit: integer expected";
                if (!$util.isInteger(message.lastBuyTime) && !(message.lastBuyTime && $util.isInteger(message.lastBuyTime.low) && $util.isInteger(message.lastBuyTime.high)))
                    return "lastBuyTime: integer|Long expected";
                return null;
            };

            return ShopGoodsPB;
        })();

        protobuf.ChatInfoPB = (function() {

            /**
             * Properties of a ChatInfoPB.
             * @memberof luck.protobuf
             * @interface IChatInfoPB
             * @property {number|Long} senderId ChatInfoPB senderId
             * @property {string} senderName ChatInfoPB senderName
             * @property {number|Long} sendTime ChatInfoPB sendTime
             * @property {number} type ChatInfoPB type
             * @property {string} content ChatInfoPB content
             * @property {Array.<luck.protobuf.IWeaponPB>|null} [weaponList] ChatInfoPB weaponList
             * @property {Array.<luck.protobuf.ICardPB>|null} [cardList] ChatInfoPB cardList
             * @property {Array.<luck.protobuf.IClothesPB>|null} [clothesList] ChatInfoPB clothesList
             * @property {number} senderLv ChatInfoPB senderLv
             * @property {string|null} [senderGangName] ChatInfoPB senderGangName
             */

            /**
             * Constructs a new ChatInfoPB.
             * @memberof luck.protobuf
             * @classdesc Represents a ChatInfoPB.
             * @implements IChatInfoPB
             * @constructor
             * @param {luck.protobuf.IChatInfoPB=} [properties] Properties to set
             */
            function ChatInfoPB(properties) {
                this.weaponList = [];
                this.cardList = [];
                this.clothesList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ChatInfoPB senderId.
             * @member {number|Long} senderId
             * @memberof luck.protobuf.ChatInfoPB
             * @instance
             */
            ChatInfoPB.prototype.senderId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * ChatInfoPB senderName.
             * @member {string} senderName
             * @memberof luck.protobuf.ChatInfoPB
             * @instance
             */
            ChatInfoPB.prototype.senderName = "";

            /**
             * ChatInfoPB sendTime.
             * @member {number|Long} sendTime
             * @memberof luck.protobuf.ChatInfoPB
             * @instance
             */
            ChatInfoPB.prototype.sendTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * ChatInfoPB type.
             * @member {number} type
             * @memberof luck.protobuf.ChatInfoPB
             * @instance
             */
            ChatInfoPB.prototype.type = 0;

            /**
             * ChatInfoPB content.
             * @member {string} content
             * @memberof luck.protobuf.ChatInfoPB
             * @instance
             */
            ChatInfoPB.prototype.content = "";

            /**
             * ChatInfoPB weaponList.
             * @member {Array.<luck.protobuf.IWeaponPB>} weaponList
             * @memberof luck.protobuf.ChatInfoPB
             * @instance
             */
            ChatInfoPB.prototype.weaponList = $util.emptyArray;

            /**
             * ChatInfoPB cardList.
             * @member {Array.<luck.protobuf.ICardPB>} cardList
             * @memberof luck.protobuf.ChatInfoPB
             * @instance
             */
            ChatInfoPB.prototype.cardList = $util.emptyArray;

            /**
             * ChatInfoPB clothesList.
             * @member {Array.<luck.protobuf.IClothesPB>} clothesList
             * @memberof luck.protobuf.ChatInfoPB
             * @instance
             */
            ChatInfoPB.prototype.clothesList = $util.emptyArray;

            /**
             * ChatInfoPB senderLv.
             * @member {number} senderLv
             * @memberof luck.protobuf.ChatInfoPB
             * @instance
             */
            ChatInfoPB.prototype.senderLv = 0;

            /**
             * ChatInfoPB senderGangName.
             * @member {string} senderGangName
             * @memberof luck.protobuf.ChatInfoPB
             * @instance
             */
            ChatInfoPB.prototype.senderGangName = "";

            /**
             * Creates a new ChatInfoPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.ChatInfoPB
             * @static
             * @param {luck.protobuf.IChatInfoPB=} [properties] Properties to set
             * @returns {luck.protobuf.ChatInfoPB} ChatInfoPB instance
             */
            ChatInfoPB.create = function create(properties) {
                return new ChatInfoPB(properties);
            };

            /**
             * Encodes the specified ChatInfoPB message. Does not implicitly {@link luck.protobuf.ChatInfoPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.ChatInfoPB
             * @static
             * @param {luck.protobuf.IChatInfoPB} message ChatInfoPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChatInfoPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.senderId);
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.senderName);
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.sendTime);
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.type);
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.content);
                if (message.weaponList != null && message.weaponList.length)
                    for (var i = 0; i < message.weaponList.length; ++i)
                        $root.luck.protobuf.WeaponPB.encode(message.weaponList[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.cardList != null && message.cardList.length)
                    for (var i = 0; i < message.cardList.length; ++i)
                        $root.luck.protobuf.CardPB.encode(message.cardList[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.clothesList != null && message.clothesList.length)
                    for (var i = 0; i < message.clothesList.length; ++i)
                        $root.luck.protobuf.ClothesPB.encode(message.clothesList[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.senderLv);
                if (message.senderGangName != null && message.hasOwnProperty("senderGangName"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.senderGangName);
                return writer;
            };

            /**
             * Encodes the specified ChatInfoPB message, length delimited. Does not implicitly {@link luck.protobuf.ChatInfoPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.ChatInfoPB
             * @static
             * @param {luck.protobuf.IChatInfoPB} message ChatInfoPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChatInfoPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ChatInfoPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.ChatInfoPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.ChatInfoPB} ChatInfoPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChatInfoPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.ChatInfoPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.senderId = reader.int64();
                        break;
                    case 2:
                        message.senderName = reader.string();
                        break;
                    case 3:
                        message.sendTime = reader.int64();
                        break;
                    case 4:
                        message.type = reader.int32();
                        break;
                    case 5:
                        message.content = reader.string();
                        break;
                    case 6:
                        if (!(message.weaponList && message.weaponList.length))
                            message.weaponList = [];
                        message.weaponList.push($root.luck.protobuf.WeaponPB.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        if (!(message.cardList && message.cardList.length))
                            message.cardList = [];
                        message.cardList.push($root.luck.protobuf.CardPB.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        if (!(message.clothesList && message.clothesList.length))
                            message.clothesList = [];
                        message.clothesList.push($root.luck.protobuf.ClothesPB.decode(reader, reader.uint32()));
                        break;
                    case 9:
                        message.senderLv = reader.int32();
                        break;
                    case 10:
                        message.senderGangName = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("senderId"))
                    throw $util.ProtocolError("missing required 'senderId'", { instance: message });
                if (!message.hasOwnProperty("senderName"))
                    throw $util.ProtocolError("missing required 'senderName'", { instance: message });
                if (!message.hasOwnProperty("sendTime"))
                    throw $util.ProtocolError("missing required 'sendTime'", { instance: message });
                if (!message.hasOwnProperty("type"))
                    throw $util.ProtocolError("missing required 'type'", { instance: message });
                if (!message.hasOwnProperty("content"))
                    throw $util.ProtocolError("missing required 'content'", { instance: message });
                if (!message.hasOwnProperty("senderLv"))
                    throw $util.ProtocolError("missing required 'senderLv'", { instance: message });
                return message;
            };

            /**
             * Decodes a ChatInfoPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.ChatInfoPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.ChatInfoPB} ChatInfoPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChatInfoPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ChatInfoPB message.
             * @function verify
             * @memberof luck.protobuf.ChatInfoPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChatInfoPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.senderId) && !(message.senderId && $util.isInteger(message.senderId.low) && $util.isInteger(message.senderId.high)))
                    return "senderId: integer|Long expected";
                if (!$util.isString(message.senderName))
                    return "senderName: string expected";
                if (!$util.isInteger(message.sendTime) && !(message.sendTime && $util.isInteger(message.sendTime.low) && $util.isInteger(message.sendTime.high)))
                    return "sendTime: integer|Long expected";
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
                if (!$util.isString(message.content))
                    return "content: string expected";
                if (message.weaponList != null && message.hasOwnProperty("weaponList")) {
                    if (!Array.isArray(message.weaponList))
                        return "weaponList: array expected";
                    for (var i = 0; i < message.weaponList.length; ++i) {
                        var error = $root.luck.protobuf.WeaponPB.verify(message.weaponList[i]);
                        if (error)
                            return "weaponList." + error;
                    }
                }
                if (message.cardList != null && message.hasOwnProperty("cardList")) {
                    if (!Array.isArray(message.cardList))
                        return "cardList: array expected";
                    for (var i = 0; i < message.cardList.length; ++i) {
                        var error = $root.luck.protobuf.CardPB.verify(message.cardList[i]);
                        if (error)
                            return "cardList." + error;
                    }
                }
                if (message.clothesList != null && message.hasOwnProperty("clothesList")) {
                    if (!Array.isArray(message.clothesList))
                        return "clothesList: array expected";
                    for (var i = 0; i < message.clothesList.length; ++i) {
                        var error = $root.luck.protobuf.ClothesPB.verify(message.clothesList[i]);
                        if (error)
                            return "clothesList." + error;
                    }
                }
                if (!$util.isInteger(message.senderLv))
                    return "senderLv: integer expected";
                if (message.senderGangName != null && message.hasOwnProperty("senderGangName"))
                    if (!$util.isString(message.senderGangName))
                        return "senderGangName: string expected";
                return null;
            };

            return ChatInfoPB;
        })();

        protobuf.GangPB = (function() {

            /**
             * Properties of a GangPB.
             * @memberof luck.protobuf
             * @interface IGangPB
             * @property {number|Long} gangId GangPB gangId
             * @property {string} gangName GangPB gangName
             * @property {number} lv GangPB lv
             * @property {number} exp GangPB exp
             * @property {Array.<luck.protobuf.IGangMemberPB>|null} [gangMemberList] GangPB gangMemberList
             * @property {Array.<luck.protobuf.IGangApplyPB>|null} [gangApplyPBList] GangPB gangApplyPBList
             * @property {string} manifesto GangPB manifesto
             * @property {number} iconId GangPB iconId
             * @property {number|Long} createTime GangPB createTime
             */

            /**
             * Constructs a new GangPB.
             * @memberof luck.protobuf
             * @classdesc Represents a GangPB.
             * @implements IGangPB
             * @constructor
             * @param {luck.protobuf.IGangPB=} [properties] Properties to set
             */
            function GangPB(properties) {
                this.gangMemberList = [];
                this.gangApplyPBList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GangPB gangId.
             * @member {number|Long} gangId
             * @memberof luck.protobuf.GangPB
             * @instance
             */
            GangPB.prototype.gangId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * GangPB gangName.
             * @member {string} gangName
             * @memberof luck.protobuf.GangPB
             * @instance
             */
            GangPB.prototype.gangName = "";

            /**
             * GangPB lv.
             * @member {number} lv
             * @memberof luck.protobuf.GangPB
             * @instance
             */
            GangPB.prototype.lv = 0;

            /**
             * GangPB exp.
             * @member {number} exp
             * @memberof luck.protobuf.GangPB
             * @instance
             */
            GangPB.prototype.exp = 0;

            /**
             * GangPB gangMemberList.
             * @member {Array.<luck.protobuf.IGangMemberPB>} gangMemberList
             * @memberof luck.protobuf.GangPB
             * @instance
             */
            GangPB.prototype.gangMemberList = $util.emptyArray;

            /**
             * GangPB gangApplyPBList.
             * @member {Array.<luck.protobuf.IGangApplyPB>} gangApplyPBList
             * @memberof luck.protobuf.GangPB
             * @instance
             */
            GangPB.prototype.gangApplyPBList = $util.emptyArray;

            /**
             * GangPB manifesto.
             * @member {string} manifesto
             * @memberof luck.protobuf.GangPB
             * @instance
             */
            GangPB.prototype.manifesto = "";

            /**
             * GangPB iconId.
             * @member {number} iconId
             * @memberof luck.protobuf.GangPB
             * @instance
             */
            GangPB.prototype.iconId = 0;

            /**
             * GangPB createTime.
             * @member {number|Long} createTime
             * @memberof luck.protobuf.GangPB
             * @instance
             */
            GangPB.prototype.createTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new GangPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.GangPB
             * @static
             * @param {luck.protobuf.IGangPB=} [properties] Properties to set
             * @returns {luck.protobuf.GangPB} GangPB instance
             */
            GangPB.create = function create(properties) {
                return new GangPB(properties);
            };

            /**
             * Encodes the specified GangPB message. Does not implicitly {@link luck.protobuf.GangPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.GangPB
             * @static
             * @param {luck.protobuf.IGangPB} message GangPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GangPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.gangId);
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.gangName);
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.lv);
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.exp);
                if (message.gangMemberList != null && message.gangMemberList.length)
                    for (var i = 0; i < message.gangMemberList.length; ++i)
                        $root.luck.protobuf.GangMemberPB.encode(message.gangMemberList[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.gangApplyPBList != null && message.gangApplyPBList.length)
                    for (var i = 0; i < message.gangApplyPBList.length; ++i)
                        $root.luck.protobuf.GangApplyPB.encode(message.gangApplyPBList[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.manifesto);
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.iconId);
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.createTime);
                return writer;
            };

            /**
             * Encodes the specified GangPB message, length delimited. Does not implicitly {@link luck.protobuf.GangPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.GangPB
             * @static
             * @param {luck.protobuf.IGangPB} message GangPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GangPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GangPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.GangPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.GangPB} GangPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GangPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.GangPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.gangId = reader.int64();
                        break;
                    case 2:
                        message.gangName = reader.string();
                        break;
                    case 3:
                        message.lv = reader.int32();
                        break;
                    case 4:
                        message.exp = reader.int32();
                        break;
                    case 5:
                        if (!(message.gangMemberList && message.gangMemberList.length))
                            message.gangMemberList = [];
                        message.gangMemberList.push($root.luck.protobuf.GangMemberPB.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.gangApplyPBList && message.gangApplyPBList.length))
                            message.gangApplyPBList = [];
                        message.gangApplyPBList.push($root.luck.protobuf.GangApplyPB.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        message.manifesto = reader.string();
                        break;
                    case 8:
                        message.iconId = reader.int32();
                        break;
                    case 9:
                        message.createTime = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("gangId"))
                    throw $util.ProtocolError("missing required 'gangId'", { instance: message });
                if (!message.hasOwnProperty("gangName"))
                    throw $util.ProtocolError("missing required 'gangName'", { instance: message });
                if (!message.hasOwnProperty("lv"))
                    throw $util.ProtocolError("missing required 'lv'", { instance: message });
                if (!message.hasOwnProperty("exp"))
                    throw $util.ProtocolError("missing required 'exp'", { instance: message });
                if (!message.hasOwnProperty("manifesto"))
                    throw $util.ProtocolError("missing required 'manifesto'", { instance: message });
                if (!message.hasOwnProperty("iconId"))
                    throw $util.ProtocolError("missing required 'iconId'", { instance: message });
                if (!message.hasOwnProperty("createTime"))
                    throw $util.ProtocolError("missing required 'createTime'", { instance: message });
                return message;
            };

            /**
             * Decodes a GangPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.GangPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.GangPB} GangPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GangPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GangPB message.
             * @function verify
             * @memberof luck.protobuf.GangPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GangPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.gangId) && !(message.gangId && $util.isInteger(message.gangId.low) && $util.isInteger(message.gangId.high)))
                    return "gangId: integer|Long expected";
                if (!$util.isString(message.gangName))
                    return "gangName: string expected";
                if (!$util.isInteger(message.lv))
                    return "lv: integer expected";
                if (!$util.isInteger(message.exp))
                    return "exp: integer expected";
                if (message.gangMemberList != null && message.hasOwnProperty("gangMemberList")) {
                    if (!Array.isArray(message.gangMemberList))
                        return "gangMemberList: array expected";
                    for (var i = 0; i < message.gangMemberList.length; ++i) {
                        var error = $root.luck.protobuf.GangMemberPB.verify(message.gangMemberList[i]);
                        if (error)
                            return "gangMemberList." + error;
                    }
                }
                if (message.gangApplyPBList != null && message.hasOwnProperty("gangApplyPBList")) {
                    if (!Array.isArray(message.gangApplyPBList))
                        return "gangApplyPBList: array expected";
                    for (var i = 0; i < message.gangApplyPBList.length; ++i) {
                        var error = $root.luck.protobuf.GangApplyPB.verify(message.gangApplyPBList[i]);
                        if (error)
                            return "gangApplyPBList." + error;
                    }
                }
                if (!$util.isString(message.manifesto))
                    return "manifesto: string expected";
                if (!$util.isInteger(message.iconId))
                    return "iconId: integer expected";
                if (!$util.isInteger(message.createTime) && !(message.createTime && $util.isInteger(message.createTime.low) && $util.isInteger(message.createTime.high)))
                    return "createTime: integer|Long expected";
                return null;
            };

            return GangPB;
        })();

        protobuf.GangMemberPB = (function() {

            /**
             * Properties of a GangMemberPB.
             * @memberof luck.protobuf
             * @interface IGangMemberPB
             * @property {luck.protobuf.ISimplePlayerPB} member GangMemberPB member
             * @property {number} job GangMemberPB job
             */

            /**
             * Constructs a new GangMemberPB.
             * @memberof luck.protobuf
             * @classdesc Represents a GangMemberPB.
             * @implements IGangMemberPB
             * @constructor
             * @param {luck.protobuf.IGangMemberPB=} [properties] Properties to set
             */
            function GangMemberPB(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GangMemberPB member.
             * @member {luck.protobuf.ISimplePlayerPB} member
             * @memberof luck.protobuf.GangMemberPB
             * @instance
             */
            GangMemberPB.prototype.member = null;

            /**
             * GangMemberPB job.
             * @member {number} job
             * @memberof luck.protobuf.GangMemberPB
             * @instance
             */
            GangMemberPB.prototype.job = 0;

            /**
             * Creates a new GangMemberPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.GangMemberPB
             * @static
             * @param {luck.protobuf.IGangMemberPB=} [properties] Properties to set
             * @returns {luck.protobuf.GangMemberPB} GangMemberPB instance
             */
            GangMemberPB.create = function create(properties) {
                return new GangMemberPB(properties);
            };

            /**
             * Encodes the specified GangMemberPB message. Does not implicitly {@link luck.protobuf.GangMemberPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.GangMemberPB
             * @static
             * @param {luck.protobuf.IGangMemberPB} message GangMemberPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GangMemberPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                $root.luck.protobuf.SimplePlayerPB.encode(message.member, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.job);
                return writer;
            };

            /**
             * Encodes the specified GangMemberPB message, length delimited. Does not implicitly {@link luck.protobuf.GangMemberPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.GangMemberPB
             * @static
             * @param {luck.protobuf.IGangMemberPB} message GangMemberPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GangMemberPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GangMemberPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.GangMemberPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.GangMemberPB} GangMemberPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GangMemberPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.GangMemberPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.member = $root.luck.protobuf.SimplePlayerPB.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.job = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("member"))
                    throw $util.ProtocolError("missing required 'member'", { instance: message });
                if (!message.hasOwnProperty("job"))
                    throw $util.ProtocolError("missing required 'job'", { instance: message });
                return message;
            };

            /**
             * Decodes a GangMemberPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.GangMemberPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.GangMemberPB} GangMemberPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GangMemberPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GangMemberPB message.
             * @function verify
             * @memberof luck.protobuf.GangMemberPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GangMemberPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                {
                    var error = $root.luck.protobuf.SimplePlayerPB.verify(message.member);
                    if (error)
                        return "member." + error;
                }
                if (!$util.isInteger(message.job))
                    return "job: integer expected";
                return null;
            };

            return GangMemberPB;
        })();

        protobuf.GangApplyPB = (function() {

            /**
             * Properties of a GangApplyPB.
             * @memberof luck.protobuf
             * @interface IGangApplyPB
             * @property {luck.protobuf.ISimplePlayerPB} member GangApplyPB member
             * @property {number|Long} applyTime GangApplyPB applyTime
             */

            /**
             * Constructs a new GangApplyPB.
             * @memberof luck.protobuf
             * @classdesc Represents a GangApplyPB.
             * @implements IGangApplyPB
             * @constructor
             * @param {luck.protobuf.IGangApplyPB=} [properties] Properties to set
             */
            function GangApplyPB(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GangApplyPB member.
             * @member {luck.protobuf.ISimplePlayerPB} member
             * @memberof luck.protobuf.GangApplyPB
             * @instance
             */
            GangApplyPB.prototype.member = null;

            /**
             * GangApplyPB applyTime.
             * @member {number|Long} applyTime
             * @memberof luck.protobuf.GangApplyPB
             * @instance
             */
            GangApplyPB.prototype.applyTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new GangApplyPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.GangApplyPB
             * @static
             * @param {luck.protobuf.IGangApplyPB=} [properties] Properties to set
             * @returns {luck.protobuf.GangApplyPB} GangApplyPB instance
             */
            GangApplyPB.create = function create(properties) {
                return new GangApplyPB(properties);
            };

            /**
             * Encodes the specified GangApplyPB message. Does not implicitly {@link luck.protobuf.GangApplyPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.GangApplyPB
             * @static
             * @param {luck.protobuf.IGangApplyPB} message GangApplyPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GangApplyPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                $root.luck.protobuf.SimplePlayerPB.encode(message.member, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.applyTime);
                return writer;
            };

            /**
             * Encodes the specified GangApplyPB message, length delimited. Does not implicitly {@link luck.protobuf.GangApplyPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.GangApplyPB
             * @static
             * @param {luck.protobuf.IGangApplyPB} message GangApplyPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GangApplyPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GangApplyPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.GangApplyPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.GangApplyPB} GangApplyPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GangApplyPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.GangApplyPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.member = $root.luck.protobuf.SimplePlayerPB.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.applyTime = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("member"))
                    throw $util.ProtocolError("missing required 'member'", { instance: message });
                if (!message.hasOwnProperty("applyTime"))
                    throw $util.ProtocolError("missing required 'applyTime'", { instance: message });
                return message;
            };

            /**
             * Decodes a GangApplyPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.GangApplyPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.GangApplyPB} GangApplyPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GangApplyPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GangApplyPB message.
             * @function verify
             * @memberof luck.protobuf.GangApplyPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GangApplyPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                {
                    var error = $root.luck.protobuf.SimplePlayerPB.verify(message.member);
                    if (error)
                        return "member." + error;
                }
                if (!$util.isInteger(message.applyTime) && !(message.applyTime && $util.isInteger(message.applyTime.low) && $util.isInteger(message.applyTime.high)))
                    return "applyTime: integer|Long expected";
                return null;
            };

            return GangApplyPB;
        })();

        protobuf.sellGoodsPB = (function() {

            /**
             * Properties of a sellGoodsPB.
             * @memberof luck.protobuf
             * @interface IsellGoodsPB
             * @property {number|null} [goodsId] sellGoodsPB goodsId
             * @property {number|null} [sellNum] sellGoodsPB sellNum
             * @property {number|Long|null} [uid] sellGoodsPB uid
             * @property {number|null} [type] sellGoodsPB type
             */

            /**
             * Constructs a new sellGoodsPB.
             * @memberof luck.protobuf
             * @classdesc Represents a sellGoodsPB.
             * @implements IsellGoodsPB
             * @constructor
             * @param {luck.protobuf.IsellGoodsPB=} [properties] Properties to set
             */
            function sellGoodsPB(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * sellGoodsPB goodsId.
             * @member {number} goodsId
             * @memberof luck.protobuf.sellGoodsPB
             * @instance
             */
            sellGoodsPB.prototype.goodsId = 0;

            /**
             * sellGoodsPB sellNum.
             * @member {number} sellNum
             * @memberof luck.protobuf.sellGoodsPB
             * @instance
             */
            sellGoodsPB.prototype.sellNum = 0;

            /**
             * sellGoodsPB uid.
             * @member {number|Long} uid
             * @memberof luck.protobuf.sellGoodsPB
             * @instance
             */
            sellGoodsPB.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * sellGoodsPB type.
             * @member {number} type
             * @memberof luck.protobuf.sellGoodsPB
             * @instance
             */
            sellGoodsPB.prototype.type = 0;

            /**
             * Creates a new sellGoodsPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.sellGoodsPB
             * @static
             * @param {luck.protobuf.IsellGoodsPB=} [properties] Properties to set
             * @returns {luck.protobuf.sellGoodsPB} sellGoodsPB instance
             */
            sellGoodsPB.create = function create(properties) {
                return new sellGoodsPB(properties);
            };

            /**
             * Encodes the specified sellGoodsPB message. Does not implicitly {@link luck.protobuf.sellGoodsPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.sellGoodsPB
             * @static
             * @param {luck.protobuf.IsellGoodsPB} message sellGoodsPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            sellGoodsPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.goodsId != null && message.hasOwnProperty("goodsId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.goodsId);
                if (message.sellNum != null && message.hasOwnProperty("sellNum"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.sellNum);
                if (message.uid != null && message.hasOwnProperty("uid"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.uid);
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.type);
                return writer;
            };

            /**
             * Encodes the specified sellGoodsPB message, length delimited. Does not implicitly {@link luck.protobuf.sellGoodsPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.sellGoodsPB
             * @static
             * @param {luck.protobuf.IsellGoodsPB} message sellGoodsPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            sellGoodsPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a sellGoodsPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.sellGoodsPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.sellGoodsPB} sellGoodsPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            sellGoodsPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.sellGoodsPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.goodsId = reader.int32();
                        break;
                    case 2:
                        message.sellNum = reader.int32();
                        break;
                    case 3:
                        message.uid = reader.int64();
                        break;
                    case 4:
                        message.type = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a sellGoodsPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.sellGoodsPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.sellGoodsPB} sellGoodsPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            sellGoodsPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a sellGoodsPB message.
             * @function verify
             * @memberof luck.protobuf.sellGoodsPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            sellGoodsPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.goodsId != null && message.hasOwnProperty("goodsId"))
                    if (!$util.isInteger(message.goodsId))
                        return "goodsId: integer expected";
                if (message.sellNum != null && message.hasOwnProperty("sellNum"))
                    if (!$util.isInteger(message.sellNum))
                        return "sellNum: integer expected";
                if (message.uid != null && message.hasOwnProperty("uid"))
                    if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                        return "uid: integer|Long expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isInteger(message.type))
                        return "type: integer expected";
                return null;
            };

            return sellGoodsPB;
        })();

        protobuf.ActivityTollgatePB = (function() {

            /**
             * Properties of an ActivityTollgatePB.
             * @memberof luck.protobuf
             * @interface IActivityTollgatePB
             * @property {number} tollgateId ActivityTollgatePB tollgateId
             * @property {number} clearNum ActivityTollgatePB clearNum
             * @property {number} isFirstClear ActivityTollgatePB isFirstClear
             * @property {boolean} isUnlock ActivityTollgatePB isUnlock
             */

            /**
             * Constructs a new ActivityTollgatePB.
             * @memberof luck.protobuf
             * @classdesc Represents an ActivityTollgatePB.
             * @implements IActivityTollgatePB
             * @constructor
             * @param {luck.protobuf.IActivityTollgatePB=} [properties] Properties to set
             */
            function ActivityTollgatePB(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ActivityTollgatePB tollgateId.
             * @member {number} tollgateId
             * @memberof luck.protobuf.ActivityTollgatePB
             * @instance
             */
            ActivityTollgatePB.prototype.tollgateId = 0;

            /**
             * ActivityTollgatePB clearNum.
             * @member {number} clearNum
             * @memberof luck.protobuf.ActivityTollgatePB
             * @instance
             */
            ActivityTollgatePB.prototype.clearNum = 0;

            /**
             * ActivityTollgatePB isFirstClear.
             * @member {number} isFirstClear
             * @memberof luck.protobuf.ActivityTollgatePB
             * @instance
             */
            ActivityTollgatePB.prototype.isFirstClear = 0;

            /**
             * ActivityTollgatePB isUnlock.
             * @member {boolean} isUnlock
             * @memberof luck.protobuf.ActivityTollgatePB
             * @instance
             */
            ActivityTollgatePB.prototype.isUnlock = false;

            /**
             * Creates a new ActivityTollgatePB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.ActivityTollgatePB
             * @static
             * @param {luck.protobuf.IActivityTollgatePB=} [properties] Properties to set
             * @returns {luck.protobuf.ActivityTollgatePB} ActivityTollgatePB instance
             */
            ActivityTollgatePB.create = function create(properties) {
                return new ActivityTollgatePB(properties);
            };

            /**
             * Encodes the specified ActivityTollgatePB message. Does not implicitly {@link luck.protobuf.ActivityTollgatePB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.ActivityTollgatePB
             * @static
             * @param {luck.protobuf.IActivityTollgatePB} message ActivityTollgatePB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ActivityTollgatePB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tollgateId);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.clearNum);
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.isFirstClear);
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.isUnlock);
                return writer;
            };

            /**
             * Encodes the specified ActivityTollgatePB message, length delimited. Does not implicitly {@link luck.protobuf.ActivityTollgatePB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.ActivityTollgatePB
             * @static
             * @param {luck.protobuf.IActivityTollgatePB} message ActivityTollgatePB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ActivityTollgatePB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ActivityTollgatePB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.ActivityTollgatePB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.ActivityTollgatePB} ActivityTollgatePB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ActivityTollgatePB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.ActivityTollgatePB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tollgateId = reader.int32();
                        break;
                    case 2:
                        message.clearNum = reader.int32();
                        break;
                    case 3:
                        message.isFirstClear = reader.int32();
                        break;
                    case 4:
                        message.isUnlock = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("tollgateId"))
                    throw $util.ProtocolError("missing required 'tollgateId'", { instance: message });
                if (!message.hasOwnProperty("clearNum"))
                    throw $util.ProtocolError("missing required 'clearNum'", { instance: message });
                if (!message.hasOwnProperty("isFirstClear"))
                    throw $util.ProtocolError("missing required 'isFirstClear'", { instance: message });
                if (!message.hasOwnProperty("isUnlock"))
                    throw $util.ProtocolError("missing required 'isUnlock'", { instance: message });
                return message;
            };

            /**
             * Decodes an ActivityTollgatePB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.ActivityTollgatePB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.ActivityTollgatePB} ActivityTollgatePB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ActivityTollgatePB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ActivityTollgatePB message.
             * @function verify
             * @memberof luck.protobuf.ActivityTollgatePB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ActivityTollgatePB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.tollgateId))
                    return "tollgateId: integer expected";
                if (!$util.isInteger(message.clearNum))
                    return "clearNum: integer expected";
                if (!$util.isInteger(message.isFirstClear))
                    return "isFirstClear: integer expected";
                if (typeof message.isUnlock !== "boolean")
                    return "isUnlock: boolean expected";
                return null;
            };

            return ActivityTollgatePB;
        })();

        protobuf.ActivityChapterPB = (function() {

            /**
             * Properties of an ActivityChapterPB.
             * @memberof luck.protobuf
             * @interface IActivityChapterPB
             * @property {number} chapterId ActivityChapterPB chapterId
             * @property {boolean} isUnlock ActivityChapterPB isUnlock
             * @property {number|Long} lastClearTime ActivityChapterPB lastClearTime
             */

            /**
             * Constructs a new ActivityChapterPB.
             * @memberof luck.protobuf
             * @classdesc Represents an ActivityChapterPB.
             * @implements IActivityChapterPB
             * @constructor
             * @param {luck.protobuf.IActivityChapterPB=} [properties] Properties to set
             */
            function ActivityChapterPB(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ActivityChapterPB chapterId.
             * @member {number} chapterId
             * @memberof luck.protobuf.ActivityChapterPB
             * @instance
             */
            ActivityChapterPB.prototype.chapterId = 0;

            /**
             * ActivityChapterPB isUnlock.
             * @member {boolean} isUnlock
             * @memberof luck.protobuf.ActivityChapterPB
             * @instance
             */
            ActivityChapterPB.prototype.isUnlock = false;

            /**
             * ActivityChapterPB lastClearTime.
             * @member {number|Long} lastClearTime
             * @memberof luck.protobuf.ActivityChapterPB
             * @instance
             */
            ActivityChapterPB.prototype.lastClearTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new ActivityChapterPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.ActivityChapterPB
             * @static
             * @param {luck.protobuf.IActivityChapterPB=} [properties] Properties to set
             * @returns {luck.protobuf.ActivityChapterPB} ActivityChapterPB instance
             */
            ActivityChapterPB.create = function create(properties) {
                return new ActivityChapterPB(properties);
            };

            /**
             * Encodes the specified ActivityChapterPB message. Does not implicitly {@link luck.protobuf.ActivityChapterPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.ActivityChapterPB
             * @static
             * @param {luck.protobuf.IActivityChapterPB} message ActivityChapterPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ActivityChapterPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.chapterId);
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isUnlock);
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.lastClearTime);
                return writer;
            };

            /**
             * Encodes the specified ActivityChapterPB message, length delimited. Does not implicitly {@link luck.protobuf.ActivityChapterPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.ActivityChapterPB
             * @static
             * @param {luck.protobuf.IActivityChapterPB} message ActivityChapterPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ActivityChapterPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ActivityChapterPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.ActivityChapterPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.ActivityChapterPB} ActivityChapterPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ActivityChapterPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.ActivityChapterPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.chapterId = reader.int32();
                        break;
                    case 2:
                        message.isUnlock = reader.bool();
                        break;
                    case 3:
                        message.lastClearTime = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("chapterId"))
                    throw $util.ProtocolError("missing required 'chapterId'", { instance: message });
                if (!message.hasOwnProperty("isUnlock"))
                    throw $util.ProtocolError("missing required 'isUnlock'", { instance: message });
                if (!message.hasOwnProperty("lastClearTime"))
                    throw $util.ProtocolError("missing required 'lastClearTime'", { instance: message });
                return message;
            };

            /**
             * Decodes an ActivityChapterPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.ActivityChapterPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.ActivityChapterPB} ActivityChapterPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ActivityChapterPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ActivityChapterPB message.
             * @function verify
             * @memberof luck.protobuf.ActivityChapterPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ActivityChapterPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.chapterId))
                    return "chapterId: integer expected";
                if (typeof message.isUnlock !== "boolean")
                    return "isUnlock: boolean expected";
                if (!$util.isInteger(message.lastClearTime) && !(message.lastClearTime && $util.isInteger(message.lastClearTime.low) && $util.isInteger(message.lastClearTime.high)))
                    return "lastClearTime: integer|Long expected";
                return null;
            };

            return ActivityChapterPB;
        })();

        protobuf.LoveBentoPB = (function() {

            /**
             * Properties of a LoveBentoPB.
             * @memberof luck.protobuf
             * @interface ILoveBentoPB
             * @property {boolean} amDraw LoveBentoPB amDraw
             * @property {boolean} pmDraw LoveBentoPB pmDraw
             */

            /**
             * Constructs a new LoveBentoPB.
             * @memberof luck.protobuf
             * @classdesc Represents a LoveBentoPB.
             * @implements ILoveBentoPB
             * @constructor
             * @param {luck.protobuf.ILoveBentoPB=} [properties] Properties to set
             */
            function LoveBentoPB(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LoveBentoPB amDraw.
             * @member {boolean} amDraw
             * @memberof luck.protobuf.LoveBentoPB
             * @instance
             */
            LoveBentoPB.prototype.amDraw = false;

            /**
             * LoveBentoPB pmDraw.
             * @member {boolean} pmDraw
             * @memberof luck.protobuf.LoveBentoPB
             * @instance
             */
            LoveBentoPB.prototype.pmDraw = false;

            /**
             * Creates a new LoveBentoPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.LoveBentoPB
             * @static
             * @param {luck.protobuf.ILoveBentoPB=} [properties] Properties to set
             * @returns {luck.protobuf.LoveBentoPB} LoveBentoPB instance
             */
            LoveBentoPB.create = function create(properties) {
                return new LoveBentoPB(properties);
            };

            /**
             * Encodes the specified LoveBentoPB message. Does not implicitly {@link luck.protobuf.LoveBentoPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.LoveBentoPB
             * @static
             * @param {luck.protobuf.ILoveBentoPB} message LoveBentoPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LoveBentoPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.amDraw);
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.pmDraw);
                return writer;
            };

            /**
             * Encodes the specified LoveBentoPB message, length delimited. Does not implicitly {@link luck.protobuf.LoveBentoPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.LoveBentoPB
             * @static
             * @param {luck.protobuf.ILoveBentoPB} message LoveBentoPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LoveBentoPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LoveBentoPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.LoveBentoPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.LoveBentoPB} LoveBentoPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LoveBentoPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.LoveBentoPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.amDraw = reader.bool();
                        break;
                    case 2:
                        message.pmDraw = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("amDraw"))
                    throw $util.ProtocolError("missing required 'amDraw'", { instance: message });
                if (!message.hasOwnProperty("pmDraw"))
                    throw $util.ProtocolError("missing required 'pmDraw'", { instance: message });
                return message;
            };

            /**
             * Decodes a LoveBentoPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.LoveBentoPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.LoveBentoPB} LoveBentoPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LoveBentoPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LoveBentoPB message.
             * @function verify
             * @memberof luck.protobuf.LoveBentoPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LoveBentoPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (typeof message.amDraw !== "boolean")
                    return "amDraw: boolean expected";
                if (typeof message.pmDraw !== "boolean")
                    return "pmDraw: boolean expected";
                return null;
            };

            return LoveBentoPB;
        })();

        protobuf.TaskConditionPB = (function() {

            /**
             * Properties of a TaskConditionPB.
             * @memberof luck.protobuf
             * @interface ITaskConditionPB
             * @property {number} taskConditionId TaskConditionPB taskConditionId
             * @property {number} num TaskConditionPB num
             * @property {Array.<number>|null} [conditionList] TaskConditionPB conditionList
             */

            /**
             * Constructs a new TaskConditionPB.
             * @memberof luck.protobuf
             * @classdesc Represents a TaskConditionPB.
             * @implements ITaskConditionPB
             * @constructor
             * @param {luck.protobuf.ITaskConditionPB=} [properties] Properties to set
             */
            function TaskConditionPB(properties) {
                this.conditionList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TaskConditionPB taskConditionId.
             * @member {number} taskConditionId
             * @memberof luck.protobuf.TaskConditionPB
             * @instance
             */
            TaskConditionPB.prototype.taskConditionId = 0;

            /**
             * TaskConditionPB num.
             * @member {number} num
             * @memberof luck.protobuf.TaskConditionPB
             * @instance
             */
            TaskConditionPB.prototype.num = 0;

            /**
             * TaskConditionPB conditionList.
             * @member {Array.<number>} conditionList
             * @memberof luck.protobuf.TaskConditionPB
             * @instance
             */
            TaskConditionPB.prototype.conditionList = $util.emptyArray;

            /**
             * Creates a new TaskConditionPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.TaskConditionPB
             * @static
             * @param {luck.protobuf.ITaskConditionPB=} [properties] Properties to set
             * @returns {luck.protobuf.TaskConditionPB} TaskConditionPB instance
             */
            TaskConditionPB.create = function create(properties) {
                return new TaskConditionPB(properties);
            };

            /**
             * Encodes the specified TaskConditionPB message. Does not implicitly {@link luck.protobuf.TaskConditionPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.TaskConditionPB
             * @static
             * @param {luck.protobuf.ITaskConditionPB} message TaskConditionPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TaskConditionPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.taskConditionId);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.num);
                if (message.conditionList != null && message.conditionList.length)
                    for (var i = 0; i < message.conditionList.length; ++i)
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.conditionList[i]);
                return writer;
            };

            /**
             * Encodes the specified TaskConditionPB message, length delimited. Does not implicitly {@link luck.protobuf.TaskConditionPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.TaskConditionPB
             * @static
             * @param {luck.protobuf.ITaskConditionPB} message TaskConditionPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TaskConditionPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TaskConditionPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.TaskConditionPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.TaskConditionPB} TaskConditionPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TaskConditionPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.TaskConditionPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.taskConditionId = reader.int32();
                        break;
                    case 2:
                        message.num = reader.int32();
                        break;
                    case 3:
                        if (!(message.conditionList && message.conditionList.length))
                            message.conditionList = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.conditionList.push(reader.int32());
                        } else
                            message.conditionList.push(reader.int32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("taskConditionId"))
                    throw $util.ProtocolError("missing required 'taskConditionId'", { instance: message });
                if (!message.hasOwnProperty("num"))
                    throw $util.ProtocolError("missing required 'num'", { instance: message });
                return message;
            };

            /**
             * Decodes a TaskConditionPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.TaskConditionPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.TaskConditionPB} TaskConditionPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TaskConditionPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TaskConditionPB message.
             * @function verify
             * @memberof luck.protobuf.TaskConditionPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TaskConditionPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.taskConditionId))
                    return "taskConditionId: integer expected";
                if (!$util.isInteger(message.num))
                    return "num: integer expected";
                if (message.conditionList != null && message.hasOwnProperty("conditionList")) {
                    if (!Array.isArray(message.conditionList))
                        return "conditionList: array expected";
                    for (var i = 0; i < message.conditionList.length; ++i)
                        if (!$util.isInteger(message.conditionList[i]))
                            return "conditionList: integer[] expected";
                }
                return null;
            };

            return TaskConditionPB;
        })();

        protobuf.MainTaskPB = (function() {

            /**
             * Properties of a MainTaskPB.
             * @memberof luck.protobuf
             * @interface IMainTaskPB
             * @property {number} mainTaskId MainTaskPB mainTaskId
             * @property {luck.protobuf.ITaskConditionPB} condition MainTaskPB condition
             * @property {boolean} bFront MainTaskPB bFront
             * @property {boolean} bDeblock MainTaskPB bDeblock
             * @property {boolean} bGain MainTaskPB bGain
             */

            /**
             * Constructs a new MainTaskPB.
             * @memberof luck.protobuf
             * @classdesc Represents a MainTaskPB.
             * @implements IMainTaskPB
             * @constructor
             * @param {luck.protobuf.IMainTaskPB=} [properties] Properties to set
             */
            function MainTaskPB(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MainTaskPB mainTaskId.
             * @member {number} mainTaskId
             * @memberof luck.protobuf.MainTaskPB
             * @instance
             */
            MainTaskPB.prototype.mainTaskId = 0;

            /**
             * MainTaskPB condition.
             * @member {luck.protobuf.ITaskConditionPB} condition
             * @memberof luck.protobuf.MainTaskPB
             * @instance
             */
            MainTaskPB.prototype.condition = null;

            /**
             * MainTaskPB bFront.
             * @member {boolean} bFront
             * @memberof luck.protobuf.MainTaskPB
             * @instance
             */
            MainTaskPB.prototype.bFront = false;

            /**
             * MainTaskPB bDeblock.
             * @member {boolean} bDeblock
             * @memberof luck.protobuf.MainTaskPB
             * @instance
             */
            MainTaskPB.prototype.bDeblock = false;

            /**
             * MainTaskPB bGain.
             * @member {boolean} bGain
             * @memberof luck.protobuf.MainTaskPB
             * @instance
             */
            MainTaskPB.prototype.bGain = false;

            /**
             * Creates a new MainTaskPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.MainTaskPB
             * @static
             * @param {luck.protobuf.IMainTaskPB=} [properties] Properties to set
             * @returns {luck.protobuf.MainTaskPB} MainTaskPB instance
             */
            MainTaskPB.create = function create(properties) {
                return new MainTaskPB(properties);
            };

            /**
             * Encodes the specified MainTaskPB message. Does not implicitly {@link luck.protobuf.MainTaskPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.MainTaskPB
             * @static
             * @param {luck.protobuf.IMainTaskPB} message MainTaskPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MainTaskPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.mainTaskId);
                $root.luck.protobuf.TaskConditionPB.encode(message.condition, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.bFront);
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.bDeblock);
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.bGain);
                return writer;
            };

            /**
             * Encodes the specified MainTaskPB message, length delimited. Does not implicitly {@link luck.protobuf.MainTaskPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.MainTaskPB
             * @static
             * @param {luck.protobuf.IMainTaskPB} message MainTaskPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MainTaskPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MainTaskPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.MainTaskPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.MainTaskPB} MainTaskPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MainTaskPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.MainTaskPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.mainTaskId = reader.int32();
                        break;
                    case 2:
                        message.condition = $root.luck.protobuf.TaskConditionPB.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.bFront = reader.bool();
                        break;
                    case 4:
                        message.bDeblock = reader.bool();
                        break;
                    case 5:
                        message.bGain = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("mainTaskId"))
                    throw $util.ProtocolError("missing required 'mainTaskId'", { instance: message });
                if (!message.hasOwnProperty("condition"))
                    throw $util.ProtocolError("missing required 'condition'", { instance: message });
                if (!message.hasOwnProperty("bFront"))
                    throw $util.ProtocolError("missing required 'bFront'", { instance: message });
                if (!message.hasOwnProperty("bDeblock"))
                    throw $util.ProtocolError("missing required 'bDeblock'", { instance: message });
                if (!message.hasOwnProperty("bGain"))
                    throw $util.ProtocolError("missing required 'bGain'", { instance: message });
                return message;
            };

            /**
             * Decodes a MainTaskPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.MainTaskPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.MainTaskPB} MainTaskPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MainTaskPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MainTaskPB message.
             * @function verify
             * @memberof luck.protobuf.MainTaskPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MainTaskPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.mainTaskId))
                    return "mainTaskId: integer expected";
                {
                    var error = $root.luck.protobuf.TaskConditionPB.verify(message.condition);
                    if (error)
                        return "condition." + error;
                }
                if (typeof message.bFront !== "boolean")
                    return "bFront: boolean expected";
                if (typeof message.bDeblock !== "boolean")
                    return "bDeblock: boolean expected";
                if (typeof message.bGain !== "boolean")
                    return "bGain: boolean expected";
                return null;
            };

            return MainTaskPB;
        })();

        protobuf.DailyTaskPB = (function() {

            /**
             * Properties of a DailyTaskPB.
             * @memberof luck.protobuf
             * @interface IDailyTaskPB
             * @property {number} dailyTaskId DailyTaskPB dailyTaskId
             * @property {luck.protobuf.ITaskConditionPB} condition DailyTaskPB condition
             * @property {boolean} bGain DailyTaskPB bGain
             */

            /**
             * Constructs a new DailyTaskPB.
             * @memberof luck.protobuf
             * @classdesc Represents a DailyTaskPB.
             * @implements IDailyTaskPB
             * @constructor
             * @param {luck.protobuf.IDailyTaskPB=} [properties] Properties to set
             */
            function DailyTaskPB(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DailyTaskPB dailyTaskId.
             * @member {number} dailyTaskId
             * @memberof luck.protobuf.DailyTaskPB
             * @instance
             */
            DailyTaskPB.prototype.dailyTaskId = 0;

            /**
             * DailyTaskPB condition.
             * @member {luck.protobuf.ITaskConditionPB} condition
             * @memberof luck.protobuf.DailyTaskPB
             * @instance
             */
            DailyTaskPB.prototype.condition = null;

            /**
             * DailyTaskPB bGain.
             * @member {boolean} bGain
             * @memberof luck.protobuf.DailyTaskPB
             * @instance
             */
            DailyTaskPB.prototype.bGain = false;

            /**
             * Creates a new DailyTaskPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.DailyTaskPB
             * @static
             * @param {luck.protobuf.IDailyTaskPB=} [properties] Properties to set
             * @returns {luck.protobuf.DailyTaskPB} DailyTaskPB instance
             */
            DailyTaskPB.create = function create(properties) {
                return new DailyTaskPB(properties);
            };

            /**
             * Encodes the specified DailyTaskPB message. Does not implicitly {@link luck.protobuf.DailyTaskPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.DailyTaskPB
             * @static
             * @param {luck.protobuf.IDailyTaskPB} message DailyTaskPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DailyTaskPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.dailyTaskId);
                $root.luck.protobuf.TaskConditionPB.encode(message.condition, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.bGain);
                return writer;
            };

            /**
             * Encodes the specified DailyTaskPB message, length delimited. Does not implicitly {@link luck.protobuf.DailyTaskPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.DailyTaskPB
             * @static
             * @param {luck.protobuf.IDailyTaskPB} message DailyTaskPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DailyTaskPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DailyTaskPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.DailyTaskPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.DailyTaskPB} DailyTaskPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DailyTaskPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.DailyTaskPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.dailyTaskId = reader.int32();
                        break;
                    case 2:
                        message.condition = $root.luck.protobuf.TaskConditionPB.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.bGain = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("dailyTaskId"))
                    throw $util.ProtocolError("missing required 'dailyTaskId'", { instance: message });
                if (!message.hasOwnProperty("condition"))
                    throw $util.ProtocolError("missing required 'condition'", { instance: message });
                if (!message.hasOwnProperty("bGain"))
                    throw $util.ProtocolError("missing required 'bGain'", { instance: message });
                return message;
            };

            /**
             * Decodes a DailyTaskPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.DailyTaskPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.DailyTaskPB} DailyTaskPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DailyTaskPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DailyTaskPB message.
             * @function verify
             * @memberof luck.protobuf.DailyTaskPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DailyTaskPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.dailyTaskId))
                    return "dailyTaskId: integer expected";
                {
                    var error = $root.luck.protobuf.TaskConditionPB.verify(message.condition);
                    if (error)
                        return "condition." + error;
                }
                if (typeof message.bGain !== "boolean")
                    return "bGain: boolean expected";
                return null;
            };

            return DailyTaskPB;
        })();

        protobuf.WeekTaskPB = (function() {

            /**
             * Properties of a WeekTaskPB.
             * @memberof luck.protobuf
             * @interface IWeekTaskPB
             * @property {number} weekTaskId WeekTaskPB weekTaskId
             * @property {luck.protobuf.ITaskConditionPB} condition WeekTaskPB condition
             * @property {boolean} bGain WeekTaskPB bGain
             */

            /**
             * Constructs a new WeekTaskPB.
             * @memberof luck.protobuf
             * @classdesc Represents a WeekTaskPB.
             * @implements IWeekTaskPB
             * @constructor
             * @param {luck.protobuf.IWeekTaskPB=} [properties] Properties to set
             */
            function WeekTaskPB(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WeekTaskPB weekTaskId.
             * @member {number} weekTaskId
             * @memberof luck.protobuf.WeekTaskPB
             * @instance
             */
            WeekTaskPB.prototype.weekTaskId = 0;

            /**
             * WeekTaskPB condition.
             * @member {luck.protobuf.ITaskConditionPB} condition
             * @memberof luck.protobuf.WeekTaskPB
             * @instance
             */
            WeekTaskPB.prototype.condition = null;

            /**
             * WeekTaskPB bGain.
             * @member {boolean} bGain
             * @memberof luck.protobuf.WeekTaskPB
             * @instance
             */
            WeekTaskPB.prototype.bGain = false;

            /**
             * Creates a new WeekTaskPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.WeekTaskPB
             * @static
             * @param {luck.protobuf.IWeekTaskPB=} [properties] Properties to set
             * @returns {luck.protobuf.WeekTaskPB} WeekTaskPB instance
             */
            WeekTaskPB.create = function create(properties) {
                return new WeekTaskPB(properties);
            };

            /**
             * Encodes the specified WeekTaskPB message. Does not implicitly {@link luck.protobuf.WeekTaskPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.WeekTaskPB
             * @static
             * @param {luck.protobuf.IWeekTaskPB} message WeekTaskPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WeekTaskPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.weekTaskId);
                $root.luck.protobuf.TaskConditionPB.encode(message.condition, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.bGain);
                return writer;
            };

            /**
             * Encodes the specified WeekTaskPB message, length delimited. Does not implicitly {@link luck.protobuf.WeekTaskPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.WeekTaskPB
             * @static
             * @param {luck.protobuf.IWeekTaskPB} message WeekTaskPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WeekTaskPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WeekTaskPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.WeekTaskPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.WeekTaskPB} WeekTaskPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WeekTaskPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.WeekTaskPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.weekTaskId = reader.int32();
                        break;
                    case 2:
                        message.condition = $root.luck.protobuf.TaskConditionPB.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.bGain = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("weekTaskId"))
                    throw $util.ProtocolError("missing required 'weekTaskId'", { instance: message });
                if (!message.hasOwnProperty("condition"))
                    throw $util.ProtocolError("missing required 'condition'", { instance: message });
                if (!message.hasOwnProperty("bGain"))
                    throw $util.ProtocolError("missing required 'bGain'", { instance: message });
                return message;
            };

            /**
             * Decodes a WeekTaskPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.WeekTaskPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.WeekTaskPB} WeekTaskPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WeekTaskPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WeekTaskPB message.
             * @function verify
             * @memberof luck.protobuf.WeekTaskPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WeekTaskPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.weekTaskId))
                    return "weekTaskId: integer expected";
                {
                    var error = $root.luck.protobuf.TaskConditionPB.verify(message.condition);
                    if (error)
                        return "condition." + error;
                }
                if (typeof message.bGain !== "boolean")
                    return "bGain: boolean expected";
                return null;
            };

            return WeekTaskPB;
        })();

        protobuf.RewardTaskPB = (function() {

            /**
             * Properties of a RewardTaskPB.
             * @memberof luck.protobuf
             * @interface IRewardTaskPB
             * @property {number} rewardTaskId RewardTaskPB rewardTaskId
             * @property {luck.protobuf.ITaskConditionPB} condition RewardTaskPB condition
             * @property {boolean} bGain RewardTaskPB bGain
             * @property {number|Long} startTime RewardTaskPB startTime
             */

            /**
             * Constructs a new RewardTaskPB.
             * @memberof luck.protobuf
             * @classdesc Represents a RewardTaskPB.
             * @implements IRewardTaskPB
             * @constructor
             * @param {luck.protobuf.IRewardTaskPB=} [properties] Properties to set
             */
            function RewardTaskPB(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RewardTaskPB rewardTaskId.
             * @member {number} rewardTaskId
             * @memberof luck.protobuf.RewardTaskPB
             * @instance
             */
            RewardTaskPB.prototype.rewardTaskId = 0;

            /**
             * RewardTaskPB condition.
             * @member {luck.protobuf.ITaskConditionPB} condition
             * @memberof luck.protobuf.RewardTaskPB
             * @instance
             */
            RewardTaskPB.prototype.condition = null;

            /**
             * RewardTaskPB bGain.
             * @member {boolean} bGain
             * @memberof luck.protobuf.RewardTaskPB
             * @instance
             */
            RewardTaskPB.prototype.bGain = false;

            /**
             * RewardTaskPB startTime.
             * @member {number|Long} startTime
             * @memberof luck.protobuf.RewardTaskPB
             * @instance
             */
            RewardTaskPB.prototype.startTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new RewardTaskPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.RewardTaskPB
             * @static
             * @param {luck.protobuf.IRewardTaskPB=} [properties] Properties to set
             * @returns {luck.protobuf.RewardTaskPB} RewardTaskPB instance
             */
            RewardTaskPB.create = function create(properties) {
                return new RewardTaskPB(properties);
            };

            /**
             * Encodes the specified RewardTaskPB message. Does not implicitly {@link luck.protobuf.RewardTaskPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.RewardTaskPB
             * @static
             * @param {luck.protobuf.IRewardTaskPB} message RewardTaskPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RewardTaskPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.rewardTaskId);
                $root.luck.protobuf.TaskConditionPB.encode(message.condition, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.bGain);
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.startTime);
                return writer;
            };

            /**
             * Encodes the specified RewardTaskPB message, length delimited. Does not implicitly {@link luck.protobuf.RewardTaskPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.RewardTaskPB
             * @static
             * @param {luck.protobuf.IRewardTaskPB} message RewardTaskPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RewardTaskPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RewardTaskPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.RewardTaskPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.RewardTaskPB} RewardTaskPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RewardTaskPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.RewardTaskPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.rewardTaskId = reader.int32();
                        break;
                    case 2:
                        message.condition = $root.luck.protobuf.TaskConditionPB.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.bGain = reader.bool();
                        break;
                    case 4:
                        message.startTime = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("rewardTaskId"))
                    throw $util.ProtocolError("missing required 'rewardTaskId'", { instance: message });
                if (!message.hasOwnProperty("condition"))
                    throw $util.ProtocolError("missing required 'condition'", { instance: message });
                if (!message.hasOwnProperty("bGain"))
                    throw $util.ProtocolError("missing required 'bGain'", { instance: message });
                if (!message.hasOwnProperty("startTime"))
                    throw $util.ProtocolError("missing required 'startTime'", { instance: message });
                return message;
            };

            /**
             * Decodes a RewardTaskPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.RewardTaskPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.RewardTaskPB} RewardTaskPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RewardTaskPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RewardTaskPB message.
             * @function verify
             * @memberof luck.protobuf.RewardTaskPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RewardTaskPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.rewardTaskId))
                    return "rewardTaskId: integer expected";
                {
                    var error = $root.luck.protobuf.TaskConditionPB.verify(message.condition);
                    if (error)
                        return "condition." + error;
                }
                if (typeof message.bGain !== "boolean")
                    return "bGain: boolean expected";
                if (!$util.isInteger(message.startTime) && !(message.startTime && $util.isInteger(message.startTime.low) && $util.isInteger(message.startTime.high)))
                    return "startTime: integer|Long expected";
                return null;
            };

            return RewardTaskPB;
        })();

        protobuf.AchievementTaskPB = (function() {

            /**
             * Properties of an AchievementTaskPB.
             * @memberof luck.protobuf
             * @interface IAchievementTaskPB
             * @property {number} achievementTaskId AchievementTaskPB achievementTaskId
             * @property {luck.protobuf.ITaskConditionPB} condition AchievementTaskPB condition
             * @property {boolean} bGain AchievementTaskPB bGain
             */

            /**
             * Constructs a new AchievementTaskPB.
             * @memberof luck.protobuf
             * @classdesc Represents an AchievementTaskPB.
             * @implements IAchievementTaskPB
             * @constructor
             * @param {luck.protobuf.IAchievementTaskPB=} [properties] Properties to set
             */
            function AchievementTaskPB(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AchievementTaskPB achievementTaskId.
             * @member {number} achievementTaskId
             * @memberof luck.protobuf.AchievementTaskPB
             * @instance
             */
            AchievementTaskPB.prototype.achievementTaskId = 0;

            /**
             * AchievementTaskPB condition.
             * @member {luck.protobuf.ITaskConditionPB} condition
             * @memberof luck.protobuf.AchievementTaskPB
             * @instance
             */
            AchievementTaskPB.prototype.condition = null;

            /**
             * AchievementTaskPB bGain.
             * @member {boolean} bGain
             * @memberof luck.protobuf.AchievementTaskPB
             * @instance
             */
            AchievementTaskPB.prototype.bGain = false;

            /**
             * Creates a new AchievementTaskPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.AchievementTaskPB
             * @static
             * @param {luck.protobuf.IAchievementTaskPB=} [properties] Properties to set
             * @returns {luck.protobuf.AchievementTaskPB} AchievementTaskPB instance
             */
            AchievementTaskPB.create = function create(properties) {
                return new AchievementTaskPB(properties);
            };

            /**
             * Encodes the specified AchievementTaskPB message. Does not implicitly {@link luck.protobuf.AchievementTaskPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.AchievementTaskPB
             * @static
             * @param {luck.protobuf.IAchievementTaskPB} message AchievementTaskPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AchievementTaskPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.achievementTaskId);
                $root.luck.protobuf.TaskConditionPB.encode(message.condition, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.bGain);
                return writer;
            };

            /**
             * Encodes the specified AchievementTaskPB message, length delimited. Does not implicitly {@link luck.protobuf.AchievementTaskPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.AchievementTaskPB
             * @static
             * @param {luck.protobuf.IAchievementTaskPB} message AchievementTaskPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AchievementTaskPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AchievementTaskPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.AchievementTaskPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.AchievementTaskPB} AchievementTaskPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AchievementTaskPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.AchievementTaskPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.achievementTaskId = reader.int32();
                        break;
                    case 2:
                        message.condition = $root.luck.protobuf.TaskConditionPB.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.bGain = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("achievementTaskId"))
                    throw $util.ProtocolError("missing required 'achievementTaskId'", { instance: message });
                if (!message.hasOwnProperty("condition"))
                    throw $util.ProtocolError("missing required 'condition'", { instance: message });
                if (!message.hasOwnProperty("bGain"))
                    throw $util.ProtocolError("missing required 'bGain'", { instance: message });
                return message;
            };

            /**
             * Decodes an AchievementTaskPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.AchievementTaskPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.AchievementTaskPB} AchievementTaskPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AchievementTaskPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AchievementTaskPB message.
             * @function verify
             * @memberof luck.protobuf.AchievementTaskPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AchievementTaskPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.achievementTaskId))
                    return "achievementTaskId: integer expected";
                {
                    var error = $root.luck.protobuf.TaskConditionPB.verify(message.condition);
                    if (error)
                        return "condition." + error;
                }
                if (typeof message.bGain !== "boolean")
                    return "bGain: boolean expected";
                return null;
            };

            return AchievementTaskPB;
        })();

        protobuf.AchievementTypePB = (function() {

            /**
             * Properties of an AchievementTypePB.
             * @memberof luck.protobuf
             * @interface IAchievementTypePB
             * @property {number} achievementTypeId AchievementTypePB achievementTypeId
             * @property {boolean} bFinish AchievementTypePB bFinish
             * @property {boolean} bGain AchievementTypePB bGain
             */

            /**
             * Constructs a new AchievementTypePB.
             * @memberof luck.protobuf
             * @classdesc Represents an AchievementTypePB.
             * @implements IAchievementTypePB
             * @constructor
             * @param {luck.protobuf.IAchievementTypePB=} [properties] Properties to set
             */
            function AchievementTypePB(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AchievementTypePB achievementTypeId.
             * @member {number} achievementTypeId
             * @memberof luck.protobuf.AchievementTypePB
             * @instance
             */
            AchievementTypePB.prototype.achievementTypeId = 0;

            /**
             * AchievementTypePB bFinish.
             * @member {boolean} bFinish
             * @memberof luck.protobuf.AchievementTypePB
             * @instance
             */
            AchievementTypePB.prototype.bFinish = false;

            /**
             * AchievementTypePB bGain.
             * @member {boolean} bGain
             * @memberof luck.protobuf.AchievementTypePB
             * @instance
             */
            AchievementTypePB.prototype.bGain = false;

            /**
             * Creates a new AchievementTypePB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.AchievementTypePB
             * @static
             * @param {luck.protobuf.IAchievementTypePB=} [properties] Properties to set
             * @returns {luck.protobuf.AchievementTypePB} AchievementTypePB instance
             */
            AchievementTypePB.create = function create(properties) {
                return new AchievementTypePB(properties);
            };

            /**
             * Encodes the specified AchievementTypePB message. Does not implicitly {@link luck.protobuf.AchievementTypePB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.AchievementTypePB
             * @static
             * @param {luck.protobuf.IAchievementTypePB} message AchievementTypePB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AchievementTypePB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.achievementTypeId);
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.bFinish);
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.bGain);
                return writer;
            };

            /**
             * Encodes the specified AchievementTypePB message, length delimited. Does not implicitly {@link luck.protobuf.AchievementTypePB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.AchievementTypePB
             * @static
             * @param {luck.protobuf.IAchievementTypePB} message AchievementTypePB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AchievementTypePB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AchievementTypePB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.AchievementTypePB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.AchievementTypePB} AchievementTypePB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AchievementTypePB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.AchievementTypePB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.achievementTypeId = reader.int32();
                        break;
                    case 2:
                        message.bFinish = reader.bool();
                        break;
                    case 3:
                        message.bGain = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("achievementTypeId"))
                    throw $util.ProtocolError("missing required 'achievementTypeId'", { instance: message });
                if (!message.hasOwnProperty("bFinish"))
                    throw $util.ProtocolError("missing required 'bFinish'", { instance: message });
                if (!message.hasOwnProperty("bGain"))
                    throw $util.ProtocolError("missing required 'bGain'", { instance: message });
                return message;
            };

            /**
             * Decodes an AchievementTypePB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.AchievementTypePB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.AchievementTypePB} AchievementTypePB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AchievementTypePB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AchievementTypePB message.
             * @function verify
             * @memberof luck.protobuf.AchievementTypePB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AchievementTypePB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.achievementTypeId))
                    return "achievementTypeId: integer expected";
                if (typeof message.bFinish !== "boolean")
                    return "bFinish: boolean expected";
                if (typeof message.bGain !== "boolean")
                    return "bGain: boolean expected";
                return null;
            };

            return AchievementTypePB;
        })();

        protobuf.PVETeamPB = (function() {

            /**
             * Properties of a PVETeamPB.
             * @memberof luck.protobuf
             * @interface IPVETeamPB
             * @property {number|Long} teamId PVETeamPB teamId
             * @property {number|Long} leaderId PVETeamPB leaderId
             * @property {Array.<luck.protobuf.IPVETeamMemberPB>|null} [memberList] PVETeamPB memberList
             * @property {number} customsType PVETeamPB customsType
             * @property {number} customsId PVETeamPB customsId
             * @property {boolean} start PVETeamPB start
             * @property {Array.<number|Long>|null} [joinApply] PVETeamPB joinApply
             */

            /**
             * Constructs a new PVETeamPB.
             * @memberof luck.protobuf
             * @classdesc Represents a PVETeamPB.
             * @implements IPVETeamPB
             * @constructor
             * @param {luck.protobuf.IPVETeamPB=} [properties] Properties to set
             */
            function PVETeamPB(properties) {
                this.memberList = [];
                this.joinApply = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PVETeamPB teamId.
             * @member {number|Long} teamId
             * @memberof luck.protobuf.PVETeamPB
             * @instance
             */
            PVETeamPB.prototype.teamId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PVETeamPB leaderId.
             * @member {number|Long} leaderId
             * @memberof luck.protobuf.PVETeamPB
             * @instance
             */
            PVETeamPB.prototype.leaderId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PVETeamPB memberList.
             * @member {Array.<luck.protobuf.IPVETeamMemberPB>} memberList
             * @memberof luck.protobuf.PVETeamPB
             * @instance
             */
            PVETeamPB.prototype.memberList = $util.emptyArray;

            /**
             * PVETeamPB customsType.
             * @member {number} customsType
             * @memberof luck.protobuf.PVETeamPB
             * @instance
             */
            PVETeamPB.prototype.customsType = 0;

            /**
             * PVETeamPB customsId.
             * @member {number} customsId
             * @memberof luck.protobuf.PVETeamPB
             * @instance
             */
            PVETeamPB.prototype.customsId = 0;

            /**
             * PVETeamPB start.
             * @member {boolean} start
             * @memberof luck.protobuf.PVETeamPB
             * @instance
             */
            PVETeamPB.prototype.start = false;

            /**
             * PVETeamPB joinApply.
             * @member {Array.<number|Long>} joinApply
             * @memberof luck.protobuf.PVETeamPB
             * @instance
             */
            PVETeamPB.prototype.joinApply = $util.emptyArray;

            /**
             * Creates a new PVETeamPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.PVETeamPB
             * @static
             * @param {luck.protobuf.IPVETeamPB=} [properties] Properties to set
             * @returns {luck.protobuf.PVETeamPB} PVETeamPB instance
             */
            PVETeamPB.create = function create(properties) {
                return new PVETeamPB(properties);
            };

            /**
             * Encodes the specified PVETeamPB message. Does not implicitly {@link luck.protobuf.PVETeamPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.PVETeamPB
             * @static
             * @param {luck.protobuf.IPVETeamPB} message PVETeamPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PVETeamPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.teamId);
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.leaderId);
                if (message.memberList != null && message.memberList.length)
                    for (var i = 0; i < message.memberList.length; ++i)
                        $root.luck.protobuf.PVETeamMemberPB.encode(message.memberList[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.customsType);
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.customsId);
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.start);
                if (message.joinApply != null && message.joinApply.length)
                    for (var i = 0; i < message.joinApply.length; ++i)
                        writer.uint32(/* id 7, wireType 0 =*/56).int64(message.joinApply[i]);
                return writer;
            };

            /**
             * Encodes the specified PVETeamPB message, length delimited. Does not implicitly {@link luck.protobuf.PVETeamPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.PVETeamPB
             * @static
             * @param {luck.protobuf.IPVETeamPB} message PVETeamPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PVETeamPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PVETeamPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.PVETeamPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.PVETeamPB} PVETeamPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PVETeamPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.PVETeamPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.teamId = reader.int64();
                        break;
                    case 2:
                        message.leaderId = reader.int64();
                        break;
                    case 3:
                        if (!(message.memberList && message.memberList.length))
                            message.memberList = [];
                        message.memberList.push($root.luck.protobuf.PVETeamMemberPB.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        message.customsType = reader.int32();
                        break;
                    case 5:
                        message.customsId = reader.int32();
                        break;
                    case 6:
                        message.start = reader.bool();
                        break;
                    case 7:
                        if (!(message.joinApply && message.joinApply.length))
                            message.joinApply = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.joinApply.push(reader.int64());
                        } else
                            message.joinApply.push(reader.int64());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("teamId"))
                    throw $util.ProtocolError("missing required 'teamId'", { instance: message });
                if (!message.hasOwnProperty("leaderId"))
                    throw $util.ProtocolError("missing required 'leaderId'", { instance: message });
                if (!message.hasOwnProperty("customsType"))
                    throw $util.ProtocolError("missing required 'customsType'", { instance: message });
                if (!message.hasOwnProperty("customsId"))
                    throw $util.ProtocolError("missing required 'customsId'", { instance: message });
                if (!message.hasOwnProperty("start"))
                    throw $util.ProtocolError("missing required 'start'", { instance: message });
                return message;
            };

            /**
             * Decodes a PVETeamPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.PVETeamPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.PVETeamPB} PVETeamPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PVETeamPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PVETeamPB message.
             * @function verify
             * @memberof luck.protobuf.PVETeamPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PVETeamPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.teamId) && !(message.teamId && $util.isInteger(message.teamId.low) && $util.isInteger(message.teamId.high)))
                    return "teamId: integer|Long expected";
                if (!$util.isInteger(message.leaderId) && !(message.leaderId && $util.isInteger(message.leaderId.low) && $util.isInteger(message.leaderId.high)))
                    return "leaderId: integer|Long expected";
                if (message.memberList != null && message.hasOwnProperty("memberList")) {
                    if (!Array.isArray(message.memberList))
                        return "memberList: array expected";
                    for (var i = 0; i < message.memberList.length; ++i) {
                        var error = $root.luck.protobuf.PVETeamMemberPB.verify(message.memberList[i]);
                        if (error)
                            return "memberList." + error;
                    }
                }
                if (!$util.isInteger(message.customsType))
                    return "customsType: integer expected";
                if (!$util.isInteger(message.customsId))
                    return "customsId: integer expected";
                if (typeof message.start !== "boolean")
                    return "start: boolean expected";
                if (message.joinApply != null && message.hasOwnProperty("joinApply")) {
                    if (!Array.isArray(message.joinApply))
                        return "joinApply: array expected";
                    for (var i = 0; i < message.joinApply.length; ++i)
                        if (!$util.isInteger(message.joinApply[i]) && !(message.joinApply[i] && $util.isInteger(message.joinApply[i].low) && $util.isInteger(message.joinApply[i].high)))
                            return "joinApply: integer|Long[] expected";
                }
                return null;
            };

            return PVETeamPB;
        })();

        protobuf.PVETeamMemberPB = (function() {

            /**
             * Properties of a PVETeamMemberPB.
             * @memberof luck.protobuf
             * @interface IPVETeamMemberPB
             * @property {number|Long} memberId PVETeamMemberPB memberId
             * @property {boolean} prepare PVETeamMemberPB prepare
             */

            /**
             * Constructs a new PVETeamMemberPB.
             * @memberof luck.protobuf
             * @classdesc Represents a PVETeamMemberPB.
             * @implements IPVETeamMemberPB
             * @constructor
             * @param {luck.protobuf.IPVETeamMemberPB=} [properties] Properties to set
             */
            function PVETeamMemberPB(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PVETeamMemberPB memberId.
             * @member {number|Long} memberId
             * @memberof luck.protobuf.PVETeamMemberPB
             * @instance
             */
            PVETeamMemberPB.prototype.memberId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PVETeamMemberPB prepare.
             * @member {boolean} prepare
             * @memberof luck.protobuf.PVETeamMemberPB
             * @instance
             */
            PVETeamMemberPB.prototype.prepare = false;

            /**
             * Creates a new PVETeamMemberPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.PVETeamMemberPB
             * @static
             * @param {luck.protobuf.IPVETeamMemberPB=} [properties] Properties to set
             * @returns {luck.protobuf.PVETeamMemberPB} PVETeamMemberPB instance
             */
            PVETeamMemberPB.create = function create(properties) {
                return new PVETeamMemberPB(properties);
            };

            /**
             * Encodes the specified PVETeamMemberPB message. Does not implicitly {@link luck.protobuf.PVETeamMemberPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.PVETeamMemberPB
             * @static
             * @param {luck.protobuf.IPVETeamMemberPB} message PVETeamMemberPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PVETeamMemberPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.memberId);
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.prepare);
                return writer;
            };

            /**
             * Encodes the specified PVETeamMemberPB message, length delimited. Does not implicitly {@link luck.protobuf.PVETeamMemberPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.PVETeamMemberPB
             * @static
             * @param {luck.protobuf.IPVETeamMemberPB} message PVETeamMemberPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PVETeamMemberPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PVETeamMemberPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.PVETeamMemberPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.PVETeamMemberPB} PVETeamMemberPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PVETeamMemberPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.PVETeamMemberPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.memberId = reader.int64();
                        break;
                    case 2:
                        message.prepare = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("memberId"))
                    throw $util.ProtocolError("missing required 'memberId'", { instance: message });
                if (!message.hasOwnProperty("prepare"))
                    throw $util.ProtocolError("missing required 'prepare'", { instance: message });
                return message;
            };

            /**
             * Decodes a PVETeamMemberPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.PVETeamMemberPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.PVETeamMemberPB} PVETeamMemberPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PVETeamMemberPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PVETeamMemberPB message.
             * @function verify
             * @memberof luck.protobuf.PVETeamMemberPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PVETeamMemberPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.memberId) && !(message.memberId && $util.isInteger(message.memberId.low) && $util.isInteger(message.memberId.high)))
                    return "memberId: integer|Long expected";
                if (typeof message.prepare !== "boolean")
                    return "prepare: boolean expected";
                return null;
            };

            return PVETeamMemberPB;
        })();

        protobuf.GangTaskPB = (function() {

            /**
             * Properties of a GangTaskPB.
             * @memberof luck.protobuf
             * @interface IGangTaskPB
             * @property {number} gangTaskId GangTaskPB gangTaskId
             * @property {luck.protobuf.ITaskConditionPB} condition GangTaskPB condition
             * @property {boolean} bGain GangTaskPB bGain
             */

            /**
             * Constructs a new GangTaskPB.
             * @memberof luck.protobuf
             * @classdesc Represents a GangTaskPB.
             * @implements IGangTaskPB
             * @constructor
             * @param {luck.protobuf.IGangTaskPB=} [properties] Properties to set
             */
            function GangTaskPB(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GangTaskPB gangTaskId.
             * @member {number} gangTaskId
             * @memberof luck.protobuf.GangTaskPB
             * @instance
             */
            GangTaskPB.prototype.gangTaskId = 0;

            /**
             * GangTaskPB condition.
             * @member {luck.protobuf.ITaskConditionPB} condition
             * @memberof luck.protobuf.GangTaskPB
             * @instance
             */
            GangTaskPB.prototype.condition = null;

            /**
             * GangTaskPB bGain.
             * @member {boolean} bGain
             * @memberof luck.protobuf.GangTaskPB
             * @instance
             */
            GangTaskPB.prototype.bGain = false;

            /**
             * Creates a new GangTaskPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.GangTaskPB
             * @static
             * @param {luck.protobuf.IGangTaskPB=} [properties] Properties to set
             * @returns {luck.protobuf.GangTaskPB} GangTaskPB instance
             */
            GangTaskPB.create = function create(properties) {
                return new GangTaskPB(properties);
            };

            /**
             * Encodes the specified GangTaskPB message. Does not implicitly {@link luck.protobuf.GangTaskPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.GangTaskPB
             * @static
             * @param {luck.protobuf.IGangTaskPB} message GangTaskPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GangTaskPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.gangTaskId);
                $root.luck.protobuf.TaskConditionPB.encode(message.condition, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.bGain);
                return writer;
            };

            /**
             * Encodes the specified GangTaskPB message, length delimited. Does not implicitly {@link luck.protobuf.GangTaskPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.GangTaskPB
             * @static
             * @param {luck.protobuf.IGangTaskPB} message GangTaskPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GangTaskPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GangTaskPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.GangTaskPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.GangTaskPB} GangTaskPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GangTaskPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.GangTaskPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.gangTaskId = reader.int32();
                        break;
                    case 2:
                        message.condition = $root.luck.protobuf.TaskConditionPB.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.bGain = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("gangTaskId"))
                    throw $util.ProtocolError("missing required 'gangTaskId'", { instance: message });
                if (!message.hasOwnProperty("condition"))
                    throw $util.ProtocolError("missing required 'condition'", { instance: message });
                if (!message.hasOwnProperty("bGain"))
                    throw $util.ProtocolError("missing required 'bGain'", { instance: message });
                return message;
            };

            /**
             * Decodes a GangTaskPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.GangTaskPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.GangTaskPB} GangTaskPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GangTaskPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GangTaskPB message.
             * @function verify
             * @memberof luck.protobuf.GangTaskPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GangTaskPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.gangTaskId))
                    return "gangTaskId: integer expected";
                {
                    var error = $root.luck.protobuf.TaskConditionPB.verify(message.condition);
                    if (error)
                        return "condition." + error;
                }
                if (typeof message.bGain !== "boolean")
                    return "bGain: boolean expected";
                return null;
            };

            return GangTaskPB;
        })();

        protobuf.sixStarEquipRankIngPB = (function() {

            /**
             * Properties of a sixStarEquipRankIngPB.
             * @memberof luck.protobuf
             * @interface IsixStarEquipRankIngPB
             * @property {number|Long} lv sixStarEquipRankIngPB lv
             * @property {number} sixStarEquipRank sixStarEquipRankIngPB sixStarEquipRank
             * @property {number|Long} roleId sixStarEquipRankIngPB roleId
             * @property {string} name sixStarEquipRankIngPB name
             * @property {number|Long} sixStarEquipNum sixStarEquipRankIngPB sixStarEquipNum
             * @property {string|null} [gangName] sixStarEquipRankIngPB gangName
             * @property {number|Long} weaponId sixStarEquipRankIngPB weaponId
             * @property {number|Long} clothesId sixStarEquipRankIngPB clothesId
             */

            /**
             * Constructs a new sixStarEquipRankIngPB.
             * @memberof luck.protobuf
             * @classdesc Represents a sixStarEquipRankIngPB.
             * @implements IsixStarEquipRankIngPB
             * @constructor
             * @param {luck.protobuf.IsixStarEquipRankIngPB=} [properties] Properties to set
             */
            function sixStarEquipRankIngPB(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * sixStarEquipRankIngPB lv.
             * @member {number|Long} lv
             * @memberof luck.protobuf.sixStarEquipRankIngPB
             * @instance
             */
            sixStarEquipRankIngPB.prototype.lv = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * sixStarEquipRankIngPB sixStarEquipRank.
             * @member {number} sixStarEquipRank
             * @memberof luck.protobuf.sixStarEquipRankIngPB
             * @instance
             */
            sixStarEquipRankIngPB.prototype.sixStarEquipRank = 0;

            /**
             * sixStarEquipRankIngPB roleId.
             * @member {number|Long} roleId
             * @memberof luck.protobuf.sixStarEquipRankIngPB
             * @instance
             */
            sixStarEquipRankIngPB.prototype.roleId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * sixStarEquipRankIngPB name.
             * @member {string} name
             * @memberof luck.protobuf.sixStarEquipRankIngPB
             * @instance
             */
            sixStarEquipRankIngPB.prototype.name = "";

            /**
             * sixStarEquipRankIngPB sixStarEquipNum.
             * @member {number|Long} sixStarEquipNum
             * @memberof luck.protobuf.sixStarEquipRankIngPB
             * @instance
             */
            sixStarEquipRankIngPB.prototype.sixStarEquipNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * sixStarEquipRankIngPB gangName.
             * @member {string} gangName
             * @memberof luck.protobuf.sixStarEquipRankIngPB
             * @instance
             */
            sixStarEquipRankIngPB.prototype.gangName = "";

            /**
             * sixStarEquipRankIngPB weaponId.
             * @member {number|Long} weaponId
             * @memberof luck.protobuf.sixStarEquipRankIngPB
             * @instance
             */
            sixStarEquipRankIngPB.prototype.weaponId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * sixStarEquipRankIngPB clothesId.
             * @member {number|Long} clothesId
             * @memberof luck.protobuf.sixStarEquipRankIngPB
             * @instance
             */
            sixStarEquipRankIngPB.prototype.clothesId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new sixStarEquipRankIngPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.sixStarEquipRankIngPB
             * @static
             * @param {luck.protobuf.IsixStarEquipRankIngPB=} [properties] Properties to set
             * @returns {luck.protobuf.sixStarEquipRankIngPB} sixStarEquipRankIngPB instance
             */
            sixStarEquipRankIngPB.create = function create(properties) {
                return new sixStarEquipRankIngPB(properties);
            };

            /**
             * Encodes the specified sixStarEquipRankIngPB message. Does not implicitly {@link luck.protobuf.sixStarEquipRankIngPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.sixStarEquipRankIngPB
             * @static
             * @param {luck.protobuf.IsixStarEquipRankIngPB} message sixStarEquipRankIngPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            sixStarEquipRankIngPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.lv);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.sixStarEquipRank);
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.roleId);
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.name);
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.sixStarEquipNum);
                if (message.gangName != null && message.hasOwnProperty("gangName"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.gangName);
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.weaponId);
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.clothesId);
                return writer;
            };

            /**
             * Encodes the specified sixStarEquipRankIngPB message, length delimited. Does not implicitly {@link luck.protobuf.sixStarEquipRankIngPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.sixStarEquipRankIngPB
             * @static
             * @param {luck.protobuf.IsixStarEquipRankIngPB} message sixStarEquipRankIngPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            sixStarEquipRankIngPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a sixStarEquipRankIngPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.sixStarEquipRankIngPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.sixStarEquipRankIngPB} sixStarEquipRankIngPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            sixStarEquipRankIngPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.sixStarEquipRankIngPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.lv = reader.int64();
                        break;
                    case 2:
                        message.sixStarEquipRank = reader.int32();
                        break;
                    case 3:
                        message.roleId = reader.int64();
                        break;
                    case 4:
                        message.name = reader.string();
                        break;
                    case 5:
                        message.sixStarEquipNum = reader.int64();
                        break;
                    case 6:
                        message.gangName = reader.string();
                        break;
                    case 7:
                        message.weaponId = reader.int64();
                        break;
                    case 8:
                        message.clothesId = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("lv"))
                    throw $util.ProtocolError("missing required 'lv'", { instance: message });
                if (!message.hasOwnProperty("sixStarEquipRank"))
                    throw $util.ProtocolError("missing required 'sixStarEquipRank'", { instance: message });
                if (!message.hasOwnProperty("roleId"))
                    throw $util.ProtocolError("missing required 'roleId'", { instance: message });
                if (!message.hasOwnProperty("name"))
                    throw $util.ProtocolError("missing required 'name'", { instance: message });
                if (!message.hasOwnProperty("sixStarEquipNum"))
                    throw $util.ProtocolError("missing required 'sixStarEquipNum'", { instance: message });
                if (!message.hasOwnProperty("weaponId"))
                    throw $util.ProtocolError("missing required 'weaponId'", { instance: message });
                if (!message.hasOwnProperty("clothesId"))
                    throw $util.ProtocolError("missing required 'clothesId'", { instance: message });
                return message;
            };

            /**
             * Decodes a sixStarEquipRankIngPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.sixStarEquipRankIngPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.sixStarEquipRankIngPB} sixStarEquipRankIngPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            sixStarEquipRankIngPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a sixStarEquipRankIngPB message.
             * @function verify
             * @memberof luck.protobuf.sixStarEquipRankIngPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            sixStarEquipRankIngPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.lv) && !(message.lv && $util.isInteger(message.lv.low) && $util.isInteger(message.lv.high)))
                    return "lv: integer|Long expected";
                if (!$util.isInteger(message.sixStarEquipRank))
                    return "sixStarEquipRank: integer expected";
                if (!$util.isInteger(message.roleId) && !(message.roleId && $util.isInteger(message.roleId.low) && $util.isInteger(message.roleId.high)))
                    return "roleId: integer|Long expected";
                if (!$util.isString(message.name))
                    return "name: string expected";
                if (!$util.isInteger(message.sixStarEquipNum) && !(message.sixStarEquipNum && $util.isInteger(message.sixStarEquipNum.low) && $util.isInteger(message.sixStarEquipNum.high)))
                    return "sixStarEquipNum: integer|Long expected";
                if (message.gangName != null && message.hasOwnProperty("gangName"))
                    if (!$util.isString(message.gangName))
                        return "gangName: string expected";
                if (!$util.isInteger(message.weaponId) && !(message.weaponId && $util.isInteger(message.weaponId.low) && $util.isInteger(message.weaponId.high)))
                    return "weaponId: integer|Long expected";
                if (!$util.isInteger(message.clothesId) && !(message.clothesId && $util.isInteger(message.clothesId.low) && $util.isInteger(message.clothesId.high)))
                    return "clothesId: integer|Long expected";
                return null;
            };

            return sixStarEquipRankIngPB;
        })();

        protobuf.fightingRankIngPB = (function() {

            /**
             * Properties of a fightingRankIngPB.
             * @memberof luck.protobuf
             * @interface IfightingRankIngPB
             * @property {number|Long} lv fightingRankIngPB lv
             * @property {number} fightingRank fightingRankIngPB fightingRank
             * @property {number|Long} roleId fightingRankIngPB roleId
             * @property {string} name fightingRankIngPB name
             * @property {number|Long} fighting fightingRankIngPB fighting
             * @property {string|null} [gangName] fightingRankIngPB gangName
             * @property {number|Long} weaponId fightingRankIngPB weaponId
             * @property {number|Long} clothesId fightingRankIngPB clothesId
             */

            /**
             * Constructs a new fightingRankIngPB.
             * @memberof luck.protobuf
             * @classdesc Represents a fightingRankIngPB.
             * @implements IfightingRankIngPB
             * @constructor
             * @param {luck.protobuf.IfightingRankIngPB=} [properties] Properties to set
             */
            function fightingRankIngPB(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * fightingRankIngPB lv.
             * @member {number|Long} lv
             * @memberof luck.protobuf.fightingRankIngPB
             * @instance
             */
            fightingRankIngPB.prototype.lv = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * fightingRankIngPB fightingRank.
             * @member {number} fightingRank
             * @memberof luck.protobuf.fightingRankIngPB
             * @instance
             */
            fightingRankIngPB.prototype.fightingRank = 0;

            /**
             * fightingRankIngPB roleId.
             * @member {number|Long} roleId
             * @memberof luck.protobuf.fightingRankIngPB
             * @instance
             */
            fightingRankIngPB.prototype.roleId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * fightingRankIngPB name.
             * @member {string} name
             * @memberof luck.protobuf.fightingRankIngPB
             * @instance
             */
            fightingRankIngPB.prototype.name = "";

            /**
             * fightingRankIngPB fighting.
             * @member {number|Long} fighting
             * @memberof luck.protobuf.fightingRankIngPB
             * @instance
             */
            fightingRankIngPB.prototype.fighting = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * fightingRankIngPB gangName.
             * @member {string} gangName
             * @memberof luck.protobuf.fightingRankIngPB
             * @instance
             */
            fightingRankIngPB.prototype.gangName = "";

            /**
             * fightingRankIngPB weaponId.
             * @member {number|Long} weaponId
             * @memberof luck.protobuf.fightingRankIngPB
             * @instance
             */
            fightingRankIngPB.prototype.weaponId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * fightingRankIngPB clothesId.
             * @member {number|Long} clothesId
             * @memberof luck.protobuf.fightingRankIngPB
             * @instance
             */
            fightingRankIngPB.prototype.clothesId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new fightingRankIngPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.fightingRankIngPB
             * @static
             * @param {luck.protobuf.IfightingRankIngPB=} [properties] Properties to set
             * @returns {luck.protobuf.fightingRankIngPB} fightingRankIngPB instance
             */
            fightingRankIngPB.create = function create(properties) {
                return new fightingRankIngPB(properties);
            };

            /**
             * Encodes the specified fightingRankIngPB message. Does not implicitly {@link luck.protobuf.fightingRankIngPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.fightingRankIngPB
             * @static
             * @param {luck.protobuf.IfightingRankIngPB} message fightingRankIngPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            fightingRankIngPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.lv);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.fightingRank);
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.roleId);
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.name);
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.fighting);
                if (message.gangName != null && message.hasOwnProperty("gangName"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.gangName);
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.weaponId);
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.clothesId);
                return writer;
            };

            /**
             * Encodes the specified fightingRankIngPB message, length delimited. Does not implicitly {@link luck.protobuf.fightingRankIngPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.fightingRankIngPB
             * @static
             * @param {luck.protobuf.IfightingRankIngPB} message fightingRankIngPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            fightingRankIngPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a fightingRankIngPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.fightingRankIngPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.fightingRankIngPB} fightingRankIngPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            fightingRankIngPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.fightingRankIngPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.lv = reader.int64();
                        break;
                    case 2:
                        message.fightingRank = reader.int32();
                        break;
                    case 3:
                        message.roleId = reader.int64();
                        break;
                    case 4:
                        message.name = reader.string();
                        break;
                    case 5:
                        message.fighting = reader.int64();
                        break;
                    case 6:
                        message.gangName = reader.string();
                        break;
                    case 7:
                        message.weaponId = reader.int64();
                        break;
                    case 8:
                        message.clothesId = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("lv"))
                    throw $util.ProtocolError("missing required 'lv'", { instance: message });
                if (!message.hasOwnProperty("fightingRank"))
                    throw $util.ProtocolError("missing required 'fightingRank'", { instance: message });
                if (!message.hasOwnProperty("roleId"))
                    throw $util.ProtocolError("missing required 'roleId'", { instance: message });
                if (!message.hasOwnProperty("name"))
                    throw $util.ProtocolError("missing required 'name'", { instance: message });
                if (!message.hasOwnProperty("fighting"))
                    throw $util.ProtocolError("missing required 'fighting'", { instance: message });
                if (!message.hasOwnProperty("weaponId"))
                    throw $util.ProtocolError("missing required 'weaponId'", { instance: message });
                if (!message.hasOwnProperty("clothesId"))
                    throw $util.ProtocolError("missing required 'clothesId'", { instance: message });
                return message;
            };

            /**
             * Decodes a fightingRankIngPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.fightingRankIngPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.fightingRankIngPB} fightingRankIngPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            fightingRankIngPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a fightingRankIngPB message.
             * @function verify
             * @memberof luck.protobuf.fightingRankIngPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            fightingRankIngPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.lv) && !(message.lv && $util.isInteger(message.lv.low) && $util.isInteger(message.lv.high)))
                    return "lv: integer|Long expected";
                if (!$util.isInteger(message.fightingRank))
                    return "fightingRank: integer expected";
                if (!$util.isInteger(message.roleId) && !(message.roleId && $util.isInteger(message.roleId.low) && $util.isInteger(message.roleId.high)))
                    return "roleId: integer|Long expected";
                if (!$util.isString(message.name))
                    return "name: string expected";
                if (!$util.isInteger(message.fighting) && !(message.fighting && $util.isInteger(message.fighting.low) && $util.isInteger(message.fighting.high)))
                    return "fighting: integer|Long expected";
                if (message.gangName != null && message.hasOwnProperty("gangName"))
                    if (!$util.isString(message.gangName))
                        return "gangName: string expected";
                if (!$util.isInteger(message.weaponId) && !(message.weaponId && $util.isInteger(message.weaponId.low) && $util.isInteger(message.weaponId.high)))
                    return "weaponId: integer|Long expected";
                if (!$util.isInteger(message.clothesId) && !(message.clothesId && $util.isInteger(message.clothesId.low) && $util.isInteger(message.clothesId.high)))
                    return "clothesId: integer|Long expected";
                return null;
            };

            return fightingRankIngPB;
        })();

        protobuf.diamondConsumeRankIngPB = (function() {

            /**
             * Properties of a diamondConsumeRankIngPB.
             * @memberof luck.protobuf
             * @interface IdiamondConsumeRankIngPB
             * @property {number|Long} lv diamondConsumeRankIngPB lv
             * @property {number} diamondConsumeRank diamondConsumeRankIngPB diamondConsumeRank
             * @property {number|Long} roleId diamondConsumeRankIngPB roleId
             * @property {string} name diamondConsumeRankIngPB name
             * @property {number|Long} diamondConsumeNum diamondConsumeRankIngPB diamondConsumeNum
             * @property {string|null} [gangName] diamondConsumeRankIngPB gangName
             * @property {number|Long} weaponId diamondConsumeRankIngPB weaponId
             * @property {number|Long} clothesId diamondConsumeRankIngPB clothesId
             */

            /**
             * Constructs a new diamondConsumeRankIngPB.
             * @memberof luck.protobuf
             * @classdesc Represents a diamondConsumeRankIngPB.
             * @implements IdiamondConsumeRankIngPB
             * @constructor
             * @param {luck.protobuf.IdiamondConsumeRankIngPB=} [properties] Properties to set
             */
            function diamondConsumeRankIngPB(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * diamondConsumeRankIngPB lv.
             * @member {number|Long} lv
             * @memberof luck.protobuf.diamondConsumeRankIngPB
             * @instance
             */
            diamondConsumeRankIngPB.prototype.lv = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * diamondConsumeRankIngPB diamondConsumeRank.
             * @member {number} diamondConsumeRank
             * @memberof luck.protobuf.diamondConsumeRankIngPB
             * @instance
             */
            diamondConsumeRankIngPB.prototype.diamondConsumeRank = 0;

            /**
             * diamondConsumeRankIngPB roleId.
             * @member {number|Long} roleId
             * @memberof luck.protobuf.diamondConsumeRankIngPB
             * @instance
             */
            diamondConsumeRankIngPB.prototype.roleId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * diamondConsumeRankIngPB name.
             * @member {string} name
             * @memberof luck.protobuf.diamondConsumeRankIngPB
             * @instance
             */
            diamondConsumeRankIngPB.prototype.name = "";

            /**
             * diamondConsumeRankIngPB diamondConsumeNum.
             * @member {number|Long} diamondConsumeNum
             * @memberof luck.protobuf.diamondConsumeRankIngPB
             * @instance
             */
            diamondConsumeRankIngPB.prototype.diamondConsumeNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * diamondConsumeRankIngPB gangName.
             * @member {string} gangName
             * @memberof luck.protobuf.diamondConsumeRankIngPB
             * @instance
             */
            diamondConsumeRankIngPB.prototype.gangName = "";

            /**
             * diamondConsumeRankIngPB weaponId.
             * @member {number|Long} weaponId
             * @memberof luck.protobuf.diamondConsumeRankIngPB
             * @instance
             */
            diamondConsumeRankIngPB.prototype.weaponId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * diamondConsumeRankIngPB clothesId.
             * @member {number|Long} clothesId
             * @memberof luck.protobuf.diamondConsumeRankIngPB
             * @instance
             */
            diamondConsumeRankIngPB.prototype.clothesId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new diamondConsumeRankIngPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.diamondConsumeRankIngPB
             * @static
             * @param {luck.protobuf.IdiamondConsumeRankIngPB=} [properties] Properties to set
             * @returns {luck.protobuf.diamondConsumeRankIngPB} diamondConsumeRankIngPB instance
             */
            diamondConsumeRankIngPB.create = function create(properties) {
                return new diamondConsumeRankIngPB(properties);
            };

            /**
             * Encodes the specified diamondConsumeRankIngPB message. Does not implicitly {@link luck.protobuf.diamondConsumeRankIngPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.diamondConsumeRankIngPB
             * @static
             * @param {luck.protobuf.IdiamondConsumeRankIngPB} message diamondConsumeRankIngPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            diamondConsumeRankIngPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.lv);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.diamondConsumeRank);
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.roleId);
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.name);
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.diamondConsumeNum);
                if (message.gangName != null && message.hasOwnProperty("gangName"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.gangName);
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.weaponId);
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.clothesId);
                return writer;
            };

            /**
             * Encodes the specified diamondConsumeRankIngPB message, length delimited. Does not implicitly {@link luck.protobuf.diamondConsumeRankIngPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.diamondConsumeRankIngPB
             * @static
             * @param {luck.protobuf.IdiamondConsumeRankIngPB} message diamondConsumeRankIngPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            diamondConsumeRankIngPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a diamondConsumeRankIngPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.diamondConsumeRankIngPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.diamondConsumeRankIngPB} diamondConsumeRankIngPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            diamondConsumeRankIngPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.diamondConsumeRankIngPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.lv = reader.int64();
                        break;
                    case 2:
                        message.diamondConsumeRank = reader.int32();
                        break;
                    case 3:
                        message.roleId = reader.int64();
                        break;
                    case 4:
                        message.name = reader.string();
                        break;
                    case 5:
                        message.diamondConsumeNum = reader.int64();
                        break;
                    case 6:
                        message.gangName = reader.string();
                        break;
                    case 7:
                        message.weaponId = reader.int64();
                        break;
                    case 8:
                        message.clothesId = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("lv"))
                    throw $util.ProtocolError("missing required 'lv'", { instance: message });
                if (!message.hasOwnProperty("diamondConsumeRank"))
                    throw $util.ProtocolError("missing required 'diamondConsumeRank'", { instance: message });
                if (!message.hasOwnProperty("roleId"))
                    throw $util.ProtocolError("missing required 'roleId'", { instance: message });
                if (!message.hasOwnProperty("name"))
                    throw $util.ProtocolError("missing required 'name'", { instance: message });
                if (!message.hasOwnProperty("diamondConsumeNum"))
                    throw $util.ProtocolError("missing required 'diamondConsumeNum'", { instance: message });
                if (!message.hasOwnProperty("weaponId"))
                    throw $util.ProtocolError("missing required 'weaponId'", { instance: message });
                if (!message.hasOwnProperty("clothesId"))
                    throw $util.ProtocolError("missing required 'clothesId'", { instance: message });
                return message;
            };

            /**
             * Decodes a diamondConsumeRankIngPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.diamondConsumeRankIngPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.diamondConsumeRankIngPB} diamondConsumeRankIngPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            diamondConsumeRankIngPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a diamondConsumeRankIngPB message.
             * @function verify
             * @memberof luck.protobuf.diamondConsumeRankIngPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            diamondConsumeRankIngPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.lv) && !(message.lv && $util.isInteger(message.lv.low) && $util.isInteger(message.lv.high)))
                    return "lv: integer|Long expected";
                if (!$util.isInteger(message.diamondConsumeRank))
                    return "diamondConsumeRank: integer expected";
                if (!$util.isInteger(message.roleId) && !(message.roleId && $util.isInteger(message.roleId.low) && $util.isInteger(message.roleId.high)))
                    return "roleId: integer|Long expected";
                if (!$util.isString(message.name))
                    return "name: string expected";
                if (!$util.isInteger(message.diamondConsumeNum) && !(message.diamondConsumeNum && $util.isInteger(message.diamondConsumeNum.low) && $util.isInteger(message.diamondConsumeNum.high)))
                    return "diamondConsumeNum: integer|Long expected";
                if (message.gangName != null && message.hasOwnProperty("gangName"))
                    if (!$util.isString(message.gangName))
                        return "gangName: string expected";
                if (!$util.isInteger(message.weaponId) && !(message.weaponId && $util.isInteger(message.weaponId.low) && $util.isInteger(message.weaponId.high)))
                    return "weaponId: integer|Long expected";
                if (!$util.isInteger(message.clothesId) && !(message.clothesId && $util.isInteger(message.clothesId.low) && $util.isInteger(message.clothesId.high)))
                    return "clothesId: integer|Long expected";
                return null;
            };

            return diamondConsumeRankIngPB;
        })();

        protobuf.VipRewardPB = (function() {

            /**
             * Properties of a VipRewardPB.
             * @memberof luck.protobuf
             * @interface IVipRewardPB
             * @property {number} vipLv VipRewardPB vipLv
             * @property {boolean} bGain VipRewardPB bGain
             */

            /**
             * Constructs a new VipRewardPB.
             * @memberof luck.protobuf
             * @classdesc Represents a VipRewardPB.
             * @implements IVipRewardPB
             * @constructor
             * @param {luck.protobuf.IVipRewardPB=} [properties] Properties to set
             */
            function VipRewardPB(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * VipRewardPB vipLv.
             * @member {number} vipLv
             * @memberof luck.protobuf.VipRewardPB
             * @instance
             */
            VipRewardPB.prototype.vipLv = 0;

            /**
             * VipRewardPB bGain.
             * @member {boolean} bGain
             * @memberof luck.protobuf.VipRewardPB
             * @instance
             */
            VipRewardPB.prototype.bGain = false;

            /**
             * Creates a new VipRewardPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.VipRewardPB
             * @static
             * @param {luck.protobuf.IVipRewardPB=} [properties] Properties to set
             * @returns {luck.protobuf.VipRewardPB} VipRewardPB instance
             */
            VipRewardPB.create = function create(properties) {
                return new VipRewardPB(properties);
            };

            /**
             * Encodes the specified VipRewardPB message. Does not implicitly {@link luck.protobuf.VipRewardPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.VipRewardPB
             * @static
             * @param {luck.protobuf.IVipRewardPB} message VipRewardPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VipRewardPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.vipLv);
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.bGain);
                return writer;
            };

            /**
             * Encodes the specified VipRewardPB message, length delimited. Does not implicitly {@link luck.protobuf.VipRewardPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.VipRewardPB
             * @static
             * @param {luck.protobuf.IVipRewardPB} message VipRewardPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VipRewardPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a VipRewardPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.VipRewardPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.VipRewardPB} VipRewardPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VipRewardPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.VipRewardPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.vipLv = reader.int32();
                        break;
                    case 2:
                        message.bGain = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("vipLv"))
                    throw $util.ProtocolError("missing required 'vipLv'", { instance: message });
                if (!message.hasOwnProperty("bGain"))
                    throw $util.ProtocolError("missing required 'bGain'", { instance: message });
                return message;
            };

            /**
             * Decodes a VipRewardPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.VipRewardPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.VipRewardPB} VipRewardPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VipRewardPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a VipRewardPB message.
             * @function verify
             * @memberof luck.protobuf.VipRewardPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            VipRewardPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.vipLv))
                    return "vipLv: integer expected";
                if (typeof message.bGain !== "boolean")
                    return "bGain: boolean expected";
                return null;
            };

            return VipRewardPB;
        })();

        protobuf.MonthCardPB = (function() {

            /**
             * Properties of a MonthCardPB.
             * @memberof luck.protobuf
             * @interface IMonthCardPB
             * @property {number} monthCardId MonthCardPB monthCardId
             * @property {number} days MonthCardPB days
             * @property {number|Long} startTime MonthCardPB startTime
             * @property {boolean} beGain MonthCardPB beGain
             */

            /**
             * Constructs a new MonthCardPB.
             * @memberof luck.protobuf
             * @classdesc Represents a MonthCardPB.
             * @implements IMonthCardPB
             * @constructor
             * @param {luck.protobuf.IMonthCardPB=} [properties] Properties to set
             */
            function MonthCardPB(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MonthCardPB monthCardId.
             * @member {number} monthCardId
             * @memberof luck.protobuf.MonthCardPB
             * @instance
             */
            MonthCardPB.prototype.monthCardId = 0;

            /**
             * MonthCardPB days.
             * @member {number} days
             * @memberof luck.protobuf.MonthCardPB
             * @instance
             */
            MonthCardPB.prototype.days = 0;

            /**
             * MonthCardPB startTime.
             * @member {number|Long} startTime
             * @memberof luck.protobuf.MonthCardPB
             * @instance
             */
            MonthCardPB.prototype.startTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * MonthCardPB beGain.
             * @member {boolean} beGain
             * @memberof luck.protobuf.MonthCardPB
             * @instance
             */
            MonthCardPB.prototype.beGain = false;

            /**
             * Creates a new MonthCardPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.MonthCardPB
             * @static
             * @param {luck.protobuf.IMonthCardPB=} [properties] Properties to set
             * @returns {luck.protobuf.MonthCardPB} MonthCardPB instance
             */
            MonthCardPB.create = function create(properties) {
                return new MonthCardPB(properties);
            };

            /**
             * Encodes the specified MonthCardPB message. Does not implicitly {@link luck.protobuf.MonthCardPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.MonthCardPB
             * @static
             * @param {luck.protobuf.IMonthCardPB} message MonthCardPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MonthCardPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.monthCardId);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.days);
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.startTime);
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.beGain);
                return writer;
            };

            /**
             * Encodes the specified MonthCardPB message, length delimited. Does not implicitly {@link luck.protobuf.MonthCardPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.MonthCardPB
             * @static
             * @param {luck.protobuf.IMonthCardPB} message MonthCardPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MonthCardPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MonthCardPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.MonthCardPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.MonthCardPB} MonthCardPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MonthCardPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.MonthCardPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.monthCardId = reader.int32();
                        break;
                    case 2:
                        message.days = reader.int32();
                        break;
                    case 3:
                        message.startTime = reader.int64();
                        break;
                    case 4:
                        message.beGain = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("monthCardId"))
                    throw $util.ProtocolError("missing required 'monthCardId'", { instance: message });
                if (!message.hasOwnProperty("days"))
                    throw $util.ProtocolError("missing required 'days'", { instance: message });
                if (!message.hasOwnProperty("startTime"))
                    throw $util.ProtocolError("missing required 'startTime'", { instance: message });
                if (!message.hasOwnProperty("beGain"))
                    throw $util.ProtocolError("missing required 'beGain'", { instance: message });
                return message;
            };

            /**
             * Decodes a MonthCardPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.MonthCardPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.MonthCardPB} MonthCardPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MonthCardPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MonthCardPB message.
             * @function verify
             * @memberof luck.protobuf.MonthCardPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MonthCardPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.monthCardId))
                    return "monthCardId: integer expected";
                if (!$util.isInteger(message.days))
                    return "days: integer expected";
                if (!$util.isInteger(message.startTime) && !(message.startTime && $util.isInteger(message.startTime.low) && $util.isInteger(message.startTime.high)))
                    return "startTime: integer|Long expected";
                if (typeof message.beGain !== "boolean")
                    return "beGain: boolean expected";
                return null;
            };

            return MonthCardPB;
        })();

        protobuf.NoticePB = (function() {

            /**
             * Properties of a NoticePB.
             * @memberof luck.protobuf
             * @interface INoticePB
             * @property {number} noticeId NoticePB noticeId
             * @property {string} title NoticePB title
             * @property {string} context NoticePB context
             */

            /**
             * Constructs a new NoticePB.
             * @memberof luck.protobuf
             * @classdesc Represents a NoticePB.
             * @implements INoticePB
             * @constructor
             * @param {luck.protobuf.INoticePB=} [properties] Properties to set
             */
            function NoticePB(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NoticePB noticeId.
             * @member {number} noticeId
             * @memberof luck.protobuf.NoticePB
             * @instance
             */
            NoticePB.prototype.noticeId = 0;

            /**
             * NoticePB title.
             * @member {string} title
             * @memberof luck.protobuf.NoticePB
             * @instance
             */
            NoticePB.prototype.title = "";

            /**
             * NoticePB context.
             * @member {string} context
             * @memberof luck.protobuf.NoticePB
             * @instance
             */
            NoticePB.prototype.context = "";

            /**
             * Creates a new NoticePB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.NoticePB
             * @static
             * @param {luck.protobuf.INoticePB=} [properties] Properties to set
             * @returns {luck.protobuf.NoticePB} NoticePB instance
             */
            NoticePB.create = function create(properties) {
                return new NoticePB(properties);
            };

            /**
             * Encodes the specified NoticePB message. Does not implicitly {@link luck.protobuf.NoticePB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.NoticePB
             * @static
             * @param {luck.protobuf.INoticePB} message NoticePB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NoticePB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.noticeId);
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.title);
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.context);
                return writer;
            };

            /**
             * Encodes the specified NoticePB message, length delimited. Does not implicitly {@link luck.protobuf.NoticePB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.NoticePB
             * @static
             * @param {luck.protobuf.INoticePB} message NoticePB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NoticePB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NoticePB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.NoticePB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.NoticePB} NoticePB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NoticePB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.NoticePB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.noticeId = reader.int32();
                        break;
                    case 2:
                        message.title = reader.string();
                        break;
                    case 3:
                        message.context = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("noticeId"))
                    throw $util.ProtocolError("missing required 'noticeId'", { instance: message });
                if (!message.hasOwnProperty("title"))
                    throw $util.ProtocolError("missing required 'title'", { instance: message });
                if (!message.hasOwnProperty("context"))
                    throw $util.ProtocolError("missing required 'context'", { instance: message });
                return message;
            };

            /**
             * Decodes a NoticePB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.NoticePB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.NoticePB} NoticePB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NoticePB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NoticePB message.
             * @function verify
             * @memberof luck.protobuf.NoticePB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NoticePB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.noticeId))
                    return "noticeId: integer expected";
                if (!$util.isString(message.title))
                    return "title: string expected";
                if (!$util.isString(message.context))
                    return "context: string expected";
                return null;
            };

            return NoticePB;
        })();

        protobuf.ActivityTaskPB = (function() {

            /**
             * Properties of an ActivityTaskPB.
             * @memberof luck.protobuf
             * @interface IActivityTaskPB
             * @property {number} activityTaskId ActivityTaskPB activityTaskId
             * @property {luck.protobuf.ITaskConditionPB} condition ActivityTaskPB condition
             * @property {boolean} bGain ActivityTaskPB bGain
             * @property {boolean} bDeblock ActivityTaskPB bDeblock
             * @property {number} haveCompleteTimes ActivityTaskPB haveCompleteTimes
             * @property {number} canDrawTimes ActivityTaskPB canDrawTimes
             */

            /**
             * Constructs a new ActivityTaskPB.
             * @memberof luck.protobuf
             * @classdesc Represents an ActivityTaskPB.
             * @implements IActivityTaskPB
             * @constructor
             * @param {luck.protobuf.IActivityTaskPB=} [properties] Properties to set
             */
            function ActivityTaskPB(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ActivityTaskPB activityTaskId.
             * @member {number} activityTaskId
             * @memberof luck.protobuf.ActivityTaskPB
             * @instance
             */
            ActivityTaskPB.prototype.activityTaskId = 0;

            /**
             * ActivityTaskPB condition.
             * @member {luck.protobuf.ITaskConditionPB} condition
             * @memberof luck.protobuf.ActivityTaskPB
             * @instance
             */
            ActivityTaskPB.prototype.condition = null;

            /**
             * ActivityTaskPB bGain.
             * @member {boolean} bGain
             * @memberof luck.protobuf.ActivityTaskPB
             * @instance
             */
            ActivityTaskPB.prototype.bGain = false;

            /**
             * ActivityTaskPB bDeblock.
             * @member {boolean} bDeblock
             * @memberof luck.protobuf.ActivityTaskPB
             * @instance
             */
            ActivityTaskPB.prototype.bDeblock = false;

            /**
             * ActivityTaskPB haveCompleteTimes.
             * @member {number} haveCompleteTimes
             * @memberof luck.protobuf.ActivityTaskPB
             * @instance
             */
            ActivityTaskPB.prototype.haveCompleteTimes = 0;

            /**
             * ActivityTaskPB canDrawTimes.
             * @member {number} canDrawTimes
             * @memberof luck.protobuf.ActivityTaskPB
             * @instance
             */
            ActivityTaskPB.prototype.canDrawTimes = 0;

            /**
             * Creates a new ActivityTaskPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.ActivityTaskPB
             * @static
             * @param {luck.protobuf.IActivityTaskPB=} [properties] Properties to set
             * @returns {luck.protobuf.ActivityTaskPB} ActivityTaskPB instance
             */
            ActivityTaskPB.create = function create(properties) {
                return new ActivityTaskPB(properties);
            };

            /**
             * Encodes the specified ActivityTaskPB message. Does not implicitly {@link luck.protobuf.ActivityTaskPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.ActivityTaskPB
             * @static
             * @param {luck.protobuf.IActivityTaskPB} message ActivityTaskPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ActivityTaskPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.activityTaskId);
                $root.luck.protobuf.TaskConditionPB.encode(message.condition, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.bGain);
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.bDeblock);
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.haveCompleteTimes);
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.canDrawTimes);
                return writer;
            };

            /**
             * Encodes the specified ActivityTaskPB message, length delimited. Does not implicitly {@link luck.protobuf.ActivityTaskPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.ActivityTaskPB
             * @static
             * @param {luck.protobuf.IActivityTaskPB} message ActivityTaskPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ActivityTaskPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ActivityTaskPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.ActivityTaskPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.ActivityTaskPB} ActivityTaskPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ActivityTaskPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.ActivityTaskPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.activityTaskId = reader.int32();
                        break;
                    case 2:
                        message.condition = $root.luck.protobuf.TaskConditionPB.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.bGain = reader.bool();
                        break;
                    case 4:
                        message.bDeblock = reader.bool();
                        break;
                    case 5:
                        message.haveCompleteTimes = reader.int32();
                        break;
                    case 6:
                        message.canDrawTimes = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("activityTaskId"))
                    throw $util.ProtocolError("missing required 'activityTaskId'", { instance: message });
                if (!message.hasOwnProperty("condition"))
                    throw $util.ProtocolError("missing required 'condition'", { instance: message });
                if (!message.hasOwnProperty("bGain"))
                    throw $util.ProtocolError("missing required 'bGain'", { instance: message });
                if (!message.hasOwnProperty("bDeblock"))
                    throw $util.ProtocolError("missing required 'bDeblock'", { instance: message });
                if (!message.hasOwnProperty("haveCompleteTimes"))
                    throw $util.ProtocolError("missing required 'haveCompleteTimes'", { instance: message });
                if (!message.hasOwnProperty("canDrawTimes"))
                    throw $util.ProtocolError("missing required 'canDrawTimes'", { instance: message });
                return message;
            };

            /**
             * Decodes an ActivityTaskPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.ActivityTaskPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.ActivityTaskPB} ActivityTaskPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ActivityTaskPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ActivityTaskPB message.
             * @function verify
             * @memberof luck.protobuf.ActivityTaskPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ActivityTaskPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.activityTaskId))
                    return "activityTaskId: integer expected";
                {
                    var error = $root.luck.protobuf.TaskConditionPB.verify(message.condition);
                    if (error)
                        return "condition." + error;
                }
                if (typeof message.bGain !== "boolean")
                    return "bGain: boolean expected";
                if (typeof message.bDeblock !== "boolean")
                    return "bDeblock: boolean expected";
                if (!$util.isInteger(message.haveCompleteTimes))
                    return "haveCompleteTimes: integer expected";
                if (!$util.isInteger(message.canDrawTimes))
                    return "canDrawTimes: integer expected";
                return null;
            };

            return ActivityTaskPB;
        })();

        protobuf.GameSystemPB = (function() {

            /**
             * Properties of a GameSystemPB.
             * @memberof luck.protobuf
             * @interface IGameSystemPB
             * @property {number|Long} openServiceTime GameSystemPB openServiceTime
             */

            /**
             * Constructs a new GameSystemPB.
             * @memberof luck.protobuf
             * @classdesc Represents a GameSystemPB.
             * @implements IGameSystemPB
             * @constructor
             * @param {luck.protobuf.IGameSystemPB=} [properties] Properties to set
             */
            function GameSystemPB(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GameSystemPB openServiceTime.
             * @member {number|Long} openServiceTime
             * @memberof luck.protobuf.GameSystemPB
             * @instance
             */
            GameSystemPB.prototype.openServiceTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new GameSystemPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.GameSystemPB
             * @static
             * @param {luck.protobuf.IGameSystemPB=} [properties] Properties to set
             * @returns {luck.protobuf.GameSystemPB} GameSystemPB instance
             */
            GameSystemPB.create = function create(properties) {
                return new GameSystemPB(properties);
            };

            /**
             * Encodes the specified GameSystemPB message. Does not implicitly {@link luck.protobuf.GameSystemPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.GameSystemPB
             * @static
             * @param {luck.protobuf.IGameSystemPB} message GameSystemPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GameSystemPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.openServiceTime);
                return writer;
            };

            /**
             * Encodes the specified GameSystemPB message, length delimited. Does not implicitly {@link luck.protobuf.GameSystemPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.GameSystemPB
             * @static
             * @param {luck.protobuf.IGameSystemPB} message GameSystemPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GameSystemPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GameSystemPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.GameSystemPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.GameSystemPB} GameSystemPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GameSystemPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.GameSystemPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.openServiceTime = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("openServiceTime"))
                    throw $util.ProtocolError("missing required 'openServiceTime'", { instance: message });
                return message;
            };

            /**
             * Decodes a GameSystemPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.GameSystemPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.GameSystemPB} GameSystemPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GameSystemPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GameSystemPB message.
             * @function verify
             * @memberof luck.protobuf.GameSystemPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GameSystemPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.openServiceTime) && !(message.openServiceTime && $util.isInteger(message.openServiceTime.low) && $util.isInteger(message.openServiceTime.high)))
                    return "openServiceTime: integer|Long expected";
                return null;
            };

            return GameSystemPB;
        })();

        protobuf.MinePB = (function() {

            /**
             * Properties of a MinePB.
             * @memberof luck.protobuf
             * @interface IMinePB
             * @property {number} id MinePB id
             * @property {number|Long} lastUpdateTime MinePB lastUpdateTime
             * @property {number|Long} gold MinePB gold
             * @property {number|Long} diamond MinePB diamond
             * @property {number|Long} beginTime MinePB beginTime
             * @property {number} goblinId MinePB goblinId
             * @property {number} type MinePB type
             * @property {number} goblinNum MinePB goblinNum
             * @property {number} refreshNum MinePB refreshNum
             */

            /**
             * Constructs a new MinePB.
             * @memberof luck.protobuf
             * @classdesc Represents a MinePB.
             * @implements IMinePB
             * @constructor
             * @param {luck.protobuf.IMinePB=} [properties] Properties to set
             */
            function MinePB(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MinePB id.
             * @member {number} id
             * @memberof luck.protobuf.MinePB
             * @instance
             */
            MinePB.prototype.id = 0;

            /**
             * MinePB lastUpdateTime.
             * @member {number|Long} lastUpdateTime
             * @memberof luck.protobuf.MinePB
             * @instance
             */
            MinePB.prototype.lastUpdateTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * MinePB gold.
             * @member {number|Long} gold
             * @memberof luck.protobuf.MinePB
             * @instance
             */
            MinePB.prototype.gold = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * MinePB diamond.
             * @member {number|Long} diamond
             * @memberof luck.protobuf.MinePB
             * @instance
             */
            MinePB.prototype.diamond = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * MinePB beginTime.
             * @member {number|Long} beginTime
             * @memberof luck.protobuf.MinePB
             * @instance
             */
            MinePB.prototype.beginTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * MinePB goblinId.
             * @member {number} goblinId
             * @memberof luck.protobuf.MinePB
             * @instance
             */
            MinePB.prototype.goblinId = 0;

            /**
             * MinePB type.
             * @member {number} type
             * @memberof luck.protobuf.MinePB
             * @instance
             */
            MinePB.prototype.type = 0;

            /**
             * MinePB goblinNum.
             * @member {number} goblinNum
             * @memberof luck.protobuf.MinePB
             * @instance
             */
            MinePB.prototype.goblinNum = 0;

            /**
             * MinePB refreshNum.
             * @member {number} refreshNum
             * @memberof luck.protobuf.MinePB
             * @instance
             */
            MinePB.prototype.refreshNum = 0;

            /**
             * Creates a new MinePB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.MinePB
             * @static
             * @param {luck.protobuf.IMinePB=} [properties] Properties to set
             * @returns {luck.protobuf.MinePB} MinePB instance
             */
            MinePB.create = function create(properties) {
                return new MinePB(properties);
            };

            /**
             * Encodes the specified MinePB message. Does not implicitly {@link luck.protobuf.MinePB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.MinePB
             * @static
             * @param {luck.protobuf.IMinePB} message MinePB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MinePB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.lastUpdateTime);
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.gold);
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.diamond);
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.beginTime);
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.goblinId);
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.type);
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.goblinNum);
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.refreshNum);
                return writer;
            };

            /**
             * Encodes the specified MinePB message, length delimited. Does not implicitly {@link luck.protobuf.MinePB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.MinePB
             * @static
             * @param {luck.protobuf.IMinePB} message MinePB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MinePB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MinePB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.MinePB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.MinePB} MinePB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MinePB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.MinePB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.int32();
                        break;
                    case 2:
                        message.lastUpdateTime = reader.int64();
                        break;
                    case 3:
                        message.gold = reader.int64();
                        break;
                    case 4:
                        message.diamond = reader.int64();
                        break;
                    case 5:
                        message.beginTime = reader.int64();
                        break;
                    case 6:
                        message.goblinId = reader.int32();
                        break;
                    case 7:
                        message.type = reader.int32();
                        break;
                    case 8:
                        message.goblinNum = reader.int32();
                        break;
                    case 9:
                        message.refreshNum = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("id"))
                    throw $util.ProtocolError("missing required 'id'", { instance: message });
                if (!message.hasOwnProperty("lastUpdateTime"))
                    throw $util.ProtocolError("missing required 'lastUpdateTime'", { instance: message });
                if (!message.hasOwnProperty("gold"))
                    throw $util.ProtocolError("missing required 'gold'", { instance: message });
                if (!message.hasOwnProperty("diamond"))
                    throw $util.ProtocolError("missing required 'diamond'", { instance: message });
                if (!message.hasOwnProperty("beginTime"))
                    throw $util.ProtocolError("missing required 'beginTime'", { instance: message });
                if (!message.hasOwnProperty("goblinId"))
                    throw $util.ProtocolError("missing required 'goblinId'", { instance: message });
                if (!message.hasOwnProperty("type"))
                    throw $util.ProtocolError("missing required 'type'", { instance: message });
                if (!message.hasOwnProperty("goblinNum"))
                    throw $util.ProtocolError("missing required 'goblinNum'", { instance: message });
                if (!message.hasOwnProperty("refreshNum"))
                    throw $util.ProtocolError("missing required 'refreshNum'", { instance: message });
                return message;
            };

            /**
             * Decodes a MinePB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.MinePB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.MinePB} MinePB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MinePB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MinePB message.
             * @function verify
             * @memberof luck.protobuf.MinePB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MinePB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
                if (!$util.isInteger(message.lastUpdateTime) && !(message.lastUpdateTime && $util.isInteger(message.lastUpdateTime.low) && $util.isInteger(message.lastUpdateTime.high)))
                    return "lastUpdateTime: integer|Long expected";
                if (!$util.isInteger(message.gold) && !(message.gold && $util.isInteger(message.gold.low) && $util.isInteger(message.gold.high)))
                    return "gold: integer|Long expected";
                if (!$util.isInteger(message.diamond) && !(message.diamond && $util.isInteger(message.diamond.low) && $util.isInteger(message.diamond.high)))
                    return "diamond: integer|Long expected";
                if (!$util.isInteger(message.beginTime) && !(message.beginTime && $util.isInteger(message.beginTime.low) && $util.isInteger(message.beginTime.high)))
                    return "beginTime: integer|Long expected";
                if (!$util.isInteger(message.goblinId))
                    return "goblinId: integer expected";
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
                if (!$util.isInteger(message.goblinNum))
                    return "goblinNum: integer expected";
                if (!$util.isInteger(message.refreshNum))
                    return "refreshNum: integer expected";
                return null;
            };

            return MinePB;
        })();

        protobuf.DiggingPB = (function() {

            /**
             * Properties of a DiggingPB.
             * @memberof luck.protobuf
             * @interface IDiggingPB
             * @property {Array.<luck.protobuf.IMinePB>|null} [mineList] DiggingPB mineList
             */

            /**
             * Constructs a new DiggingPB.
             * @memberof luck.protobuf
             * @classdesc Represents a DiggingPB.
             * @implements IDiggingPB
             * @constructor
             * @param {luck.protobuf.IDiggingPB=} [properties] Properties to set
             */
            function DiggingPB(properties) {
                this.mineList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DiggingPB mineList.
             * @member {Array.<luck.protobuf.IMinePB>} mineList
             * @memberof luck.protobuf.DiggingPB
             * @instance
             */
            DiggingPB.prototype.mineList = $util.emptyArray;

            /**
             * Creates a new DiggingPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.DiggingPB
             * @static
             * @param {luck.protobuf.IDiggingPB=} [properties] Properties to set
             * @returns {luck.protobuf.DiggingPB} DiggingPB instance
             */
            DiggingPB.create = function create(properties) {
                return new DiggingPB(properties);
            };

            /**
             * Encodes the specified DiggingPB message. Does not implicitly {@link luck.protobuf.DiggingPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.DiggingPB
             * @static
             * @param {luck.protobuf.IDiggingPB} message DiggingPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DiggingPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.mineList != null && message.mineList.length)
                    for (var i = 0; i < message.mineList.length; ++i)
                        $root.luck.protobuf.MinePB.encode(message.mineList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DiggingPB message, length delimited. Does not implicitly {@link luck.protobuf.DiggingPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.DiggingPB
             * @static
             * @param {luck.protobuf.IDiggingPB} message DiggingPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DiggingPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DiggingPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.DiggingPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.DiggingPB} DiggingPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DiggingPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.DiggingPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.mineList && message.mineList.length))
                            message.mineList = [];
                        message.mineList.push($root.luck.protobuf.MinePB.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DiggingPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.DiggingPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.DiggingPB} DiggingPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DiggingPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DiggingPB message.
             * @function verify
             * @memberof luck.protobuf.DiggingPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DiggingPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.mineList != null && message.hasOwnProperty("mineList")) {
                    if (!Array.isArray(message.mineList))
                        return "mineList: array expected";
                    for (var i = 0; i < message.mineList.length; ++i) {
                        var error = $root.luck.protobuf.MinePB.verify(message.mineList[i]);
                        if (error)
                            return "mineList." + error;
                    }
                }
                return null;
            };

            return DiggingPB;
        })();

        protobuf.activityTaskRewardPB = (function() {

            /**
             * Properties of an activityTaskRewardPB.
             * @memberof luck.protobuf
             * @interface IactivityTaskRewardPB
             * @property {number} type activityTaskRewardPB type
             * @property {number} num activityTaskRewardPB num
             * @property {boolean} bGain activityTaskRewardPB bGain
             */

            /**
             * Constructs a new activityTaskRewardPB.
             * @memberof luck.protobuf
             * @classdesc Represents an activityTaskRewardPB.
             * @implements IactivityTaskRewardPB
             * @constructor
             * @param {luck.protobuf.IactivityTaskRewardPB=} [properties] Properties to set
             */
            function activityTaskRewardPB(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * activityTaskRewardPB type.
             * @member {number} type
             * @memberof luck.protobuf.activityTaskRewardPB
             * @instance
             */
            activityTaskRewardPB.prototype.type = 0;

            /**
             * activityTaskRewardPB num.
             * @member {number} num
             * @memberof luck.protobuf.activityTaskRewardPB
             * @instance
             */
            activityTaskRewardPB.prototype.num = 0;

            /**
             * activityTaskRewardPB bGain.
             * @member {boolean} bGain
             * @memberof luck.protobuf.activityTaskRewardPB
             * @instance
             */
            activityTaskRewardPB.prototype.bGain = false;

            /**
             * Creates a new activityTaskRewardPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.activityTaskRewardPB
             * @static
             * @param {luck.protobuf.IactivityTaskRewardPB=} [properties] Properties to set
             * @returns {luck.protobuf.activityTaskRewardPB} activityTaskRewardPB instance
             */
            activityTaskRewardPB.create = function create(properties) {
                return new activityTaskRewardPB(properties);
            };

            /**
             * Encodes the specified activityTaskRewardPB message. Does not implicitly {@link luck.protobuf.activityTaskRewardPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.activityTaskRewardPB
             * @static
             * @param {luck.protobuf.IactivityTaskRewardPB} message activityTaskRewardPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            activityTaskRewardPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.num);
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.bGain);
                return writer;
            };

            /**
             * Encodes the specified activityTaskRewardPB message, length delimited. Does not implicitly {@link luck.protobuf.activityTaskRewardPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.activityTaskRewardPB
             * @static
             * @param {luck.protobuf.IactivityTaskRewardPB} message activityTaskRewardPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            activityTaskRewardPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an activityTaskRewardPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.activityTaskRewardPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.activityTaskRewardPB} activityTaskRewardPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            activityTaskRewardPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.activityTaskRewardPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.num = reader.int32();
                        break;
                    case 3:
                        message.bGain = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("type"))
                    throw $util.ProtocolError("missing required 'type'", { instance: message });
                if (!message.hasOwnProperty("num"))
                    throw $util.ProtocolError("missing required 'num'", { instance: message });
                if (!message.hasOwnProperty("bGain"))
                    throw $util.ProtocolError("missing required 'bGain'", { instance: message });
                return message;
            };

            /**
             * Decodes an activityTaskRewardPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.activityTaskRewardPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.activityTaskRewardPB} activityTaskRewardPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            activityTaskRewardPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an activityTaskRewardPB message.
             * @function verify
             * @memberof luck.protobuf.activityTaskRewardPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            activityTaskRewardPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
                if (!$util.isInteger(message.num))
                    return "num: integer expected";
                if (typeof message.bGain !== "boolean")
                    return "bGain: boolean expected";
                return null;
            };

            return activityTaskRewardPB;
        })();

        protobuf.pveBallteFinishReward = (function() {

            /**
             * Properties of a pveBallteFinishReward.
             * @memberof luck.protobuf
             * @interface IpveBallteFinishReward
             * @property {number|Long} playerId pveBallteFinishReward playerId
             * @property {Array.<luck.protobuf.IWeaponPB>|null} [weaponList] pveBallteFinishReward weaponList
             * @property {Array.<luck.protobuf.ICardPB>|null} [cardList] pveBallteFinishReward cardList
             * @property {Array.<luck.protobuf.IClothesPB>|null} [clothesList] pveBallteFinishReward clothesList
             * @property {Array.<luck.protobuf.IPropPB>|null} [propList] pveBallteFinishReward propList
             * @property {Array.<luck.protobuf.IMaterialsPB>|null} [materialsList] pveBallteFinishReward materialsList
             * @property {number|Long|null} [gold] pveBallteFinishReward gold
             * @property {number|Long|null} [diamond] pveBallteFinishReward diamond
             */

            /**
             * Constructs a new pveBallteFinishReward.
             * @memberof luck.protobuf
             * @classdesc Represents a pveBallteFinishReward.
             * @implements IpveBallteFinishReward
             * @constructor
             * @param {luck.protobuf.IpveBallteFinishReward=} [properties] Properties to set
             */
            function pveBallteFinishReward(properties) {
                this.weaponList = [];
                this.cardList = [];
                this.clothesList = [];
                this.propList = [];
                this.materialsList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * pveBallteFinishReward playerId.
             * @member {number|Long} playerId
             * @memberof luck.protobuf.pveBallteFinishReward
             * @instance
             */
            pveBallteFinishReward.prototype.playerId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * pveBallteFinishReward weaponList.
             * @member {Array.<luck.protobuf.IWeaponPB>} weaponList
             * @memberof luck.protobuf.pveBallteFinishReward
             * @instance
             */
            pveBallteFinishReward.prototype.weaponList = $util.emptyArray;

            /**
             * pveBallteFinishReward cardList.
             * @member {Array.<luck.protobuf.ICardPB>} cardList
             * @memberof luck.protobuf.pveBallteFinishReward
             * @instance
             */
            pveBallteFinishReward.prototype.cardList = $util.emptyArray;

            /**
             * pveBallteFinishReward clothesList.
             * @member {Array.<luck.protobuf.IClothesPB>} clothesList
             * @memberof luck.protobuf.pveBallteFinishReward
             * @instance
             */
            pveBallteFinishReward.prototype.clothesList = $util.emptyArray;

            /**
             * pveBallteFinishReward propList.
             * @member {Array.<luck.protobuf.IPropPB>} propList
             * @memberof luck.protobuf.pveBallteFinishReward
             * @instance
             */
            pveBallteFinishReward.prototype.propList = $util.emptyArray;

            /**
             * pveBallteFinishReward materialsList.
             * @member {Array.<luck.protobuf.IMaterialsPB>} materialsList
             * @memberof luck.protobuf.pveBallteFinishReward
             * @instance
             */
            pveBallteFinishReward.prototype.materialsList = $util.emptyArray;

            /**
             * pveBallteFinishReward gold.
             * @member {number|Long} gold
             * @memberof luck.protobuf.pveBallteFinishReward
             * @instance
             */
            pveBallteFinishReward.prototype.gold = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * pveBallteFinishReward diamond.
             * @member {number|Long} diamond
             * @memberof luck.protobuf.pveBallteFinishReward
             * @instance
             */
            pveBallteFinishReward.prototype.diamond = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new pveBallteFinishReward instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.pveBallteFinishReward
             * @static
             * @param {luck.protobuf.IpveBallteFinishReward=} [properties] Properties to set
             * @returns {luck.protobuf.pveBallteFinishReward} pveBallteFinishReward instance
             */
            pveBallteFinishReward.create = function create(properties) {
                return new pveBallteFinishReward(properties);
            };

            /**
             * Encodes the specified pveBallteFinishReward message. Does not implicitly {@link luck.protobuf.pveBallteFinishReward.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.pveBallteFinishReward
             * @static
             * @param {luck.protobuf.IpveBallteFinishReward} message pveBallteFinishReward message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            pveBallteFinishReward.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.playerId);
                if (message.weaponList != null && message.weaponList.length)
                    for (var i = 0; i < message.weaponList.length; ++i)
                        $root.luck.protobuf.WeaponPB.encode(message.weaponList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.cardList != null && message.cardList.length)
                    for (var i = 0; i < message.cardList.length; ++i)
                        $root.luck.protobuf.CardPB.encode(message.cardList[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.clothesList != null && message.clothesList.length)
                    for (var i = 0; i < message.clothesList.length; ++i)
                        $root.luck.protobuf.ClothesPB.encode(message.clothesList[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.propList != null && message.propList.length)
                    for (var i = 0; i < message.propList.length; ++i)
                        $root.luck.protobuf.PropPB.encode(message.propList[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.materialsList != null && message.materialsList.length)
                    for (var i = 0; i < message.materialsList.length; ++i)
                        $root.luck.protobuf.MaterialsPB.encode(message.materialsList[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.gold != null && message.hasOwnProperty("gold"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int64(message.gold);
                if (message.diamond != null && message.hasOwnProperty("diamond"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int64(message.diamond);
                return writer;
            };

            /**
             * Encodes the specified pveBallteFinishReward message, length delimited. Does not implicitly {@link luck.protobuf.pveBallteFinishReward.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.pveBallteFinishReward
             * @static
             * @param {luck.protobuf.IpveBallteFinishReward} message pveBallteFinishReward message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            pveBallteFinishReward.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a pveBallteFinishReward message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.pveBallteFinishReward
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.pveBallteFinishReward} pveBallteFinishReward
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            pveBallteFinishReward.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.pveBallteFinishReward();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.playerId = reader.int64();
                        break;
                    case 2:
                        if (!(message.weaponList && message.weaponList.length))
                            message.weaponList = [];
                        message.weaponList.push($root.luck.protobuf.WeaponPB.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.cardList && message.cardList.length))
                            message.cardList = [];
                        message.cardList.push($root.luck.protobuf.CardPB.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        if (!(message.clothesList && message.clothesList.length))
                            message.clothesList = [];
                        message.clothesList.push($root.luck.protobuf.ClothesPB.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.propList && message.propList.length))
                            message.propList = [];
                        message.propList.push($root.luck.protobuf.PropPB.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.materialsList && message.materialsList.length))
                            message.materialsList = [];
                        message.materialsList.push($root.luck.protobuf.MaterialsPB.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        message.gold = reader.int64();
                        break;
                    case 8:
                        message.diamond = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("playerId"))
                    throw $util.ProtocolError("missing required 'playerId'", { instance: message });
                return message;
            };

            /**
             * Decodes a pveBallteFinishReward message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.pveBallteFinishReward
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.pveBallteFinishReward} pveBallteFinishReward
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            pveBallteFinishReward.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a pveBallteFinishReward message.
             * @function verify
             * @memberof luck.protobuf.pveBallteFinishReward
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            pveBallteFinishReward.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.playerId) && !(message.playerId && $util.isInteger(message.playerId.low) && $util.isInteger(message.playerId.high)))
                    return "playerId: integer|Long expected";
                if (message.weaponList != null && message.hasOwnProperty("weaponList")) {
                    if (!Array.isArray(message.weaponList))
                        return "weaponList: array expected";
                    for (var i = 0; i < message.weaponList.length; ++i) {
                        var error = $root.luck.protobuf.WeaponPB.verify(message.weaponList[i]);
                        if (error)
                            return "weaponList." + error;
                    }
                }
                if (message.cardList != null && message.hasOwnProperty("cardList")) {
                    if (!Array.isArray(message.cardList))
                        return "cardList: array expected";
                    for (var i = 0; i < message.cardList.length; ++i) {
                        var error = $root.luck.protobuf.CardPB.verify(message.cardList[i]);
                        if (error)
                            return "cardList." + error;
                    }
                }
                if (message.clothesList != null && message.hasOwnProperty("clothesList")) {
                    if (!Array.isArray(message.clothesList))
                        return "clothesList: array expected";
                    for (var i = 0; i < message.clothesList.length; ++i) {
                        var error = $root.luck.protobuf.ClothesPB.verify(message.clothesList[i]);
                        if (error)
                            return "clothesList." + error;
                    }
                }
                if (message.propList != null && message.hasOwnProperty("propList")) {
                    if (!Array.isArray(message.propList))
                        return "propList: array expected";
                    for (var i = 0; i < message.propList.length; ++i) {
                        var error = $root.luck.protobuf.PropPB.verify(message.propList[i]);
                        if (error)
                            return "propList." + error;
                    }
                }
                if (message.materialsList != null && message.hasOwnProperty("materialsList")) {
                    if (!Array.isArray(message.materialsList))
                        return "materialsList: array expected";
                    for (var i = 0; i < message.materialsList.length; ++i) {
                        var error = $root.luck.protobuf.MaterialsPB.verify(message.materialsList[i]);
                        if (error)
                            return "materialsList." + error;
                    }
                }
                if (message.gold != null && message.hasOwnProperty("gold"))
                    if (!$util.isInteger(message.gold) && !(message.gold && $util.isInteger(message.gold.low) && $util.isInteger(message.gold.high)))
                        return "gold: integer|Long expected";
                if (message.diamond != null && message.hasOwnProperty("diamond"))
                    if (!$util.isInteger(message.diamond) && !(message.diamond && $util.isInteger(message.diamond.low) && $util.isInteger(message.diamond.high)))
                        return "diamond: integer|Long expected";
                return null;
            };

            return pveBallteFinishReward;
        })();

        protobuf.ActivityLotteryPB = (function() {

            /**
             * Properties of an ActivityLotteryPB.
             * @memberof luck.protobuf
             * @interface IActivityLotteryPB
             * @property {number} activityId ActivityLotteryPB activityId
             * @property {Array.<number>|null} [poolList] ActivityLotteryPB poolList
             * @property {number|Long} lastLotteryTime ActivityLotteryPB lastLotteryTime
             * @property {boolean} canFreeLottery ActivityLotteryPB canFreeLottery
             */

            /**
             * Constructs a new ActivityLotteryPB.
             * @memberof luck.protobuf
             * @classdesc Represents an ActivityLotteryPB.
             * @implements IActivityLotteryPB
             * @constructor
             * @param {luck.protobuf.IActivityLotteryPB=} [properties] Properties to set
             */
            function ActivityLotteryPB(properties) {
                this.poolList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ActivityLotteryPB activityId.
             * @member {number} activityId
             * @memberof luck.protobuf.ActivityLotteryPB
             * @instance
             */
            ActivityLotteryPB.prototype.activityId = 0;

            /**
             * ActivityLotteryPB poolList.
             * @member {Array.<number>} poolList
             * @memberof luck.protobuf.ActivityLotteryPB
             * @instance
             */
            ActivityLotteryPB.prototype.poolList = $util.emptyArray;

            /**
             * ActivityLotteryPB lastLotteryTime.
             * @member {number|Long} lastLotteryTime
             * @memberof luck.protobuf.ActivityLotteryPB
             * @instance
             */
            ActivityLotteryPB.prototype.lastLotteryTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * ActivityLotteryPB canFreeLottery.
             * @member {boolean} canFreeLottery
             * @memberof luck.protobuf.ActivityLotteryPB
             * @instance
             */
            ActivityLotteryPB.prototype.canFreeLottery = false;

            /**
             * Creates a new ActivityLotteryPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.ActivityLotteryPB
             * @static
             * @param {luck.protobuf.IActivityLotteryPB=} [properties] Properties to set
             * @returns {luck.protobuf.ActivityLotteryPB} ActivityLotteryPB instance
             */
            ActivityLotteryPB.create = function create(properties) {
                return new ActivityLotteryPB(properties);
            };

            /**
             * Encodes the specified ActivityLotteryPB message. Does not implicitly {@link luck.protobuf.ActivityLotteryPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.ActivityLotteryPB
             * @static
             * @param {luck.protobuf.IActivityLotteryPB} message ActivityLotteryPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ActivityLotteryPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.activityId);
                if (message.poolList != null && message.poolList.length)
                    for (var i = 0; i < message.poolList.length; ++i)
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.poolList[i]);
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.lastLotteryTime);
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.canFreeLottery);
                return writer;
            };

            /**
             * Encodes the specified ActivityLotteryPB message, length delimited. Does not implicitly {@link luck.protobuf.ActivityLotteryPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.ActivityLotteryPB
             * @static
             * @param {luck.protobuf.IActivityLotteryPB} message ActivityLotteryPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ActivityLotteryPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ActivityLotteryPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.ActivityLotteryPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.ActivityLotteryPB} ActivityLotteryPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ActivityLotteryPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.ActivityLotteryPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.activityId = reader.int32();
                        break;
                    case 2:
                        if (!(message.poolList && message.poolList.length))
                            message.poolList = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.poolList.push(reader.int32());
                        } else
                            message.poolList.push(reader.int32());
                        break;
                    case 3:
                        message.lastLotteryTime = reader.int64();
                        break;
                    case 4:
                        message.canFreeLottery = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("activityId"))
                    throw $util.ProtocolError("missing required 'activityId'", { instance: message });
                if (!message.hasOwnProperty("lastLotteryTime"))
                    throw $util.ProtocolError("missing required 'lastLotteryTime'", { instance: message });
                if (!message.hasOwnProperty("canFreeLottery"))
                    throw $util.ProtocolError("missing required 'canFreeLottery'", { instance: message });
                return message;
            };

            /**
             * Decodes an ActivityLotteryPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.ActivityLotteryPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.ActivityLotteryPB} ActivityLotteryPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ActivityLotteryPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ActivityLotteryPB message.
             * @function verify
             * @memberof luck.protobuf.ActivityLotteryPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ActivityLotteryPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.activityId))
                    return "activityId: integer expected";
                if (message.poolList != null && message.hasOwnProperty("poolList")) {
                    if (!Array.isArray(message.poolList))
                        return "poolList: array expected";
                    for (var i = 0; i < message.poolList.length; ++i)
                        if (!$util.isInteger(message.poolList[i]))
                            return "poolList: integer[] expected";
                }
                if (!$util.isInteger(message.lastLotteryTime) && !(message.lastLotteryTime && $util.isInteger(message.lastLotteryTime.low) && $util.isInteger(message.lastLotteryTime.high)))
                    return "lastLotteryTime: integer|Long expected";
                if (typeof message.canFreeLottery !== "boolean")
                    return "canFreeLottery: boolean expected";
                return null;
            };

            return ActivityLotteryPB;
        })();

        protobuf.GainBuffPB = (function() {

            /**
             * Properties of a GainBuffPB.
             * @memberof luck.protobuf
             * @interface IGainBuffPB
             * @property {number} buffId GainBuffPB buffId
             * @property {number} multiple GainBuffPB multiple
             * @property {number|Long} startTime GainBuffPB startTime
             * @property {number|Long} endTime GainBuffPB endTime
             */

            /**
             * Constructs a new GainBuffPB.
             * @memberof luck.protobuf
             * @classdesc Represents a GainBuffPB.
             * @implements IGainBuffPB
             * @constructor
             * @param {luck.protobuf.IGainBuffPB=} [properties] Properties to set
             */
            function GainBuffPB(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GainBuffPB buffId.
             * @member {number} buffId
             * @memberof luck.protobuf.GainBuffPB
             * @instance
             */
            GainBuffPB.prototype.buffId = 0;

            /**
             * GainBuffPB multiple.
             * @member {number} multiple
             * @memberof luck.protobuf.GainBuffPB
             * @instance
             */
            GainBuffPB.prototype.multiple = 0;

            /**
             * GainBuffPB startTime.
             * @member {number|Long} startTime
             * @memberof luck.protobuf.GainBuffPB
             * @instance
             */
            GainBuffPB.prototype.startTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * GainBuffPB endTime.
             * @member {number|Long} endTime
             * @memberof luck.protobuf.GainBuffPB
             * @instance
             */
            GainBuffPB.prototype.endTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new GainBuffPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.GainBuffPB
             * @static
             * @param {luck.protobuf.IGainBuffPB=} [properties] Properties to set
             * @returns {luck.protobuf.GainBuffPB} GainBuffPB instance
             */
            GainBuffPB.create = function create(properties) {
                return new GainBuffPB(properties);
            };

            /**
             * Encodes the specified GainBuffPB message. Does not implicitly {@link luck.protobuf.GainBuffPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.GainBuffPB
             * @static
             * @param {luck.protobuf.IGainBuffPB} message GainBuffPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GainBuffPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.buffId);
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.multiple);
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.startTime);
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.endTime);
                return writer;
            };

            /**
             * Encodes the specified GainBuffPB message, length delimited. Does not implicitly {@link luck.protobuf.GainBuffPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.GainBuffPB
             * @static
             * @param {luck.protobuf.IGainBuffPB} message GainBuffPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GainBuffPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GainBuffPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.GainBuffPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.GainBuffPB} GainBuffPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GainBuffPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.GainBuffPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.buffId = reader.int32();
                        break;
                    case 2:
                        message.multiple = reader.double();
                        break;
                    case 3:
                        message.startTime = reader.int64();
                        break;
                    case 4:
                        message.endTime = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("buffId"))
                    throw $util.ProtocolError("missing required 'buffId'", { instance: message });
                if (!message.hasOwnProperty("multiple"))
                    throw $util.ProtocolError("missing required 'multiple'", { instance: message });
                if (!message.hasOwnProperty("startTime"))
                    throw $util.ProtocolError("missing required 'startTime'", { instance: message });
                if (!message.hasOwnProperty("endTime"))
                    throw $util.ProtocolError("missing required 'endTime'", { instance: message });
                return message;
            };

            /**
             * Decodes a GainBuffPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.GainBuffPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.GainBuffPB} GainBuffPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GainBuffPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GainBuffPB message.
             * @function verify
             * @memberof luck.protobuf.GainBuffPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GainBuffPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.buffId))
                    return "buffId: integer expected";
                if (typeof message.multiple !== "number")
                    return "multiple: number expected";
                if (!$util.isInteger(message.startTime) && !(message.startTime && $util.isInteger(message.startTime.low) && $util.isInteger(message.startTime.high)))
                    return "startTime: integer|Long expected";
                if (!$util.isInteger(message.endTime) && !(message.endTime && $util.isInteger(message.endTime.low) && $util.isInteger(message.endTime.high)))
                    return "endTime: integer|Long expected";
                return null;
            };

            return GainBuffPB;
        })();

        protobuf.RolePB = (function() {

            /**
             * Properties of a RolePB.
             * @memberof luck.protobuf
             * @interface IRolePB
             * @property {number|Long} id RolePB id
             * @property {number|Long} pid RolePB pid
             * @property {number} roleId RolePB roleId
             * @property {number} favorability RolePB favorability
             * @property {number} mood RolePB mood
             * @property {number} imageId RolePB imageId
             * @property {Array.<luck.protobuf.IRoleChatPB>|null} [chatScheduleMap] RolePB chatScheduleMap
             * @property {number} haveGetFavorability RolePB haveGetFavorability
             * @property {Array.<number>|null} [imageList] RolePB imageList
             */

            /**
             * Constructs a new RolePB.
             * @memberof luck.protobuf
             * @classdesc Represents a RolePB.
             * @implements IRolePB
             * @constructor
             * @param {luck.protobuf.IRolePB=} [properties] Properties to set
             */
            function RolePB(properties) {
                this.chatScheduleMap = [];
                this.imageList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RolePB id.
             * @member {number|Long} id
             * @memberof luck.protobuf.RolePB
             * @instance
             */
            RolePB.prototype.id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * RolePB pid.
             * @member {number|Long} pid
             * @memberof luck.protobuf.RolePB
             * @instance
             */
            RolePB.prototype.pid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * RolePB roleId.
             * @member {number} roleId
             * @memberof luck.protobuf.RolePB
             * @instance
             */
            RolePB.prototype.roleId = 0;

            /**
             * RolePB favorability.
             * @member {number} favorability
             * @memberof luck.protobuf.RolePB
             * @instance
             */
            RolePB.prototype.favorability = 0;

            /**
             * RolePB mood.
             * @member {number} mood
             * @memberof luck.protobuf.RolePB
             * @instance
             */
            RolePB.prototype.mood = 0;

            /**
             * RolePB imageId.
             * @member {number} imageId
             * @memberof luck.protobuf.RolePB
             * @instance
             */
            RolePB.prototype.imageId = 0;

            /**
             * RolePB chatScheduleMap.
             * @member {Array.<luck.protobuf.IRoleChatPB>} chatScheduleMap
             * @memberof luck.protobuf.RolePB
             * @instance
             */
            RolePB.prototype.chatScheduleMap = $util.emptyArray;

            /**
             * RolePB haveGetFavorability.
             * @member {number} haveGetFavorability
             * @memberof luck.protobuf.RolePB
             * @instance
             */
            RolePB.prototype.haveGetFavorability = 0;

            /**
             * RolePB imageList.
             * @member {Array.<number>} imageList
             * @memberof luck.protobuf.RolePB
             * @instance
             */
            RolePB.prototype.imageList = $util.emptyArray;

            /**
             * Creates a new RolePB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.RolePB
             * @static
             * @param {luck.protobuf.IRolePB=} [properties] Properties to set
             * @returns {luck.protobuf.RolePB} RolePB instance
             */
            RolePB.create = function create(properties) {
                return new RolePB(properties);
            };

            /**
             * Encodes the specified RolePB message. Does not implicitly {@link luck.protobuf.RolePB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.RolePB
             * @static
             * @param {luck.protobuf.IRolePB} message RolePB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RolePB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.id);
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.pid);
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.roleId);
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.favorability);
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.mood);
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.imageId);
                if (message.chatScheduleMap != null && message.chatScheduleMap.length)
                    for (var i = 0; i < message.chatScheduleMap.length; ++i)
                        $root.luck.protobuf.RoleChatPB.encode(message.chatScheduleMap[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.haveGetFavorability);
                if (message.imageList != null && message.imageList.length)
                    for (var i = 0; i < message.imageList.length; ++i)
                        writer.uint32(/* id 9, wireType 0 =*/72).int32(message.imageList[i]);
                return writer;
            };

            /**
             * Encodes the specified RolePB message, length delimited. Does not implicitly {@link luck.protobuf.RolePB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.RolePB
             * @static
             * @param {luck.protobuf.IRolePB} message RolePB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RolePB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RolePB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.RolePB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.RolePB} RolePB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RolePB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.RolePB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.int64();
                        break;
                    case 2:
                        message.pid = reader.int64();
                        break;
                    case 3:
                        message.roleId = reader.int32();
                        break;
                    case 4:
                        message.favorability = reader.int32();
                        break;
                    case 5:
                        message.mood = reader.int32();
                        break;
                    case 6:
                        message.imageId = reader.int32();
                        break;
                    case 7:
                        if (!(message.chatScheduleMap && message.chatScheduleMap.length))
                            message.chatScheduleMap = [];
                        message.chatScheduleMap.push($root.luck.protobuf.RoleChatPB.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        message.haveGetFavorability = reader.int32();
                        break;
                    case 9:
                        if (!(message.imageList && message.imageList.length))
                            message.imageList = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.imageList.push(reader.int32());
                        } else
                            message.imageList.push(reader.int32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("id"))
                    throw $util.ProtocolError("missing required 'id'", { instance: message });
                if (!message.hasOwnProperty("pid"))
                    throw $util.ProtocolError("missing required 'pid'", { instance: message });
                if (!message.hasOwnProperty("roleId"))
                    throw $util.ProtocolError("missing required 'roleId'", { instance: message });
                if (!message.hasOwnProperty("favorability"))
                    throw $util.ProtocolError("missing required 'favorability'", { instance: message });
                if (!message.hasOwnProperty("mood"))
                    throw $util.ProtocolError("missing required 'mood'", { instance: message });
                if (!message.hasOwnProperty("imageId"))
                    throw $util.ProtocolError("missing required 'imageId'", { instance: message });
                if (!message.hasOwnProperty("haveGetFavorability"))
                    throw $util.ProtocolError("missing required 'haveGetFavorability'", { instance: message });
                return message;
            };

            /**
             * Decodes a RolePB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.RolePB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.RolePB} RolePB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RolePB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RolePB message.
             * @function verify
             * @memberof luck.protobuf.RolePB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RolePB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
                if (!$util.isInteger(message.pid) && !(message.pid && $util.isInteger(message.pid.low) && $util.isInteger(message.pid.high)))
                    return "pid: integer|Long expected";
                if (!$util.isInteger(message.roleId))
                    return "roleId: integer expected";
                if (!$util.isInteger(message.favorability))
                    return "favorability: integer expected";
                if (!$util.isInteger(message.mood))
                    return "mood: integer expected";
                if (!$util.isInteger(message.imageId))
                    return "imageId: integer expected";
                if (message.chatScheduleMap != null && message.hasOwnProperty("chatScheduleMap")) {
                    if (!Array.isArray(message.chatScheduleMap))
                        return "chatScheduleMap: array expected";
                    for (var i = 0; i < message.chatScheduleMap.length; ++i) {
                        var error = $root.luck.protobuf.RoleChatPB.verify(message.chatScheduleMap[i]);
                        if (error)
                            return "chatScheduleMap." + error;
                    }
                }
                if (!$util.isInteger(message.haveGetFavorability))
                    return "haveGetFavorability: integer expected";
                if (message.imageList != null && message.hasOwnProperty("imageList")) {
                    if (!Array.isArray(message.imageList))
                        return "imageList: array expected";
                    for (var i = 0; i < message.imageList.length; ++i)
                        if (!$util.isInteger(message.imageList[i]))
                            return "imageList: integer[] expected";
                }
                return null;
            };

            return RolePB;
        })();

        protobuf.SpecialTaskPB = (function() {

            /**
             * Properties of a SpecialTaskPB.
             * @memberof luck.protobuf
             * @interface ISpecialTaskPB
             * @property {number} roleId SpecialTaskPB roleId
             * @property {number} specialTaskId SpecialTaskPB specialTaskId
             * @property {luck.protobuf.ITaskConditionPB} condition SpecialTaskPB condition
             * @property {boolean} bGain SpecialTaskPB bGain
             */

            /**
             * Constructs a new SpecialTaskPB.
             * @memberof luck.protobuf
             * @classdesc Represents a SpecialTaskPB.
             * @implements ISpecialTaskPB
             * @constructor
             * @param {luck.protobuf.ISpecialTaskPB=} [properties] Properties to set
             */
            function SpecialTaskPB(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SpecialTaskPB roleId.
             * @member {number} roleId
             * @memberof luck.protobuf.SpecialTaskPB
             * @instance
             */
            SpecialTaskPB.prototype.roleId = 0;

            /**
             * SpecialTaskPB specialTaskId.
             * @member {number} specialTaskId
             * @memberof luck.protobuf.SpecialTaskPB
             * @instance
             */
            SpecialTaskPB.prototype.specialTaskId = 0;

            /**
             * SpecialTaskPB condition.
             * @member {luck.protobuf.ITaskConditionPB} condition
             * @memberof luck.protobuf.SpecialTaskPB
             * @instance
             */
            SpecialTaskPB.prototype.condition = null;

            /**
             * SpecialTaskPB bGain.
             * @member {boolean} bGain
             * @memberof luck.protobuf.SpecialTaskPB
             * @instance
             */
            SpecialTaskPB.prototype.bGain = false;

            /**
             * Creates a new SpecialTaskPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.SpecialTaskPB
             * @static
             * @param {luck.protobuf.ISpecialTaskPB=} [properties] Properties to set
             * @returns {luck.protobuf.SpecialTaskPB} SpecialTaskPB instance
             */
            SpecialTaskPB.create = function create(properties) {
                return new SpecialTaskPB(properties);
            };

            /**
             * Encodes the specified SpecialTaskPB message. Does not implicitly {@link luck.protobuf.SpecialTaskPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.SpecialTaskPB
             * @static
             * @param {luck.protobuf.ISpecialTaskPB} message SpecialTaskPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SpecialTaskPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.roleId);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.specialTaskId);
                $root.luck.protobuf.TaskConditionPB.encode(message.condition, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.bGain);
                return writer;
            };

            /**
             * Encodes the specified SpecialTaskPB message, length delimited. Does not implicitly {@link luck.protobuf.SpecialTaskPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.SpecialTaskPB
             * @static
             * @param {luck.protobuf.ISpecialTaskPB} message SpecialTaskPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SpecialTaskPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SpecialTaskPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.SpecialTaskPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.SpecialTaskPB} SpecialTaskPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SpecialTaskPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.SpecialTaskPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.roleId = reader.int32();
                        break;
                    case 2:
                        message.specialTaskId = reader.int32();
                        break;
                    case 3:
                        message.condition = $root.luck.protobuf.TaskConditionPB.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.bGain = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("roleId"))
                    throw $util.ProtocolError("missing required 'roleId'", { instance: message });
                if (!message.hasOwnProperty("specialTaskId"))
                    throw $util.ProtocolError("missing required 'specialTaskId'", { instance: message });
                if (!message.hasOwnProperty("condition"))
                    throw $util.ProtocolError("missing required 'condition'", { instance: message });
                if (!message.hasOwnProperty("bGain"))
                    throw $util.ProtocolError("missing required 'bGain'", { instance: message });
                return message;
            };

            /**
             * Decodes a SpecialTaskPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.SpecialTaskPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.SpecialTaskPB} SpecialTaskPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SpecialTaskPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SpecialTaskPB message.
             * @function verify
             * @memberof luck.protobuf.SpecialTaskPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SpecialTaskPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.roleId))
                    return "roleId: integer expected";
                if (!$util.isInteger(message.specialTaskId))
                    return "specialTaskId: integer expected";
                {
                    var error = $root.luck.protobuf.TaskConditionPB.verify(message.condition);
                    if (error)
                        return "condition." + error;
                }
                if (typeof message.bGain !== "boolean")
                    return "bGain: boolean expected";
                return null;
            };

            return SpecialTaskPB;
        })();

        protobuf.RoleChatPB = (function() {

            /**
             * Properties of a RoleChatPB.
             * @memberof luck.protobuf
             * @interface IRoleChatPB
             * @property {number} startId RoleChatPB startId
             * @property {number} endId RoleChatPB endId
             */

            /**
             * Constructs a new RoleChatPB.
             * @memberof luck.protobuf
             * @classdesc Represents a RoleChatPB.
             * @implements IRoleChatPB
             * @constructor
             * @param {luck.protobuf.IRoleChatPB=} [properties] Properties to set
             */
            function RoleChatPB(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RoleChatPB startId.
             * @member {number} startId
             * @memberof luck.protobuf.RoleChatPB
             * @instance
             */
            RoleChatPB.prototype.startId = 0;

            /**
             * RoleChatPB endId.
             * @member {number} endId
             * @memberof luck.protobuf.RoleChatPB
             * @instance
             */
            RoleChatPB.prototype.endId = 0;

            /**
             * Creates a new RoleChatPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.RoleChatPB
             * @static
             * @param {luck.protobuf.IRoleChatPB=} [properties] Properties to set
             * @returns {luck.protobuf.RoleChatPB} RoleChatPB instance
             */
            RoleChatPB.create = function create(properties) {
                return new RoleChatPB(properties);
            };

            /**
             * Encodes the specified RoleChatPB message. Does not implicitly {@link luck.protobuf.RoleChatPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.RoleChatPB
             * @static
             * @param {luck.protobuf.IRoleChatPB} message RoleChatPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RoleChatPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.startId);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.endId);
                return writer;
            };

            /**
             * Encodes the specified RoleChatPB message, length delimited. Does not implicitly {@link luck.protobuf.RoleChatPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.RoleChatPB
             * @static
             * @param {luck.protobuf.IRoleChatPB} message RoleChatPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RoleChatPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RoleChatPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.RoleChatPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.RoleChatPB} RoleChatPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RoleChatPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.RoleChatPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.startId = reader.int32();
                        break;
                    case 2:
                        message.endId = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("startId"))
                    throw $util.ProtocolError("missing required 'startId'", { instance: message });
                if (!message.hasOwnProperty("endId"))
                    throw $util.ProtocolError("missing required 'endId'", { instance: message });
                return message;
            };

            /**
             * Decodes a RoleChatPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.RoleChatPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.RoleChatPB} RoleChatPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RoleChatPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RoleChatPB message.
             * @function verify
             * @memberof luck.protobuf.RoleChatPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RoleChatPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.startId))
                    return "startId: integer expected";
                if (!$util.isInteger(message.endId))
                    return "endId: integer expected";
                return null;
            };

            return RoleChatPB;
        })();

        protobuf.GameBulletDataPB = (function() {

            /**
             * Properties of a GameBulletDataPB.
             * @memberof luck.protobuf
             * @interface IGameBulletDataPB
             * @property {number} RandomFameNumber GameBulletDataPB RandomFameNumber
             * @property {number} CurrFame GameBulletDataPB CurrFame
             * @property {Array.<luck.protobuf.IBattleBulletPB>|null} [battleBulletPb] GameBulletDataPB battleBulletPb
             * @property {Array.<luck.protobuf.IBattleRolePB>|null} [battleRolePb] GameBulletDataPB battleRolePb
             * @property {Array.<luck.protobuf.IBattleMonsterPB>|null} [battleMonsterPb] GameBulletDataPB battleMonsterPb
             */

            /**
             * Constructs a new GameBulletDataPB.
             * @memberof luck.protobuf
             * @classdesc Represents a GameBulletDataPB.
             * @implements IGameBulletDataPB
             * @constructor
             * @param {luck.protobuf.IGameBulletDataPB=} [properties] Properties to set
             */
            function GameBulletDataPB(properties) {
                this.battleBulletPb = [];
                this.battleRolePb = [];
                this.battleMonsterPb = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GameBulletDataPB RandomFameNumber.
             * @member {number} RandomFameNumber
             * @memberof luck.protobuf.GameBulletDataPB
             * @instance
             */
            GameBulletDataPB.prototype.RandomFameNumber = 0;

            /**
             * GameBulletDataPB CurrFame.
             * @member {number} CurrFame
             * @memberof luck.protobuf.GameBulletDataPB
             * @instance
             */
            GameBulletDataPB.prototype.CurrFame = 0;

            /**
             * GameBulletDataPB battleBulletPb.
             * @member {Array.<luck.protobuf.IBattleBulletPB>} battleBulletPb
             * @memberof luck.protobuf.GameBulletDataPB
             * @instance
             */
            GameBulletDataPB.prototype.battleBulletPb = $util.emptyArray;

            /**
             * GameBulletDataPB battleRolePb.
             * @member {Array.<luck.protobuf.IBattleRolePB>} battleRolePb
             * @memberof luck.protobuf.GameBulletDataPB
             * @instance
             */
            GameBulletDataPB.prototype.battleRolePb = $util.emptyArray;

            /**
             * GameBulletDataPB battleMonsterPb.
             * @member {Array.<luck.protobuf.IBattleMonsterPB>} battleMonsterPb
             * @memberof luck.protobuf.GameBulletDataPB
             * @instance
             */
            GameBulletDataPB.prototype.battleMonsterPb = $util.emptyArray;

            /**
             * Creates a new GameBulletDataPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.GameBulletDataPB
             * @static
             * @param {luck.protobuf.IGameBulletDataPB=} [properties] Properties to set
             * @returns {luck.protobuf.GameBulletDataPB} GameBulletDataPB instance
             */
            GameBulletDataPB.create = function create(properties) {
                return new GameBulletDataPB(properties);
            };

            /**
             * Encodes the specified GameBulletDataPB message. Does not implicitly {@link luck.protobuf.GameBulletDataPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.GameBulletDataPB
             * @static
             * @param {luck.protobuf.IGameBulletDataPB} message GameBulletDataPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GameBulletDataPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.RandomFameNumber);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.CurrFame);
                if (message.battleBulletPb != null && message.battleBulletPb.length)
                    for (var i = 0; i < message.battleBulletPb.length; ++i)
                        $root.luck.protobuf.BattleBulletPB.encode(message.battleBulletPb[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.battleRolePb != null && message.battleRolePb.length)
                    for (var i = 0; i < message.battleRolePb.length; ++i)
                        $root.luck.protobuf.BattleRolePB.encode(message.battleRolePb[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.battleMonsterPb != null && message.battleMonsterPb.length)
                    for (var i = 0; i < message.battleMonsterPb.length; ++i)
                        $root.luck.protobuf.BattleMonsterPB.encode(message.battleMonsterPb[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GameBulletDataPB message, length delimited. Does not implicitly {@link luck.protobuf.GameBulletDataPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.GameBulletDataPB
             * @static
             * @param {luck.protobuf.IGameBulletDataPB} message GameBulletDataPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GameBulletDataPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GameBulletDataPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.GameBulletDataPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.GameBulletDataPB} GameBulletDataPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GameBulletDataPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.GameBulletDataPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.RandomFameNumber = reader.int32();
                        break;
                    case 2:
                        message.CurrFame = reader.int32();
                        break;
                    case 3:
                        if (!(message.battleBulletPb && message.battleBulletPb.length))
                            message.battleBulletPb = [];
                        message.battleBulletPb.push($root.luck.protobuf.BattleBulletPB.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        if (!(message.battleRolePb && message.battleRolePb.length))
                            message.battleRolePb = [];
                        message.battleRolePb.push($root.luck.protobuf.BattleRolePB.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.battleMonsterPb && message.battleMonsterPb.length))
                            message.battleMonsterPb = [];
                        message.battleMonsterPb.push($root.luck.protobuf.BattleMonsterPB.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("RandomFameNumber"))
                    throw $util.ProtocolError("missing required 'RandomFameNumber'", { instance: message });
                if (!message.hasOwnProperty("CurrFame"))
                    throw $util.ProtocolError("missing required 'CurrFame'", { instance: message });
                return message;
            };

            /**
             * Decodes a GameBulletDataPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.GameBulletDataPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.GameBulletDataPB} GameBulletDataPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GameBulletDataPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GameBulletDataPB message.
             * @function verify
             * @memberof luck.protobuf.GameBulletDataPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GameBulletDataPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.RandomFameNumber))
                    return "RandomFameNumber: integer expected";
                if (!$util.isInteger(message.CurrFame))
                    return "CurrFame: integer expected";
                if (message.battleBulletPb != null && message.hasOwnProperty("battleBulletPb")) {
                    if (!Array.isArray(message.battleBulletPb))
                        return "battleBulletPb: array expected";
                    for (var i = 0; i < message.battleBulletPb.length; ++i) {
                        var error = $root.luck.protobuf.BattleBulletPB.verify(message.battleBulletPb[i]);
                        if (error)
                            return "battleBulletPb." + error;
                    }
                }
                if (message.battleRolePb != null && message.hasOwnProperty("battleRolePb")) {
                    if (!Array.isArray(message.battleRolePb))
                        return "battleRolePb: array expected";
                    for (var i = 0; i < message.battleRolePb.length; ++i) {
                        var error = $root.luck.protobuf.BattleRolePB.verify(message.battleRolePb[i]);
                        if (error)
                            return "battleRolePb." + error;
                    }
                }
                if (message.battleMonsterPb != null && message.hasOwnProperty("battleMonsterPb")) {
                    if (!Array.isArray(message.battleMonsterPb))
                        return "battleMonsterPb: array expected";
                    for (var i = 0; i < message.battleMonsterPb.length; ++i) {
                        var error = $root.luck.protobuf.BattleMonsterPB.verify(message.battleMonsterPb[i]);
                        if (error)
                            return "battleMonsterPb." + error;
                    }
                }
                return null;
            };

            return GameBulletDataPB;
        })();

        protobuf.BattleBulletPB = (function() {

            /**
             * Properties of a BattleBulletPB.
             * @memberof luck.protobuf
             * @interface IBattleBulletPB
             * @property {number} campeID BattleBulletPB campeID
             * @property {number} bulletID BattleBulletPB bulletID
             * @property {number} StartPosX BattleBulletPB StartPosX
             * @property {number} StartPosY BattleBulletPB StartPosY
             * @property {number} StartPosZ BattleBulletPB StartPosZ
             * @property {number} AngleX BattleBulletPB AngleX
             * @property {number} AngleY BattleBulletPB AngleY
             * @property {number} AngleZ BattleBulletPB AngleZ
             * @property {number} PosX BattleBulletPB PosX
             * @property {number} PosY BattleBulletPB PosY
             * @property {number} PosZ BattleBulletPB PosZ
             * @property {number} damageType BattleBulletPB damageType
             * @property {number} Dir BattleBulletPB Dir
             * @property {number} Speed BattleBulletPB Speed
             * @property {number} BulletDestructionMethod BattleBulletPB BulletDestructionMethod
             * @property {boolean} AttackWay0 BattleBulletPB AttackWay0
             * @property {boolean} AttackWay1 BattleBulletPB AttackWay1
             * @property {number} AttackWayDis BattleBulletPB AttackWayDis
             * @property {number} PenetrationNuber BattleBulletPB PenetrationNuber
             * @property {Array.<number>|null} [targetList] BattleBulletPB targetList
             * @property {Array.<number>|null} [TargetTempList] BattleBulletPB TargetTempList
             * @property {boolean} CanUpdate BattleBulletPB CanUpdate
             * @property {number} BulletFlyCos BattleBulletPB BulletFlyCos
             * @property {number} timer BattleBulletPB timer
             * @property {number} hurtCalculate BattleBulletPB hurtCalculate
             * @property {number} buff_AttackAdd BattleBulletPB buff_AttackAdd
             * @property {number} attackhurtDist BattleBulletPB attackhurtDist
             * @property {number} AttackRolePosZ BattleBulletPB AttackRolePosZ
             * @property {number} attackRoleLevel BattleBulletPB attackRoleLevel
             * @property {number} attackRoleNoPropertyPower BattleBulletPB attackRoleNoPropertyPower
             * @property {number} attackRoleIcePropertyPower BattleBulletPB attackRoleIcePropertyPower
             * @property {number} attackRoleFirePropertyPower BattleBulletPB attackRoleFirePropertyPower
             * @property {number} attackRoleElectricPropertyPower BattleBulletPB attackRoleElectricPropertyPower
             * @property {number} attackRoleLandPropertyPower BattleBulletPB attackRoleLandPropertyPower
             * @property {number} attackRolePoisonPropertyPower BattleBulletPB attackRolePoisonPropertyPower
             * @property {number} attackRoleLightPropertyPower BattleBulletPB attackRoleLightPropertyPower
             * @property {number} attackRoleDarkPropertyPower BattleBulletPB attackRoleDarkPropertyPower
             * @property {number} attackRoleAttackPropertyHurt BattleBulletPB attackRoleAttackPropertyHurt
             * @property {number} attackRoleIcePropertyHurt BattleBulletPB attackRoleIcePropertyHurt
             * @property {number} attackRoleFirePropertyHurt BattleBulletPB attackRoleFirePropertyHurt
             * @property {number} attackRoleElectricPropertyHurt BattleBulletPB attackRoleElectricPropertyHurt
             * @property {number} attackRoleLandPropertyHurt BattleBulletPB attackRoleLandPropertyHurt
             * @property {number} attackRolePoisonPropertyHurt BattleBulletPB attackRolePoisonPropertyHurt
             * @property {number} attackRoleLightPropertyHurt BattleBulletPB attackRoleLightPropertyHurt
             * @property {number} attackRoleDarkPropertyHurt BattleBulletPB attackRoleDarkPropertyHurt
             * @property {number} attackRoleHitRate BattleBulletPB attackRoleHitRate
             * @property {number} attackRoleCri BattleBulletPB attackRoleCri
             * @property {number} attackRoleCriStrength BattleBulletPB attackRoleCriStrength
             * @property {number} bulletType BattleBulletPB bulletType
             * @property {luck.protobuf.IBattleBulletDataPB} bulletDataPb BattleBulletPB bulletDataPb
             */

            /**
             * Constructs a new BattleBulletPB.
             * @memberof luck.protobuf
             * @classdesc Represents a BattleBulletPB.
             * @implements IBattleBulletPB
             * @constructor
             * @param {luck.protobuf.IBattleBulletPB=} [properties] Properties to set
             */
            function BattleBulletPB(properties) {
                this.targetList = [];
                this.TargetTempList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BattleBulletPB campeID.
             * @member {number} campeID
             * @memberof luck.protobuf.BattleBulletPB
             * @instance
             */
            BattleBulletPB.prototype.campeID = 0;

            /**
             * BattleBulletPB bulletID.
             * @member {number} bulletID
             * @memberof luck.protobuf.BattleBulletPB
             * @instance
             */
            BattleBulletPB.prototype.bulletID = 0;

            /**
             * BattleBulletPB StartPosX.
             * @member {number} StartPosX
             * @memberof luck.protobuf.BattleBulletPB
             * @instance
             */
            BattleBulletPB.prototype.StartPosX = 0;

            /**
             * BattleBulletPB StartPosY.
             * @member {number} StartPosY
             * @memberof luck.protobuf.BattleBulletPB
             * @instance
             */
            BattleBulletPB.prototype.StartPosY = 0;

            /**
             * BattleBulletPB StartPosZ.
             * @member {number} StartPosZ
             * @memberof luck.protobuf.BattleBulletPB
             * @instance
             */
            BattleBulletPB.prototype.StartPosZ = 0;

            /**
             * BattleBulletPB AngleX.
             * @member {number} AngleX
             * @memberof luck.protobuf.BattleBulletPB
             * @instance
             */
            BattleBulletPB.prototype.AngleX = 0;

            /**
             * BattleBulletPB AngleY.
             * @member {number} AngleY
             * @memberof luck.protobuf.BattleBulletPB
             * @instance
             */
            BattleBulletPB.prototype.AngleY = 0;

            /**
             * BattleBulletPB AngleZ.
             * @member {number} AngleZ
             * @memberof luck.protobuf.BattleBulletPB
             * @instance
             */
            BattleBulletPB.prototype.AngleZ = 0;

            /**
             * BattleBulletPB PosX.
             * @member {number} PosX
             * @memberof luck.protobuf.BattleBulletPB
             * @instance
             */
            BattleBulletPB.prototype.PosX = 0;

            /**
             * BattleBulletPB PosY.
             * @member {number} PosY
             * @memberof luck.protobuf.BattleBulletPB
             * @instance
             */
            BattleBulletPB.prototype.PosY = 0;

            /**
             * BattleBulletPB PosZ.
             * @member {number} PosZ
             * @memberof luck.protobuf.BattleBulletPB
             * @instance
             */
            BattleBulletPB.prototype.PosZ = 0;

            /**
             * BattleBulletPB damageType.
             * @member {number} damageType
             * @memberof luck.protobuf.BattleBulletPB
             * @instance
             */
            BattleBulletPB.prototype.damageType = 0;

            /**
             * BattleBulletPB Dir.
             * @member {number} Dir
             * @memberof luck.protobuf.BattleBulletPB
             * @instance
             */
            BattleBulletPB.prototype.Dir = 0;

            /**
             * BattleBulletPB Speed.
             * @member {number} Speed
             * @memberof luck.protobuf.BattleBulletPB
             * @instance
             */
            BattleBulletPB.prototype.Speed = 0;

            /**
             * BattleBulletPB BulletDestructionMethod.
             * @member {number} BulletDestructionMethod
             * @memberof luck.protobuf.BattleBulletPB
             * @instance
             */
            BattleBulletPB.prototype.BulletDestructionMethod = 0;

            /**
             * BattleBulletPB AttackWay0.
             * @member {boolean} AttackWay0
             * @memberof luck.protobuf.BattleBulletPB
             * @instance
             */
            BattleBulletPB.prototype.AttackWay0 = false;

            /**
             * BattleBulletPB AttackWay1.
             * @member {boolean} AttackWay1
             * @memberof luck.protobuf.BattleBulletPB
             * @instance
             */
            BattleBulletPB.prototype.AttackWay1 = false;

            /**
             * BattleBulletPB AttackWayDis.
             * @member {number} AttackWayDis
             * @memberof luck.protobuf.BattleBulletPB
             * @instance
             */
            BattleBulletPB.prototype.AttackWayDis = 0;

            /**
             * BattleBulletPB PenetrationNuber.
             * @member {number} PenetrationNuber
             * @memberof luck.protobuf.BattleBulletPB
             * @instance
             */
            BattleBulletPB.prototype.PenetrationNuber = 0;

            /**
             * BattleBulletPB targetList.
             * @member {Array.<number>} targetList
             * @memberof luck.protobuf.BattleBulletPB
             * @instance
             */
            BattleBulletPB.prototype.targetList = $util.emptyArray;

            /**
             * BattleBulletPB TargetTempList.
             * @member {Array.<number>} TargetTempList
             * @memberof luck.protobuf.BattleBulletPB
             * @instance
             */
            BattleBulletPB.prototype.TargetTempList = $util.emptyArray;

            /**
             * BattleBulletPB CanUpdate.
             * @member {boolean} CanUpdate
             * @memberof luck.protobuf.BattleBulletPB
             * @instance
             */
            BattleBulletPB.prototype.CanUpdate = false;

            /**
             * BattleBulletPB BulletFlyCos.
             * @member {number} BulletFlyCos
             * @memberof luck.protobuf.BattleBulletPB
             * @instance
             */
            BattleBulletPB.prototype.BulletFlyCos = 0;

            /**
             * BattleBulletPB timer.
             * @member {number} timer
             * @memberof luck.protobuf.BattleBulletPB
             * @instance
             */
            BattleBulletPB.prototype.timer = 0;

            /**
             * BattleBulletPB hurtCalculate.
             * @member {number} hurtCalculate
             * @memberof luck.protobuf.BattleBulletPB
             * @instance
             */
            BattleBulletPB.prototype.hurtCalculate = 0;

            /**
             * BattleBulletPB buff_AttackAdd.
             * @member {number} buff_AttackAdd
             * @memberof luck.protobuf.BattleBulletPB
             * @instance
             */
            BattleBulletPB.prototype.buff_AttackAdd = 0;

            /**
             * BattleBulletPB attackhurtDist.
             * @member {number} attackhurtDist
             * @memberof luck.protobuf.BattleBulletPB
             * @instance
             */
            BattleBulletPB.prototype.attackhurtDist = 0;

            /**
             * BattleBulletPB AttackRolePosZ.
             * @member {number} AttackRolePosZ
             * @memberof luck.protobuf.BattleBulletPB
             * @instance
             */
            BattleBulletPB.prototype.AttackRolePosZ = 0;

            /**
             * BattleBulletPB attackRoleLevel.
             * @member {number} attackRoleLevel
             * @memberof luck.protobuf.BattleBulletPB
             * @instance
             */
            BattleBulletPB.prototype.attackRoleLevel = 0;

            /**
             * BattleBulletPB attackRoleNoPropertyPower.
             * @member {number} attackRoleNoPropertyPower
             * @memberof luck.protobuf.BattleBulletPB
             * @instance
             */
            BattleBulletPB.prototype.attackRoleNoPropertyPower = 0;

            /**
             * BattleBulletPB attackRoleIcePropertyPower.
             * @member {number} attackRoleIcePropertyPower
             * @memberof luck.protobuf.BattleBulletPB
             * @instance
             */
            BattleBulletPB.prototype.attackRoleIcePropertyPower = 0;

            /**
             * BattleBulletPB attackRoleFirePropertyPower.
             * @member {number} attackRoleFirePropertyPower
             * @memberof luck.protobuf.BattleBulletPB
             * @instance
             */
            BattleBulletPB.prototype.attackRoleFirePropertyPower = 0;

            /**
             * BattleBulletPB attackRoleElectricPropertyPower.
             * @member {number} attackRoleElectricPropertyPower
             * @memberof luck.protobuf.BattleBulletPB
             * @instance
             */
            BattleBulletPB.prototype.attackRoleElectricPropertyPower = 0;

            /**
             * BattleBulletPB attackRoleLandPropertyPower.
             * @member {number} attackRoleLandPropertyPower
             * @memberof luck.protobuf.BattleBulletPB
             * @instance
             */
            BattleBulletPB.prototype.attackRoleLandPropertyPower = 0;

            /**
             * BattleBulletPB attackRolePoisonPropertyPower.
             * @member {number} attackRolePoisonPropertyPower
             * @memberof luck.protobuf.BattleBulletPB
             * @instance
             */
            BattleBulletPB.prototype.attackRolePoisonPropertyPower = 0;

            /**
             * BattleBulletPB attackRoleLightPropertyPower.
             * @member {number} attackRoleLightPropertyPower
             * @memberof luck.protobuf.BattleBulletPB
             * @instance
             */
            BattleBulletPB.prototype.attackRoleLightPropertyPower = 0;

            /**
             * BattleBulletPB attackRoleDarkPropertyPower.
             * @member {number} attackRoleDarkPropertyPower
             * @memberof luck.protobuf.BattleBulletPB
             * @instance
             */
            BattleBulletPB.prototype.attackRoleDarkPropertyPower = 0;

            /**
             * BattleBulletPB attackRoleAttackPropertyHurt.
             * @member {number} attackRoleAttackPropertyHurt
             * @memberof luck.protobuf.BattleBulletPB
             * @instance
             */
            BattleBulletPB.prototype.attackRoleAttackPropertyHurt = 0;

            /**
             * BattleBulletPB attackRoleIcePropertyHurt.
             * @member {number} attackRoleIcePropertyHurt
             * @memberof luck.protobuf.BattleBulletPB
             * @instance
             */
            BattleBulletPB.prototype.attackRoleIcePropertyHurt = 0;

            /**
             * BattleBulletPB attackRoleFirePropertyHurt.
             * @member {number} attackRoleFirePropertyHurt
             * @memberof luck.protobuf.BattleBulletPB
             * @instance
             */
            BattleBulletPB.prototype.attackRoleFirePropertyHurt = 0;

            /**
             * BattleBulletPB attackRoleElectricPropertyHurt.
             * @member {number} attackRoleElectricPropertyHurt
             * @memberof luck.protobuf.BattleBulletPB
             * @instance
             */
            BattleBulletPB.prototype.attackRoleElectricPropertyHurt = 0;

            /**
             * BattleBulletPB attackRoleLandPropertyHurt.
             * @member {number} attackRoleLandPropertyHurt
             * @memberof luck.protobuf.BattleBulletPB
             * @instance
             */
            BattleBulletPB.prototype.attackRoleLandPropertyHurt = 0;

            /**
             * BattleBulletPB attackRolePoisonPropertyHurt.
             * @member {number} attackRolePoisonPropertyHurt
             * @memberof luck.protobuf.BattleBulletPB
             * @instance
             */
            BattleBulletPB.prototype.attackRolePoisonPropertyHurt = 0;

            /**
             * BattleBulletPB attackRoleLightPropertyHurt.
             * @member {number} attackRoleLightPropertyHurt
             * @memberof luck.protobuf.BattleBulletPB
             * @instance
             */
            BattleBulletPB.prototype.attackRoleLightPropertyHurt = 0;

            /**
             * BattleBulletPB attackRoleDarkPropertyHurt.
             * @member {number} attackRoleDarkPropertyHurt
             * @memberof luck.protobuf.BattleBulletPB
             * @instance
             */
            BattleBulletPB.prototype.attackRoleDarkPropertyHurt = 0;

            /**
             * BattleBulletPB attackRoleHitRate.
             * @member {number} attackRoleHitRate
             * @memberof luck.protobuf.BattleBulletPB
             * @instance
             */
            BattleBulletPB.prototype.attackRoleHitRate = 0;

            /**
             * BattleBulletPB attackRoleCri.
             * @member {number} attackRoleCri
             * @memberof luck.protobuf.BattleBulletPB
             * @instance
             */
            BattleBulletPB.prototype.attackRoleCri = 0;

            /**
             * BattleBulletPB attackRoleCriStrength.
             * @member {number} attackRoleCriStrength
             * @memberof luck.protobuf.BattleBulletPB
             * @instance
             */
            BattleBulletPB.prototype.attackRoleCriStrength = 0;

            /**
             * BattleBulletPB bulletType.
             * @member {number} bulletType
             * @memberof luck.protobuf.BattleBulletPB
             * @instance
             */
            BattleBulletPB.prototype.bulletType = 0;

            /**
             * BattleBulletPB bulletDataPb.
             * @member {luck.protobuf.IBattleBulletDataPB} bulletDataPb
             * @memberof luck.protobuf.BattleBulletPB
             * @instance
             */
            BattleBulletPB.prototype.bulletDataPb = null;

            /**
             * Creates a new BattleBulletPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.BattleBulletPB
             * @static
             * @param {luck.protobuf.IBattleBulletPB=} [properties] Properties to set
             * @returns {luck.protobuf.BattleBulletPB} BattleBulletPB instance
             */
            BattleBulletPB.create = function create(properties) {
                return new BattleBulletPB(properties);
            };

            /**
             * Encodes the specified BattleBulletPB message. Does not implicitly {@link luck.protobuf.BattleBulletPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.BattleBulletPB
             * @static
             * @param {luck.protobuf.IBattleBulletPB} message BattleBulletPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BattleBulletPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.campeID);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.bulletID);
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.StartPosX);
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.StartPosY);
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.StartPosZ);
                writer.uint32(/* id 6, wireType 5 =*/53).float(message.AngleX);
                writer.uint32(/* id 7, wireType 5 =*/61).float(message.AngleY);
                writer.uint32(/* id 8, wireType 5 =*/69).float(message.AngleZ);
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.PosX);
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.PosY);
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.PosZ);
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.damageType);
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.Dir);
                writer.uint32(/* id 14, wireType 5 =*/117).float(message.Speed);
                writer.uint32(/* id 15, wireType 0 =*/120).int32(message.BulletDestructionMethod);
                writer.uint32(/* id 16, wireType 0 =*/128).bool(message.AttackWay0);
                writer.uint32(/* id 17, wireType 0 =*/136).bool(message.AttackWay1);
                writer.uint32(/* id 18, wireType 0 =*/144).int32(message.AttackWayDis);
                writer.uint32(/* id 19, wireType 0 =*/152).int32(message.PenetrationNuber);
                if (message.targetList != null && message.targetList.length)
                    for (var i = 0; i < message.targetList.length; ++i)
                        writer.uint32(/* id 20, wireType 0 =*/160).int32(message.targetList[i]);
                if (message.TargetTempList != null && message.TargetTempList.length)
                    for (var i = 0; i < message.TargetTempList.length; ++i)
                        writer.uint32(/* id 21, wireType 0 =*/168).int32(message.TargetTempList[i]);
                writer.uint32(/* id 22, wireType 0 =*/176).bool(message.CanUpdate);
                writer.uint32(/* id 23, wireType 0 =*/184).int32(message.BulletFlyCos);
                writer.uint32(/* id 24, wireType 0 =*/192).int32(message.timer);
                writer.uint32(/* id 25, wireType 0 =*/200).int32(message.hurtCalculate);
                writer.uint32(/* id 26, wireType 5 =*/213).float(message.buff_AttackAdd);
                writer.uint32(/* id 27, wireType 0 =*/216).int32(message.attackhurtDist);
                writer.uint32(/* id 28, wireType 0 =*/224).int32(message.AttackRolePosZ);
                writer.uint32(/* id 29, wireType 0 =*/232).int32(message.attackRoleLevel);
                writer.uint32(/* id 30, wireType 5 =*/245).float(message.attackRoleNoPropertyPower);
                writer.uint32(/* id 31, wireType 5 =*/253).float(message.attackRoleIcePropertyPower);
                writer.uint32(/* id 32, wireType 5 =*/261).float(message.attackRoleFirePropertyPower);
                writer.uint32(/* id 33, wireType 5 =*/269).float(message.attackRoleElectricPropertyPower);
                writer.uint32(/* id 34, wireType 5 =*/277).float(message.attackRoleLandPropertyPower);
                writer.uint32(/* id 35, wireType 5 =*/285).float(message.attackRolePoisonPropertyPower);
                writer.uint32(/* id 36, wireType 5 =*/293).float(message.attackRoleLightPropertyPower);
                writer.uint32(/* id 37, wireType 5 =*/301).float(message.attackRoleDarkPropertyPower);
                writer.uint32(/* id 38, wireType 5 =*/309).float(message.attackRoleAttackPropertyHurt);
                writer.uint32(/* id 39, wireType 5 =*/317).float(message.attackRoleIcePropertyHurt);
                writer.uint32(/* id 40, wireType 5 =*/325).float(message.attackRoleFirePropertyHurt);
                writer.uint32(/* id 41, wireType 5 =*/333).float(message.attackRoleElectricPropertyHurt);
                writer.uint32(/* id 42, wireType 5 =*/341).float(message.attackRoleLandPropertyHurt);
                writer.uint32(/* id 43, wireType 5 =*/349).float(message.attackRolePoisonPropertyHurt);
                writer.uint32(/* id 44, wireType 5 =*/357).float(message.attackRoleLightPropertyHurt);
                writer.uint32(/* id 45, wireType 5 =*/365).float(message.attackRoleDarkPropertyHurt);
                writer.uint32(/* id 46, wireType 5 =*/373).float(message.attackRoleHitRate);
                writer.uint32(/* id 47, wireType 5 =*/381).float(message.attackRoleCri);
                writer.uint32(/* id 48, wireType 5 =*/389).float(message.attackRoleCriStrength);
                writer.uint32(/* id 49, wireType 0 =*/392).int32(message.bulletType);
                $root.luck.protobuf.BattleBulletDataPB.encode(message.bulletDataPb, writer.uint32(/* id 50, wireType 2 =*/402).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified BattleBulletPB message, length delimited. Does not implicitly {@link luck.protobuf.BattleBulletPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.BattleBulletPB
             * @static
             * @param {luck.protobuf.IBattleBulletPB} message BattleBulletPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BattleBulletPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BattleBulletPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.BattleBulletPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.BattleBulletPB} BattleBulletPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BattleBulletPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.BattleBulletPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.campeID = reader.int32();
                        break;
                    case 2:
                        message.bulletID = reader.int32();
                        break;
                    case 3:
                        message.StartPosX = reader.int32();
                        break;
                    case 4:
                        message.StartPosY = reader.int32();
                        break;
                    case 5:
                        message.StartPosZ = reader.int32();
                        break;
                    case 6:
                        message.AngleX = reader.float();
                        break;
                    case 7:
                        message.AngleY = reader.float();
                        break;
                    case 8:
                        message.AngleZ = reader.float();
                        break;
                    case 9:
                        message.PosX = reader.int32();
                        break;
                    case 10:
                        message.PosY = reader.int32();
                        break;
                    case 11:
                        message.PosZ = reader.int32();
                        break;
                    case 12:
                        message.damageType = reader.int32();
                        break;
                    case 13:
                        message.Dir = reader.int32();
                        break;
                    case 14:
                        message.Speed = reader.float();
                        break;
                    case 15:
                        message.BulletDestructionMethod = reader.int32();
                        break;
                    case 16:
                        message.AttackWay0 = reader.bool();
                        break;
                    case 17:
                        message.AttackWay1 = reader.bool();
                        break;
                    case 18:
                        message.AttackWayDis = reader.int32();
                        break;
                    case 19:
                        message.PenetrationNuber = reader.int32();
                        break;
                    case 20:
                        if (!(message.targetList && message.targetList.length))
                            message.targetList = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.targetList.push(reader.int32());
                        } else
                            message.targetList.push(reader.int32());
                        break;
                    case 21:
                        if (!(message.TargetTempList && message.TargetTempList.length))
                            message.TargetTempList = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.TargetTempList.push(reader.int32());
                        } else
                            message.TargetTempList.push(reader.int32());
                        break;
                    case 22:
                        message.CanUpdate = reader.bool();
                        break;
                    case 23:
                        message.BulletFlyCos = reader.int32();
                        break;
                    case 24:
                        message.timer = reader.int32();
                        break;
                    case 25:
                        message.hurtCalculate = reader.int32();
                        break;
                    case 26:
                        message.buff_AttackAdd = reader.float();
                        break;
                    case 27:
                        message.attackhurtDist = reader.int32();
                        break;
                    case 28:
                        message.AttackRolePosZ = reader.int32();
                        break;
                    case 29:
                        message.attackRoleLevel = reader.int32();
                        break;
                    case 30:
                        message.attackRoleNoPropertyPower = reader.float();
                        break;
                    case 31:
                        message.attackRoleIcePropertyPower = reader.float();
                        break;
                    case 32:
                        message.attackRoleFirePropertyPower = reader.float();
                        break;
                    case 33:
                        message.attackRoleElectricPropertyPower = reader.float();
                        break;
                    case 34:
                        message.attackRoleLandPropertyPower = reader.float();
                        break;
                    case 35:
                        message.attackRolePoisonPropertyPower = reader.float();
                        break;
                    case 36:
                        message.attackRoleLightPropertyPower = reader.float();
                        break;
                    case 37:
                        message.attackRoleDarkPropertyPower = reader.float();
                        break;
                    case 38:
                        message.attackRoleAttackPropertyHurt = reader.float();
                        break;
                    case 39:
                        message.attackRoleIcePropertyHurt = reader.float();
                        break;
                    case 40:
                        message.attackRoleFirePropertyHurt = reader.float();
                        break;
                    case 41:
                        message.attackRoleElectricPropertyHurt = reader.float();
                        break;
                    case 42:
                        message.attackRoleLandPropertyHurt = reader.float();
                        break;
                    case 43:
                        message.attackRolePoisonPropertyHurt = reader.float();
                        break;
                    case 44:
                        message.attackRoleLightPropertyHurt = reader.float();
                        break;
                    case 45:
                        message.attackRoleDarkPropertyHurt = reader.float();
                        break;
                    case 46:
                        message.attackRoleHitRate = reader.float();
                        break;
                    case 47:
                        message.attackRoleCri = reader.float();
                        break;
                    case 48:
                        message.attackRoleCriStrength = reader.float();
                        break;
                    case 49:
                        message.bulletType = reader.int32();
                        break;
                    case 50:
                        message.bulletDataPb = $root.luck.protobuf.BattleBulletDataPB.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("campeID"))
                    throw $util.ProtocolError("missing required 'campeID'", { instance: message });
                if (!message.hasOwnProperty("bulletID"))
                    throw $util.ProtocolError("missing required 'bulletID'", { instance: message });
                if (!message.hasOwnProperty("StartPosX"))
                    throw $util.ProtocolError("missing required 'StartPosX'", { instance: message });
                if (!message.hasOwnProperty("StartPosY"))
                    throw $util.ProtocolError("missing required 'StartPosY'", { instance: message });
                if (!message.hasOwnProperty("StartPosZ"))
                    throw $util.ProtocolError("missing required 'StartPosZ'", { instance: message });
                if (!message.hasOwnProperty("AngleX"))
                    throw $util.ProtocolError("missing required 'AngleX'", { instance: message });
                if (!message.hasOwnProperty("AngleY"))
                    throw $util.ProtocolError("missing required 'AngleY'", { instance: message });
                if (!message.hasOwnProperty("AngleZ"))
                    throw $util.ProtocolError("missing required 'AngleZ'", { instance: message });
                if (!message.hasOwnProperty("PosX"))
                    throw $util.ProtocolError("missing required 'PosX'", { instance: message });
                if (!message.hasOwnProperty("PosY"))
                    throw $util.ProtocolError("missing required 'PosY'", { instance: message });
                if (!message.hasOwnProperty("PosZ"))
                    throw $util.ProtocolError("missing required 'PosZ'", { instance: message });
                if (!message.hasOwnProperty("damageType"))
                    throw $util.ProtocolError("missing required 'damageType'", { instance: message });
                if (!message.hasOwnProperty("Dir"))
                    throw $util.ProtocolError("missing required 'Dir'", { instance: message });
                if (!message.hasOwnProperty("Speed"))
                    throw $util.ProtocolError("missing required 'Speed'", { instance: message });
                if (!message.hasOwnProperty("BulletDestructionMethod"))
                    throw $util.ProtocolError("missing required 'BulletDestructionMethod'", { instance: message });
                if (!message.hasOwnProperty("AttackWay0"))
                    throw $util.ProtocolError("missing required 'AttackWay0'", { instance: message });
                if (!message.hasOwnProperty("AttackWay1"))
                    throw $util.ProtocolError("missing required 'AttackWay1'", { instance: message });
                if (!message.hasOwnProperty("AttackWayDis"))
                    throw $util.ProtocolError("missing required 'AttackWayDis'", { instance: message });
                if (!message.hasOwnProperty("PenetrationNuber"))
                    throw $util.ProtocolError("missing required 'PenetrationNuber'", { instance: message });
                if (!message.hasOwnProperty("CanUpdate"))
                    throw $util.ProtocolError("missing required 'CanUpdate'", { instance: message });
                if (!message.hasOwnProperty("BulletFlyCos"))
                    throw $util.ProtocolError("missing required 'BulletFlyCos'", { instance: message });
                if (!message.hasOwnProperty("timer"))
                    throw $util.ProtocolError("missing required 'timer'", { instance: message });
                if (!message.hasOwnProperty("hurtCalculate"))
                    throw $util.ProtocolError("missing required 'hurtCalculate'", { instance: message });
                if (!message.hasOwnProperty("buff_AttackAdd"))
                    throw $util.ProtocolError("missing required 'buff_AttackAdd'", { instance: message });
                if (!message.hasOwnProperty("attackhurtDist"))
                    throw $util.ProtocolError("missing required 'attackhurtDist'", { instance: message });
                if (!message.hasOwnProperty("AttackRolePosZ"))
                    throw $util.ProtocolError("missing required 'AttackRolePosZ'", { instance: message });
                if (!message.hasOwnProperty("attackRoleLevel"))
                    throw $util.ProtocolError("missing required 'attackRoleLevel'", { instance: message });
                if (!message.hasOwnProperty("attackRoleNoPropertyPower"))
                    throw $util.ProtocolError("missing required 'attackRoleNoPropertyPower'", { instance: message });
                if (!message.hasOwnProperty("attackRoleIcePropertyPower"))
                    throw $util.ProtocolError("missing required 'attackRoleIcePropertyPower'", { instance: message });
                if (!message.hasOwnProperty("attackRoleFirePropertyPower"))
                    throw $util.ProtocolError("missing required 'attackRoleFirePropertyPower'", { instance: message });
                if (!message.hasOwnProperty("attackRoleElectricPropertyPower"))
                    throw $util.ProtocolError("missing required 'attackRoleElectricPropertyPower'", { instance: message });
                if (!message.hasOwnProperty("attackRoleLandPropertyPower"))
                    throw $util.ProtocolError("missing required 'attackRoleLandPropertyPower'", { instance: message });
                if (!message.hasOwnProperty("attackRolePoisonPropertyPower"))
                    throw $util.ProtocolError("missing required 'attackRolePoisonPropertyPower'", { instance: message });
                if (!message.hasOwnProperty("attackRoleLightPropertyPower"))
                    throw $util.ProtocolError("missing required 'attackRoleLightPropertyPower'", { instance: message });
                if (!message.hasOwnProperty("attackRoleDarkPropertyPower"))
                    throw $util.ProtocolError("missing required 'attackRoleDarkPropertyPower'", { instance: message });
                if (!message.hasOwnProperty("attackRoleAttackPropertyHurt"))
                    throw $util.ProtocolError("missing required 'attackRoleAttackPropertyHurt'", { instance: message });
                if (!message.hasOwnProperty("attackRoleIcePropertyHurt"))
                    throw $util.ProtocolError("missing required 'attackRoleIcePropertyHurt'", { instance: message });
                if (!message.hasOwnProperty("attackRoleFirePropertyHurt"))
                    throw $util.ProtocolError("missing required 'attackRoleFirePropertyHurt'", { instance: message });
                if (!message.hasOwnProperty("attackRoleElectricPropertyHurt"))
                    throw $util.ProtocolError("missing required 'attackRoleElectricPropertyHurt'", { instance: message });
                if (!message.hasOwnProperty("attackRoleLandPropertyHurt"))
                    throw $util.ProtocolError("missing required 'attackRoleLandPropertyHurt'", { instance: message });
                if (!message.hasOwnProperty("attackRolePoisonPropertyHurt"))
                    throw $util.ProtocolError("missing required 'attackRolePoisonPropertyHurt'", { instance: message });
                if (!message.hasOwnProperty("attackRoleLightPropertyHurt"))
                    throw $util.ProtocolError("missing required 'attackRoleLightPropertyHurt'", { instance: message });
                if (!message.hasOwnProperty("attackRoleDarkPropertyHurt"))
                    throw $util.ProtocolError("missing required 'attackRoleDarkPropertyHurt'", { instance: message });
                if (!message.hasOwnProperty("attackRoleHitRate"))
                    throw $util.ProtocolError("missing required 'attackRoleHitRate'", { instance: message });
                if (!message.hasOwnProperty("attackRoleCri"))
                    throw $util.ProtocolError("missing required 'attackRoleCri'", { instance: message });
                if (!message.hasOwnProperty("attackRoleCriStrength"))
                    throw $util.ProtocolError("missing required 'attackRoleCriStrength'", { instance: message });
                if (!message.hasOwnProperty("bulletType"))
                    throw $util.ProtocolError("missing required 'bulletType'", { instance: message });
                if (!message.hasOwnProperty("bulletDataPb"))
                    throw $util.ProtocolError("missing required 'bulletDataPb'", { instance: message });
                return message;
            };

            /**
             * Decodes a BattleBulletPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.BattleBulletPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.BattleBulletPB} BattleBulletPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BattleBulletPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BattleBulletPB message.
             * @function verify
             * @memberof luck.protobuf.BattleBulletPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BattleBulletPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.campeID))
                    return "campeID: integer expected";
                if (!$util.isInteger(message.bulletID))
                    return "bulletID: integer expected";
                if (!$util.isInteger(message.StartPosX))
                    return "StartPosX: integer expected";
                if (!$util.isInteger(message.StartPosY))
                    return "StartPosY: integer expected";
                if (!$util.isInteger(message.StartPosZ))
                    return "StartPosZ: integer expected";
                if (typeof message.AngleX !== "number")
                    return "AngleX: number expected";
                if (typeof message.AngleY !== "number")
                    return "AngleY: number expected";
                if (typeof message.AngleZ !== "number")
                    return "AngleZ: number expected";
                if (!$util.isInteger(message.PosX))
                    return "PosX: integer expected";
                if (!$util.isInteger(message.PosY))
                    return "PosY: integer expected";
                if (!$util.isInteger(message.PosZ))
                    return "PosZ: integer expected";
                if (!$util.isInteger(message.damageType))
                    return "damageType: integer expected";
                if (!$util.isInteger(message.Dir))
                    return "Dir: integer expected";
                if (typeof message.Speed !== "number")
                    return "Speed: number expected";
                if (!$util.isInteger(message.BulletDestructionMethod))
                    return "BulletDestructionMethod: integer expected";
                if (typeof message.AttackWay0 !== "boolean")
                    return "AttackWay0: boolean expected";
                if (typeof message.AttackWay1 !== "boolean")
                    return "AttackWay1: boolean expected";
                if (!$util.isInteger(message.AttackWayDis))
                    return "AttackWayDis: integer expected";
                if (!$util.isInteger(message.PenetrationNuber))
                    return "PenetrationNuber: integer expected";
                if (message.targetList != null && message.hasOwnProperty("targetList")) {
                    if (!Array.isArray(message.targetList))
                        return "targetList: array expected";
                    for (var i = 0; i < message.targetList.length; ++i)
                        if (!$util.isInteger(message.targetList[i]))
                            return "targetList: integer[] expected";
                }
                if (message.TargetTempList != null && message.hasOwnProperty("TargetTempList")) {
                    if (!Array.isArray(message.TargetTempList))
                        return "TargetTempList: array expected";
                    for (var i = 0; i < message.TargetTempList.length; ++i)
                        if (!$util.isInteger(message.TargetTempList[i]))
                            return "TargetTempList: integer[] expected";
                }
                if (typeof message.CanUpdate !== "boolean")
                    return "CanUpdate: boolean expected";
                if (!$util.isInteger(message.BulletFlyCos))
                    return "BulletFlyCos: integer expected";
                if (!$util.isInteger(message.timer))
                    return "timer: integer expected";
                if (!$util.isInteger(message.hurtCalculate))
                    return "hurtCalculate: integer expected";
                if (typeof message.buff_AttackAdd !== "number")
                    return "buff_AttackAdd: number expected";
                if (!$util.isInteger(message.attackhurtDist))
                    return "attackhurtDist: integer expected";
                if (!$util.isInteger(message.AttackRolePosZ))
                    return "AttackRolePosZ: integer expected";
                if (!$util.isInteger(message.attackRoleLevel))
                    return "attackRoleLevel: integer expected";
                if (typeof message.attackRoleNoPropertyPower !== "number")
                    return "attackRoleNoPropertyPower: number expected";
                if (typeof message.attackRoleIcePropertyPower !== "number")
                    return "attackRoleIcePropertyPower: number expected";
                if (typeof message.attackRoleFirePropertyPower !== "number")
                    return "attackRoleFirePropertyPower: number expected";
                if (typeof message.attackRoleElectricPropertyPower !== "number")
                    return "attackRoleElectricPropertyPower: number expected";
                if (typeof message.attackRoleLandPropertyPower !== "number")
                    return "attackRoleLandPropertyPower: number expected";
                if (typeof message.attackRolePoisonPropertyPower !== "number")
                    return "attackRolePoisonPropertyPower: number expected";
                if (typeof message.attackRoleLightPropertyPower !== "number")
                    return "attackRoleLightPropertyPower: number expected";
                if (typeof message.attackRoleDarkPropertyPower !== "number")
                    return "attackRoleDarkPropertyPower: number expected";
                if (typeof message.attackRoleAttackPropertyHurt !== "number")
                    return "attackRoleAttackPropertyHurt: number expected";
                if (typeof message.attackRoleIcePropertyHurt !== "number")
                    return "attackRoleIcePropertyHurt: number expected";
                if (typeof message.attackRoleFirePropertyHurt !== "number")
                    return "attackRoleFirePropertyHurt: number expected";
                if (typeof message.attackRoleElectricPropertyHurt !== "number")
                    return "attackRoleElectricPropertyHurt: number expected";
                if (typeof message.attackRoleLandPropertyHurt !== "number")
                    return "attackRoleLandPropertyHurt: number expected";
                if (typeof message.attackRolePoisonPropertyHurt !== "number")
                    return "attackRolePoisonPropertyHurt: number expected";
                if (typeof message.attackRoleLightPropertyHurt !== "number")
                    return "attackRoleLightPropertyHurt: number expected";
                if (typeof message.attackRoleDarkPropertyHurt !== "number")
                    return "attackRoleDarkPropertyHurt: number expected";
                if (typeof message.attackRoleHitRate !== "number")
                    return "attackRoleHitRate: number expected";
                if (typeof message.attackRoleCri !== "number")
                    return "attackRoleCri: number expected";
                if (typeof message.attackRoleCriStrength !== "number")
                    return "attackRoleCriStrength: number expected";
                if (!$util.isInteger(message.bulletType))
                    return "bulletType: integer expected";
                {
                    var error = $root.luck.protobuf.BattleBulletDataPB.verify(message.bulletDataPb);
                    if (error)
                        return "bulletDataPb." + error;
                }
                return null;
            };

            return BattleBulletPB;
        })();

        protobuf.BattleBulletDataPB = (function() {

            /**
             * Properties of a BattleBulletDataPB.
             * @memberof luck.protobuf
             * @interface IBattleBulletDataPB
             * @property {number} ID BattleBulletDataPB ID
             * @property {string} Name BattleBulletDataPB Name
             * @property {string} BulletFXPrefab BattleBulletDataPB BulletFXPrefab
             * @property {string} MuzzleFxPrefab BattleBulletDataPB MuzzleFxPrefab
             * @property {string} HitFXPrefab BattleBulletDataPB HitFXPrefab
             * @property {string} StartPos BattleBulletDataPB StartPos
             * @property {string} AttackWay BattleBulletDataPB AttackWay
             * @property {string} AttackWayCon BattleBulletDataPB AttackWayCon
             * @property {number} HurtCalculate BattleBulletDataPB HurtCalculate
             * @property {number} HurtCalculateCoe BattleBulletDataPB HurtCalculateCoe
             * @property {number} BulletCount BattleBulletDataPB BulletCount
             * @property {number} FlyDirection BattleBulletDataPB FlyDirection
             * @property {number} FlyWay BattleBulletDataPB FlyWay
             * @property {number} FlyWayCoe BattleBulletDataPB FlyWayCoe
             * @property {number} FlySpeed BattleBulletDataPB FlySpeed
             * @property {number} BulletDestructionMethod BattleBulletDataPB BulletDestructionMethod
             * @property {number} FlyCos BattleBulletDataPB FlyCos
             * @property {number} PenetrationCount BattleBulletDataPB PenetrationCount
             * @property {number} RepelDis BattleBulletDataPB RepelDis
             * @property {number} timer BattleBulletDataPB timer
             */

            /**
             * Constructs a new BattleBulletDataPB.
             * @memberof luck.protobuf
             * @classdesc Represents a BattleBulletDataPB.
             * @implements IBattleBulletDataPB
             * @constructor
             * @param {luck.protobuf.IBattleBulletDataPB=} [properties] Properties to set
             */
            function BattleBulletDataPB(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BattleBulletDataPB ID.
             * @member {number} ID
             * @memberof luck.protobuf.BattleBulletDataPB
             * @instance
             */
            BattleBulletDataPB.prototype.ID = 0;

            /**
             * BattleBulletDataPB Name.
             * @member {string} Name
             * @memberof luck.protobuf.BattleBulletDataPB
             * @instance
             */
            BattleBulletDataPB.prototype.Name = "";

            /**
             * BattleBulletDataPB BulletFXPrefab.
             * @member {string} BulletFXPrefab
             * @memberof luck.protobuf.BattleBulletDataPB
             * @instance
             */
            BattleBulletDataPB.prototype.BulletFXPrefab = "";

            /**
             * BattleBulletDataPB MuzzleFxPrefab.
             * @member {string} MuzzleFxPrefab
             * @memberof luck.protobuf.BattleBulletDataPB
             * @instance
             */
            BattleBulletDataPB.prototype.MuzzleFxPrefab = "";

            /**
             * BattleBulletDataPB HitFXPrefab.
             * @member {string} HitFXPrefab
             * @memberof luck.protobuf.BattleBulletDataPB
             * @instance
             */
            BattleBulletDataPB.prototype.HitFXPrefab = "";

            /**
             * BattleBulletDataPB StartPos.
             * @member {string} StartPos
             * @memberof luck.protobuf.BattleBulletDataPB
             * @instance
             */
            BattleBulletDataPB.prototype.StartPos = "";

            /**
             * BattleBulletDataPB AttackWay.
             * @member {string} AttackWay
             * @memberof luck.protobuf.BattleBulletDataPB
             * @instance
             */
            BattleBulletDataPB.prototype.AttackWay = "";

            /**
             * BattleBulletDataPB AttackWayCon.
             * @member {string} AttackWayCon
             * @memberof luck.protobuf.BattleBulletDataPB
             * @instance
             */
            BattleBulletDataPB.prototype.AttackWayCon = "";

            /**
             * BattleBulletDataPB HurtCalculate.
             * @member {number} HurtCalculate
             * @memberof luck.protobuf.BattleBulletDataPB
             * @instance
             */
            BattleBulletDataPB.prototype.HurtCalculate = 0;

            /**
             * BattleBulletDataPB HurtCalculateCoe.
             * @member {number} HurtCalculateCoe
             * @memberof luck.protobuf.BattleBulletDataPB
             * @instance
             */
            BattleBulletDataPB.prototype.HurtCalculateCoe = 0;

            /**
             * BattleBulletDataPB BulletCount.
             * @member {number} BulletCount
             * @memberof luck.protobuf.BattleBulletDataPB
             * @instance
             */
            BattleBulletDataPB.prototype.BulletCount = 0;

            /**
             * BattleBulletDataPB FlyDirection.
             * @member {number} FlyDirection
             * @memberof luck.protobuf.BattleBulletDataPB
             * @instance
             */
            BattleBulletDataPB.prototype.FlyDirection = 0;

            /**
             * BattleBulletDataPB FlyWay.
             * @member {number} FlyWay
             * @memberof luck.protobuf.BattleBulletDataPB
             * @instance
             */
            BattleBulletDataPB.prototype.FlyWay = 0;

            /**
             * BattleBulletDataPB FlyWayCoe.
             * @member {number} FlyWayCoe
             * @memberof luck.protobuf.BattleBulletDataPB
             * @instance
             */
            BattleBulletDataPB.prototype.FlyWayCoe = 0;

            /**
             * BattleBulletDataPB FlySpeed.
             * @member {number} FlySpeed
             * @memberof luck.protobuf.BattleBulletDataPB
             * @instance
             */
            BattleBulletDataPB.prototype.FlySpeed = 0;

            /**
             * BattleBulletDataPB BulletDestructionMethod.
             * @member {number} BulletDestructionMethod
             * @memberof luck.protobuf.BattleBulletDataPB
             * @instance
             */
            BattleBulletDataPB.prototype.BulletDestructionMethod = 0;

            /**
             * BattleBulletDataPB FlyCos.
             * @member {number} FlyCos
             * @memberof luck.protobuf.BattleBulletDataPB
             * @instance
             */
            BattleBulletDataPB.prototype.FlyCos = 0;

            /**
             * BattleBulletDataPB PenetrationCount.
             * @member {number} PenetrationCount
             * @memberof luck.protobuf.BattleBulletDataPB
             * @instance
             */
            BattleBulletDataPB.prototype.PenetrationCount = 0;

            /**
             * BattleBulletDataPB RepelDis.
             * @member {number} RepelDis
             * @memberof luck.protobuf.BattleBulletDataPB
             * @instance
             */
            BattleBulletDataPB.prototype.RepelDis = 0;

            /**
             * BattleBulletDataPB timer.
             * @member {number} timer
             * @memberof luck.protobuf.BattleBulletDataPB
             * @instance
             */
            BattleBulletDataPB.prototype.timer = 0;

            /**
             * Creates a new BattleBulletDataPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.BattleBulletDataPB
             * @static
             * @param {luck.protobuf.IBattleBulletDataPB=} [properties] Properties to set
             * @returns {luck.protobuf.BattleBulletDataPB} BattleBulletDataPB instance
             */
            BattleBulletDataPB.create = function create(properties) {
                return new BattleBulletDataPB(properties);
            };

            /**
             * Encodes the specified BattleBulletDataPB message. Does not implicitly {@link luck.protobuf.BattleBulletDataPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.BattleBulletDataPB
             * @static
             * @param {luck.protobuf.IBattleBulletDataPB} message BattleBulletDataPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BattleBulletDataPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ID);
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.Name);
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.BulletFXPrefab);
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.MuzzleFxPrefab);
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.HitFXPrefab);
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.StartPos);
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.AttackWay);
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.AttackWayCon);
                writer.uint32(/* id 9, wireType 5 =*/77).float(message.HurtCalculate);
                writer.uint32(/* id 10, wireType 5 =*/85).float(message.HurtCalculateCoe);
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.BulletCount);
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.FlyDirection);
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.FlyWay);
                writer.uint32(/* id 14, wireType 5 =*/117).float(message.FlyWayCoe);
                writer.uint32(/* id 15, wireType 5 =*/125).float(message.FlySpeed);
                writer.uint32(/* id 16, wireType 0 =*/128).int32(message.BulletDestructionMethod);
                writer.uint32(/* id 17, wireType 5 =*/141).float(message.FlyCos);
                writer.uint32(/* id 18, wireType 0 =*/144).int32(message.PenetrationCount);
                writer.uint32(/* id 19, wireType 5 =*/157).float(message.RepelDis);
                writer.uint32(/* id 20, wireType 5 =*/165).float(message.timer);
                return writer;
            };

            /**
             * Encodes the specified BattleBulletDataPB message, length delimited. Does not implicitly {@link luck.protobuf.BattleBulletDataPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.BattleBulletDataPB
             * @static
             * @param {luck.protobuf.IBattleBulletDataPB} message BattleBulletDataPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BattleBulletDataPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BattleBulletDataPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.BattleBulletDataPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.BattleBulletDataPB} BattleBulletDataPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BattleBulletDataPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.BattleBulletDataPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.ID = reader.int32();
                        break;
                    case 2:
                        message.Name = reader.string();
                        break;
                    case 3:
                        message.BulletFXPrefab = reader.string();
                        break;
                    case 4:
                        message.MuzzleFxPrefab = reader.string();
                        break;
                    case 5:
                        message.HitFXPrefab = reader.string();
                        break;
                    case 6:
                        message.StartPos = reader.string();
                        break;
                    case 7:
                        message.AttackWay = reader.string();
                        break;
                    case 8:
                        message.AttackWayCon = reader.string();
                        break;
                    case 9:
                        message.HurtCalculate = reader.float();
                        break;
                    case 10:
                        message.HurtCalculateCoe = reader.float();
                        break;
                    case 11:
                        message.BulletCount = reader.int32();
                        break;
                    case 12:
                        message.FlyDirection = reader.int32();
                        break;
                    case 13:
                        message.FlyWay = reader.int32();
                        break;
                    case 14:
                        message.FlyWayCoe = reader.float();
                        break;
                    case 15:
                        message.FlySpeed = reader.float();
                        break;
                    case 16:
                        message.BulletDestructionMethod = reader.int32();
                        break;
                    case 17:
                        message.FlyCos = reader.float();
                        break;
                    case 18:
                        message.PenetrationCount = reader.int32();
                        break;
                    case 19:
                        message.RepelDis = reader.float();
                        break;
                    case 20:
                        message.timer = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("ID"))
                    throw $util.ProtocolError("missing required 'ID'", { instance: message });
                if (!message.hasOwnProperty("Name"))
                    throw $util.ProtocolError("missing required 'Name'", { instance: message });
                if (!message.hasOwnProperty("BulletFXPrefab"))
                    throw $util.ProtocolError("missing required 'BulletFXPrefab'", { instance: message });
                if (!message.hasOwnProperty("MuzzleFxPrefab"))
                    throw $util.ProtocolError("missing required 'MuzzleFxPrefab'", { instance: message });
                if (!message.hasOwnProperty("HitFXPrefab"))
                    throw $util.ProtocolError("missing required 'HitFXPrefab'", { instance: message });
                if (!message.hasOwnProperty("StartPos"))
                    throw $util.ProtocolError("missing required 'StartPos'", { instance: message });
                if (!message.hasOwnProperty("AttackWay"))
                    throw $util.ProtocolError("missing required 'AttackWay'", { instance: message });
                if (!message.hasOwnProperty("AttackWayCon"))
                    throw $util.ProtocolError("missing required 'AttackWayCon'", { instance: message });
                if (!message.hasOwnProperty("HurtCalculate"))
                    throw $util.ProtocolError("missing required 'HurtCalculate'", { instance: message });
                if (!message.hasOwnProperty("HurtCalculateCoe"))
                    throw $util.ProtocolError("missing required 'HurtCalculateCoe'", { instance: message });
                if (!message.hasOwnProperty("BulletCount"))
                    throw $util.ProtocolError("missing required 'BulletCount'", { instance: message });
                if (!message.hasOwnProperty("FlyDirection"))
                    throw $util.ProtocolError("missing required 'FlyDirection'", { instance: message });
                if (!message.hasOwnProperty("FlyWay"))
                    throw $util.ProtocolError("missing required 'FlyWay'", { instance: message });
                if (!message.hasOwnProperty("FlyWayCoe"))
                    throw $util.ProtocolError("missing required 'FlyWayCoe'", { instance: message });
                if (!message.hasOwnProperty("FlySpeed"))
                    throw $util.ProtocolError("missing required 'FlySpeed'", { instance: message });
                if (!message.hasOwnProperty("BulletDestructionMethod"))
                    throw $util.ProtocolError("missing required 'BulletDestructionMethod'", { instance: message });
                if (!message.hasOwnProperty("FlyCos"))
                    throw $util.ProtocolError("missing required 'FlyCos'", { instance: message });
                if (!message.hasOwnProperty("PenetrationCount"))
                    throw $util.ProtocolError("missing required 'PenetrationCount'", { instance: message });
                if (!message.hasOwnProperty("RepelDis"))
                    throw $util.ProtocolError("missing required 'RepelDis'", { instance: message });
                if (!message.hasOwnProperty("timer"))
                    throw $util.ProtocolError("missing required 'timer'", { instance: message });
                return message;
            };

            /**
             * Decodes a BattleBulletDataPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.BattleBulletDataPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.BattleBulletDataPB} BattleBulletDataPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BattleBulletDataPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BattleBulletDataPB message.
             * @function verify
             * @memberof luck.protobuf.BattleBulletDataPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BattleBulletDataPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.ID))
                    return "ID: integer expected";
                if (!$util.isString(message.Name))
                    return "Name: string expected";
                if (!$util.isString(message.BulletFXPrefab))
                    return "BulletFXPrefab: string expected";
                if (!$util.isString(message.MuzzleFxPrefab))
                    return "MuzzleFxPrefab: string expected";
                if (!$util.isString(message.HitFXPrefab))
                    return "HitFXPrefab: string expected";
                if (!$util.isString(message.StartPos))
                    return "StartPos: string expected";
                if (!$util.isString(message.AttackWay))
                    return "AttackWay: string expected";
                if (!$util.isString(message.AttackWayCon))
                    return "AttackWayCon: string expected";
                if (typeof message.HurtCalculate !== "number")
                    return "HurtCalculate: number expected";
                if (typeof message.HurtCalculateCoe !== "number")
                    return "HurtCalculateCoe: number expected";
                if (!$util.isInteger(message.BulletCount))
                    return "BulletCount: integer expected";
                if (!$util.isInteger(message.FlyDirection))
                    return "FlyDirection: integer expected";
                if (!$util.isInteger(message.FlyWay))
                    return "FlyWay: integer expected";
                if (typeof message.FlyWayCoe !== "number")
                    return "FlyWayCoe: number expected";
                if (typeof message.FlySpeed !== "number")
                    return "FlySpeed: number expected";
                if (!$util.isInteger(message.BulletDestructionMethod))
                    return "BulletDestructionMethod: integer expected";
                if (typeof message.FlyCos !== "number")
                    return "FlyCos: number expected";
                if (!$util.isInteger(message.PenetrationCount))
                    return "PenetrationCount: integer expected";
                if (typeof message.RepelDis !== "number")
                    return "RepelDis: number expected";
                if (typeof message.timer !== "number")
                    return "timer: number expected";
                return null;
            };

            return BattleBulletDataPB;
        })();

        protobuf.BattleRolePB = (function() {

            /**
             * Properties of a BattleRolePB.
             * @memberof luck.protobuf
             * @interface IBattleRolePB
             * @property {number} PosX BattleRolePB PosX
             * @property {number} PosY BattleRolePB PosY
             * @property {number} PosZ BattleRolePB PosZ
             * @property {number} AngleX BattleRolePB AngleX
             * @property {number} AngleY BattleRolePB AngleY
             * @property {number} AngleZ BattleRolePB AngleZ
             * @property {number} StateID BattleRolePB StateID
             * @property {number} CurrWeaponID BattleRolePB CurrWeaponID
             * @property {number} SwithWeaponState BattleRolePB SwithWeaponState
             * @property {number} SwithWeaponTimer BattleRolePB SwithWeaponTimer
             * @property {number} HitTimer BattleRolePB HitTimer
             * @property {number} CurrWeaponAttackTime BattleRolePB CurrWeaponAttackTime
             * @property {number} KnifAttackEndTime BattleRolePB KnifAttackEndTime
             * @property {number} KinfeAttackState BattleRolePB KinfeAttackState
             * @property {boolean} IsAttackState BattleRolePB IsAttackState
             * @property {boolean} IsMoveState BattleRolePB IsMoveState
             * @property {boolean} isCanAttack BattleRolePB isCanAttack
             * @property {luck.protobuf.IBattlePlayerDataPB} playerDataPb BattleRolePB playerDataPb
             * @property {Array.<luck.protobuf.IBattleWeaponPB>|null} [weaponPBList] BattleRolePB weaponPBList
             */

            /**
             * Constructs a new BattleRolePB.
             * @memberof luck.protobuf
             * @classdesc Represents a BattleRolePB.
             * @implements IBattleRolePB
             * @constructor
             * @param {luck.protobuf.IBattleRolePB=} [properties] Properties to set
             */
            function BattleRolePB(properties) {
                this.weaponPBList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BattleRolePB PosX.
             * @member {number} PosX
             * @memberof luck.protobuf.BattleRolePB
             * @instance
             */
            BattleRolePB.prototype.PosX = 0;

            /**
             * BattleRolePB PosY.
             * @member {number} PosY
             * @memberof luck.protobuf.BattleRolePB
             * @instance
             */
            BattleRolePB.prototype.PosY = 0;

            /**
             * BattleRolePB PosZ.
             * @member {number} PosZ
             * @memberof luck.protobuf.BattleRolePB
             * @instance
             */
            BattleRolePB.prototype.PosZ = 0;

            /**
             * BattleRolePB AngleX.
             * @member {number} AngleX
             * @memberof luck.protobuf.BattleRolePB
             * @instance
             */
            BattleRolePB.prototype.AngleX = 0;

            /**
             * BattleRolePB AngleY.
             * @member {number} AngleY
             * @memberof luck.protobuf.BattleRolePB
             * @instance
             */
            BattleRolePB.prototype.AngleY = 0;

            /**
             * BattleRolePB AngleZ.
             * @member {number} AngleZ
             * @memberof luck.protobuf.BattleRolePB
             * @instance
             */
            BattleRolePB.prototype.AngleZ = 0;

            /**
             * BattleRolePB StateID.
             * @member {number} StateID
             * @memberof luck.protobuf.BattleRolePB
             * @instance
             */
            BattleRolePB.prototype.StateID = 0;

            /**
             * BattleRolePB CurrWeaponID.
             * @member {number} CurrWeaponID
             * @memberof luck.protobuf.BattleRolePB
             * @instance
             */
            BattleRolePB.prototype.CurrWeaponID = 0;

            /**
             * BattleRolePB SwithWeaponState.
             * @member {number} SwithWeaponState
             * @memberof luck.protobuf.BattleRolePB
             * @instance
             */
            BattleRolePB.prototype.SwithWeaponState = 0;

            /**
             * BattleRolePB SwithWeaponTimer.
             * @member {number} SwithWeaponTimer
             * @memberof luck.protobuf.BattleRolePB
             * @instance
             */
            BattleRolePB.prototype.SwithWeaponTimer = 0;

            /**
             * BattleRolePB HitTimer.
             * @member {number} HitTimer
             * @memberof luck.protobuf.BattleRolePB
             * @instance
             */
            BattleRolePB.prototype.HitTimer = 0;

            /**
             * BattleRolePB CurrWeaponAttackTime.
             * @member {number} CurrWeaponAttackTime
             * @memberof luck.protobuf.BattleRolePB
             * @instance
             */
            BattleRolePB.prototype.CurrWeaponAttackTime = 0;

            /**
             * BattleRolePB KnifAttackEndTime.
             * @member {number} KnifAttackEndTime
             * @memberof luck.protobuf.BattleRolePB
             * @instance
             */
            BattleRolePB.prototype.KnifAttackEndTime = 0;

            /**
             * BattleRolePB KinfeAttackState.
             * @member {number} KinfeAttackState
             * @memberof luck.protobuf.BattleRolePB
             * @instance
             */
            BattleRolePB.prototype.KinfeAttackState = 0;

            /**
             * BattleRolePB IsAttackState.
             * @member {boolean} IsAttackState
             * @memberof luck.protobuf.BattleRolePB
             * @instance
             */
            BattleRolePB.prototype.IsAttackState = false;

            /**
             * BattleRolePB IsMoveState.
             * @member {boolean} IsMoveState
             * @memberof luck.protobuf.BattleRolePB
             * @instance
             */
            BattleRolePB.prototype.IsMoveState = false;

            /**
             * BattleRolePB isCanAttack.
             * @member {boolean} isCanAttack
             * @memberof luck.protobuf.BattleRolePB
             * @instance
             */
            BattleRolePB.prototype.isCanAttack = false;

            /**
             * BattleRolePB playerDataPb.
             * @member {luck.protobuf.IBattlePlayerDataPB} playerDataPb
             * @memberof luck.protobuf.BattleRolePB
             * @instance
             */
            BattleRolePB.prototype.playerDataPb = null;

            /**
             * BattleRolePB weaponPBList.
             * @member {Array.<luck.protobuf.IBattleWeaponPB>} weaponPBList
             * @memberof luck.protobuf.BattleRolePB
             * @instance
             */
            BattleRolePB.prototype.weaponPBList = $util.emptyArray;

            /**
             * Creates a new BattleRolePB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.BattleRolePB
             * @static
             * @param {luck.protobuf.IBattleRolePB=} [properties] Properties to set
             * @returns {luck.protobuf.BattleRolePB} BattleRolePB instance
             */
            BattleRolePB.create = function create(properties) {
                return new BattleRolePB(properties);
            };

            /**
             * Encodes the specified BattleRolePB message. Does not implicitly {@link luck.protobuf.BattleRolePB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.BattleRolePB
             * @static
             * @param {luck.protobuf.IBattleRolePB} message BattleRolePB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BattleRolePB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.PosX);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.PosY);
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.PosZ);
                writer.uint32(/* id 4, wireType 5 =*/37).float(message.AngleX);
                writer.uint32(/* id 5, wireType 5 =*/45).float(message.AngleY);
                writer.uint32(/* id 6, wireType 5 =*/53).float(message.AngleZ);
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.StateID);
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.CurrWeaponID);
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.SwithWeaponState);
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.SwithWeaponTimer);
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.HitTimer);
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.CurrWeaponAttackTime);
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.KnifAttackEndTime);
                writer.uint32(/* id 14, wireType 0 =*/112).int32(message.KinfeAttackState);
                writer.uint32(/* id 15, wireType 0 =*/120).bool(message.IsAttackState);
                writer.uint32(/* id 16, wireType 0 =*/128).bool(message.IsMoveState);
                writer.uint32(/* id 17, wireType 0 =*/136).bool(message.isCanAttack);
                $root.luck.protobuf.BattlePlayerDataPB.encode(message.playerDataPb, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
                if (message.weaponPBList != null && message.weaponPBList.length)
                    for (var i = 0; i < message.weaponPBList.length; ++i)
                        $root.luck.protobuf.BattleWeaponPB.encode(message.weaponPBList[i], writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified BattleRolePB message, length delimited. Does not implicitly {@link luck.protobuf.BattleRolePB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.BattleRolePB
             * @static
             * @param {luck.protobuf.IBattleRolePB} message BattleRolePB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BattleRolePB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BattleRolePB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.BattleRolePB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.BattleRolePB} BattleRolePB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BattleRolePB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.BattleRolePB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.PosX = reader.int32();
                        break;
                    case 2:
                        message.PosY = reader.int32();
                        break;
                    case 3:
                        message.PosZ = reader.int32();
                        break;
                    case 4:
                        message.AngleX = reader.float();
                        break;
                    case 5:
                        message.AngleY = reader.float();
                        break;
                    case 6:
                        message.AngleZ = reader.float();
                        break;
                    case 7:
                        message.StateID = reader.int32();
                        break;
                    case 8:
                        message.CurrWeaponID = reader.int32();
                        break;
                    case 9:
                        message.SwithWeaponState = reader.int32();
                        break;
                    case 10:
                        message.SwithWeaponTimer = reader.int32();
                        break;
                    case 11:
                        message.HitTimer = reader.int32();
                        break;
                    case 12:
                        message.CurrWeaponAttackTime = reader.int32();
                        break;
                    case 13:
                        message.KnifAttackEndTime = reader.int32();
                        break;
                    case 14:
                        message.KinfeAttackState = reader.int32();
                        break;
                    case 15:
                        message.IsAttackState = reader.bool();
                        break;
                    case 16:
                        message.IsMoveState = reader.bool();
                        break;
                    case 17:
                        message.isCanAttack = reader.bool();
                        break;
                    case 18:
                        message.playerDataPb = $root.luck.protobuf.BattlePlayerDataPB.decode(reader, reader.uint32());
                        break;
                    case 19:
                        if (!(message.weaponPBList && message.weaponPBList.length))
                            message.weaponPBList = [];
                        message.weaponPBList.push($root.luck.protobuf.BattleWeaponPB.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("PosX"))
                    throw $util.ProtocolError("missing required 'PosX'", { instance: message });
                if (!message.hasOwnProperty("PosY"))
                    throw $util.ProtocolError("missing required 'PosY'", { instance: message });
                if (!message.hasOwnProperty("PosZ"))
                    throw $util.ProtocolError("missing required 'PosZ'", { instance: message });
                if (!message.hasOwnProperty("AngleX"))
                    throw $util.ProtocolError("missing required 'AngleX'", { instance: message });
                if (!message.hasOwnProperty("AngleY"))
                    throw $util.ProtocolError("missing required 'AngleY'", { instance: message });
                if (!message.hasOwnProperty("AngleZ"))
                    throw $util.ProtocolError("missing required 'AngleZ'", { instance: message });
                if (!message.hasOwnProperty("StateID"))
                    throw $util.ProtocolError("missing required 'StateID'", { instance: message });
                if (!message.hasOwnProperty("CurrWeaponID"))
                    throw $util.ProtocolError("missing required 'CurrWeaponID'", { instance: message });
                if (!message.hasOwnProperty("SwithWeaponState"))
                    throw $util.ProtocolError("missing required 'SwithWeaponState'", { instance: message });
                if (!message.hasOwnProperty("SwithWeaponTimer"))
                    throw $util.ProtocolError("missing required 'SwithWeaponTimer'", { instance: message });
                if (!message.hasOwnProperty("HitTimer"))
                    throw $util.ProtocolError("missing required 'HitTimer'", { instance: message });
                if (!message.hasOwnProperty("CurrWeaponAttackTime"))
                    throw $util.ProtocolError("missing required 'CurrWeaponAttackTime'", { instance: message });
                if (!message.hasOwnProperty("KnifAttackEndTime"))
                    throw $util.ProtocolError("missing required 'KnifAttackEndTime'", { instance: message });
                if (!message.hasOwnProperty("KinfeAttackState"))
                    throw $util.ProtocolError("missing required 'KinfeAttackState'", { instance: message });
                if (!message.hasOwnProperty("IsAttackState"))
                    throw $util.ProtocolError("missing required 'IsAttackState'", { instance: message });
                if (!message.hasOwnProperty("IsMoveState"))
                    throw $util.ProtocolError("missing required 'IsMoveState'", { instance: message });
                if (!message.hasOwnProperty("isCanAttack"))
                    throw $util.ProtocolError("missing required 'isCanAttack'", { instance: message });
                if (!message.hasOwnProperty("playerDataPb"))
                    throw $util.ProtocolError("missing required 'playerDataPb'", { instance: message });
                return message;
            };

            /**
             * Decodes a BattleRolePB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.BattleRolePB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.BattleRolePB} BattleRolePB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BattleRolePB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BattleRolePB message.
             * @function verify
             * @memberof luck.protobuf.BattleRolePB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BattleRolePB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.PosX))
                    return "PosX: integer expected";
                if (!$util.isInteger(message.PosY))
                    return "PosY: integer expected";
                if (!$util.isInteger(message.PosZ))
                    return "PosZ: integer expected";
                if (typeof message.AngleX !== "number")
                    return "AngleX: number expected";
                if (typeof message.AngleY !== "number")
                    return "AngleY: number expected";
                if (typeof message.AngleZ !== "number")
                    return "AngleZ: number expected";
                if (!$util.isInteger(message.StateID))
                    return "StateID: integer expected";
                if (!$util.isInteger(message.CurrWeaponID))
                    return "CurrWeaponID: integer expected";
                if (!$util.isInteger(message.SwithWeaponState))
                    return "SwithWeaponState: integer expected";
                if (!$util.isInteger(message.SwithWeaponTimer))
                    return "SwithWeaponTimer: integer expected";
                if (!$util.isInteger(message.HitTimer))
                    return "HitTimer: integer expected";
                if (!$util.isInteger(message.CurrWeaponAttackTime))
                    return "CurrWeaponAttackTime: integer expected";
                if (!$util.isInteger(message.KnifAttackEndTime))
                    return "KnifAttackEndTime: integer expected";
                if (!$util.isInteger(message.KinfeAttackState))
                    return "KinfeAttackState: integer expected";
                if (typeof message.IsAttackState !== "boolean")
                    return "IsAttackState: boolean expected";
                if (typeof message.IsMoveState !== "boolean")
                    return "IsMoveState: boolean expected";
                if (typeof message.isCanAttack !== "boolean")
                    return "isCanAttack: boolean expected";
                {
                    var error = $root.luck.protobuf.BattlePlayerDataPB.verify(message.playerDataPb);
                    if (error)
                        return "playerDataPb." + error;
                }
                if (message.weaponPBList != null && message.hasOwnProperty("weaponPBList")) {
                    if (!Array.isArray(message.weaponPBList))
                        return "weaponPBList: array expected";
                    for (var i = 0; i < message.weaponPBList.length; ++i) {
                        var error = $root.luck.protobuf.BattleWeaponPB.verify(message.weaponPBList[i]);
                        if (error)
                            return "weaponPBList." + error;
                    }
                }
                return null;
            };

            return BattleRolePB;
        })();

        protobuf.BattlePlayerDataPB = (function() {

            /**
             * Properties of a BattlePlayerDataPB.
             * @memberof luck.protobuf
             * @interface IBattlePlayerDataPB
             * @property {Array.<luck.protobuf.IBattleWeaponPB>|null} [weaponList] BattlePlayerDataPB weaponList
             * @property {number} PlayerID BattlePlayerDataPB PlayerID
             * @property {number} RoleID BattlePlayerDataPB RoleID
             * @property {number} CampID BattlePlayerDataPB CampID
             * @property {number} ClothsVoID BattlePlayerDataPB ClothsVoID
             * @property {string} PrefabName BattlePlayerDataPB PrefabName
             * @property {number} Level BattlePlayerDataPB Level
             * @property {number} Experience BattlePlayerDataPB Experience
             * @property {number} Weight BattlePlayerDataPB Weight
             * @property {number} BodyPower BattlePlayerDataPB BodyPower
             * @property {number} GameCoin BattlePlayerDataPB GameCoin
             * @property {number} RechargeCoin BattlePlayerDataPB RechargeCoin
             * @property {number} MoveSpeed BattlePlayerDataPB MoveSpeed
             * @property {number} Hit BattlePlayerDataPB Hit
             * @property {number} Dodge BattlePlayerDataPB Dodge
             * @property {number} Cir BattlePlayerDataPB Cir
             * @property {number} CriStrength BattlePlayerDataPB CriStrength
             * @property {number} GoldCoinPlus BattlePlayerDataPB GoldCoinPlus
             * @property {number} ProPlus BattlePlayerDataPB ProPlus
             * @property {number|Long} MaxHp BattlePlayerDataPB MaxHp
             * @property {number|Long} CurrHp BattlePlayerDataPB CurrHp
             * @property {number} CostBulletJiaCheng BattlePlayerDataPB CostBulletJiaCheng
             * @property {number} NoPropertyResistance BattlePlayerDataPB NoPropertyResistance
             * @property {number} IcePropertyResistance BattlePlayerDataPB IcePropertyResistance
             * @property {number} FirePropertyResistance BattlePlayerDataPB FirePropertyResistance
             * @property {number} ElectricPropertyResistance BattlePlayerDataPB ElectricPropertyResistance
             * @property {number} LandPropertyResistance BattlePlayerDataPB LandPropertyResistance
             * @property {number} PoisonPropertyResistance BattlePlayerDataPB PoisonPropertyResistance
             * @property {number} LightPropertyResistance BattlePlayerDataPB LightPropertyResistance
             * @property {number} DarkPropertyResistance BattlePlayerDataPB DarkPropertyResistance
             * @property {number} ClothsInlay BattlePlayerDataPB ClothsInlay
             * @property {number} NoPropertyReduction BattlePlayerDataPB NoPropertyReduction
             * @property {number} IcePropertyReduction BattlePlayerDataPB IcePropertyReduction
             * @property {number} FirePropertyReduction BattlePlayerDataPB FirePropertyReduction
             * @property {number} ElectricPropertyReduction BattlePlayerDataPB ElectricPropertyReduction
             * @property {number} LandPropertyReduction BattlePlayerDataPB LandPropertyReduction
             * @property {number} PoisonPropertyReduction BattlePlayerDataPB PoisonPropertyReduction
             * @property {number} LightPropertyReduction BattlePlayerDataPB LightPropertyReduction
             * @property {number} DarkPropertyReduction BattlePlayerDataPB DarkPropertyReduction
             * @property {Array.<number>|null} [skillList] BattlePlayerDataPB skillList
             */

            /**
             * Constructs a new BattlePlayerDataPB.
             * @memberof luck.protobuf
             * @classdesc Represents a BattlePlayerDataPB.
             * @implements IBattlePlayerDataPB
             * @constructor
             * @param {luck.protobuf.IBattlePlayerDataPB=} [properties] Properties to set
             */
            function BattlePlayerDataPB(properties) {
                this.weaponList = [];
                this.skillList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BattlePlayerDataPB weaponList.
             * @member {Array.<luck.protobuf.IBattleWeaponPB>} weaponList
             * @memberof luck.protobuf.BattlePlayerDataPB
             * @instance
             */
            BattlePlayerDataPB.prototype.weaponList = $util.emptyArray;

            /**
             * BattlePlayerDataPB PlayerID.
             * @member {number} PlayerID
             * @memberof luck.protobuf.BattlePlayerDataPB
             * @instance
             */
            BattlePlayerDataPB.prototype.PlayerID = 0;

            /**
             * BattlePlayerDataPB RoleID.
             * @member {number} RoleID
             * @memberof luck.protobuf.BattlePlayerDataPB
             * @instance
             */
            BattlePlayerDataPB.prototype.RoleID = 0;

            /**
             * BattlePlayerDataPB CampID.
             * @member {number} CampID
             * @memberof luck.protobuf.BattlePlayerDataPB
             * @instance
             */
            BattlePlayerDataPB.prototype.CampID = 0;

            /**
             * BattlePlayerDataPB ClothsVoID.
             * @member {number} ClothsVoID
             * @memberof luck.protobuf.BattlePlayerDataPB
             * @instance
             */
            BattlePlayerDataPB.prototype.ClothsVoID = 0;

            /**
             * BattlePlayerDataPB PrefabName.
             * @member {string} PrefabName
             * @memberof luck.protobuf.BattlePlayerDataPB
             * @instance
             */
            BattlePlayerDataPB.prototype.PrefabName = "";

            /**
             * BattlePlayerDataPB Level.
             * @member {number} Level
             * @memberof luck.protobuf.BattlePlayerDataPB
             * @instance
             */
            BattlePlayerDataPB.prototype.Level = 0;

            /**
             * BattlePlayerDataPB Experience.
             * @member {number} Experience
             * @memberof luck.protobuf.BattlePlayerDataPB
             * @instance
             */
            BattlePlayerDataPB.prototype.Experience = 0;

            /**
             * BattlePlayerDataPB Weight.
             * @member {number} Weight
             * @memberof luck.protobuf.BattlePlayerDataPB
             * @instance
             */
            BattlePlayerDataPB.prototype.Weight = 0;

            /**
             * BattlePlayerDataPB BodyPower.
             * @member {number} BodyPower
             * @memberof luck.protobuf.BattlePlayerDataPB
             * @instance
             */
            BattlePlayerDataPB.prototype.BodyPower = 0;

            /**
             * BattlePlayerDataPB GameCoin.
             * @member {number} GameCoin
             * @memberof luck.protobuf.BattlePlayerDataPB
             * @instance
             */
            BattlePlayerDataPB.prototype.GameCoin = 0;

            /**
             * BattlePlayerDataPB RechargeCoin.
             * @member {number} RechargeCoin
             * @memberof luck.protobuf.BattlePlayerDataPB
             * @instance
             */
            BattlePlayerDataPB.prototype.RechargeCoin = 0;

            /**
             * BattlePlayerDataPB MoveSpeed.
             * @member {number} MoveSpeed
             * @memberof luck.protobuf.BattlePlayerDataPB
             * @instance
             */
            BattlePlayerDataPB.prototype.MoveSpeed = 0;

            /**
             * BattlePlayerDataPB Hit.
             * @member {number} Hit
             * @memberof luck.protobuf.BattlePlayerDataPB
             * @instance
             */
            BattlePlayerDataPB.prototype.Hit = 0;

            /**
             * BattlePlayerDataPB Dodge.
             * @member {number} Dodge
             * @memberof luck.protobuf.BattlePlayerDataPB
             * @instance
             */
            BattlePlayerDataPB.prototype.Dodge = 0;

            /**
             * BattlePlayerDataPB Cir.
             * @member {number} Cir
             * @memberof luck.protobuf.BattlePlayerDataPB
             * @instance
             */
            BattlePlayerDataPB.prototype.Cir = 0;

            /**
             * BattlePlayerDataPB CriStrength.
             * @member {number} CriStrength
             * @memberof luck.protobuf.BattlePlayerDataPB
             * @instance
             */
            BattlePlayerDataPB.prototype.CriStrength = 0;

            /**
             * BattlePlayerDataPB GoldCoinPlus.
             * @member {number} GoldCoinPlus
             * @memberof luck.protobuf.BattlePlayerDataPB
             * @instance
             */
            BattlePlayerDataPB.prototype.GoldCoinPlus = 0;

            /**
             * BattlePlayerDataPB ProPlus.
             * @member {number} ProPlus
             * @memberof luck.protobuf.BattlePlayerDataPB
             * @instance
             */
            BattlePlayerDataPB.prototype.ProPlus = 0;

            /**
             * BattlePlayerDataPB MaxHp.
             * @member {number|Long} MaxHp
             * @memberof luck.protobuf.BattlePlayerDataPB
             * @instance
             */
            BattlePlayerDataPB.prototype.MaxHp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * BattlePlayerDataPB CurrHp.
             * @member {number|Long} CurrHp
             * @memberof luck.protobuf.BattlePlayerDataPB
             * @instance
             */
            BattlePlayerDataPB.prototype.CurrHp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * BattlePlayerDataPB CostBulletJiaCheng.
             * @member {number} CostBulletJiaCheng
             * @memberof luck.protobuf.BattlePlayerDataPB
             * @instance
             */
            BattlePlayerDataPB.prototype.CostBulletJiaCheng = 0;

            /**
             * BattlePlayerDataPB NoPropertyResistance.
             * @member {number} NoPropertyResistance
             * @memberof luck.protobuf.BattlePlayerDataPB
             * @instance
             */
            BattlePlayerDataPB.prototype.NoPropertyResistance = 0;

            /**
             * BattlePlayerDataPB IcePropertyResistance.
             * @member {number} IcePropertyResistance
             * @memberof luck.protobuf.BattlePlayerDataPB
             * @instance
             */
            BattlePlayerDataPB.prototype.IcePropertyResistance = 0;

            /**
             * BattlePlayerDataPB FirePropertyResistance.
             * @member {number} FirePropertyResistance
             * @memberof luck.protobuf.BattlePlayerDataPB
             * @instance
             */
            BattlePlayerDataPB.prototype.FirePropertyResistance = 0;

            /**
             * BattlePlayerDataPB ElectricPropertyResistance.
             * @member {number} ElectricPropertyResistance
             * @memberof luck.protobuf.BattlePlayerDataPB
             * @instance
             */
            BattlePlayerDataPB.prototype.ElectricPropertyResistance = 0;

            /**
             * BattlePlayerDataPB LandPropertyResistance.
             * @member {number} LandPropertyResistance
             * @memberof luck.protobuf.BattlePlayerDataPB
             * @instance
             */
            BattlePlayerDataPB.prototype.LandPropertyResistance = 0;

            /**
             * BattlePlayerDataPB PoisonPropertyResistance.
             * @member {number} PoisonPropertyResistance
             * @memberof luck.protobuf.BattlePlayerDataPB
             * @instance
             */
            BattlePlayerDataPB.prototype.PoisonPropertyResistance = 0;

            /**
             * BattlePlayerDataPB LightPropertyResistance.
             * @member {number} LightPropertyResistance
             * @memberof luck.protobuf.BattlePlayerDataPB
             * @instance
             */
            BattlePlayerDataPB.prototype.LightPropertyResistance = 0;

            /**
             * BattlePlayerDataPB DarkPropertyResistance.
             * @member {number} DarkPropertyResistance
             * @memberof luck.protobuf.BattlePlayerDataPB
             * @instance
             */
            BattlePlayerDataPB.prototype.DarkPropertyResistance = 0;

            /**
             * BattlePlayerDataPB ClothsInlay.
             * @member {number} ClothsInlay
             * @memberof luck.protobuf.BattlePlayerDataPB
             * @instance
             */
            BattlePlayerDataPB.prototype.ClothsInlay = 0;

            /**
             * BattlePlayerDataPB NoPropertyReduction.
             * @member {number} NoPropertyReduction
             * @memberof luck.protobuf.BattlePlayerDataPB
             * @instance
             */
            BattlePlayerDataPB.prototype.NoPropertyReduction = 0;

            /**
             * BattlePlayerDataPB IcePropertyReduction.
             * @member {number} IcePropertyReduction
             * @memberof luck.protobuf.BattlePlayerDataPB
             * @instance
             */
            BattlePlayerDataPB.prototype.IcePropertyReduction = 0;

            /**
             * BattlePlayerDataPB FirePropertyReduction.
             * @member {number} FirePropertyReduction
             * @memberof luck.protobuf.BattlePlayerDataPB
             * @instance
             */
            BattlePlayerDataPB.prototype.FirePropertyReduction = 0;

            /**
             * BattlePlayerDataPB ElectricPropertyReduction.
             * @member {number} ElectricPropertyReduction
             * @memberof luck.protobuf.BattlePlayerDataPB
             * @instance
             */
            BattlePlayerDataPB.prototype.ElectricPropertyReduction = 0;

            /**
             * BattlePlayerDataPB LandPropertyReduction.
             * @member {number} LandPropertyReduction
             * @memberof luck.protobuf.BattlePlayerDataPB
             * @instance
             */
            BattlePlayerDataPB.prototype.LandPropertyReduction = 0;

            /**
             * BattlePlayerDataPB PoisonPropertyReduction.
             * @member {number} PoisonPropertyReduction
             * @memberof luck.protobuf.BattlePlayerDataPB
             * @instance
             */
            BattlePlayerDataPB.prototype.PoisonPropertyReduction = 0;

            /**
             * BattlePlayerDataPB LightPropertyReduction.
             * @member {number} LightPropertyReduction
             * @memberof luck.protobuf.BattlePlayerDataPB
             * @instance
             */
            BattlePlayerDataPB.prototype.LightPropertyReduction = 0;

            /**
             * BattlePlayerDataPB DarkPropertyReduction.
             * @member {number} DarkPropertyReduction
             * @memberof luck.protobuf.BattlePlayerDataPB
             * @instance
             */
            BattlePlayerDataPB.prototype.DarkPropertyReduction = 0;

            /**
             * BattlePlayerDataPB skillList.
             * @member {Array.<number>} skillList
             * @memberof luck.protobuf.BattlePlayerDataPB
             * @instance
             */
            BattlePlayerDataPB.prototype.skillList = $util.emptyArray;

            /**
             * Creates a new BattlePlayerDataPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.BattlePlayerDataPB
             * @static
             * @param {luck.protobuf.IBattlePlayerDataPB=} [properties] Properties to set
             * @returns {luck.protobuf.BattlePlayerDataPB} BattlePlayerDataPB instance
             */
            BattlePlayerDataPB.create = function create(properties) {
                return new BattlePlayerDataPB(properties);
            };

            /**
             * Encodes the specified BattlePlayerDataPB message. Does not implicitly {@link luck.protobuf.BattlePlayerDataPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.BattlePlayerDataPB
             * @static
             * @param {luck.protobuf.IBattlePlayerDataPB} message BattlePlayerDataPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BattlePlayerDataPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.weaponList != null && message.weaponList.length)
                    for (var i = 0; i < message.weaponList.length; ++i)
                        $root.luck.protobuf.BattleWeaponPB.encode(message.weaponList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.PlayerID);
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.RoleID);
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.CampID);
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.ClothsVoID);
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.PrefabName);
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.Level);
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.Experience);
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.Weight);
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.BodyPower);
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.GameCoin);
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.RechargeCoin);
                writer.uint32(/* id 13, wireType 5 =*/109).float(message.MoveSpeed);
                writer.uint32(/* id 14, wireType 5 =*/117).float(message.Hit);
                writer.uint32(/* id 15, wireType 5 =*/125).float(message.Dodge);
                writer.uint32(/* id 16, wireType 5 =*/133).float(message.Cir);
                writer.uint32(/* id 17, wireType 5 =*/141).float(message.CriStrength);
                writer.uint32(/* id 18, wireType 5 =*/149).float(message.GoldCoinPlus);
                writer.uint32(/* id 19, wireType 5 =*/157).float(message.ProPlus);
                writer.uint32(/* id 20, wireType 0 =*/160).int64(message.MaxHp);
                writer.uint32(/* id 21, wireType 0 =*/168).int64(message.CurrHp);
                writer.uint32(/* id 22, wireType 5 =*/181).float(message.CostBulletJiaCheng);
                writer.uint32(/* id 23, wireType 5 =*/189).float(message.NoPropertyResistance);
                writer.uint32(/* id 24, wireType 5 =*/197).float(message.IcePropertyResistance);
                writer.uint32(/* id 25, wireType 5 =*/205).float(message.FirePropertyResistance);
                writer.uint32(/* id 26, wireType 5 =*/213).float(message.ElectricPropertyResistance);
                writer.uint32(/* id 27, wireType 5 =*/221).float(message.LandPropertyResistance);
                writer.uint32(/* id 28, wireType 5 =*/229).float(message.PoisonPropertyResistance);
                writer.uint32(/* id 29, wireType 5 =*/237).float(message.LightPropertyResistance);
                writer.uint32(/* id 30, wireType 5 =*/245).float(message.DarkPropertyResistance);
                writer.uint32(/* id 31, wireType 0 =*/248).int32(message.ClothsInlay);
                writer.uint32(/* id 32, wireType 5 =*/261).float(message.NoPropertyReduction);
                writer.uint32(/* id 33, wireType 5 =*/269).float(message.IcePropertyReduction);
                writer.uint32(/* id 34, wireType 5 =*/277).float(message.FirePropertyReduction);
                writer.uint32(/* id 35, wireType 5 =*/285).float(message.ElectricPropertyReduction);
                writer.uint32(/* id 36, wireType 5 =*/293).float(message.LandPropertyReduction);
                writer.uint32(/* id 37, wireType 5 =*/301).float(message.PoisonPropertyReduction);
                writer.uint32(/* id 38, wireType 5 =*/309).float(message.LightPropertyReduction);
                writer.uint32(/* id 39, wireType 5 =*/317).float(message.DarkPropertyReduction);
                if (message.skillList != null && message.skillList.length)
                    for (var i = 0; i < message.skillList.length; ++i)
                        writer.uint32(/* id 40, wireType 0 =*/320).int32(message.skillList[i]);
                return writer;
            };

            /**
             * Encodes the specified BattlePlayerDataPB message, length delimited. Does not implicitly {@link luck.protobuf.BattlePlayerDataPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.BattlePlayerDataPB
             * @static
             * @param {luck.protobuf.IBattlePlayerDataPB} message BattlePlayerDataPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BattlePlayerDataPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BattlePlayerDataPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.BattlePlayerDataPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.BattlePlayerDataPB} BattlePlayerDataPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BattlePlayerDataPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.BattlePlayerDataPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.weaponList && message.weaponList.length))
                            message.weaponList = [];
                        message.weaponList.push($root.luck.protobuf.BattleWeaponPB.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.PlayerID = reader.int32();
                        break;
                    case 3:
                        message.RoleID = reader.int32();
                        break;
                    case 4:
                        message.CampID = reader.int32();
                        break;
                    case 5:
                        message.ClothsVoID = reader.int32();
                        break;
                    case 6:
                        message.PrefabName = reader.string();
                        break;
                    case 7:
                        message.Level = reader.int32();
                        break;
                    case 8:
                        message.Experience = reader.int32();
                        break;
                    case 9:
                        message.Weight = reader.int32();
                        break;
                    case 10:
                        message.BodyPower = reader.int32();
                        break;
                    case 11:
                        message.GameCoin = reader.int32();
                        break;
                    case 12:
                        message.RechargeCoin = reader.int32();
                        break;
                    case 13:
                        message.MoveSpeed = reader.float();
                        break;
                    case 14:
                        message.Hit = reader.float();
                        break;
                    case 15:
                        message.Dodge = reader.float();
                        break;
                    case 16:
                        message.Cir = reader.float();
                        break;
                    case 17:
                        message.CriStrength = reader.float();
                        break;
                    case 18:
                        message.GoldCoinPlus = reader.float();
                        break;
                    case 19:
                        message.ProPlus = reader.float();
                        break;
                    case 20:
                        message.MaxHp = reader.int64();
                        break;
                    case 21:
                        message.CurrHp = reader.int64();
                        break;
                    case 22:
                        message.CostBulletJiaCheng = reader.float();
                        break;
                    case 23:
                        message.NoPropertyResistance = reader.float();
                        break;
                    case 24:
                        message.IcePropertyResistance = reader.float();
                        break;
                    case 25:
                        message.FirePropertyResistance = reader.float();
                        break;
                    case 26:
                        message.ElectricPropertyResistance = reader.float();
                        break;
                    case 27:
                        message.LandPropertyResistance = reader.float();
                        break;
                    case 28:
                        message.PoisonPropertyResistance = reader.float();
                        break;
                    case 29:
                        message.LightPropertyResistance = reader.float();
                        break;
                    case 30:
                        message.DarkPropertyResistance = reader.float();
                        break;
                    case 31:
                        message.ClothsInlay = reader.int32();
                        break;
                    case 32:
                        message.NoPropertyReduction = reader.float();
                        break;
                    case 33:
                        message.IcePropertyReduction = reader.float();
                        break;
                    case 34:
                        message.FirePropertyReduction = reader.float();
                        break;
                    case 35:
                        message.ElectricPropertyReduction = reader.float();
                        break;
                    case 36:
                        message.LandPropertyReduction = reader.float();
                        break;
                    case 37:
                        message.PoisonPropertyReduction = reader.float();
                        break;
                    case 38:
                        message.LightPropertyReduction = reader.float();
                        break;
                    case 39:
                        message.DarkPropertyReduction = reader.float();
                        break;
                    case 40:
                        if (!(message.skillList && message.skillList.length))
                            message.skillList = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.skillList.push(reader.int32());
                        } else
                            message.skillList.push(reader.int32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("PlayerID"))
                    throw $util.ProtocolError("missing required 'PlayerID'", { instance: message });
                if (!message.hasOwnProperty("RoleID"))
                    throw $util.ProtocolError("missing required 'RoleID'", { instance: message });
                if (!message.hasOwnProperty("CampID"))
                    throw $util.ProtocolError("missing required 'CampID'", { instance: message });
                if (!message.hasOwnProperty("ClothsVoID"))
                    throw $util.ProtocolError("missing required 'ClothsVoID'", { instance: message });
                if (!message.hasOwnProperty("PrefabName"))
                    throw $util.ProtocolError("missing required 'PrefabName'", { instance: message });
                if (!message.hasOwnProperty("Level"))
                    throw $util.ProtocolError("missing required 'Level'", { instance: message });
                if (!message.hasOwnProperty("Experience"))
                    throw $util.ProtocolError("missing required 'Experience'", { instance: message });
                if (!message.hasOwnProperty("Weight"))
                    throw $util.ProtocolError("missing required 'Weight'", { instance: message });
                if (!message.hasOwnProperty("BodyPower"))
                    throw $util.ProtocolError("missing required 'BodyPower'", { instance: message });
                if (!message.hasOwnProperty("GameCoin"))
                    throw $util.ProtocolError("missing required 'GameCoin'", { instance: message });
                if (!message.hasOwnProperty("RechargeCoin"))
                    throw $util.ProtocolError("missing required 'RechargeCoin'", { instance: message });
                if (!message.hasOwnProperty("MoveSpeed"))
                    throw $util.ProtocolError("missing required 'MoveSpeed'", { instance: message });
                if (!message.hasOwnProperty("Hit"))
                    throw $util.ProtocolError("missing required 'Hit'", { instance: message });
                if (!message.hasOwnProperty("Dodge"))
                    throw $util.ProtocolError("missing required 'Dodge'", { instance: message });
                if (!message.hasOwnProperty("Cir"))
                    throw $util.ProtocolError("missing required 'Cir'", { instance: message });
                if (!message.hasOwnProperty("CriStrength"))
                    throw $util.ProtocolError("missing required 'CriStrength'", { instance: message });
                if (!message.hasOwnProperty("GoldCoinPlus"))
                    throw $util.ProtocolError("missing required 'GoldCoinPlus'", { instance: message });
                if (!message.hasOwnProperty("ProPlus"))
                    throw $util.ProtocolError("missing required 'ProPlus'", { instance: message });
                if (!message.hasOwnProperty("MaxHp"))
                    throw $util.ProtocolError("missing required 'MaxHp'", { instance: message });
                if (!message.hasOwnProperty("CurrHp"))
                    throw $util.ProtocolError("missing required 'CurrHp'", { instance: message });
                if (!message.hasOwnProperty("CostBulletJiaCheng"))
                    throw $util.ProtocolError("missing required 'CostBulletJiaCheng'", { instance: message });
                if (!message.hasOwnProperty("NoPropertyResistance"))
                    throw $util.ProtocolError("missing required 'NoPropertyResistance'", { instance: message });
                if (!message.hasOwnProperty("IcePropertyResistance"))
                    throw $util.ProtocolError("missing required 'IcePropertyResistance'", { instance: message });
                if (!message.hasOwnProperty("FirePropertyResistance"))
                    throw $util.ProtocolError("missing required 'FirePropertyResistance'", { instance: message });
                if (!message.hasOwnProperty("ElectricPropertyResistance"))
                    throw $util.ProtocolError("missing required 'ElectricPropertyResistance'", { instance: message });
                if (!message.hasOwnProperty("LandPropertyResistance"))
                    throw $util.ProtocolError("missing required 'LandPropertyResistance'", { instance: message });
                if (!message.hasOwnProperty("PoisonPropertyResistance"))
                    throw $util.ProtocolError("missing required 'PoisonPropertyResistance'", { instance: message });
                if (!message.hasOwnProperty("LightPropertyResistance"))
                    throw $util.ProtocolError("missing required 'LightPropertyResistance'", { instance: message });
                if (!message.hasOwnProperty("DarkPropertyResistance"))
                    throw $util.ProtocolError("missing required 'DarkPropertyResistance'", { instance: message });
                if (!message.hasOwnProperty("ClothsInlay"))
                    throw $util.ProtocolError("missing required 'ClothsInlay'", { instance: message });
                if (!message.hasOwnProperty("NoPropertyReduction"))
                    throw $util.ProtocolError("missing required 'NoPropertyReduction'", { instance: message });
                if (!message.hasOwnProperty("IcePropertyReduction"))
                    throw $util.ProtocolError("missing required 'IcePropertyReduction'", { instance: message });
                if (!message.hasOwnProperty("FirePropertyReduction"))
                    throw $util.ProtocolError("missing required 'FirePropertyReduction'", { instance: message });
                if (!message.hasOwnProperty("ElectricPropertyReduction"))
                    throw $util.ProtocolError("missing required 'ElectricPropertyReduction'", { instance: message });
                if (!message.hasOwnProperty("LandPropertyReduction"))
                    throw $util.ProtocolError("missing required 'LandPropertyReduction'", { instance: message });
                if (!message.hasOwnProperty("PoisonPropertyReduction"))
                    throw $util.ProtocolError("missing required 'PoisonPropertyReduction'", { instance: message });
                if (!message.hasOwnProperty("LightPropertyReduction"))
                    throw $util.ProtocolError("missing required 'LightPropertyReduction'", { instance: message });
                if (!message.hasOwnProperty("DarkPropertyReduction"))
                    throw $util.ProtocolError("missing required 'DarkPropertyReduction'", { instance: message });
                return message;
            };

            /**
             * Decodes a BattlePlayerDataPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.BattlePlayerDataPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.BattlePlayerDataPB} BattlePlayerDataPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BattlePlayerDataPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BattlePlayerDataPB message.
             * @function verify
             * @memberof luck.protobuf.BattlePlayerDataPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BattlePlayerDataPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.weaponList != null && message.hasOwnProperty("weaponList")) {
                    if (!Array.isArray(message.weaponList))
                        return "weaponList: array expected";
                    for (var i = 0; i < message.weaponList.length; ++i) {
                        var error = $root.luck.protobuf.BattleWeaponPB.verify(message.weaponList[i]);
                        if (error)
                            return "weaponList." + error;
                    }
                }
                if (!$util.isInteger(message.PlayerID))
                    return "PlayerID: integer expected";
                if (!$util.isInteger(message.RoleID))
                    return "RoleID: integer expected";
                if (!$util.isInteger(message.CampID))
                    return "CampID: integer expected";
                if (!$util.isInteger(message.ClothsVoID))
                    return "ClothsVoID: integer expected";
                if (!$util.isString(message.PrefabName))
                    return "PrefabName: string expected";
                if (!$util.isInteger(message.Level))
                    return "Level: integer expected";
                if (!$util.isInteger(message.Experience))
                    return "Experience: integer expected";
                if (!$util.isInteger(message.Weight))
                    return "Weight: integer expected";
                if (!$util.isInteger(message.BodyPower))
                    return "BodyPower: integer expected";
                if (!$util.isInteger(message.GameCoin))
                    return "GameCoin: integer expected";
                if (!$util.isInteger(message.RechargeCoin))
                    return "RechargeCoin: integer expected";
                if (typeof message.MoveSpeed !== "number")
                    return "MoveSpeed: number expected";
                if (typeof message.Hit !== "number")
                    return "Hit: number expected";
                if (typeof message.Dodge !== "number")
                    return "Dodge: number expected";
                if (typeof message.Cir !== "number")
                    return "Cir: number expected";
                if (typeof message.CriStrength !== "number")
                    return "CriStrength: number expected";
                if (typeof message.GoldCoinPlus !== "number")
                    return "GoldCoinPlus: number expected";
                if (typeof message.ProPlus !== "number")
                    return "ProPlus: number expected";
                if (!$util.isInteger(message.MaxHp) && !(message.MaxHp && $util.isInteger(message.MaxHp.low) && $util.isInteger(message.MaxHp.high)))
                    return "MaxHp: integer|Long expected";
                if (!$util.isInteger(message.CurrHp) && !(message.CurrHp && $util.isInteger(message.CurrHp.low) && $util.isInteger(message.CurrHp.high)))
                    return "CurrHp: integer|Long expected";
                if (typeof message.CostBulletJiaCheng !== "number")
                    return "CostBulletJiaCheng: number expected";
                if (typeof message.NoPropertyResistance !== "number")
                    return "NoPropertyResistance: number expected";
                if (typeof message.IcePropertyResistance !== "number")
                    return "IcePropertyResistance: number expected";
                if (typeof message.FirePropertyResistance !== "number")
                    return "FirePropertyResistance: number expected";
                if (typeof message.ElectricPropertyResistance !== "number")
                    return "ElectricPropertyResistance: number expected";
                if (typeof message.LandPropertyResistance !== "number")
                    return "LandPropertyResistance: number expected";
                if (typeof message.PoisonPropertyResistance !== "number")
                    return "PoisonPropertyResistance: number expected";
                if (typeof message.LightPropertyResistance !== "number")
                    return "LightPropertyResistance: number expected";
                if (typeof message.DarkPropertyResistance !== "number")
                    return "DarkPropertyResistance: number expected";
                if (!$util.isInteger(message.ClothsInlay))
                    return "ClothsInlay: integer expected";
                if (typeof message.NoPropertyReduction !== "number")
                    return "NoPropertyReduction: number expected";
                if (typeof message.IcePropertyReduction !== "number")
                    return "IcePropertyReduction: number expected";
                if (typeof message.FirePropertyReduction !== "number")
                    return "FirePropertyReduction: number expected";
                if (typeof message.ElectricPropertyReduction !== "number")
                    return "ElectricPropertyReduction: number expected";
                if (typeof message.LandPropertyReduction !== "number")
                    return "LandPropertyReduction: number expected";
                if (typeof message.PoisonPropertyReduction !== "number")
                    return "PoisonPropertyReduction: number expected";
                if (typeof message.LightPropertyReduction !== "number")
                    return "LightPropertyReduction: number expected";
                if (typeof message.DarkPropertyReduction !== "number")
                    return "DarkPropertyReduction: number expected";
                if (message.skillList != null && message.hasOwnProperty("skillList")) {
                    if (!Array.isArray(message.skillList))
                        return "skillList: array expected";
                    for (var i = 0; i < message.skillList.length; ++i)
                        if (!$util.isInteger(message.skillList[i]))
                            return "skillList: integer[] expected";
                }
                return null;
            };

            return BattlePlayerDataPB;
        })();

        protobuf.BattleWeaponPB = (function() {

            /**
             * Properties of a BattleWeaponPB.
             * @memberof luck.protobuf
             * @interface IBattleWeaponPB
             * @property {number} WeaponID BattleWeaponPB WeaponID
             * @property {luck.protobuf.IBattleWeaponDataPB} weaponPb BattleWeaponPB weaponPb
             */

            /**
             * Constructs a new BattleWeaponPB.
             * @memberof luck.protobuf
             * @classdesc Represents a BattleWeaponPB.
             * @implements IBattleWeaponPB
             * @constructor
             * @param {luck.protobuf.IBattleWeaponPB=} [properties] Properties to set
             */
            function BattleWeaponPB(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BattleWeaponPB WeaponID.
             * @member {number} WeaponID
             * @memberof luck.protobuf.BattleWeaponPB
             * @instance
             */
            BattleWeaponPB.prototype.WeaponID = 0;

            /**
             * BattleWeaponPB weaponPb.
             * @member {luck.protobuf.IBattleWeaponDataPB} weaponPb
             * @memberof luck.protobuf.BattleWeaponPB
             * @instance
             */
            BattleWeaponPB.prototype.weaponPb = null;

            /**
             * Creates a new BattleWeaponPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.BattleWeaponPB
             * @static
             * @param {luck.protobuf.IBattleWeaponPB=} [properties] Properties to set
             * @returns {luck.protobuf.BattleWeaponPB} BattleWeaponPB instance
             */
            BattleWeaponPB.create = function create(properties) {
                return new BattleWeaponPB(properties);
            };

            /**
             * Encodes the specified BattleWeaponPB message. Does not implicitly {@link luck.protobuf.BattleWeaponPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.BattleWeaponPB
             * @static
             * @param {luck.protobuf.IBattleWeaponPB} message BattleWeaponPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BattleWeaponPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.WeaponID);
                $root.luck.protobuf.BattleWeaponDataPB.encode(message.weaponPb, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified BattleWeaponPB message, length delimited. Does not implicitly {@link luck.protobuf.BattleWeaponPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.BattleWeaponPB
             * @static
             * @param {luck.protobuf.IBattleWeaponPB} message BattleWeaponPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BattleWeaponPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BattleWeaponPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.BattleWeaponPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.BattleWeaponPB} BattleWeaponPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BattleWeaponPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.BattleWeaponPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.WeaponID = reader.int32();
                        break;
                    case 2:
                        message.weaponPb = $root.luck.protobuf.BattleWeaponDataPB.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("WeaponID"))
                    throw $util.ProtocolError("missing required 'WeaponID'", { instance: message });
                if (!message.hasOwnProperty("weaponPb"))
                    throw $util.ProtocolError("missing required 'weaponPb'", { instance: message });
                return message;
            };

            /**
             * Decodes a BattleWeaponPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.BattleWeaponPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.BattleWeaponPB} BattleWeaponPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BattleWeaponPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BattleWeaponPB message.
             * @function verify
             * @memberof luck.protobuf.BattleWeaponPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BattleWeaponPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.WeaponID))
                    return "WeaponID: integer expected";
                {
                    var error = $root.luck.protobuf.BattleWeaponDataPB.verify(message.weaponPb);
                    if (error)
                        return "weaponPb." + error;
                }
                return null;
            };

            return BattleWeaponPB;
        })();

        protobuf.BattleWeaponDataPB = (function() {

            /**
             * Properties of a BattleWeaponDataPB.
             * @memberof luck.protobuf
             * @interface IBattleWeaponDataPB
             * @property {number} WeaponID BattleWeaponDataPB WeaponID
             * @property {number} Uid BattleWeaponDataPB Uid
             * @property {number} WeaponNode BattleWeaponDataPB WeaponNode
             * @property {number} CostBulletCount BattleWeaponDataPB CostBulletCount
             * @property {number} CurrBullet BattleWeaponDataPB CurrBullet
             * @property {number} BombLoad BattleWeaponDataPB BombLoad
             * @property {luck.protobuf.IBattleBulletDataPB} bulletDataPb BattleWeaponDataPB bulletDataPb
             * @property {luck.protobuf.IBattleBulletDataPB} Bulletdata1 BattleWeaponDataPB Bulletdata1
             * @property {luck.protobuf.IBattleBulletDataPB} Bulletdata2 BattleWeaponDataPB Bulletdata2
             * @property {luck.protobuf.IBattleBulletDataPB} Bulletdata3 BattleWeaponDataPB Bulletdata3
             * @property {number} InlayHoleCount BattleWeaponDataPB InlayHoleCount
             * @property {string} InlayHoleEffect1 BattleWeaponDataPB InlayHoleEffect1
             * @property {string} InlayHoleEffect2 BattleWeaponDataPB InlayHoleEffect2
             * @property {string} InlayHoleEffect3 BattleWeaponDataPB InlayHoleEffect3
             * @property {string} InlayHoleEffect4 BattleWeaponDataPB InlayHoleEffect4
             * @property {number} NoPropertyPower BattleWeaponDataPB NoPropertyPower
             * @property {number} IcePropertyPower BattleWeaponDataPB IcePropertyPower
             * @property {number} FirePropertyPower BattleWeaponDataPB FirePropertyPower
             * @property {number} ElectricPropertyPower BattleWeaponDataPB ElectricPropertyPower
             * @property {number} LandPropertyPower BattleWeaponDataPB LandPropertyPower
             * @property {number} PoisonPropertyPower BattleWeaponDataPB PoisonPropertyPower
             * @property {number} LightPropertyPower BattleWeaponDataPB LightPropertyPower
             * @property {number} DarkPropertyPower BattleWeaponDataPB DarkPropertyPower
             * @property {number} NoPropertyStreng BattleWeaponDataPB NoPropertyStreng
             * @property {number} IcePropertyStreng BattleWeaponDataPB IcePropertyStreng
             * @property {number} FirePropertyStreng BattleWeaponDataPB FirePropertyStreng
             * @property {number} ElectricPropertyStreng BattleWeaponDataPB ElectricPropertyStreng
             * @property {number} LandPropertyStreng BattleWeaponDataPB LandPropertyStreng
             * @property {number} PoisonPropertyStreng BattleWeaponDataPB PoisonPropertyStreng
             * @property {number} LightPropertyStreng BattleWeaponDataPB LightPropertyStreng
             * @property {number} DarkPropertyStreng BattleWeaponDataPB DarkPropertyStreng
             * @property {number} NoPropertyHurt BattleWeaponDataPB NoPropertyHurt
             * @property {number} IcePropertyHurt BattleWeaponDataPB IcePropertyHurt
             * @property {number} FirePropertyHurt BattleWeaponDataPB FirePropertyHurt
             * @property {number} ElectricPropertyHurt BattleWeaponDataPB ElectricPropertyHurt
             * @property {number} LandPropertyHurt BattleWeaponDataPB LandPropertyHurt
             * @property {number} PoisonPropertyHurt BattleWeaponDataPB PoisonPropertyHurt
             * @property {number} LightPropertyHurt BattleWeaponDataPB LightPropertyHurt
             * @property {number} DarkPropertyHurt BattleWeaponDataPB DarkPropertyHurt
             * @property {number} AttackSpeed BattleWeaponDataPB AttackSpeed
             * @property {Array.<number>|null} [skillList] BattleWeaponDataPB skillList
             * @property {number} WeaponType BattleWeaponDataPB WeaponType
             */

            /**
             * Constructs a new BattleWeaponDataPB.
             * @memberof luck.protobuf
             * @classdesc Represents a BattleWeaponDataPB.
             * @implements IBattleWeaponDataPB
             * @constructor
             * @param {luck.protobuf.IBattleWeaponDataPB=} [properties] Properties to set
             */
            function BattleWeaponDataPB(properties) {
                this.skillList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BattleWeaponDataPB WeaponID.
             * @member {number} WeaponID
             * @memberof luck.protobuf.BattleWeaponDataPB
             * @instance
             */
            BattleWeaponDataPB.prototype.WeaponID = 0;

            /**
             * BattleWeaponDataPB Uid.
             * @member {number} Uid
             * @memberof luck.protobuf.BattleWeaponDataPB
             * @instance
             */
            BattleWeaponDataPB.prototype.Uid = 0;

            /**
             * BattleWeaponDataPB WeaponNode.
             * @member {number} WeaponNode
             * @memberof luck.protobuf.BattleWeaponDataPB
             * @instance
             */
            BattleWeaponDataPB.prototype.WeaponNode = 0;

            /**
             * BattleWeaponDataPB CostBulletCount.
             * @member {number} CostBulletCount
             * @memberof luck.protobuf.BattleWeaponDataPB
             * @instance
             */
            BattleWeaponDataPB.prototype.CostBulletCount = 0;

            /**
             * BattleWeaponDataPB CurrBullet.
             * @member {number} CurrBullet
             * @memberof luck.protobuf.BattleWeaponDataPB
             * @instance
             */
            BattleWeaponDataPB.prototype.CurrBullet = 0;

            /**
             * BattleWeaponDataPB BombLoad.
             * @member {number} BombLoad
             * @memberof luck.protobuf.BattleWeaponDataPB
             * @instance
             */
            BattleWeaponDataPB.prototype.BombLoad = 0;

            /**
             * BattleWeaponDataPB bulletDataPb.
             * @member {luck.protobuf.IBattleBulletDataPB} bulletDataPb
             * @memberof luck.protobuf.BattleWeaponDataPB
             * @instance
             */
            BattleWeaponDataPB.prototype.bulletDataPb = null;

            /**
             * BattleWeaponDataPB Bulletdata1.
             * @member {luck.protobuf.IBattleBulletDataPB} Bulletdata1
             * @memberof luck.protobuf.BattleWeaponDataPB
             * @instance
             */
            BattleWeaponDataPB.prototype.Bulletdata1 = null;

            /**
             * BattleWeaponDataPB Bulletdata2.
             * @member {luck.protobuf.IBattleBulletDataPB} Bulletdata2
             * @memberof luck.protobuf.BattleWeaponDataPB
             * @instance
             */
            BattleWeaponDataPB.prototype.Bulletdata2 = null;

            /**
             * BattleWeaponDataPB Bulletdata3.
             * @member {luck.protobuf.IBattleBulletDataPB} Bulletdata3
             * @memberof luck.protobuf.BattleWeaponDataPB
             * @instance
             */
            BattleWeaponDataPB.prototype.Bulletdata3 = null;

            /**
             * BattleWeaponDataPB InlayHoleCount.
             * @member {number} InlayHoleCount
             * @memberof luck.protobuf.BattleWeaponDataPB
             * @instance
             */
            BattleWeaponDataPB.prototype.InlayHoleCount = 0;

            /**
             * BattleWeaponDataPB InlayHoleEffect1.
             * @member {string} InlayHoleEffect1
             * @memberof luck.protobuf.BattleWeaponDataPB
             * @instance
             */
            BattleWeaponDataPB.prototype.InlayHoleEffect1 = "";

            /**
             * BattleWeaponDataPB InlayHoleEffect2.
             * @member {string} InlayHoleEffect2
             * @memberof luck.protobuf.BattleWeaponDataPB
             * @instance
             */
            BattleWeaponDataPB.prototype.InlayHoleEffect2 = "";

            /**
             * BattleWeaponDataPB InlayHoleEffect3.
             * @member {string} InlayHoleEffect3
             * @memberof luck.protobuf.BattleWeaponDataPB
             * @instance
             */
            BattleWeaponDataPB.prototype.InlayHoleEffect3 = "";

            /**
             * BattleWeaponDataPB InlayHoleEffect4.
             * @member {string} InlayHoleEffect4
             * @memberof luck.protobuf.BattleWeaponDataPB
             * @instance
             */
            BattleWeaponDataPB.prototype.InlayHoleEffect4 = "";

            /**
             * BattleWeaponDataPB NoPropertyPower.
             * @member {number} NoPropertyPower
             * @memberof luck.protobuf.BattleWeaponDataPB
             * @instance
             */
            BattleWeaponDataPB.prototype.NoPropertyPower = 0;

            /**
             * BattleWeaponDataPB IcePropertyPower.
             * @member {number} IcePropertyPower
             * @memberof luck.protobuf.BattleWeaponDataPB
             * @instance
             */
            BattleWeaponDataPB.prototype.IcePropertyPower = 0;

            /**
             * BattleWeaponDataPB FirePropertyPower.
             * @member {number} FirePropertyPower
             * @memberof luck.protobuf.BattleWeaponDataPB
             * @instance
             */
            BattleWeaponDataPB.prototype.FirePropertyPower = 0;

            /**
             * BattleWeaponDataPB ElectricPropertyPower.
             * @member {number} ElectricPropertyPower
             * @memberof luck.protobuf.BattleWeaponDataPB
             * @instance
             */
            BattleWeaponDataPB.prototype.ElectricPropertyPower = 0;

            /**
             * BattleWeaponDataPB LandPropertyPower.
             * @member {number} LandPropertyPower
             * @memberof luck.protobuf.BattleWeaponDataPB
             * @instance
             */
            BattleWeaponDataPB.prototype.LandPropertyPower = 0;

            /**
             * BattleWeaponDataPB PoisonPropertyPower.
             * @member {number} PoisonPropertyPower
             * @memberof luck.protobuf.BattleWeaponDataPB
             * @instance
             */
            BattleWeaponDataPB.prototype.PoisonPropertyPower = 0;

            /**
             * BattleWeaponDataPB LightPropertyPower.
             * @member {number} LightPropertyPower
             * @memberof luck.protobuf.BattleWeaponDataPB
             * @instance
             */
            BattleWeaponDataPB.prototype.LightPropertyPower = 0;

            /**
             * BattleWeaponDataPB DarkPropertyPower.
             * @member {number} DarkPropertyPower
             * @memberof luck.protobuf.BattleWeaponDataPB
             * @instance
             */
            BattleWeaponDataPB.prototype.DarkPropertyPower = 0;

            /**
             * BattleWeaponDataPB NoPropertyStreng.
             * @member {number} NoPropertyStreng
             * @memberof luck.protobuf.BattleWeaponDataPB
             * @instance
             */
            BattleWeaponDataPB.prototype.NoPropertyStreng = 0;

            /**
             * BattleWeaponDataPB IcePropertyStreng.
             * @member {number} IcePropertyStreng
             * @memberof luck.protobuf.BattleWeaponDataPB
             * @instance
             */
            BattleWeaponDataPB.prototype.IcePropertyStreng = 0;

            /**
             * BattleWeaponDataPB FirePropertyStreng.
             * @member {number} FirePropertyStreng
             * @memberof luck.protobuf.BattleWeaponDataPB
             * @instance
             */
            BattleWeaponDataPB.prototype.FirePropertyStreng = 0;

            /**
             * BattleWeaponDataPB ElectricPropertyStreng.
             * @member {number} ElectricPropertyStreng
             * @memberof luck.protobuf.BattleWeaponDataPB
             * @instance
             */
            BattleWeaponDataPB.prototype.ElectricPropertyStreng = 0;

            /**
             * BattleWeaponDataPB LandPropertyStreng.
             * @member {number} LandPropertyStreng
             * @memberof luck.protobuf.BattleWeaponDataPB
             * @instance
             */
            BattleWeaponDataPB.prototype.LandPropertyStreng = 0;

            /**
             * BattleWeaponDataPB PoisonPropertyStreng.
             * @member {number} PoisonPropertyStreng
             * @memberof luck.protobuf.BattleWeaponDataPB
             * @instance
             */
            BattleWeaponDataPB.prototype.PoisonPropertyStreng = 0;

            /**
             * BattleWeaponDataPB LightPropertyStreng.
             * @member {number} LightPropertyStreng
             * @memberof luck.protobuf.BattleWeaponDataPB
             * @instance
             */
            BattleWeaponDataPB.prototype.LightPropertyStreng = 0;

            /**
             * BattleWeaponDataPB DarkPropertyStreng.
             * @member {number} DarkPropertyStreng
             * @memberof luck.protobuf.BattleWeaponDataPB
             * @instance
             */
            BattleWeaponDataPB.prototype.DarkPropertyStreng = 0;

            /**
             * BattleWeaponDataPB NoPropertyHurt.
             * @member {number} NoPropertyHurt
             * @memberof luck.protobuf.BattleWeaponDataPB
             * @instance
             */
            BattleWeaponDataPB.prototype.NoPropertyHurt = 0;

            /**
             * BattleWeaponDataPB IcePropertyHurt.
             * @member {number} IcePropertyHurt
             * @memberof luck.protobuf.BattleWeaponDataPB
             * @instance
             */
            BattleWeaponDataPB.prototype.IcePropertyHurt = 0;

            /**
             * BattleWeaponDataPB FirePropertyHurt.
             * @member {number} FirePropertyHurt
             * @memberof luck.protobuf.BattleWeaponDataPB
             * @instance
             */
            BattleWeaponDataPB.prototype.FirePropertyHurt = 0;

            /**
             * BattleWeaponDataPB ElectricPropertyHurt.
             * @member {number} ElectricPropertyHurt
             * @memberof luck.protobuf.BattleWeaponDataPB
             * @instance
             */
            BattleWeaponDataPB.prototype.ElectricPropertyHurt = 0;

            /**
             * BattleWeaponDataPB LandPropertyHurt.
             * @member {number} LandPropertyHurt
             * @memberof luck.protobuf.BattleWeaponDataPB
             * @instance
             */
            BattleWeaponDataPB.prototype.LandPropertyHurt = 0;

            /**
             * BattleWeaponDataPB PoisonPropertyHurt.
             * @member {number} PoisonPropertyHurt
             * @memberof luck.protobuf.BattleWeaponDataPB
             * @instance
             */
            BattleWeaponDataPB.prototype.PoisonPropertyHurt = 0;

            /**
             * BattleWeaponDataPB LightPropertyHurt.
             * @member {number} LightPropertyHurt
             * @memberof luck.protobuf.BattleWeaponDataPB
             * @instance
             */
            BattleWeaponDataPB.prototype.LightPropertyHurt = 0;

            /**
             * BattleWeaponDataPB DarkPropertyHurt.
             * @member {number} DarkPropertyHurt
             * @memberof luck.protobuf.BattleWeaponDataPB
             * @instance
             */
            BattleWeaponDataPB.prototype.DarkPropertyHurt = 0;

            /**
             * BattleWeaponDataPB AttackSpeed.
             * @member {number} AttackSpeed
             * @memberof luck.protobuf.BattleWeaponDataPB
             * @instance
             */
            BattleWeaponDataPB.prototype.AttackSpeed = 0;

            /**
             * BattleWeaponDataPB skillList.
             * @member {Array.<number>} skillList
             * @memberof luck.protobuf.BattleWeaponDataPB
             * @instance
             */
            BattleWeaponDataPB.prototype.skillList = $util.emptyArray;

            /**
             * BattleWeaponDataPB WeaponType.
             * @member {number} WeaponType
             * @memberof luck.protobuf.BattleWeaponDataPB
             * @instance
             */
            BattleWeaponDataPB.prototype.WeaponType = 0;

            /**
             * Creates a new BattleWeaponDataPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.BattleWeaponDataPB
             * @static
             * @param {luck.protobuf.IBattleWeaponDataPB=} [properties] Properties to set
             * @returns {luck.protobuf.BattleWeaponDataPB} BattleWeaponDataPB instance
             */
            BattleWeaponDataPB.create = function create(properties) {
                return new BattleWeaponDataPB(properties);
            };

            /**
             * Encodes the specified BattleWeaponDataPB message. Does not implicitly {@link luck.protobuf.BattleWeaponDataPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.BattleWeaponDataPB
             * @static
             * @param {luck.protobuf.IBattleWeaponDataPB} message BattleWeaponDataPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BattleWeaponDataPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.WeaponID);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Uid);
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.WeaponNode);
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.CostBulletCount);
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.CurrBullet);
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.BombLoad);
                $root.luck.protobuf.BattleBulletDataPB.encode(message.bulletDataPb, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                $root.luck.protobuf.BattleBulletDataPB.encode(message.Bulletdata1, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                $root.luck.protobuf.BattleBulletDataPB.encode(message.Bulletdata2, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                $root.luck.protobuf.BattleBulletDataPB.encode(message.Bulletdata3, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.InlayHoleCount);
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.InlayHoleEffect1);
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.InlayHoleEffect2);
                writer.uint32(/* id 14, wireType 2 =*/114).string(message.InlayHoleEffect3);
                writer.uint32(/* id 15, wireType 2 =*/122).string(message.InlayHoleEffect4);
                writer.uint32(/* id 16, wireType 5 =*/133).float(message.NoPropertyPower);
                writer.uint32(/* id 17, wireType 5 =*/141).float(message.IcePropertyPower);
                writer.uint32(/* id 18, wireType 5 =*/149).float(message.FirePropertyPower);
                writer.uint32(/* id 19, wireType 5 =*/157).float(message.ElectricPropertyPower);
                writer.uint32(/* id 20, wireType 5 =*/165).float(message.LandPropertyPower);
                writer.uint32(/* id 21, wireType 5 =*/173).float(message.PoisonPropertyPower);
                writer.uint32(/* id 22, wireType 5 =*/181).float(message.LightPropertyPower);
                writer.uint32(/* id 23, wireType 5 =*/189).float(message.DarkPropertyPower);
                writer.uint32(/* id 24, wireType 5 =*/197).float(message.NoPropertyStreng);
                writer.uint32(/* id 25, wireType 5 =*/205).float(message.IcePropertyStreng);
                writer.uint32(/* id 26, wireType 5 =*/213).float(message.FirePropertyStreng);
                writer.uint32(/* id 27, wireType 5 =*/221).float(message.ElectricPropertyStreng);
                writer.uint32(/* id 28, wireType 5 =*/229).float(message.LandPropertyStreng);
                writer.uint32(/* id 29, wireType 5 =*/237).float(message.PoisonPropertyStreng);
                writer.uint32(/* id 30, wireType 5 =*/245).float(message.LightPropertyStreng);
                writer.uint32(/* id 31, wireType 5 =*/253).float(message.DarkPropertyStreng);
                writer.uint32(/* id 32, wireType 5 =*/261).float(message.NoPropertyHurt);
                writer.uint32(/* id 33, wireType 5 =*/269).float(message.IcePropertyHurt);
                writer.uint32(/* id 34, wireType 5 =*/277).float(message.FirePropertyHurt);
                writer.uint32(/* id 35, wireType 5 =*/285).float(message.ElectricPropertyHurt);
                writer.uint32(/* id 36, wireType 5 =*/293).float(message.LandPropertyHurt);
                writer.uint32(/* id 37, wireType 5 =*/301).float(message.PoisonPropertyHurt);
                writer.uint32(/* id 38, wireType 5 =*/309).float(message.LightPropertyHurt);
                writer.uint32(/* id 39, wireType 5 =*/317).float(message.DarkPropertyHurt);
                writer.uint32(/* id 40, wireType 5 =*/325).float(message.AttackSpeed);
                if (message.skillList != null && message.skillList.length)
                    for (var i = 0; i < message.skillList.length; ++i)
                        writer.uint32(/* id 41, wireType 0 =*/328).int32(message.skillList[i]);
                writer.uint32(/* id 42, wireType 0 =*/336).int32(message.WeaponType);
                return writer;
            };

            /**
             * Encodes the specified BattleWeaponDataPB message, length delimited. Does not implicitly {@link luck.protobuf.BattleWeaponDataPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.BattleWeaponDataPB
             * @static
             * @param {luck.protobuf.IBattleWeaponDataPB} message BattleWeaponDataPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BattleWeaponDataPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BattleWeaponDataPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.BattleWeaponDataPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.BattleWeaponDataPB} BattleWeaponDataPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BattleWeaponDataPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.BattleWeaponDataPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.WeaponID = reader.int32();
                        break;
                    case 2:
                        message.Uid = reader.int32();
                        break;
                    case 3:
                        message.WeaponNode = reader.int32();
                        break;
                    case 4:
                        message.CostBulletCount = reader.int32();
                        break;
                    case 5:
                        message.CurrBullet = reader.int32();
                        break;
                    case 6:
                        message.BombLoad = reader.int32();
                        break;
                    case 7:
                        message.bulletDataPb = $root.luck.protobuf.BattleBulletDataPB.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.Bulletdata1 = $root.luck.protobuf.BattleBulletDataPB.decode(reader, reader.uint32());
                        break;
                    case 9:
                        message.Bulletdata2 = $root.luck.protobuf.BattleBulletDataPB.decode(reader, reader.uint32());
                        break;
                    case 10:
                        message.Bulletdata3 = $root.luck.protobuf.BattleBulletDataPB.decode(reader, reader.uint32());
                        break;
                    case 11:
                        message.InlayHoleCount = reader.int32();
                        break;
                    case 12:
                        message.InlayHoleEffect1 = reader.string();
                        break;
                    case 13:
                        message.InlayHoleEffect2 = reader.string();
                        break;
                    case 14:
                        message.InlayHoleEffect3 = reader.string();
                        break;
                    case 15:
                        message.InlayHoleEffect4 = reader.string();
                        break;
                    case 16:
                        message.NoPropertyPower = reader.float();
                        break;
                    case 17:
                        message.IcePropertyPower = reader.float();
                        break;
                    case 18:
                        message.FirePropertyPower = reader.float();
                        break;
                    case 19:
                        message.ElectricPropertyPower = reader.float();
                        break;
                    case 20:
                        message.LandPropertyPower = reader.float();
                        break;
                    case 21:
                        message.PoisonPropertyPower = reader.float();
                        break;
                    case 22:
                        message.LightPropertyPower = reader.float();
                        break;
                    case 23:
                        message.DarkPropertyPower = reader.float();
                        break;
                    case 24:
                        message.NoPropertyStreng = reader.float();
                        break;
                    case 25:
                        message.IcePropertyStreng = reader.float();
                        break;
                    case 26:
                        message.FirePropertyStreng = reader.float();
                        break;
                    case 27:
                        message.ElectricPropertyStreng = reader.float();
                        break;
                    case 28:
                        message.LandPropertyStreng = reader.float();
                        break;
                    case 29:
                        message.PoisonPropertyStreng = reader.float();
                        break;
                    case 30:
                        message.LightPropertyStreng = reader.float();
                        break;
                    case 31:
                        message.DarkPropertyStreng = reader.float();
                        break;
                    case 32:
                        message.NoPropertyHurt = reader.float();
                        break;
                    case 33:
                        message.IcePropertyHurt = reader.float();
                        break;
                    case 34:
                        message.FirePropertyHurt = reader.float();
                        break;
                    case 35:
                        message.ElectricPropertyHurt = reader.float();
                        break;
                    case 36:
                        message.LandPropertyHurt = reader.float();
                        break;
                    case 37:
                        message.PoisonPropertyHurt = reader.float();
                        break;
                    case 38:
                        message.LightPropertyHurt = reader.float();
                        break;
                    case 39:
                        message.DarkPropertyHurt = reader.float();
                        break;
                    case 40:
                        message.AttackSpeed = reader.float();
                        break;
                    case 41:
                        if (!(message.skillList && message.skillList.length))
                            message.skillList = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.skillList.push(reader.int32());
                        } else
                            message.skillList.push(reader.int32());
                        break;
                    case 42:
                        message.WeaponType = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("WeaponID"))
                    throw $util.ProtocolError("missing required 'WeaponID'", { instance: message });
                if (!message.hasOwnProperty("Uid"))
                    throw $util.ProtocolError("missing required 'Uid'", { instance: message });
                if (!message.hasOwnProperty("WeaponNode"))
                    throw $util.ProtocolError("missing required 'WeaponNode'", { instance: message });
                if (!message.hasOwnProperty("CostBulletCount"))
                    throw $util.ProtocolError("missing required 'CostBulletCount'", { instance: message });
                if (!message.hasOwnProperty("CurrBullet"))
                    throw $util.ProtocolError("missing required 'CurrBullet'", { instance: message });
                if (!message.hasOwnProperty("BombLoad"))
                    throw $util.ProtocolError("missing required 'BombLoad'", { instance: message });
                if (!message.hasOwnProperty("bulletDataPb"))
                    throw $util.ProtocolError("missing required 'bulletDataPb'", { instance: message });
                if (!message.hasOwnProperty("Bulletdata1"))
                    throw $util.ProtocolError("missing required 'Bulletdata1'", { instance: message });
                if (!message.hasOwnProperty("Bulletdata2"))
                    throw $util.ProtocolError("missing required 'Bulletdata2'", { instance: message });
                if (!message.hasOwnProperty("Bulletdata3"))
                    throw $util.ProtocolError("missing required 'Bulletdata3'", { instance: message });
                if (!message.hasOwnProperty("InlayHoleCount"))
                    throw $util.ProtocolError("missing required 'InlayHoleCount'", { instance: message });
                if (!message.hasOwnProperty("InlayHoleEffect1"))
                    throw $util.ProtocolError("missing required 'InlayHoleEffect1'", { instance: message });
                if (!message.hasOwnProperty("InlayHoleEffect2"))
                    throw $util.ProtocolError("missing required 'InlayHoleEffect2'", { instance: message });
                if (!message.hasOwnProperty("InlayHoleEffect3"))
                    throw $util.ProtocolError("missing required 'InlayHoleEffect3'", { instance: message });
                if (!message.hasOwnProperty("InlayHoleEffect4"))
                    throw $util.ProtocolError("missing required 'InlayHoleEffect4'", { instance: message });
                if (!message.hasOwnProperty("NoPropertyPower"))
                    throw $util.ProtocolError("missing required 'NoPropertyPower'", { instance: message });
                if (!message.hasOwnProperty("IcePropertyPower"))
                    throw $util.ProtocolError("missing required 'IcePropertyPower'", { instance: message });
                if (!message.hasOwnProperty("FirePropertyPower"))
                    throw $util.ProtocolError("missing required 'FirePropertyPower'", { instance: message });
                if (!message.hasOwnProperty("ElectricPropertyPower"))
                    throw $util.ProtocolError("missing required 'ElectricPropertyPower'", { instance: message });
                if (!message.hasOwnProperty("LandPropertyPower"))
                    throw $util.ProtocolError("missing required 'LandPropertyPower'", { instance: message });
                if (!message.hasOwnProperty("PoisonPropertyPower"))
                    throw $util.ProtocolError("missing required 'PoisonPropertyPower'", { instance: message });
                if (!message.hasOwnProperty("LightPropertyPower"))
                    throw $util.ProtocolError("missing required 'LightPropertyPower'", { instance: message });
                if (!message.hasOwnProperty("DarkPropertyPower"))
                    throw $util.ProtocolError("missing required 'DarkPropertyPower'", { instance: message });
                if (!message.hasOwnProperty("NoPropertyStreng"))
                    throw $util.ProtocolError("missing required 'NoPropertyStreng'", { instance: message });
                if (!message.hasOwnProperty("IcePropertyStreng"))
                    throw $util.ProtocolError("missing required 'IcePropertyStreng'", { instance: message });
                if (!message.hasOwnProperty("FirePropertyStreng"))
                    throw $util.ProtocolError("missing required 'FirePropertyStreng'", { instance: message });
                if (!message.hasOwnProperty("ElectricPropertyStreng"))
                    throw $util.ProtocolError("missing required 'ElectricPropertyStreng'", { instance: message });
                if (!message.hasOwnProperty("LandPropertyStreng"))
                    throw $util.ProtocolError("missing required 'LandPropertyStreng'", { instance: message });
                if (!message.hasOwnProperty("PoisonPropertyStreng"))
                    throw $util.ProtocolError("missing required 'PoisonPropertyStreng'", { instance: message });
                if (!message.hasOwnProperty("LightPropertyStreng"))
                    throw $util.ProtocolError("missing required 'LightPropertyStreng'", { instance: message });
                if (!message.hasOwnProperty("DarkPropertyStreng"))
                    throw $util.ProtocolError("missing required 'DarkPropertyStreng'", { instance: message });
                if (!message.hasOwnProperty("NoPropertyHurt"))
                    throw $util.ProtocolError("missing required 'NoPropertyHurt'", { instance: message });
                if (!message.hasOwnProperty("IcePropertyHurt"))
                    throw $util.ProtocolError("missing required 'IcePropertyHurt'", { instance: message });
                if (!message.hasOwnProperty("FirePropertyHurt"))
                    throw $util.ProtocolError("missing required 'FirePropertyHurt'", { instance: message });
                if (!message.hasOwnProperty("ElectricPropertyHurt"))
                    throw $util.ProtocolError("missing required 'ElectricPropertyHurt'", { instance: message });
                if (!message.hasOwnProperty("LandPropertyHurt"))
                    throw $util.ProtocolError("missing required 'LandPropertyHurt'", { instance: message });
                if (!message.hasOwnProperty("PoisonPropertyHurt"))
                    throw $util.ProtocolError("missing required 'PoisonPropertyHurt'", { instance: message });
                if (!message.hasOwnProperty("LightPropertyHurt"))
                    throw $util.ProtocolError("missing required 'LightPropertyHurt'", { instance: message });
                if (!message.hasOwnProperty("DarkPropertyHurt"))
                    throw $util.ProtocolError("missing required 'DarkPropertyHurt'", { instance: message });
                if (!message.hasOwnProperty("AttackSpeed"))
                    throw $util.ProtocolError("missing required 'AttackSpeed'", { instance: message });
                if (!message.hasOwnProperty("WeaponType"))
                    throw $util.ProtocolError("missing required 'WeaponType'", { instance: message });
                return message;
            };

            /**
             * Decodes a BattleWeaponDataPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.BattleWeaponDataPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.BattleWeaponDataPB} BattleWeaponDataPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BattleWeaponDataPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BattleWeaponDataPB message.
             * @function verify
             * @memberof luck.protobuf.BattleWeaponDataPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BattleWeaponDataPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.WeaponID))
                    return "WeaponID: integer expected";
                if (!$util.isInteger(message.Uid))
                    return "Uid: integer expected";
                if (!$util.isInteger(message.WeaponNode))
                    return "WeaponNode: integer expected";
                if (!$util.isInteger(message.CostBulletCount))
                    return "CostBulletCount: integer expected";
                if (!$util.isInteger(message.CurrBullet))
                    return "CurrBullet: integer expected";
                if (!$util.isInteger(message.BombLoad))
                    return "BombLoad: integer expected";
                {
                    var error = $root.luck.protobuf.BattleBulletDataPB.verify(message.bulletDataPb);
                    if (error)
                        return "bulletDataPb." + error;
                }
                {
                    var error = $root.luck.protobuf.BattleBulletDataPB.verify(message.Bulletdata1);
                    if (error)
                        return "Bulletdata1." + error;
                }
                {
                    var error = $root.luck.protobuf.BattleBulletDataPB.verify(message.Bulletdata2);
                    if (error)
                        return "Bulletdata2." + error;
                }
                {
                    var error = $root.luck.protobuf.BattleBulletDataPB.verify(message.Bulletdata3);
                    if (error)
                        return "Bulletdata3." + error;
                }
                if (!$util.isInteger(message.InlayHoleCount))
                    return "InlayHoleCount: integer expected";
                if (!$util.isString(message.InlayHoleEffect1))
                    return "InlayHoleEffect1: string expected";
                if (!$util.isString(message.InlayHoleEffect2))
                    return "InlayHoleEffect2: string expected";
                if (!$util.isString(message.InlayHoleEffect3))
                    return "InlayHoleEffect3: string expected";
                if (!$util.isString(message.InlayHoleEffect4))
                    return "InlayHoleEffect4: string expected";
                if (typeof message.NoPropertyPower !== "number")
                    return "NoPropertyPower: number expected";
                if (typeof message.IcePropertyPower !== "number")
                    return "IcePropertyPower: number expected";
                if (typeof message.FirePropertyPower !== "number")
                    return "FirePropertyPower: number expected";
                if (typeof message.ElectricPropertyPower !== "number")
                    return "ElectricPropertyPower: number expected";
                if (typeof message.LandPropertyPower !== "number")
                    return "LandPropertyPower: number expected";
                if (typeof message.PoisonPropertyPower !== "number")
                    return "PoisonPropertyPower: number expected";
                if (typeof message.LightPropertyPower !== "number")
                    return "LightPropertyPower: number expected";
                if (typeof message.DarkPropertyPower !== "number")
                    return "DarkPropertyPower: number expected";
                if (typeof message.NoPropertyStreng !== "number")
                    return "NoPropertyStreng: number expected";
                if (typeof message.IcePropertyStreng !== "number")
                    return "IcePropertyStreng: number expected";
                if (typeof message.FirePropertyStreng !== "number")
                    return "FirePropertyStreng: number expected";
                if (typeof message.ElectricPropertyStreng !== "number")
                    return "ElectricPropertyStreng: number expected";
                if (typeof message.LandPropertyStreng !== "number")
                    return "LandPropertyStreng: number expected";
                if (typeof message.PoisonPropertyStreng !== "number")
                    return "PoisonPropertyStreng: number expected";
                if (typeof message.LightPropertyStreng !== "number")
                    return "LightPropertyStreng: number expected";
                if (typeof message.DarkPropertyStreng !== "number")
                    return "DarkPropertyStreng: number expected";
                if (typeof message.NoPropertyHurt !== "number")
                    return "NoPropertyHurt: number expected";
                if (typeof message.IcePropertyHurt !== "number")
                    return "IcePropertyHurt: number expected";
                if (typeof message.FirePropertyHurt !== "number")
                    return "FirePropertyHurt: number expected";
                if (typeof message.ElectricPropertyHurt !== "number")
                    return "ElectricPropertyHurt: number expected";
                if (typeof message.LandPropertyHurt !== "number")
                    return "LandPropertyHurt: number expected";
                if (typeof message.PoisonPropertyHurt !== "number")
                    return "PoisonPropertyHurt: number expected";
                if (typeof message.LightPropertyHurt !== "number")
                    return "LightPropertyHurt: number expected";
                if (typeof message.DarkPropertyHurt !== "number")
                    return "DarkPropertyHurt: number expected";
                if (typeof message.AttackSpeed !== "number")
                    return "AttackSpeed: number expected";
                if (message.skillList != null && message.hasOwnProperty("skillList")) {
                    if (!Array.isArray(message.skillList))
                        return "skillList: array expected";
                    for (var i = 0; i < message.skillList.length; ++i)
                        if (!$util.isInteger(message.skillList[i]))
                            return "skillList: integer[] expected";
                }
                if (!$util.isInteger(message.WeaponType))
                    return "WeaponType: integer expected";
                return null;
            };

            return BattleWeaponDataPB;
        })();

        protobuf.BattleMonsterPB = (function() {

            /**
             * Properties of a BattleMonsterPB.
             * @memberof luck.protobuf
             * @interface IBattleMonsterPB
             * @property {number} PosX BattleMonsterPB PosX
             * @property {number} PosY BattleMonsterPB PosY
             * @property {number} PosZ BattleMonsterPB PosZ
             * @property {number} AngleX BattleMonsterPB AngleX
             * @property {number} AngleY BattleMonsterPB AngleY
             * @property {number} AngleZ BattleMonsterPB AngleZ
             * @property {number} TargetX BattleMonsterPB TargetX
             * @property {number} TargetY BattleMonsterPB TargetY
             * @property {number} TargetZ BattleMonsterPB TargetZ
             * @property {luck.protobuf.IBattleMonsterDataPB} monsterPb BattleMonsterPB monsterPb
             * @property {number} CurrStateID BattleMonsterPB CurrStateID
             * @property {boolean} IsAttackState BattleMonsterPB IsAttackState
             * @property {boolean} IsMoveState BattleMonsterPB IsMoveState
             * @property {boolean} isCanAttack BattleMonsterPB isCanAttack
             * @property {number} AttackTimer BattleMonsterPB AttackTimer
             * @property {number} HitTimer BattleMonsterPB HitTimer
             */

            /**
             * Constructs a new BattleMonsterPB.
             * @memberof luck.protobuf
             * @classdesc Represents a BattleMonsterPB.
             * @implements IBattleMonsterPB
             * @constructor
             * @param {luck.protobuf.IBattleMonsterPB=} [properties] Properties to set
             */
            function BattleMonsterPB(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BattleMonsterPB PosX.
             * @member {number} PosX
             * @memberof luck.protobuf.BattleMonsterPB
             * @instance
             */
            BattleMonsterPB.prototype.PosX = 0;

            /**
             * BattleMonsterPB PosY.
             * @member {number} PosY
             * @memberof luck.protobuf.BattleMonsterPB
             * @instance
             */
            BattleMonsterPB.prototype.PosY = 0;

            /**
             * BattleMonsterPB PosZ.
             * @member {number} PosZ
             * @memberof luck.protobuf.BattleMonsterPB
             * @instance
             */
            BattleMonsterPB.prototype.PosZ = 0;

            /**
             * BattleMonsterPB AngleX.
             * @member {number} AngleX
             * @memberof luck.protobuf.BattleMonsterPB
             * @instance
             */
            BattleMonsterPB.prototype.AngleX = 0;

            /**
             * BattleMonsterPB AngleY.
             * @member {number} AngleY
             * @memberof luck.protobuf.BattleMonsterPB
             * @instance
             */
            BattleMonsterPB.prototype.AngleY = 0;

            /**
             * BattleMonsterPB AngleZ.
             * @member {number} AngleZ
             * @memberof luck.protobuf.BattleMonsterPB
             * @instance
             */
            BattleMonsterPB.prototype.AngleZ = 0;

            /**
             * BattleMonsterPB TargetX.
             * @member {number} TargetX
             * @memberof luck.protobuf.BattleMonsterPB
             * @instance
             */
            BattleMonsterPB.prototype.TargetX = 0;

            /**
             * BattleMonsterPB TargetY.
             * @member {number} TargetY
             * @memberof luck.protobuf.BattleMonsterPB
             * @instance
             */
            BattleMonsterPB.prototype.TargetY = 0;

            /**
             * BattleMonsterPB TargetZ.
             * @member {number} TargetZ
             * @memberof luck.protobuf.BattleMonsterPB
             * @instance
             */
            BattleMonsterPB.prototype.TargetZ = 0;

            /**
             * BattleMonsterPB monsterPb.
             * @member {luck.protobuf.IBattleMonsterDataPB} monsterPb
             * @memberof luck.protobuf.BattleMonsterPB
             * @instance
             */
            BattleMonsterPB.prototype.monsterPb = null;

            /**
             * BattleMonsterPB CurrStateID.
             * @member {number} CurrStateID
             * @memberof luck.protobuf.BattleMonsterPB
             * @instance
             */
            BattleMonsterPB.prototype.CurrStateID = 0;

            /**
             * BattleMonsterPB IsAttackState.
             * @member {boolean} IsAttackState
             * @memberof luck.protobuf.BattleMonsterPB
             * @instance
             */
            BattleMonsterPB.prototype.IsAttackState = false;

            /**
             * BattleMonsterPB IsMoveState.
             * @member {boolean} IsMoveState
             * @memberof luck.protobuf.BattleMonsterPB
             * @instance
             */
            BattleMonsterPB.prototype.IsMoveState = false;

            /**
             * BattleMonsterPB isCanAttack.
             * @member {boolean} isCanAttack
             * @memberof luck.protobuf.BattleMonsterPB
             * @instance
             */
            BattleMonsterPB.prototype.isCanAttack = false;

            /**
             * BattleMonsterPB AttackTimer.
             * @member {number} AttackTimer
             * @memberof luck.protobuf.BattleMonsterPB
             * @instance
             */
            BattleMonsterPB.prototype.AttackTimer = 0;

            /**
             * BattleMonsterPB HitTimer.
             * @member {number} HitTimer
             * @memberof luck.protobuf.BattleMonsterPB
             * @instance
             */
            BattleMonsterPB.prototype.HitTimer = 0;

            /**
             * Creates a new BattleMonsterPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.BattleMonsterPB
             * @static
             * @param {luck.protobuf.IBattleMonsterPB=} [properties] Properties to set
             * @returns {luck.protobuf.BattleMonsterPB} BattleMonsterPB instance
             */
            BattleMonsterPB.create = function create(properties) {
                return new BattleMonsterPB(properties);
            };

            /**
             * Encodes the specified BattleMonsterPB message. Does not implicitly {@link luck.protobuf.BattleMonsterPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.BattleMonsterPB
             * @static
             * @param {luck.protobuf.IBattleMonsterPB} message BattleMonsterPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BattleMonsterPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.PosX);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.PosY);
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.PosZ);
                writer.uint32(/* id 4, wireType 5 =*/37).float(message.AngleX);
                writer.uint32(/* id 5, wireType 5 =*/45).float(message.AngleY);
                writer.uint32(/* id 6, wireType 5 =*/53).float(message.AngleZ);
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.TargetX);
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.TargetY);
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.TargetZ);
                $root.luck.protobuf.BattleMonsterDataPB.encode(message.monsterPb, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.CurrStateID);
                writer.uint32(/* id 12, wireType 0 =*/96).bool(message.IsAttackState);
                writer.uint32(/* id 13, wireType 0 =*/104).bool(message.IsMoveState);
                writer.uint32(/* id 14, wireType 0 =*/112).bool(message.isCanAttack);
                writer.uint32(/* id 15, wireType 0 =*/120).int32(message.AttackTimer);
                writer.uint32(/* id 16, wireType 0 =*/128).int32(message.HitTimer);
                return writer;
            };

            /**
             * Encodes the specified BattleMonsterPB message, length delimited. Does not implicitly {@link luck.protobuf.BattleMonsterPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.BattleMonsterPB
             * @static
             * @param {luck.protobuf.IBattleMonsterPB} message BattleMonsterPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BattleMonsterPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BattleMonsterPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.BattleMonsterPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.BattleMonsterPB} BattleMonsterPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BattleMonsterPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.BattleMonsterPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.PosX = reader.int32();
                        break;
                    case 2:
                        message.PosY = reader.int32();
                        break;
                    case 3:
                        message.PosZ = reader.int32();
                        break;
                    case 4:
                        message.AngleX = reader.float();
                        break;
                    case 5:
                        message.AngleY = reader.float();
                        break;
                    case 6:
                        message.AngleZ = reader.float();
                        break;
                    case 7:
                        message.TargetX = reader.int32();
                        break;
                    case 8:
                        message.TargetY = reader.int32();
                        break;
                    case 9:
                        message.TargetZ = reader.int32();
                        break;
                    case 10:
                        message.monsterPb = $root.luck.protobuf.BattleMonsterDataPB.decode(reader, reader.uint32());
                        break;
                    case 11:
                        message.CurrStateID = reader.int32();
                        break;
                    case 12:
                        message.IsAttackState = reader.bool();
                        break;
                    case 13:
                        message.IsMoveState = reader.bool();
                        break;
                    case 14:
                        message.isCanAttack = reader.bool();
                        break;
                    case 15:
                        message.AttackTimer = reader.int32();
                        break;
                    case 16:
                        message.HitTimer = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("PosX"))
                    throw $util.ProtocolError("missing required 'PosX'", { instance: message });
                if (!message.hasOwnProperty("PosY"))
                    throw $util.ProtocolError("missing required 'PosY'", { instance: message });
                if (!message.hasOwnProperty("PosZ"))
                    throw $util.ProtocolError("missing required 'PosZ'", { instance: message });
                if (!message.hasOwnProperty("AngleX"))
                    throw $util.ProtocolError("missing required 'AngleX'", { instance: message });
                if (!message.hasOwnProperty("AngleY"))
                    throw $util.ProtocolError("missing required 'AngleY'", { instance: message });
                if (!message.hasOwnProperty("AngleZ"))
                    throw $util.ProtocolError("missing required 'AngleZ'", { instance: message });
                if (!message.hasOwnProperty("TargetX"))
                    throw $util.ProtocolError("missing required 'TargetX'", { instance: message });
                if (!message.hasOwnProperty("TargetY"))
                    throw $util.ProtocolError("missing required 'TargetY'", { instance: message });
                if (!message.hasOwnProperty("TargetZ"))
                    throw $util.ProtocolError("missing required 'TargetZ'", { instance: message });
                if (!message.hasOwnProperty("monsterPb"))
                    throw $util.ProtocolError("missing required 'monsterPb'", { instance: message });
                if (!message.hasOwnProperty("CurrStateID"))
                    throw $util.ProtocolError("missing required 'CurrStateID'", { instance: message });
                if (!message.hasOwnProperty("IsAttackState"))
                    throw $util.ProtocolError("missing required 'IsAttackState'", { instance: message });
                if (!message.hasOwnProperty("IsMoveState"))
                    throw $util.ProtocolError("missing required 'IsMoveState'", { instance: message });
                if (!message.hasOwnProperty("isCanAttack"))
                    throw $util.ProtocolError("missing required 'isCanAttack'", { instance: message });
                if (!message.hasOwnProperty("AttackTimer"))
                    throw $util.ProtocolError("missing required 'AttackTimer'", { instance: message });
                if (!message.hasOwnProperty("HitTimer"))
                    throw $util.ProtocolError("missing required 'HitTimer'", { instance: message });
                return message;
            };

            /**
             * Decodes a BattleMonsterPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.BattleMonsterPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.BattleMonsterPB} BattleMonsterPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BattleMonsterPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BattleMonsterPB message.
             * @function verify
             * @memberof luck.protobuf.BattleMonsterPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BattleMonsterPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.PosX))
                    return "PosX: integer expected";
                if (!$util.isInteger(message.PosY))
                    return "PosY: integer expected";
                if (!$util.isInteger(message.PosZ))
                    return "PosZ: integer expected";
                if (typeof message.AngleX !== "number")
                    return "AngleX: number expected";
                if (typeof message.AngleY !== "number")
                    return "AngleY: number expected";
                if (typeof message.AngleZ !== "number")
                    return "AngleZ: number expected";
                if (!$util.isInteger(message.TargetX))
                    return "TargetX: integer expected";
                if (!$util.isInteger(message.TargetY))
                    return "TargetY: integer expected";
                if (!$util.isInteger(message.TargetZ))
                    return "TargetZ: integer expected";
                {
                    var error = $root.luck.protobuf.BattleMonsterDataPB.verify(message.monsterPb);
                    if (error)
                        return "monsterPb." + error;
                }
                if (!$util.isInteger(message.CurrStateID))
                    return "CurrStateID: integer expected";
                if (typeof message.IsAttackState !== "boolean")
                    return "IsAttackState: boolean expected";
                if (typeof message.IsMoveState !== "boolean")
                    return "IsMoveState: boolean expected";
                if (typeof message.isCanAttack !== "boolean")
                    return "isCanAttack: boolean expected";
                if (!$util.isInteger(message.AttackTimer))
                    return "AttackTimer: integer expected";
                if (!$util.isInteger(message.HitTimer))
                    return "HitTimer: integer expected";
                return null;
            };

            return BattleMonsterPB;
        })();

        protobuf.BattleMonsterDataPB = (function() {

            /**
             * Properties of a BattleMonsterDataPB.
             * @memberof luck.protobuf
             * @interface IBattleMonsterDataPB
             * @property {number} ID BattleMonsterDataPB ID
             * @property {number} serveID BattleMonsterDataPB serveID
             * @property {string} Name BattleMonsterDataPB Name
             * @property {number} Lelel BattleMonsterDataPB Lelel
             * @property {number} CampID BattleMonsterDataPB CampID
             * @property {string} PrefabName BattleMonsterDataPB PrefabName
             * @property {number} MonsterType BattleMonsterDataPB MonsterType
             * @property {number} WarnRange BattleMonsterDataPB WarnRange
             * @property {number} Pursuit BattleMonsterDataPB Pursuit
             * @property {number|Long} CurrHp BattleMonsterDataPB CurrHp
             * @property {number|Long} MaxHp BattleMonsterDataPB MaxHp
             * @property {number} ModeOfPursuit BattleMonsterDataPB ModeOfPursuit
             * @property {number} Time BattleMonsterDataPB Time
             * @property {number} Probability BattleMonsterDataPB Probability
             * @property {number} NoPropertyResistance BattleMonsterDataPB NoPropertyResistance
             * @property {number} IcePropertyResistance BattleMonsterDataPB IcePropertyResistance
             * @property {number} FirePropertyResistance BattleMonsterDataPB FirePropertyResistance
             * @property {number} ElectricPropertyResistance BattleMonsterDataPB ElectricPropertyResistance
             * @property {number} LandPropertyResistance BattleMonsterDataPB LandPropertyResistance
             * @property {number} PoisonPropertyResistance BattleMonsterDataPB PoisonPropertyResistance
             * @property {number} LightPropertyResistance BattleMonsterDataPB LightPropertyResistance
             * @property {number} DarkPropertyResistance BattleMonsterDataPB DarkPropertyResistance
             * @property {number} NoPropertyReduction BattleMonsterDataPB NoPropertyReduction
             * @property {number} IcePropertyReduction BattleMonsterDataPB IcePropertyReduction
             * @property {number} FirePropertyReduction BattleMonsterDataPB FirePropertyReduction
             * @property {number} ElectricPropertyReduction BattleMonsterDataPB ElectricPropertyReduction
             * @property {number} LandPropertyReduction BattleMonsterDataPB LandPropertyReduction
             * @property {number} PoisonPropertyReduction BattleMonsterDataPB PoisonPropertyReduction
             * @property {number} LightPropertyReduction BattleMonsterDataPB LightPropertyReduction
             * @property {number} DarkPropertyReduction BattleMonsterDataPB DarkPropertyReduction
             * @property {number} AttackType BattleMonsterDataPB AttackType
             * @property {number} AttackLenth BattleMonsterDataPB AttackLenth
             * @property {number} MoveSpeed BattleMonsterDataPB MoveSpeed
             * @property {number} Hit BattleMonsterDataPB Hit
             * @property {number} Dodge BattleMonsterDataPB Dodge
             * @property {number} Cri BattleMonsterDataPB Cri
             * @property {number} CriStrength BattleMonsterDataPB CriStrength
             * @property {Array.<number>|null} [skillList] BattleMonsterDataPB skillList
             * @property {number} NoPropertyHurt BattleMonsterDataPB NoPropertyHurt
             * @property {number} IcePropertyHurt BattleMonsterDataPB IcePropertyHurt
             * @property {number} FirePropertyHurt BattleMonsterDataPB FirePropertyHurt
             * @property {number} ElectricPropertyHurt BattleMonsterDataPB ElectricPropertyHurt
             * @property {number} LandPropertyHurt BattleMonsterDataPB LandPropertyHurt
             * @property {number} PoisonPropertyHurt BattleMonsterDataPB PoisonPropertyHurt
             * @property {number} LightPropertyHurt BattleMonsterDataPB LightPropertyHurt
             * @property {number} DarkPropertyHurt BattleMonsterDataPB DarkPropertyHurt
             * @property {number} NoPropertyPower BattleMonsterDataPB NoPropertyPower
             * @property {number} IcePropertyPower BattleMonsterDataPB IcePropertyPower
             * @property {number} FirePropertyPower BattleMonsterDataPB FirePropertyPower
             * @property {number} ElectricPropertyPower BattleMonsterDataPB ElectricPropertyPower
             * @property {number} LandPropertyPower BattleMonsterDataPB LandPropertyPower
             * @property {number} PoisonPropertyPower BattleMonsterDataPB PoisonPropertyPower
             * @property {number} LightPropertyPower BattleMonsterDataPB LightPropertyPower
             * @property {number} DarkPropertyPower BattleMonsterDataPB DarkPropertyPower
             * @property {number} AttackSpeed BattleMonsterDataPB AttackSpeed
             * @property {string} GeneratingEffect BattleMonsterDataPB GeneratingEffect
             * @property {luck.protobuf.IBattleBulletDataPB} bulletDataPb BattleMonsterDataPB bulletDataPb
             */

            /**
             * Constructs a new BattleMonsterDataPB.
             * @memberof luck.protobuf
             * @classdesc Represents a BattleMonsterDataPB.
             * @implements IBattleMonsterDataPB
             * @constructor
             * @param {luck.protobuf.IBattleMonsterDataPB=} [properties] Properties to set
             */
            function BattleMonsterDataPB(properties) {
                this.skillList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BattleMonsterDataPB ID.
             * @member {number} ID
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.ID = 0;

            /**
             * BattleMonsterDataPB serveID.
             * @member {number} serveID
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.serveID = 0;

            /**
             * BattleMonsterDataPB Name.
             * @member {string} Name
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.Name = "";

            /**
             * BattleMonsterDataPB Lelel.
             * @member {number} Lelel
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.Lelel = 0;

            /**
             * BattleMonsterDataPB CampID.
             * @member {number} CampID
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.CampID = 0;

            /**
             * BattleMonsterDataPB PrefabName.
             * @member {string} PrefabName
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.PrefabName = "";

            /**
             * BattleMonsterDataPB MonsterType.
             * @member {number} MonsterType
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.MonsterType = 0;

            /**
             * BattleMonsterDataPB WarnRange.
             * @member {number} WarnRange
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.WarnRange = 0;

            /**
             * BattleMonsterDataPB Pursuit.
             * @member {number} Pursuit
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.Pursuit = 0;

            /**
             * BattleMonsterDataPB CurrHp.
             * @member {number|Long} CurrHp
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.CurrHp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * BattleMonsterDataPB MaxHp.
             * @member {number|Long} MaxHp
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.MaxHp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * BattleMonsterDataPB ModeOfPursuit.
             * @member {number} ModeOfPursuit
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.ModeOfPursuit = 0;

            /**
             * BattleMonsterDataPB Time.
             * @member {number} Time
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.Time = 0;

            /**
             * BattleMonsterDataPB Probability.
             * @member {number} Probability
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.Probability = 0;

            /**
             * BattleMonsterDataPB NoPropertyResistance.
             * @member {number} NoPropertyResistance
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.NoPropertyResistance = 0;

            /**
             * BattleMonsterDataPB IcePropertyResistance.
             * @member {number} IcePropertyResistance
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.IcePropertyResistance = 0;

            /**
             * BattleMonsterDataPB FirePropertyResistance.
             * @member {number} FirePropertyResistance
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.FirePropertyResistance = 0;

            /**
             * BattleMonsterDataPB ElectricPropertyResistance.
             * @member {number} ElectricPropertyResistance
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.ElectricPropertyResistance = 0;

            /**
             * BattleMonsterDataPB LandPropertyResistance.
             * @member {number} LandPropertyResistance
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.LandPropertyResistance = 0;

            /**
             * BattleMonsterDataPB PoisonPropertyResistance.
             * @member {number} PoisonPropertyResistance
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.PoisonPropertyResistance = 0;

            /**
             * BattleMonsterDataPB LightPropertyResistance.
             * @member {number} LightPropertyResistance
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.LightPropertyResistance = 0;

            /**
             * BattleMonsterDataPB DarkPropertyResistance.
             * @member {number} DarkPropertyResistance
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.DarkPropertyResistance = 0;

            /**
             * BattleMonsterDataPB NoPropertyReduction.
             * @member {number} NoPropertyReduction
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.NoPropertyReduction = 0;

            /**
             * BattleMonsterDataPB IcePropertyReduction.
             * @member {number} IcePropertyReduction
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.IcePropertyReduction = 0;

            /**
             * BattleMonsterDataPB FirePropertyReduction.
             * @member {number} FirePropertyReduction
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.FirePropertyReduction = 0;

            /**
             * BattleMonsterDataPB ElectricPropertyReduction.
             * @member {number} ElectricPropertyReduction
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.ElectricPropertyReduction = 0;

            /**
             * BattleMonsterDataPB LandPropertyReduction.
             * @member {number} LandPropertyReduction
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.LandPropertyReduction = 0;

            /**
             * BattleMonsterDataPB PoisonPropertyReduction.
             * @member {number} PoisonPropertyReduction
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.PoisonPropertyReduction = 0;

            /**
             * BattleMonsterDataPB LightPropertyReduction.
             * @member {number} LightPropertyReduction
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.LightPropertyReduction = 0;

            /**
             * BattleMonsterDataPB DarkPropertyReduction.
             * @member {number} DarkPropertyReduction
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.DarkPropertyReduction = 0;

            /**
             * BattleMonsterDataPB AttackType.
             * @member {number} AttackType
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.AttackType = 0;

            /**
             * BattleMonsterDataPB AttackLenth.
             * @member {number} AttackLenth
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.AttackLenth = 0;

            /**
             * BattleMonsterDataPB MoveSpeed.
             * @member {number} MoveSpeed
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.MoveSpeed = 0;

            /**
             * BattleMonsterDataPB Hit.
             * @member {number} Hit
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.Hit = 0;

            /**
             * BattleMonsterDataPB Dodge.
             * @member {number} Dodge
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.Dodge = 0;

            /**
             * BattleMonsterDataPB Cri.
             * @member {number} Cri
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.Cri = 0;

            /**
             * BattleMonsterDataPB CriStrength.
             * @member {number} CriStrength
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.CriStrength = 0;

            /**
             * BattleMonsterDataPB skillList.
             * @member {Array.<number>} skillList
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.skillList = $util.emptyArray;

            /**
             * BattleMonsterDataPB NoPropertyHurt.
             * @member {number} NoPropertyHurt
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.NoPropertyHurt = 0;

            /**
             * BattleMonsterDataPB IcePropertyHurt.
             * @member {number} IcePropertyHurt
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.IcePropertyHurt = 0;

            /**
             * BattleMonsterDataPB FirePropertyHurt.
             * @member {number} FirePropertyHurt
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.FirePropertyHurt = 0;

            /**
             * BattleMonsterDataPB ElectricPropertyHurt.
             * @member {number} ElectricPropertyHurt
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.ElectricPropertyHurt = 0;

            /**
             * BattleMonsterDataPB LandPropertyHurt.
             * @member {number} LandPropertyHurt
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.LandPropertyHurt = 0;

            /**
             * BattleMonsterDataPB PoisonPropertyHurt.
             * @member {number} PoisonPropertyHurt
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.PoisonPropertyHurt = 0;

            /**
             * BattleMonsterDataPB LightPropertyHurt.
             * @member {number} LightPropertyHurt
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.LightPropertyHurt = 0;

            /**
             * BattleMonsterDataPB DarkPropertyHurt.
             * @member {number} DarkPropertyHurt
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.DarkPropertyHurt = 0;

            /**
             * BattleMonsterDataPB NoPropertyPower.
             * @member {number} NoPropertyPower
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.NoPropertyPower = 0;

            /**
             * BattleMonsterDataPB IcePropertyPower.
             * @member {number} IcePropertyPower
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.IcePropertyPower = 0;

            /**
             * BattleMonsterDataPB FirePropertyPower.
             * @member {number} FirePropertyPower
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.FirePropertyPower = 0;

            /**
             * BattleMonsterDataPB ElectricPropertyPower.
             * @member {number} ElectricPropertyPower
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.ElectricPropertyPower = 0;

            /**
             * BattleMonsterDataPB LandPropertyPower.
             * @member {number} LandPropertyPower
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.LandPropertyPower = 0;

            /**
             * BattleMonsterDataPB PoisonPropertyPower.
             * @member {number} PoisonPropertyPower
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.PoisonPropertyPower = 0;

            /**
             * BattleMonsterDataPB LightPropertyPower.
             * @member {number} LightPropertyPower
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.LightPropertyPower = 0;

            /**
             * BattleMonsterDataPB DarkPropertyPower.
             * @member {number} DarkPropertyPower
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.DarkPropertyPower = 0;

            /**
             * BattleMonsterDataPB AttackSpeed.
             * @member {number} AttackSpeed
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.AttackSpeed = 0;

            /**
             * BattleMonsterDataPB GeneratingEffect.
             * @member {string} GeneratingEffect
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.GeneratingEffect = "";

            /**
             * BattleMonsterDataPB bulletDataPb.
             * @member {luck.protobuf.IBattleBulletDataPB} bulletDataPb
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @instance
             */
            BattleMonsterDataPB.prototype.bulletDataPb = null;

            /**
             * Creates a new BattleMonsterDataPB instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @static
             * @param {luck.protobuf.IBattleMonsterDataPB=} [properties] Properties to set
             * @returns {luck.protobuf.BattleMonsterDataPB} BattleMonsterDataPB instance
             */
            BattleMonsterDataPB.create = function create(properties) {
                return new BattleMonsterDataPB(properties);
            };

            /**
             * Encodes the specified BattleMonsterDataPB message. Does not implicitly {@link luck.protobuf.BattleMonsterDataPB.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @static
             * @param {luck.protobuf.IBattleMonsterDataPB} message BattleMonsterDataPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BattleMonsterDataPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ID);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.serveID);
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.Name);
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.Lelel);
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.CampID);
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.PrefabName);
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.MonsterType);
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.WarnRange);
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.Pursuit);
                writer.uint32(/* id 10, wireType 0 =*/80).int64(message.CurrHp);
                writer.uint32(/* id 11, wireType 0 =*/88).int64(message.MaxHp);
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.ModeOfPursuit);
                writer.uint32(/* id 13, wireType 5 =*/109).float(message.Time);
                writer.uint32(/* id 14, wireType 0 =*/112).int32(message.Probability);
                writer.uint32(/* id 15, wireType 5 =*/125).float(message.NoPropertyResistance);
                writer.uint32(/* id 16, wireType 5 =*/133).float(message.IcePropertyResistance);
                writer.uint32(/* id 17, wireType 5 =*/141).float(message.FirePropertyResistance);
                writer.uint32(/* id 18, wireType 5 =*/149).float(message.ElectricPropertyResistance);
                writer.uint32(/* id 19, wireType 5 =*/157).float(message.LandPropertyResistance);
                writer.uint32(/* id 20, wireType 5 =*/165).float(message.PoisonPropertyResistance);
                writer.uint32(/* id 21, wireType 5 =*/173).float(message.LightPropertyResistance);
                writer.uint32(/* id 22, wireType 5 =*/181).float(message.DarkPropertyResistance);
                writer.uint32(/* id 23, wireType 5 =*/189).float(message.NoPropertyReduction);
                writer.uint32(/* id 24, wireType 5 =*/197).float(message.IcePropertyReduction);
                writer.uint32(/* id 25, wireType 5 =*/205).float(message.FirePropertyReduction);
                writer.uint32(/* id 26, wireType 5 =*/213).float(message.ElectricPropertyReduction);
                writer.uint32(/* id 27, wireType 5 =*/221).float(message.LandPropertyReduction);
                writer.uint32(/* id 28, wireType 5 =*/229).float(message.PoisonPropertyReduction);
                writer.uint32(/* id 29, wireType 5 =*/237).float(message.LightPropertyReduction);
                writer.uint32(/* id 30, wireType 5 =*/245).float(message.DarkPropertyReduction);
                writer.uint32(/* id 31, wireType 0 =*/248).int32(message.AttackType);
                writer.uint32(/* id 32, wireType 5 =*/261).float(message.AttackLenth);
                writer.uint32(/* id 33, wireType 5 =*/269).float(message.MoveSpeed);
                writer.uint32(/* id 34, wireType 5 =*/277).float(message.Hit);
                writer.uint32(/* id 35, wireType 5 =*/285).float(message.Dodge);
                writer.uint32(/* id 36, wireType 5 =*/293).float(message.Cri);
                writer.uint32(/* id 37, wireType 5 =*/301).float(message.CriStrength);
                if (message.skillList != null && message.skillList.length)
                    for (var i = 0; i < message.skillList.length; ++i)
                        writer.uint32(/* id 38, wireType 0 =*/304).int32(message.skillList[i]);
                writer.uint32(/* id 39, wireType 5 =*/317).float(message.NoPropertyHurt);
                writer.uint32(/* id 40, wireType 5 =*/325).float(message.IcePropertyHurt);
                writer.uint32(/* id 41, wireType 5 =*/333).float(message.FirePropertyHurt);
                writer.uint32(/* id 42, wireType 5 =*/341).float(message.ElectricPropertyHurt);
                writer.uint32(/* id 43, wireType 5 =*/349).float(message.LandPropertyHurt);
                writer.uint32(/* id 44, wireType 5 =*/357).float(message.PoisonPropertyHurt);
                writer.uint32(/* id 45, wireType 5 =*/365).float(message.LightPropertyHurt);
                writer.uint32(/* id 46, wireType 5 =*/373).float(message.DarkPropertyHurt);
                writer.uint32(/* id 47, wireType 5 =*/381).float(message.NoPropertyPower);
                writer.uint32(/* id 48, wireType 5 =*/389).float(message.IcePropertyPower);
                writer.uint32(/* id 49, wireType 5 =*/397).float(message.FirePropertyPower);
                writer.uint32(/* id 50, wireType 5 =*/405).float(message.ElectricPropertyPower);
                writer.uint32(/* id 51, wireType 5 =*/413).float(message.LandPropertyPower);
                writer.uint32(/* id 52, wireType 5 =*/421).float(message.PoisonPropertyPower);
                writer.uint32(/* id 53, wireType 5 =*/429).float(message.LightPropertyPower);
                writer.uint32(/* id 54, wireType 5 =*/437).float(message.DarkPropertyPower);
                writer.uint32(/* id 55, wireType 5 =*/445).float(message.AttackSpeed);
                writer.uint32(/* id 56, wireType 2 =*/450).string(message.GeneratingEffect);
                $root.luck.protobuf.BattleBulletDataPB.encode(message.bulletDataPb, writer.uint32(/* id 57, wireType 2 =*/458).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified BattleMonsterDataPB message, length delimited. Does not implicitly {@link luck.protobuf.BattleMonsterDataPB.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @static
             * @param {luck.protobuf.IBattleMonsterDataPB} message BattleMonsterDataPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BattleMonsterDataPB.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BattleMonsterDataPB message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.BattleMonsterDataPB} BattleMonsterDataPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BattleMonsterDataPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.BattleMonsterDataPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.ID = reader.int32();
                        break;
                    case 2:
                        message.serveID = reader.int32();
                        break;
                    case 3:
                        message.Name = reader.string();
                        break;
                    case 4:
                        message.Lelel = reader.int32();
                        break;
                    case 5:
                        message.CampID = reader.int32();
                        break;
                    case 6:
                        message.PrefabName = reader.string();
                        break;
                    case 7:
                        message.MonsterType = reader.int32();
                        break;
                    case 8:
                        message.WarnRange = reader.int32();
                        break;
                    case 9:
                        message.Pursuit = reader.int32();
                        break;
                    case 10:
                        message.CurrHp = reader.int64();
                        break;
                    case 11:
                        message.MaxHp = reader.int64();
                        break;
                    case 12:
                        message.ModeOfPursuit = reader.int32();
                        break;
                    case 13:
                        message.Time = reader.float();
                        break;
                    case 14:
                        message.Probability = reader.int32();
                        break;
                    case 15:
                        message.NoPropertyResistance = reader.float();
                        break;
                    case 16:
                        message.IcePropertyResistance = reader.float();
                        break;
                    case 17:
                        message.FirePropertyResistance = reader.float();
                        break;
                    case 18:
                        message.ElectricPropertyResistance = reader.float();
                        break;
                    case 19:
                        message.LandPropertyResistance = reader.float();
                        break;
                    case 20:
                        message.PoisonPropertyResistance = reader.float();
                        break;
                    case 21:
                        message.LightPropertyResistance = reader.float();
                        break;
                    case 22:
                        message.DarkPropertyResistance = reader.float();
                        break;
                    case 23:
                        message.NoPropertyReduction = reader.float();
                        break;
                    case 24:
                        message.IcePropertyReduction = reader.float();
                        break;
                    case 25:
                        message.FirePropertyReduction = reader.float();
                        break;
                    case 26:
                        message.ElectricPropertyReduction = reader.float();
                        break;
                    case 27:
                        message.LandPropertyReduction = reader.float();
                        break;
                    case 28:
                        message.PoisonPropertyReduction = reader.float();
                        break;
                    case 29:
                        message.LightPropertyReduction = reader.float();
                        break;
                    case 30:
                        message.DarkPropertyReduction = reader.float();
                        break;
                    case 31:
                        message.AttackType = reader.int32();
                        break;
                    case 32:
                        message.AttackLenth = reader.float();
                        break;
                    case 33:
                        message.MoveSpeed = reader.float();
                        break;
                    case 34:
                        message.Hit = reader.float();
                        break;
                    case 35:
                        message.Dodge = reader.float();
                        break;
                    case 36:
                        message.Cri = reader.float();
                        break;
                    case 37:
                        message.CriStrength = reader.float();
                        break;
                    case 38:
                        if (!(message.skillList && message.skillList.length))
                            message.skillList = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.skillList.push(reader.int32());
                        } else
                            message.skillList.push(reader.int32());
                        break;
                    case 39:
                        message.NoPropertyHurt = reader.float();
                        break;
                    case 40:
                        message.IcePropertyHurt = reader.float();
                        break;
                    case 41:
                        message.FirePropertyHurt = reader.float();
                        break;
                    case 42:
                        message.ElectricPropertyHurt = reader.float();
                        break;
                    case 43:
                        message.LandPropertyHurt = reader.float();
                        break;
                    case 44:
                        message.PoisonPropertyHurt = reader.float();
                        break;
                    case 45:
                        message.LightPropertyHurt = reader.float();
                        break;
                    case 46:
                        message.DarkPropertyHurt = reader.float();
                        break;
                    case 47:
                        message.NoPropertyPower = reader.float();
                        break;
                    case 48:
                        message.IcePropertyPower = reader.float();
                        break;
                    case 49:
                        message.FirePropertyPower = reader.float();
                        break;
                    case 50:
                        message.ElectricPropertyPower = reader.float();
                        break;
                    case 51:
                        message.LandPropertyPower = reader.float();
                        break;
                    case 52:
                        message.PoisonPropertyPower = reader.float();
                        break;
                    case 53:
                        message.LightPropertyPower = reader.float();
                        break;
                    case 54:
                        message.DarkPropertyPower = reader.float();
                        break;
                    case 55:
                        message.AttackSpeed = reader.float();
                        break;
                    case 56:
                        message.GeneratingEffect = reader.string();
                        break;
                    case 57:
                        message.bulletDataPb = $root.luck.protobuf.BattleBulletDataPB.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("ID"))
                    throw $util.ProtocolError("missing required 'ID'", { instance: message });
                if (!message.hasOwnProperty("serveID"))
                    throw $util.ProtocolError("missing required 'serveID'", { instance: message });
                if (!message.hasOwnProperty("Name"))
                    throw $util.ProtocolError("missing required 'Name'", { instance: message });
                if (!message.hasOwnProperty("Lelel"))
                    throw $util.ProtocolError("missing required 'Lelel'", { instance: message });
                if (!message.hasOwnProperty("CampID"))
                    throw $util.ProtocolError("missing required 'CampID'", { instance: message });
                if (!message.hasOwnProperty("PrefabName"))
                    throw $util.ProtocolError("missing required 'PrefabName'", { instance: message });
                if (!message.hasOwnProperty("MonsterType"))
                    throw $util.ProtocolError("missing required 'MonsterType'", { instance: message });
                if (!message.hasOwnProperty("WarnRange"))
                    throw $util.ProtocolError("missing required 'WarnRange'", { instance: message });
                if (!message.hasOwnProperty("Pursuit"))
                    throw $util.ProtocolError("missing required 'Pursuit'", { instance: message });
                if (!message.hasOwnProperty("CurrHp"))
                    throw $util.ProtocolError("missing required 'CurrHp'", { instance: message });
                if (!message.hasOwnProperty("MaxHp"))
                    throw $util.ProtocolError("missing required 'MaxHp'", { instance: message });
                if (!message.hasOwnProperty("ModeOfPursuit"))
                    throw $util.ProtocolError("missing required 'ModeOfPursuit'", { instance: message });
                if (!message.hasOwnProperty("Time"))
                    throw $util.ProtocolError("missing required 'Time'", { instance: message });
                if (!message.hasOwnProperty("Probability"))
                    throw $util.ProtocolError("missing required 'Probability'", { instance: message });
                if (!message.hasOwnProperty("NoPropertyResistance"))
                    throw $util.ProtocolError("missing required 'NoPropertyResistance'", { instance: message });
                if (!message.hasOwnProperty("IcePropertyResistance"))
                    throw $util.ProtocolError("missing required 'IcePropertyResistance'", { instance: message });
                if (!message.hasOwnProperty("FirePropertyResistance"))
                    throw $util.ProtocolError("missing required 'FirePropertyResistance'", { instance: message });
                if (!message.hasOwnProperty("ElectricPropertyResistance"))
                    throw $util.ProtocolError("missing required 'ElectricPropertyResistance'", { instance: message });
                if (!message.hasOwnProperty("LandPropertyResistance"))
                    throw $util.ProtocolError("missing required 'LandPropertyResistance'", { instance: message });
                if (!message.hasOwnProperty("PoisonPropertyResistance"))
                    throw $util.ProtocolError("missing required 'PoisonPropertyResistance'", { instance: message });
                if (!message.hasOwnProperty("LightPropertyResistance"))
                    throw $util.ProtocolError("missing required 'LightPropertyResistance'", { instance: message });
                if (!message.hasOwnProperty("DarkPropertyResistance"))
                    throw $util.ProtocolError("missing required 'DarkPropertyResistance'", { instance: message });
                if (!message.hasOwnProperty("NoPropertyReduction"))
                    throw $util.ProtocolError("missing required 'NoPropertyReduction'", { instance: message });
                if (!message.hasOwnProperty("IcePropertyReduction"))
                    throw $util.ProtocolError("missing required 'IcePropertyReduction'", { instance: message });
                if (!message.hasOwnProperty("FirePropertyReduction"))
                    throw $util.ProtocolError("missing required 'FirePropertyReduction'", { instance: message });
                if (!message.hasOwnProperty("ElectricPropertyReduction"))
                    throw $util.ProtocolError("missing required 'ElectricPropertyReduction'", { instance: message });
                if (!message.hasOwnProperty("LandPropertyReduction"))
                    throw $util.ProtocolError("missing required 'LandPropertyReduction'", { instance: message });
                if (!message.hasOwnProperty("PoisonPropertyReduction"))
                    throw $util.ProtocolError("missing required 'PoisonPropertyReduction'", { instance: message });
                if (!message.hasOwnProperty("LightPropertyReduction"))
                    throw $util.ProtocolError("missing required 'LightPropertyReduction'", { instance: message });
                if (!message.hasOwnProperty("DarkPropertyReduction"))
                    throw $util.ProtocolError("missing required 'DarkPropertyReduction'", { instance: message });
                if (!message.hasOwnProperty("AttackType"))
                    throw $util.ProtocolError("missing required 'AttackType'", { instance: message });
                if (!message.hasOwnProperty("AttackLenth"))
                    throw $util.ProtocolError("missing required 'AttackLenth'", { instance: message });
                if (!message.hasOwnProperty("MoveSpeed"))
                    throw $util.ProtocolError("missing required 'MoveSpeed'", { instance: message });
                if (!message.hasOwnProperty("Hit"))
                    throw $util.ProtocolError("missing required 'Hit'", { instance: message });
                if (!message.hasOwnProperty("Dodge"))
                    throw $util.ProtocolError("missing required 'Dodge'", { instance: message });
                if (!message.hasOwnProperty("Cri"))
                    throw $util.ProtocolError("missing required 'Cri'", { instance: message });
                if (!message.hasOwnProperty("CriStrength"))
                    throw $util.ProtocolError("missing required 'CriStrength'", { instance: message });
                if (!message.hasOwnProperty("NoPropertyHurt"))
                    throw $util.ProtocolError("missing required 'NoPropertyHurt'", { instance: message });
                if (!message.hasOwnProperty("IcePropertyHurt"))
                    throw $util.ProtocolError("missing required 'IcePropertyHurt'", { instance: message });
                if (!message.hasOwnProperty("FirePropertyHurt"))
                    throw $util.ProtocolError("missing required 'FirePropertyHurt'", { instance: message });
                if (!message.hasOwnProperty("ElectricPropertyHurt"))
                    throw $util.ProtocolError("missing required 'ElectricPropertyHurt'", { instance: message });
                if (!message.hasOwnProperty("LandPropertyHurt"))
                    throw $util.ProtocolError("missing required 'LandPropertyHurt'", { instance: message });
                if (!message.hasOwnProperty("PoisonPropertyHurt"))
                    throw $util.ProtocolError("missing required 'PoisonPropertyHurt'", { instance: message });
                if (!message.hasOwnProperty("LightPropertyHurt"))
                    throw $util.ProtocolError("missing required 'LightPropertyHurt'", { instance: message });
                if (!message.hasOwnProperty("DarkPropertyHurt"))
                    throw $util.ProtocolError("missing required 'DarkPropertyHurt'", { instance: message });
                if (!message.hasOwnProperty("NoPropertyPower"))
                    throw $util.ProtocolError("missing required 'NoPropertyPower'", { instance: message });
                if (!message.hasOwnProperty("IcePropertyPower"))
                    throw $util.ProtocolError("missing required 'IcePropertyPower'", { instance: message });
                if (!message.hasOwnProperty("FirePropertyPower"))
                    throw $util.ProtocolError("missing required 'FirePropertyPower'", { instance: message });
                if (!message.hasOwnProperty("ElectricPropertyPower"))
                    throw $util.ProtocolError("missing required 'ElectricPropertyPower'", { instance: message });
                if (!message.hasOwnProperty("LandPropertyPower"))
                    throw $util.ProtocolError("missing required 'LandPropertyPower'", { instance: message });
                if (!message.hasOwnProperty("PoisonPropertyPower"))
                    throw $util.ProtocolError("missing required 'PoisonPropertyPower'", { instance: message });
                if (!message.hasOwnProperty("LightPropertyPower"))
                    throw $util.ProtocolError("missing required 'LightPropertyPower'", { instance: message });
                if (!message.hasOwnProperty("DarkPropertyPower"))
                    throw $util.ProtocolError("missing required 'DarkPropertyPower'", { instance: message });
                if (!message.hasOwnProperty("AttackSpeed"))
                    throw $util.ProtocolError("missing required 'AttackSpeed'", { instance: message });
                if (!message.hasOwnProperty("GeneratingEffect"))
                    throw $util.ProtocolError("missing required 'GeneratingEffect'", { instance: message });
                if (!message.hasOwnProperty("bulletDataPb"))
                    throw $util.ProtocolError("missing required 'bulletDataPb'", { instance: message });
                return message;
            };

            /**
             * Decodes a BattleMonsterDataPB message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.BattleMonsterDataPB} BattleMonsterDataPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BattleMonsterDataPB.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BattleMonsterDataPB message.
             * @function verify
             * @memberof luck.protobuf.BattleMonsterDataPB
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BattleMonsterDataPB.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.ID))
                    return "ID: integer expected";
                if (!$util.isInteger(message.serveID))
                    return "serveID: integer expected";
                if (!$util.isString(message.Name))
                    return "Name: string expected";
                if (!$util.isInteger(message.Lelel))
                    return "Lelel: integer expected";
                if (!$util.isInteger(message.CampID))
                    return "CampID: integer expected";
                if (!$util.isString(message.PrefabName))
                    return "PrefabName: string expected";
                if (!$util.isInteger(message.MonsterType))
                    return "MonsterType: integer expected";
                if (!$util.isInteger(message.WarnRange))
                    return "WarnRange: integer expected";
                if (!$util.isInteger(message.Pursuit))
                    return "Pursuit: integer expected";
                if (!$util.isInteger(message.CurrHp) && !(message.CurrHp && $util.isInteger(message.CurrHp.low) && $util.isInteger(message.CurrHp.high)))
                    return "CurrHp: integer|Long expected";
                if (!$util.isInteger(message.MaxHp) && !(message.MaxHp && $util.isInteger(message.MaxHp.low) && $util.isInteger(message.MaxHp.high)))
                    return "MaxHp: integer|Long expected";
                if (!$util.isInteger(message.ModeOfPursuit))
                    return "ModeOfPursuit: integer expected";
                if (typeof message.Time !== "number")
                    return "Time: number expected";
                if (!$util.isInteger(message.Probability))
                    return "Probability: integer expected";
                if (typeof message.NoPropertyResistance !== "number")
                    return "NoPropertyResistance: number expected";
                if (typeof message.IcePropertyResistance !== "number")
                    return "IcePropertyResistance: number expected";
                if (typeof message.FirePropertyResistance !== "number")
                    return "FirePropertyResistance: number expected";
                if (typeof message.ElectricPropertyResistance !== "number")
                    return "ElectricPropertyResistance: number expected";
                if (typeof message.LandPropertyResistance !== "number")
                    return "LandPropertyResistance: number expected";
                if (typeof message.PoisonPropertyResistance !== "number")
                    return "PoisonPropertyResistance: number expected";
                if (typeof message.LightPropertyResistance !== "number")
                    return "LightPropertyResistance: number expected";
                if (typeof message.DarkPropertyResistance !== "number")
                    return "DarkPropertyResistance: number expected";
                if (typeof message.NoPropertyReduction !== "number")
                    return "NoPropertyReduction: number expected";
                if (typeof message.IcePropertyReduction !== "number")
                    return "IcePropertyReduction: number expected";
                if (typeof message.FirePropertyReduction !== "number")
                    return "FirePropertyReduction: number expected";
                if (typeof message.ElectricPropertyReduction !== "number")
                    return "ElectricPropertyReduction: number expected";
                if (typeof message.LandPropertyReduction !== "number")
                    return "LandPropertyReduction: number expected";
                if (typeof message.PoisonPropertyReduction !== "number")
                    return "PoisonPropertyReduction: number expected";
                if (typeof message.LightPropertyReduction !== "number")
                    return "LightPropertyReduction: number expected";
                if (typeof message.DarkPropertyReduction !== "number")
                    return "DarkPropertyReduction: number expected";
                if (!$util.isInteger(message.AttackType))
                    return "AttackType: integer expected";
                if (typeof message.AttackLenth !== "number")
                    return "AttackLenth: number expected";
                if (typeof message.MoveSpeed !== "number")
                    return "MoveSpeed: number expected";
                if (typeof message.Hit !== "number")
                    return "Hit: number expected";
                if (typeof message.Dodge !== "number")
                    return "Dodge: number expected";
                if (typeof message.Cri !== "number")
                    return "Cri: number expected";
                if (typeof message.CriStrength !== "number")
                    return "CriStrength: number expected";
                if (message.skillList != null && message.hasOwnProperty("skillList")) {
                    if (!Array.isArray(message.skillList))
                        return "skillList: array expected";
                    for (var i = 0; i < message.skillList.length; ++i)
                        if (!$util.isInteger(message.skillList[i]))
                            return "skillList: integer[] expected";
                }
                if (typeof message.NoPropertyHurt !== "number")
                    return "NoPropertyHurt: number expected";
                if (typeof message.IcePropertyHurt !== "number")
                    return "IcePropertyHurt: number expected";
                if (typeof message.FirePropertyHurt !== "number")
                    return "FirePropertyHurt: number expected";
                if (typeof message.ElectricPropertyHurt !== "number")
                    return "ElectricPropertyHurt: number expected";
                if (typeof message.LandPropertyHurt !== "number")
                    return "LandPropertyHurt: number expected";
                if (typeof message.PoisonPropertyHurt !== "number")
                    return "PoisonPropertyHurt: number expected";
                if (typeof message.LightPropertyHurt !== "number")
                    return "LightPropertyHurt: number expected";
                if (typeof message.DarkPropertyHurt !== "number")
                    return "DarkPropertyHurt: number expected";
                if (typeof message.NoPropertyPower !== "number")
                    return "NoPropertyPower: number expected";
                if (typeof message.IcePropertyPower !== "number")
                    return "IcePropertyPower: number expected";
                if (typeof message.FirePropertyPower !== "number")
                    return "FirePropertyPower: number expected";
                if (typeof message.ElectricPropertyPower !== "number")
                    return "ElectricPropertyPower: number expected";
                if (typeof message.LandPropertyPower !== "number")
                    return "LandPropertyPower: number expected";
                if (typeof message.PoisonPropertyPower !== "number")
                    return "PoisonPropertyPower: number expected";
                if (typeof message.LightPropertyPower !== "number")
                    return "LightPropertyPower: number expected";
                if (typeof message.DarkPropertyPower !== "number")
                    return "DarkPropertyPower: number expected";
                if (typeof message.AttackSpeed !== "number")
                    return "AttackSpeed: number expected";
                if (!$util.isString(message.GeneratingEffect))
                    return "GeneratingEffect: string expected";
                {
                    var error = $root.luck.protobuf.BattleBulletDataPB.verify(message.bulletDataPb);
                    if (error)
                        return "bulletDataPb." + error;
                }
                return null;
            };

            return BattleMonsterDataPB;
        })();

        /**
         * EnumType enum.
         * @name luck.protobuf.EnumType
         * @enum {string}
         * @property {number} LOGINREQ=1 LOGINREQ value
         * @property {number} LOGINRESP=2 LOGINRESP value
         * @property {number} CREATEPLAYERREQ=3 CREATEPLAYERREQ value
         * @property {number} CREATEPLAYERRESP=4 CREATEPLAYERRESP value
         * @property {number} HEARTBEATREQ=1001 HEARTBEATREQ value
         * @property {number} HEARTBEATRESP=1002 HEARTBEATRESP value
         * @property {number} PINGREQ=1003 PINGREQ value
         * @property {number} PINGRESP=1004 PINGRESP value
         * @property {number} CHANGE_EQUIP_REQ=1010 CHANGE_EQUIP_REQ value
         * @property {number} CHANGE_EQUIP_RESP=1011 CHANGE_EQUIP_RESP value
         * @property {number} CHECKNODE_START_REQ=1015 CHECKNODE_START_REQ value
         * @property {number} CHECKNODE_START_RESP=1016 CHECKNODE_START_RESP value
         * @property {number} CHECKNODE_FINISH_REQ=1017 CHECKNODE_FINISH_REQ value
         * @property {number} CHECKNODE_FINISH_RESP=1018 CHECKNODE_FINISH_RESP value
         * @property {number} CREATEROOMREQ=3001 CREATEROOMREQ value
         * @property {number} CREATEROOMRESP=3002 CREATEROOMRESP value
         * @property {number} ENTERROOMREQ=3003 ENTERROOMREQ value
         * @property {number} ENTERROOMRESP=3004 ENTERROOMRESP value
         * @property {number} STARTBATTLEREQ=3005 STARTBATTLEREQ value
         * @property {number} STARTBATTLERESP=3006 STARTBATTLERESP value
         * @property {number} EXITROOMREQ=3007 EXITROOMREQ value
         * @property {number} EXITROOMRESP=3008 EXITROOMRESP value
         * @property {number} GETROOMLISTREQ=3009 GETROOMLISTREQ value
         * @property {number} GETROOMLISTRESP=3010 GETROOMLISTRESP value
         * @property {number} BATTLE_OPERATION_REQ=3011 BATTLE_OPERATION_REQ value
         * @property {number} BATTLE_OPERATION_RESP=3012 BATTLE_OPERATION_RESP value
         * @property {number} BATTLE_DROP_REQ=3015 BATTLE_DROP_REQ value
         * @property {number} BATTLE_DROP_RESP=3016 BATTLE_DROP_RESP value
         * @property {number} BATTLE_GINGLE_DROP_REQ=3017 BATTLE_GINGLE_DROP_REQ value
         * @property {number} BATTLE_GINGLE_DROP_RESP=3018 BATTLE_GINGLE_DROP_RESP value
         * @property {number} BATTLE_PICKUP_REQ=3019 BATTLE_PICKUP_REQ value
         * @property {number} BATTLE_PICKUP_RESP=3020 BATTLE_PICKUP_RESP value
         * @property {number} BATTLE_GINGLE_PICKUP_REQ=3021 BATTLE_GINGLE_PICKUP_REQ value
         * @property {number} BATTLE_GINGLE_PICKUP_RESP=3022 BATTLE_GINGLE_PICKUP_RESP value
         * @property {number} LOTTERY_REQ=3023 LOTTERY_REQ value
         * @property {number} LOTTERY_RESP=3024 LOTTERY_RESP value
         * @property {number} SYNTHESIS_REQ=3025 SYNTHESIS_REQ value
         * @property {number} SYNTHESIS_RESP=3026 SYNTHESIS_RESP value
         * @property {number} RECAST_REQ=3027 RECAST_REQ value
         * @property {number} RECAST_RESP=3028 RECAST_RESP value
         * @property {number} RECAST_AFFIRM_REQ=3029 RECAST_AFFIRM_REQ value
         * @property {number} RECAST_AFFIRM_RESP=3030 RECAST_AFFIRM_RESP value
         * @property {number} SETTING_REQ=3031 SETTING_REQ value
         * @property {number} SETTING_RESP=3032 SETTING_RESP value
         * @property {number} GET_EMAIL_LIST_REQ=3035 GET_EMAIL_LIST_REQ value
         * @property {number} GET_EMAIL_LIST_RESP=3036 GET_EMAIL_LIST_RESP value
         * @property {number} EMAILDRAW_REQ=3037 EMAILDRAW_REQ value
         * @property {number} EMAILDRAW_RESP=3038 EMAILDRAW_RESP value
         * @property {number} EMAILDEL_REQ=3039 EMAILDEL_REQ value
         * @property {number} EMAILDEL_RESP=3040 EMAILDEL_RESP value
         * @property {number} EQUIP_UPGRADE_REQ=3041 EQUIP_UPGRADE_REQ value
         * @property {number} EQUIP_UPGRADE_RESP=3042 EQUIP_UPGRADE_RESP value
         * @property {number} EQUIP_BAPTIZE_REQ=3043 EQUIP_BAPTIZE_REQ value
         * @property {number} EQUIP_BAPTIZE_RESP=3044 EQUIP_BAPTIZE_RESP value
         * @property {number} EQUIP_INLAY_REQ=3045 EQUIP_INLAY_REQ value
         * @property {number} EQUIP_INLAY_RESP=3046 EQUIP_INLAY_RESP value
         * @property {number} EQUIP_INLAY_DISMANTLE_REQ=3047 EQUIP_INLAY_DISMANTLE_REQ value
         * @property {number} EQUIP_INLAY_DISMANTLE_RESP=3048 EQUIP_INLAY_DISMANTLE_RESP value
         * @property {number} EQUIP_ADVANCE_REQ=3049 EQUIP_ADVANCE_REQ value
         * @property {number} EQUIP_ADVANCE_RESP=3050 EQUIP_ADVANCE_RESP value
         * @property {number} ROLE_UNLOCK_REQ=3051 ROLE_UNLOCK_REQ value
         * @property {number} ROLE_UNLOCK_RESP=3052 ROLE_UNLOCK_RESP value
         * @property {number} ROLE_CHANGE_REQ=3053 ROLE_CHANGE_REQ value
         * @property {number} ROLE_CHANGE_RESP=3054 ROLE_CHANGE_RESP value
         * @property {number} STAMINA_BUY_REQ=3055 STAMINA_BUY_REQ value
         * @property {number} STAMINA_BUY_RESP=3056 STAMINA_BUY_RESP value
         * @property {number} FRIEND_RECOMMEND_REQ=3057 FRIEND_RECOMMEND_REQ value
         * @property {number} FRIEND_RECOMMEND_RESP=3058 FRIEND_RECOMMEND_RESP value
         * @property {number} FRIEND_SEARCH_REQ=3059 FRIEND_SEARCH_REQ value
         * @property {number} FRIEND_SEARCH_RESP=3060 FRIEND_SEARCH_RESP value
         * @property {number} SHOP_BUY_REQ=3061 SHOP_BUY_REQ value
         * @property {number} SHOP_BUY_RESP=3062 SHOP_BUY_RESP value
         * @property {number} DRAWALLEMAIL_REQ=3063 DRAWALLEMAIL_REQ value
         * @property {number} DRAWALLEMAIL_RESP=3064 DRAWALLEMAIL_RESP value
         * @property {number} FRIEND_APPLY_REQ=3065 FRIEND_APPLY_REQ value
         * @property {number} FRIEND_APPLY_RESP=3066 FRIEND_APPLY_RESP value
         * @property {number} FRIEND_APPROVE_APPLY_REQ=3067 FRIEND_APPROVE_APPLY_REQ value
         * @property {number} FRIEND_APPROVE_APPLY_RESP=3068 FRIEND_APPROVE_APPLY_RESP value
         * @property {number} FRIEND_DELETE_REQ=3069 FRIEND_DELETE_REQ value
         * @property {number} FRIEND_DELETE_RESP=3070 FRIEND_DELETE_RESP value
         * @property {number} GET_FRIEND_LIST_REQ=3071 GET_FRIEND_LIST_REQ value
         * @property {number} GET_FRIEND_LIST_RESP=3072 GET_FRIEND_LIST_RESP value
         * @property {number} SEND_CHAT_REQ=3073 SEND_CHAT_REQ value
         * @property {number} SEND_CHAT_RESP=3074 SEND_CHAT_RESP value
         * @property {number} GET_SHOP_LIST_REQ=3075 GET_SHOP_LIST_REQ value
         * @property {number} GET_SHOP_LIST_RESP=3076 GET_SHOP_LIST_RESP value
         * @property {number} EXPANSION_BAG_REQ=3077 EXPANSION_BAG_REQ value
         * @property {number} EXPANSION_BAG_RESP=3078 EXPANSION_BAG_RESP value
         * @property {number} SELL_GOODS_REQ=3079 SELL_GOODS_REQ value
         * @property {number} SELL_GOODS_RESP=3080 SELL_GOODS_RESP value
         * @property {number} ACTIVITY_TOLLGATE_REQ=3081 ACTIVITY_TOLLGATE_REQ value
         * @property {number} ACTIVITY_TOLLGATE_RESP=3082 ACTIVITY_TOLLGATE_RESP value
         * @property {number} COMPLETE_ACTIVITY_TOLLGATE_REQ=3087 COMPLETE_ACTIVITY_TOLLGATE_REQ value
         * @property {number} COMPLETE_ACTIVITY_TOLLGATE_RESP=3088 COMPLETE_ACTIVITY_TOLLGATE_RESP value
         * @property {number} PULL_GANGINFO_REQ=3089 PULL_GANGINFO_REQ value
         * @property {number} PULL_GANGINFO_RESP=3090 PULL_GANGINFO_RESP value
         * @property {number} PULL_ALL_GANGINFO_REQ=3091 PULL_ALL_GANGINFO_REQ value
         * @property {number} PULL_ALL_GANGINFO_RESP=3092 PULL_ALL_GANGINFO_RESP value
         * @property {number} CREATE_GANG_REQ=3093 CREATE_GANG_REQ value
         * @property {number} CREATE_GANG_RESP=3094 CREATE_GANG_RESP value
         * @property {number} APPLY_JOIN_GANG_REQ=3095 APPLY_JOIN_GANG_REQ value
         * @property {number} APPLY_JOIN_GANG_RESP=3096 APPLY_JOIN_GANG_RESP value
         * @property {number} APPROVE_JOIN_GANG_REQ=3097 APPROVE_JOIN_GANG_REQ value
         * @property {number} APPROVE_JOIN_GANG_RESP=3098 APPROVE_JOIN_GANG_RESP value
         * @property {number} KICK_OUT_GANG_REQ=3099 KICK_OUT_GANG_REQ value
         * @property {number} KICK_OUT_GANG_RESP=3100 KICK_OUT_GANG_RESP value
         * @property {number} QUIT_GANG_REQ=3101 QUIT_GANG_REQ value
         * @property {number} QUIT_GANG_RESP=3102 QUIT_GANG_RESP value
         * @property {number} CHANGE_GANG_JOB_REQ=3103 CHANGE_GANG_JOB_REQ value
         * @property {number} CHANGE_GANG_JOB_RESP=3104 CHANGE_GANG_JOB_RESP value
         * @property {number} DRAW_LOVEBENTO_REQ=3105 DRAW_LOVEBENTO_REQ value
         * @property {number} DRAW_LOVEBENTO_RESP=3106 DRAW_LOVEBENTO_RESP value
         * @property {number} PROP_CONSUME_REQ=3107 PROP_CONSUME_REQ value
         * @property {number} PROP_CONSUME_RESP=3108 PROP_CONSUME_RESP value
         * @property {number} SEARCH_GANG_REQ=3109 SEARCH_GANG_REQ value
         * @property {number} SEARCH_GANG_RESP=3110 SEARCH_GANG_RESP value
         * @property {number} BATTLE_GINGLE_RESURGENCE_REQ=3111 BATTLE_GINGLE_RESURGENCE_REQ value
         * @property {number} BATTLE_GINGLE_RESURGENCE_RESP=3112 BATTLE_GINGLE_RESURGENCE_RESP value
         * @property {number} RECONNECTION_REQ=3113 RECONNECTION_REQ value
         * @property {number} RECONNECTION_RESP=3114 RECONNECTION_RESP value
         * @property {number} JIGUANG_REGISTER_REQ=3115 JIGUANG_REGISTER_REQ value
         * @property {number} JIGUANG_REGISTER_RESP=3116 JIGUANG_REGISTER_RESP value
         * @property {number} DRAW_TASK_REQ=3117 DRAW_TASK_REQ value
         * @property {number} DRAW_TASK_RESP=3118 DRAW_TASK_RESP value
         * @property {number} DRAW_DAILY_VITALITY_REWARD_REQ=3119 DRAW_DAILY_VITALITY_REWARD_REQ value
         * @property {number} DRAW_DAILY_VITALITY_REWARD_RESP=3120 DRAW_DAILY_VITALITY_REWARD_RESP value
         * @property {number} CREATE_PVE_TEAM_REQ=3121 CREATE_PVE_TEAM_REQ value
         * @property {number} CREATE_PVE_TEAM_RESP=3122 CREATE_PVE_TEAM_RESP value
         * @property {number} PVE_INVITE_REQ=3123 PVE_INVITE_REQ value
         * @property {number} PVE_INVITE_RESP=3124 PVE_INVITE_RESP value
         * @property {number} PVE_APPLY_JOIN_TEAM_REQ=3125 PVE_APPLY_JOIN_TEAM_REQ value
         * @property {number} PVE_APPLY_JOIN_TEAM_RESP=3126 PVE_APPLY_JOIN_TEAM_RESP value
         * @property {number} PVE_APPROVE_JOIN_TEAM_REQ=3127 PVE_APPROVE_JOIN_TEAM_REQ value
         * @property {number} PVE_APPROVE_JOIN_TEAM_RESP=3128 PVE_APPROVE_JOIN_TEAM_RESP value
         * @property {number} PVE_PREPARE_REQ=3129 PVE_PREPARE_REQ value
         * @property {number} PVE_PREPARE_RESP=3130 PVE_PREPARE_RESP value
         * @property {number} PVE_SELECT_CUSTOMS_REQ=3131 PVE_SELECT_CUSTOMS_REQ value
         * @property {number} PVE_SELECT_CUSTOMS_RESP=3132 PVE_SELECT_CUSTOMS_RESP value
         * @property {number} LOAD_GANG_SHOP_REQ=3133 LOAD_GANG_SHOP_REQ value
         * @property {number} LOAD_GANG_SHOP_RESP=3134 LOAD_GANG_SHOP_RESP value
         * @property {number} GANG_SHOP_BUY_REQ=3135 GANG_SHOP_BUY_REQ value
         * @property {number} GANG_SHOP_BUY_RESP=3136 GANG_SHOP_BUY_RESP value
         * @property {number} PVE_QUIT_TEAM_REQ=3137 PVE_QUIT_TEAM_REQ value
         * @property {number} PVE_QUIT_TEAM_RESP=3138 PVE_QUIT_TEAM_RESP value
         * @property {number} GET_PLAYER_INFO_REQ=3139 GET_PLAYER_INFO_REQ value
         * @property {number} GET_PLAYER_INFO_RESP=3140 GET_PLAYER_INFO_RESP value
         * @property {number} PVE_BATTLE_START_REQ=3141 PVE_BATTLE_START_REQ value
         * @property {number} PVE_BATTLE_START_RESP=3142 PVE_BATTLE_START_RESP value
         * @property {number} GET_PLAYER_FIGHTING_REQ=3143 GET_PLAYER_FIGHTING_REQ value
         * @property {number} GET_PLAYER_FIGHTING_RESP=3144 GET_PLAYER_FIGHTING_RESP value
         * @property {number} GET_PLAYER_EQUIP_FIGHTING_REQ=3145 GET_PLAYER_EQUIP_FIGHTING_REQ value
         * @property {number} GET_PLAYER_EQUIP_FIGHTING_RESP=3146 GET_PLAYER_EQUIP_FIGHTING_RESP value
         * @property {number} GET_RANKING_REQ=3147 GET_RANKING_REQ value
         * @property {number} GET_RANKING_RESP=3148 GET_RANKING_RESP value
         * @property {number} GAIN_ACHIEVEMENT_SERIES_AWARD_REQ=3149 GAIN_ACHIEVEMENT_SERIES_AWARD_REQ value
         * @property {number} GAIN_ACHIEVEMENT_SERIES_AWARD_RESP=3150 GAIN_ACHIEVEMENT_SERIES_AWARD_RESP value
         * @property {number} DRAW_VIP_REWARD_REQ=3153 DRAW_VIP_REWARD_REQ value
         * @property {number} DRAW_VIP_REWARD_RESP=3154 DRAW_VIP_REWARD_RESP value
         * @property {number} RECHARGE_REQ=3155 RECHARGE_REQ value
         * @property {number} RECHARGE_RESP=3156 RECHARGE_RESP value
         * @property {number} NOTICE_REQ=3157 NOTICE_REQ value
         * @property {number} NOTICE_RESP=3158 NOTICE_RESP value
         * @property {number} EQUIP_BAPTIZE_AFFIRM_REQ=3159 EQUIP_BAPTIZE_AFFIRM_REQ value
         * @property {number} EQUIP_BAPTIZE_AFFIRM_RESP=3160 EQUIP_BAPTIZE_AFFIRM_RESP value
         * @property {number} ADD_BKACK_LIST_REQ=3161 ADD_BKACK_LIST_REQ value
         * @property {number} ADD_BKACK_LIST_RESP=3162 ADD_BKACK_LIST_RESP value
         * @property {number} DEL_BKACK_LIST_REQ=3163 DEL_BKACK_LIST_REQ value
         * @property {number} DEL_BKACK_LIST_RESP=3164 DEL_BKACK_LIST_RESP value
         * @property {number} BUY_GROWTH_CAPITAL_REQ=3165 BUY_GROWTH_CAPITAL_REQ value
         * @property {number} BUY_GROWTH_CAPITAL_RESP=3166 BUY_GROWTH_CAPITAL_RESP value
         * @property {number} GET_DIGGING_LIST_REQ=3167 GET_DIGGING_LIST_REQ value
         * @property {number} GET_DIGGING_LIST_RESP=3168 GET_DIGGING_LIST_RESP value
         * @property {number} REFRESH_DIGGING_REQ=3169 REFRESH_DIGGING_REQ value
         * @property {number} REFRESH_DIGGING_RESP=3170 REFRESH_DIGGING_RESP value
         * @property {number} GET_DIGGING_AWARD_REQ=3171 GET_DIGGING_AWARD_REQ value
         * @property {number} GET_DIGGING_AWARD_RESP=3172 GET_DIGGING_AWARD_RESP value
         * @property {number} LOAD_ACTIVITY_SHOP_REQ=3173 LOAD_ACTIVITY_SHOP_REQ value
         * @property {number} LOAD_ACTIVITY_SHOP_RESP=3174 LOAD_ACTIVITY_SHOP_RESP value
         * @property {number} ACTIVITY_SHOP_BUY_REQ=3175 ACTIVITY_SHOP_BUY_REQ value
         * @property {number} ACTIVITY_SHOP_BUY_RESP=3176 ACTIVITY_SHOP_BUY_RESP value
         * @property {number} START_DIGGING_POINT_REQ=3177 START_DIGGING_POINT_REQ value
         * @property {number} START_DIGGING_POINT_RESP=3178 START_DIGGING_POINT_RESP value
         * @property {number} FINISH_DIGGING_POINT_REQ=3179 FINISH_DIGGING_POINT_REQ value
         * @property {number} FINISH_DIGGING_POINT_RESP=3180 FINISH_DIGGING_POINT_RESP value
         * @property {number} DRAW_ACTIVITY_TASK_REWARD_REQ=3181 DRAW_ACTIVITY_TASK_REWARD_REQ value
         * @property {number} DRAW_ACTIVITY_TASK_REWARD_RESP=3182 DRAW_ACTIVITY_TASK_REWARD_RESP value
         * @property {number} ACTIVITY_LOTTERY_REQ=3183 ACTIVITY_LOTTERY_REQ value
         * @property {number} ACTIVITY_LOTTERY_RESP=3184 ACTIVITY_LOTTERY_RESP value
         * @property {number} CHANGE_NAME_REQ=3185 CHANGE_NAME_REQ value
         * @property {number} CHANGE_NAME_RESP=3186 CHANGE_NAME_RESP value
         * @property {number} SAVE_NOVICE_GUIDE_NUM_REQ=3187 SAVE_NOVICE_GUIDE_NUM_REQ value
         * @property {number} SAVE_NOVICE_GUIDE_NUM_RESP=3188 SAVE_NOVICE_GUIDE_NUM_RESP value
         * @property {number} DRAW_MONTH_CARD_REQ=3189 DRAW_MONTH_CARD_REQ value
         * @property {number} DRAW_MONTH_CARD_RESP=3190 DRAW_MONTH_CARD_RESP value
         * @property {number} ROLE_CHAT_REQ=3191 ROLE_CHAT_REQ value
         * @property {number} ROLE_CHAT_RESP=3192 ROLE_CHAT_RESP value
         * @property {number} ROLE_INTERACTION_REQ=3193 ROLE_INTERACTION_REQ value
         * @property {number} ROLE_INTERACTION_RESP=3194 ROLE_INTERACTION_RESP value
         * @property {number} STROKE_ROLE_REQ=3195 STROKE_ROLE_REQ value
         * @property {number} STROKE_ROLE_RESP=3196 STROKE_ROLE_RESP value
         * @property {number} CHANGE_ROLE_IMAGE_REQ=3197 CHANGE_ROLE_IMAGE_REQ value
         * @property {number} CHANGE_ROLE_IMAGE_RESP=3198 CHANGE_ROLE_IMAGE_RESP value
         * @property {number} CHANGE_HEAD_PORTRAIT_REQ=3199 CHANGE_HEAD_PORTRAIT_REQ value
         * @property {number} CHANGE_HEAD_PORTRAIT_RESP=3200 CHANGE_HEAD_PORTRAIT_RESP value
         * @property {number} CHANGE_RAHMEN_REQ=3201 CHANGE_RAHMEN_REQ value
         * @property {number} CHANGE_RAHMEN_RESP=3202 CHANGE_RAHMEN_RESP value
         * @property {number} GIVE_ROLE_GIFT_REQ=3203 GIVE_ROLE_GIFT_REQ value
         * @property {number} GIVE_ROLE_GIFT_RESP=3204 GIVE_ROLE_GIFT_RESP value
         * @property {number} GANG_SGININ_REQ=3205 GANG_SGININ_REQ value
         * @property {number} GANG_SGININ_RESP=3206 GANG_SGININ_RESP value
         * @property {number} DRAW_GANG_VITALITY_REWARD_REQ=3207 DRAW_GANG_VITALITY_REWARD_REQ value
         * @property {number} DRAW_GANG_VITALITY_REWARD_RESP=3208 DRAW_GANG_VITALITY_REWARD_RESP value
         * @property {number} SAVE_PERSON_MESSAGE_REQ=3209 SAVE_PERSON_MESSAGE_REQ value
         * @property {number} SAVE_PERSON_MESSAGE_RESP=3210 SAVE_PERSON_MESSAGE_RESP value
         * @property {number} BATTLE_SENDGAMEDATA_REQ=3211 BATTLE_SENDGAMEDATA_REQ value
         * @property {number} BATTLE_SENDGAMEDATA_RESP=3212 BATTLE_SENDGAMEDATA_RESP value
         * @property {number} BATTLE_SAVEGAMEDATA_RESP=3213 BATTLE_SAVEGAMEDATA_RESP value
         * @property {number} GM_BUILD_WEAPON_REQ=5001 GM_BUILD_WEAPON_REQ value
         * @property {number} GM_BUILD_WEAPON_RESP=5002 GM_BUILD_WEAPON_RESP value
         * @property {number} GM_BUILD_CARD_REQ=5003 GM_BUILD_CARD_REQ value
         * @property {number} GM_BUILD_CARD_RESP=5004 GM_BUILD_CARD_RESP value
         * @property {number} GM_BUILD_CLOTHES_REQ=5005 GM_BUILD_CLOTHES_REQ value
         * @property {number} GM_BUILD_CLOTHES_RESP=5006 GM_BUILD_CLOTHES_RESP value
         * @property {number} SGININ_REQ=5007 SGININ_REQ value
         * @property {number} SGININ_RESP=5008 SGININ_RESP value
         * @property {number} GM_ADD_GOODS_REQ=5009 GM_ADD_GOODS_REQ value
         * @property {number} GM_ADD_GOODS_RESP=5010 GM_ADD_GOODS_RESP value
         * @property {number} PUSH_GOODS_UPDATE_RESP=20001 PUSH_GOODS_UPDATE_RESP value
         * @property {number} PUSH_FRIEND_APPLY_RESP=20021 PUSH_FRIEND_APPLY_RESP value
         * @property {number} PUSH_ADD_FRIEND_RESP=20022 PUSH_ADD_FRIEND_RESP value
         * @property {number} PUSH_DEL_FRIEND_RESP=20023 PUSH_DEL_FRIEND_RESP value
         * @property {number} PUSH_EMAIL_RESP=20011 PUSH_EMAIL_RESP value
         * @property {number} PUSH_CHAT_RESP=20031 PUSH_CHAT_RESP value
         * @property {number} PUSH_ILLUSTRATION_RESP=20041 PUSH_ILLUSTRATION_RESP value
         * @property {number} PUSH_TASK_RESP=20051 PUSH_TASK_RESP value
         * @property {number} PUSH_PVE_INVITE_RESP=20061 PUSH_PVE_INVITE_RESP value
         * @property {number} PUSH_PVE_APPROVE_JOIN_TEAM_RESP=20071 PUSH_PVE_APPROVE_JOIN_TEAM_RESP value
         * @property {number} PUSH_PVE_TEAM_UPDATE_RESP=20081 PUSH_PVE_TEAM_UPDATE_RESP value
         * @property {number} PUSH_WORLD_NOTICE_RESP=20091 PUSH_WORLD_NOTICE_RESP value
         * @property {number} PUSH_REPETITION_LOGIN=20101 PUSH_REPETITION_LOGIN value
         * @property {number} PUSH_GANG_UPDATE_LOGIN=20111 PUSH_GANG_UPDATE_LOGIN value
         */
        protobuf.EnumType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "LOGINREQ"] = 1;
            values[valuesById[2] = "LOGINRESP"] = 2;
            values[valuesById[3] = "CREATEPLAYERREQ"] = 3;
            values[valuesById[4] = "CREATEPLAYERRESP"] = 4;
            values[valuesById[1001] = "HEARTBEATREQ"] = 1001;
            values[valuesById[1002] = "HEARTBEATRESP"] = 1002;
            values[valuesById[1003] = "PINGREQ"] = 1003;
            values[valuesById[1004] = "PINGRESP"] = 1004;
            values[valuesById[1010] = "CHANGE_EQUIP_REQ"] = 1010;
            values[valuesById[1011] = "CHANGE_EQUIP_RESP"] = 1011;
            values[valuesById[1015] = "CHECKNODE_START_REQ"] = 1015;
            values[valuesById[1016] = "CHECKNODE_START_RESP"] = 1016;
            values[valuesById[1017] = "CHECKNODE_FINISH_REQ"] = 1017;
            values[valuesById[1018] = "CHECKNODE_FINISH_RESP"] = 1018;
            values[valuesById[3001] = "CREATEROOMREQ"] = 3001;
            values[valuesById[3002] = "CREATEROOMRESP"] = 3002;
            values[valuesById[3003] = "ENTERROOMREQ"] = 3003;
            values[valuesById[3004] = "ENTERROOMRESP"] = 3004;
            values[valuesById[3005] = "STARTBATTLEREQ"] = 3005;
            values[valuesById[3006] = "STARTBATTLERESP"] = 3006;
            values[valuesById[3007] = "EXITROOMREQ"] = 3007;
            values[valuesById[3008] = "EXITROOMRESP"] = 3008;
            values[valuesById[3009] = "GETROOMLISTREQ"] = 3009;
            values[valuesById[3010] = "GETROOMLISTRESP"] = 3010;
            values[valuesById[3011] = "BATTLE_OPERATION_REQ"] = 3011;
            values[valuesById[3012] = "BATTLE_OPERATION_RESP"] = 3012;
            values[valuesById[3015] = "BATTLE_DROP_REQ"] = 3015;
            values[valuesById[3016] = "BATTLE_DROP_RESP"] = 3016;
            values[valuesById[3017] = "BATTLE_GINGLE_DROP_REQ"] = 3017;
            values[valuesById[3018] = "BATTLE_GINGLE_DROP_RESP"] = 3018;
            values[valuesById[3019] = "BATTLE_PICKUP_REQ"] = 3019;
            values[valuesById[3020] = "BATTLE_PICKUP_RESP"] = 3020;
            values[valuesById[3021] = "BATTLE_GINGLE_PICKUP_REQ"] = 3021;
            values[valuesById[3022] = "BATTLE_GINGLE_PICKUP_RESP"] = 3022;
            values[valuesById[3023] = "LOTTERY_REQ"] = 3023;
            values[valuesById[3024] = "LOTTERY_RESP"] = 3024;
            values[valuesById[3025] = "SYNTHESIS_REQ"] = 3025;
            values[valuesById[3026] = "SYNTHESIS_RESP"] = 3026;
            values[valuesById[3027] = "RECAST_REQ"] = 3027;
            values[valuesById[3028] = "RECAST_RESP"] = 3028;
            values[valuesById[3029] = "RECAST_AFFIRM_REQ"] = 3029;
            values[valuesById[3030] = "RECAST_AFFIRM_RESP"] = 3030;
            values[valuesById[3031] = "SETTING_REQ"] = 3031;
            values[valuesById[3032] = "SETTING_RESP"] = 3032;
            values[valuesById[3035] = "GET_EMAIL_LIST_REQ"] = 3035;
            values[valuesById[3036] = "GET_EMAIL_LIST_RESP"] = 3036;
            values[valuesById[3037] = "EMAILDRAW_REQ"] = 3037;
            values[valuesById[3038] = "EMAILDRAW_RESP"] = 3038;
            values[valuesById[3039] = "EMAILDEL_REQ"] = 3039;
            values[valuesById[3040] = "EMAILDEL_RESP"] = 3040;
            values[valuesById[3041] = "EQUIP_UPGRADE_REQ"] = 3041;
            values[valuesById[3042] = "EQUIP_UPGRADE_RESP"] = 3042;
            values[valuesById[3043] = "EQUIP_BAPTIZE_REQ"] = 3043;
            values[valuesById[3044] = "EQUIP_BAPTIZE_RESP"] = 3044;
            values[valuesById[3045] = "EQUIP_INLAY_REQ"] = 3045;
            values[valuesById[3046] = "EQUIP_INLAY_RESP"] = 3046;
            values[valuesById[3047] = "EQUIP_INLAY_DISMANTLE_REQ"] = 3047;
            values[valuesById[3048] = "EQUIP_INLAY_DISMANTLE_RESP"] = 3048;
            values[valuesById[3049] = "EQUIP_ADVANCE_REQ"] = 3049;
            values[valuesById[3050] = "EQUIP_ADVANCE_RESP"] = 3050;
            values[valuesById[3051] = "ROLE_UNLOCK_REQ"] = 3051;
            values[valuesById[3052] = "ROLE_UNLOCK_RESP"] = 3052;
            values[valuesById[3053] = "ROLE_CHANGE_REQ"] = 3053;
            values[valuesById[3054] = "ROLE_CHANGE_RESP"] = 3054;
            values[valuesById[3055] = "STAMINA_BUY_REQ"] = 3055;
            values[valuesById[3056] = "STAMINA_BUY_RESP"] = 3056;
            values[valuesById[3057] = "FRIEND_RECOMMEND_REQ"] = 3057;
            values[valuesById[3058] = "FRIEND_RECOMMEND_RESP"] = 3058;
            values[valuesById[3059] = "FRIEND_SEARCH_REQ"] = 3059;
            values[valuesById[3060] = "FRIEND_SEARCH_RESP"] = 3060;
            values[valuesById[3061] = "SHOP_BUY_REQ"] = 3061;
            values[valuesById[3062] = "SHOP_BUY_RESP"] = 3062;
            values[valuesById[3063] = "DRAWALLEMAIL_REQ"] = 3063;
            values[valuesById[3064] = "DRAWALLEMAIL_RESP"] = 3064;
            values[valuesById[3065] = "FRIEND_APPLY_REQ"] = 3065;
            values[valuesById[3066] = "FRIEND_APPLY_RESP"] = 3066;
            values[valuesById[3067] = "FRIEND_APPROVE_APPLY_REQ"] = 3067;
            values[valuesById[3068] = "FRIEND_APPROVE_APPLY_RESP"] = 3068;
            values[valuesById[3069] = "FRIEND_DELETE_REQ"] = 3069;
            values[valuesById[3070] = "FRIEND_DELETE_RESP"] = 3070;
            values[valuesById[3071] = "GET_FRIEND_LIST_REQ"] = 3071;
            values[valuesById[3072] = "GET_FRIEND_LIST_RESP"] = 3072;
            values[valuesById[3073] = "SEND_CHAT_REQ"] = 3073;
            values[valuesById[3074] = "SEND_CHAT_RESP"] = 3074;
            values[valuesById[3075] = "GET_SHOP_LIST_REQ"] = 3075;
            values[valuesById[3076] = "GET_SHOP_LIST_RESP"] = 3076;
            values[valuesById[3077] = "EXPANSION_BAG_REQ"] = 3077;
            values[valuesById[3078] = "EXPANSION_BAG_RESP"] = 3078;
            values[valuesById[3079] = "SELL_GOODS_REQ"] = 3079;
            values[valuesById[3080] = "SELL_GOODS_RESP"] = 3080;
            values[valuesById[3081] = "ACTIVITY_TOLLGATE_REQ"] = 3081;
            values[valuesById[3082] = "ACTIVITY_TOLLGATE_RESP"] = 3082;
            values[valuesById[3087] = "COMPLETE_ACTIVITY_TOLLGATE_REQ"] = 3087;
            values[valuesById[3088] = "COMPLETE_ACTIVITY_TOLLGATE_RESP"] = 3088;
            values[valuesById[3089] = "PULL_GANGINFO_REQ"] = 3089;
            values[valuesById[3090] = "PULL_GANGINFO_RESP"] = 3090;
            values[valuesById[3091] = "PULL_ALL_GANGINFO_REQ"] = 3091;
            values[valuesById[3092] = "PULL_ALL_GANGINFO_RESP"] = 3092;
            values[valuesById[3093] = "CREATE_GANG_REQ"] = 3093;
            values[valuesById[3094] = "CREATE_GANG_RESP"] = 3094;
            values[valuesById[3095] = "APPLY_JOIN_GANG_REQ"] = 3095;
            values[valuesById[3096] = "APPLY_JOIN_GANG_RESP"] = 3096;
            values[valuesById[3097] = "APPROVE_JOIN_GANG_REQ"] = 3097;
            values[valuesById[3098] = "APPROVE_JOIN_GANG_RESP"] = 3098;
            values[valuesById[3099] = "KICK_OUT_GANG_REQ"] = 3099;
            values[valuesById[3100] = "KICK_OUT_GANG_RESP"] = 3100;
            values[valuesById[3101] = "QUIT_GANG_REQ"] = 3101;
            values[valuesById[3102] = "QUIT_GANG_RESP"] = 3102;
            values[valuesById[3103] = "CHANGE_GANG_JOB_REQ"] = 3103;
            values[valuesById[3104] = "CHANGE_GANG_JOB_RESP"] = 3104;
            values[valuesById[3105] = "DRAW_LOVEBENTO_REQ"] = 3105;
            values[valuesById[3106] = "DRAW_LOVEBENTO_RESP"] = 3106;
            values[valuesById[3107] = "PROP_CONSUME_REQ"] = 3107;
            values[valuesById[3108] = "PROP_CONSUME_RESP"] = 3108;
            values[valuesById[3109] = "SEARCH_GANG_REQ"] = 3109;
            values[valuesById[3110] = "SEARCH_GANG_RESP"] = 3110;
            values[valuesById[3111] = "BATTLE_GINGLE_RESURGENCE_REQ"] = 3111;
            values[valuesById[3112] = "BATTLE_GINGLE_RESURGENCE_RESP"] = 3112;
            values[valuesById[3113] = "RECONNECTION_REQ"] = 3113;
            values[valuesById[3114] = "RECONNECTION_RESP"] = 3114;
            values[valuesById[3115] = "JIGUANG_REGISTER_REQ"] = 3115;
            values[valuesById[3116] = "JIGUANG_REGISTER_RESP"] = 3116;
            values[valuesById[3117] = "DRAW_TASK_REQ"] = 3117;
            values[valuesById[3118] = "DRAW_TASK_RESP"] = 3118;
            values[valuesById[3119] = "DRAW_DAILY_VITALITY_REWARD_REQ"] = 3119;
            values[valuesById[3120] = "DRAW_DAILY_VITALITY_REWARD_RESP"] = 3120;
            values[valuesById[3121] = "CREATE_PVE_TEAM_REQ"] = 3121;
            values[valuesById[3122] = "CREATE_PVE_TEAM_RESP"] = 3122;
            values[valuesById[3123] = "PVE_INVITE_REQ"] = 3123;
            values[valuesById[3124] = "PVE_INVITE_RESP"] = 3124;
            values[valuesById[3125] = "PVE_APPLY_JOIN_TEAM_REQ"] = 3125;
            values[valuesById[3126] = "PVE_APPLY_JOIN_TEAM_RESP"] = 3126;
            values[valuesById[3127] = "PVE_APPROVE_JOIN_TEAM_REQ"] = 3127;
            values[valuesById[3128] = "PVE_APPROVE_JOIN_TEAM_RESP"] = 3128;
            values[valuesById[3129] = "PVE_PREPARE_REQ"] = 3129;
            values[valuesById[3130] = "PVE_PREPARE_RESP"] = 3130;
            values[valuesById[3131] = "PVE_SELECT_CUSTOMS_REQ"] = 3131;
            values[valuesById[3132] = "PVE_SELECT_CUSTOMS_RESP"] = 3132;
            values[valuesById[3133] = "LOAD_GANG_SHOP_REQ"] = 3133;
            values[valuesById[3134] = "LOAD_GANG_SHOP_RESP"] = 3134;
            values[valuesById[3135] = "GANG_SHOP_BUY_REQ"] = 3135;
            values[valuesById[3136] = "GANG_SHOP_BUY_RESP"] = 3136;
            values[valuesById[3137] = "PVE_QUIT_TEAM_REQ"] = 3137;
            values[valuesById[3138] = "PVE_QUIT_TEAM_RESP"] = 3138;
            values[valuesById[3139] = "GET_PLAYER_INFO_REQ"] = 3139;
            values[valuesById[3140] = "GET_PLAYER_INFO_RESP"] = 3140;
            values[valuesById[3141] = "PVE_BATTLE_START_REQ"] = 3141;
            values[valuesById[3142] = "PVE_BATTLE_START_RESP"] = 3142;
            values[valuesById[3143] = "GET_PLAYER_FIGHTING_REQ"] = 3143;
            values[valuesById[3144] = "GET_PLAYER_FIGHTING_RESP"] = 3144;
            values[valuesById[3145] = "GET_PLAYER_EQUIP_FIGHTING_REQ"] = 3145;
            values[valuesById[3146] = "GET_PLAYER_EQUIP_FIGHTING_RESP"] = 3146;
            values[valuesById[3147] = "GET_RANKING_REQ"] = 3147;
            values[valuesById[3148] = "GET_RANKING_RESP"] = 3148;
            values[valuesById[3149] = "GAIN_ACHIEVEMENT_SERIES_AWARD_REQ"] = 3149;
            values[valuesById[3150] = "GAIN_ACHIEVEMENT_SERIES_AWARD_RESP"] = 3150;
            values[valuesById[3153] = "DRAW_VIP_REWARD_REQ"] = 3153;
            values[valuesById[3154] = "DRAW_VIP_REWARD_RESP"] = 3154;
            values[valuesById[3155] = "RECHARGE_REQ"] = 3155;
            values[valuesById[3156] = "RECHARGE_RESP"] = 3156;
            values[valuesById[3157] = "NOTICE_REQ"] = 3157;
            values[valuesById[3158] = "NOTICE_RESP"] = 3158;
            values[valuesById[3159] = "EQUIP_BAPTIZE_AFFIRM_REQ"] = 3159;
            values[valuesById[3160] = "EQUIP_BAPTIZE_AFFIRM_RESP"] = 3160;
            values[valuesById[3161] = "ADD_BKACK_LIST_REQ"] = 3161;
            values[valuesById[3162] = "ADD_BKACK_LIST_RESP"] = 3162;
            values[valuesById[3163] = "DEL_BKACK_LIST_REQ"] = 3163;
            values[valuesById[3164] = "DEL_BKACK_LIST_RESP"] = 3164;
            values[valuesById[3165] = "BUY_GROWTH_CAPITAL_REQ"] = 3165;
            values[valuesById[3166] = "BUY_GROWTH_CAPITAL_RESP"] = 3166;
            values[valuesById[3167] = "GET_DIGGING_LIST_REQ"] = 3167;
            values[valuesById[3168] = "GET_DIGGING_LIST_RESP"] = 3168;
            values[valuesById[3169] = "REFRESH_DIGGING_REQ"] = 3169;
            values[valuesById[3170] = "REFRESH_DIGGING_RESP"] = 3170;
            values[valuesById[3171] = "GET_DIGGING_AWARD_REQ"] = 3171;
            values[valuesById[3172] = "GET_DIGGING_AWARD_RESP"] = 3172;
            values[valuesById[3173] = "LOAD_ACTIVITY_SHOP_REQ"] = 3173;
            values[valuesById[3174] = "LOAD_ACTIVITY_SHOP_RESP"] = 3174;
            values[valuesById[3175] = "ACTIVITY_SHOP_BUY_REQ"] = 3175;
            values[valuesById[3176] = "ACTIVITY_SHOP_BUY_RESP"] = 3176;
            values[valuesById[3177] = "START_DIGGING_POINT_REQ"] = 3177;
            values[valuesById[3178] = "START_DIGGING_POINT_RESP"] = 3178;
            values[valuesById[3179] = "FINISH_DIGGING_POINT_REQ"] = 3179;
            values[valuesById[3180] = "FINISH_DIGGING_POINT_RESP"] = 3180;
            values[valuesById[3181] = "DRAW_ACTIVITY_TASK_REWARD_REQ"] = 3181;
            values[valuesById[3182] = "DRAW_ACTIVITY_TASK_REWARD_RESP"] = 3182;
            values[valuesById[3183] = "ACTIVITY_LOTTERY_REQ"] = 3183;
            values[valuesById[3184] = "ACTIVITY_LOTTERY_RESP"] = 3184;
            values[valuesById[3185] = "CHANGE_NAME_REQ"] = 3185;
            values[valuesById[3186] = "CHANGE_NAME_RESP"] = 3186;
            values[valuesById[3187] = "SAVE_NOVICE_GUIDE_NUM_REQ"] = 3187;
            values[valuesById[3188] = "SAVE_NOVICE_GUIDE_NUM_RESP"] = 3188;
            values[valuesById[3189] = "DRAW_MONTH_CARD_REQ"] = 3189;
            values[valuesById[3190] = "DRAW_MONTH_CARD_RESP"] = 3190;
            values[valuesById[3191] = "ROLE_CHAT_REQ"] = 3191;
            values[valuesById[3192] = "ROLE_CHAT_RESP"] = 3192;
            values[valuesById[3193] = "ROLE_INTERACTION_REQ"] = 3193;
            values[valuesById[3194] = "ROLE_INTERACTION_RESP"] = 3194;
            values[valuesById[3195] = "STROKE_ROLE_REQ"] = 3195;
            values[valuesById[3196] = "STROKE_ROLE_RESP"] = 3196;
            values[valuesById[3197] = "CHANGE_ROLE_IMAGE_REQ"] = 3197;
            values[valuesById[3198] = "CHANGE_ROLE_IMAGE_RESP"] = 3198;
            values[valuesById[3199] = "CHANGE_HEAD_PORTRAIT_REQ"] = 3199;
            values[valuesById[3200] = "CHANGE_HEAD_PORTRAIT_RESP"] = 3200;
            values[valuesById[3201] = "CHANGE_RAHMEN_REQ"] = 3201;
            values[valuesById[3202] = "CHANGE_RAHMEN_RESP"] = 3202;
            values[valuesById[3203] = "GIVE_ROLE_GIFT_REQ"] = 3203;
            values[valuesById[3204] = "GIVE_ROLE_GIFT_RESP"] = 3204;
            values[valuesById[3205] = "GANG_SGININ_REQ"] = 3205;
            values[valuesById[3206] = "GANG_SGININ_RESP"] = 3206;
            values[valuesById[3207] = "DRAW_GANG_VITALITY_REWARD_REQ"] = 3207;
            values[valuesById[3208] = "DRAW_GANG_VITALITY_REWARD_RESP"] = 3208;
            values[valuesById[3209] = "SAVE_PERSON_MESSAGE_REQ"] = 3209;
            values[valuesById[3210] = "SAVE_PERSON_MESSAGE_RESP"] = 3210;
            values[valuesById[3211] = "BATTLE_SENDGAMEDATA_REQ"] = 3211;
            values[valuesById[3212] = "BATTLE_SENDGAMEDATA_RESP"] = 3212;
            values[valuesById[3213] = "BATTLE_SAVEGAMEDATA_RESP"] = 3213;
            values[valuesById[5001] = "GM_BUILD_WEAPON_REQ"] = 5001;
            values[valuesById[5002] = "GM_BUILD_WEAPON_RESP"] = 5002;
            values[valuesById[5003] = "GM_BUILD_CARD_REQ"] = 5003;
            values[valuesById[5004] = "GM_BUILD_CARD_RESP"] = 5004;
            values[valuesById[5005] = "GM_BUILD_CLOTHES_REQ"] = 5005;
            values[valuesById[5006] = "GM_BUILD_CLOTHES_RESP"] = 5006;
            values[valuesById[5007] = "SGININ_REQ"] = 5007;
            values[valuesById[5008] = "SGININ_RESP"] = 5008;
            values[valuesById[5009] = "GM_ADD_GOODS_REQ"] = 5009;
            values[valuesById[5010] = "GM_ADD_GOODS_RESP"] = 5010;
            values[valuesById[20001] = "PUSH_GOODS_UPDATE_RESP"] = 20001;
            values[valuesById[20021] = "PUSH_FRIEND_APPLY_RESP"] = 20021;
            values[valuesById[20022] = "PUSH_ADD_FRIEND_RESP"] = 20022;
            values[valuesById[20023] = "PUSH_DEL_FRIEND_RESP"] = 20023;
            values[valuesById[20011] = "PUSH_EMAIL_RESP"] = 20011;
            values[valuesById[20031] = "PUSH_CHAT_RESP"] = 20031;
            values[valuesById[20041] = "PUSH_ILLUSTRATION_RESP"] = 20041;
            values[valuesById[20051] = "PUSH_TASK_RESP"] = 20051;
            values[valuesById[20061] = "PUSH_PVE_INVITE_RESP"] = 20061;
            values[valuesById[20071] = "PUSH_PVE_APPROVE_JOIN_TEAM_RESP"] = 20071;
            values[valuesById[20081] = "PUSH_PVE_TEAM_UPDATE_RESP"] = 20081;
            values[valuesById[20091] = "PUSH_WORLD_NOTICE_RESP"] = 20091;
            values[valuesById[20101] = "PUSH_REPETITION_LOGIN"] = 20101;
            values[valuesById[20111] = "PUSH_GANG_UPDATE_LOGIN"] = 20111;
            return values;
        })();

        /**
         * ReturnCodeType enum.
         * @name luck.protobuf.ReturnCodeType
         * @enum {string}
         * @property {number} FAILED=0 FAILED value
         * @property {number} SUCCESS=1 SUCCESS value
         * @property {number} NAME_REPETITION=2 NAME_REPETITION value
         * @property {number} ITEM_LACK=3 ITEM_LACK value
         * @property {number} ROLE_ISHAVE=4 ROLE_ISHAVE value
         * @property {number} BODY_NOT_ENOUGH_ISHAVE=5 BODY_NOT_ENOUGH_ISHAVE value
         * @property {number} NOT_UNLOCK=6 NOT_UNLOCK value
         * @property {number} TARGET_NOT_ONLINE=7 TARGET_NOT_ONLINE value
         * @property {number} GANG_NAME_REPEAT=8 GANG_NAME_REPEAT value
         * @property {number} GANG_APPLY_REPEAT=9 GANG_APPLY_REPEAT value
         * @property {number} DIAMOND_NOT_ENOUGH=10 DIAMOND_NOT_ENOUGH value
         * @property {number} KEY_LOSE_EFFICACY=11 KEY_LOSE_EFFICACY value
         * @property {number} PACKGRID_INSUFFICIENT=12 PACKGRID_INSUFFICIENT value
         * @property {number} EMAIL_HAVEDRAW=13 EMAIL_HAVEDRAW value
         * @property {number} PVE_HAVE_TEAM=14 PVE_HAVE_TEAM value
         * @property {number} PVE_TEAM_NOT_EXIST=15 PVE_TEAM_NOT_EXIST value
         * @property {number} PVE_TEAM_MEMBER_EXIST=16 PVE_TEAM_MEMBER_EXIST value
         * @property {number} PVE_TEAM_FULL=17 PVE_TEAM_FULL value
         * @property {number} LOTTERY_TICKET_NOT_ENOUGH=18 LOTTERY_TICKET_NOT_ENOUGH value
         * @property {number} BEYOND_BUY_TIMES_DAY=19 BEYOND_BUY_TIMES_DAY value
         * @property {number} BEYOND_BUY_TIMES_WEEK=20 BEYOND_BUY_TIMES_WEEK value
         * @property {number} BEYOND_BUY_TIMES_MONTH=21 BEYOND_BUY_TIMES_MONTH value
         * @property {number} BEYOND_BUY_TIMES_YEAR=22 BEYOND_BUY_TIMES_YEAR value
         * @property {number} REVIVE_TIMES=23 REVIVE_TIMES value
         * @property {number} BURDEN_LIMIT=24 BURDEN_LIMIT value
         * @property {number} ADVANCE_MATERIALS_NOT_ENOUGH=25 ADVANCE_MATERIALS_NOT_ENOUGH value
         * @property {number} SEND_FAILED_CHAT_REQBLACK_LIST=26 SEND_FAILED_CHAT_REQBLACK_LIST value
         * @property {number} BLACK_LIST_ADD_FAILED=27 BLACK_LIST_ADD_FAILED value
         * @property {number} EXIST_FRIEND=28 EXIST_FRIEND value
         * @property {number} NOT_IN_ACTIVITY_TIME=29 NOT_IN_ACTIVITY_TIME value
         * @property {number} NOT_MINE=30 NOT_MINE value
         * @property {number} PROP_NOT_ENOUGH=31 PROP_NOT_ENOUGH value
         * @property {number} GOLD_NOT_ENOUGH=32 GOLD_NOT_ENOUGH value
         * @property {number} MATERIALS_NOT_ENOUGH=33 MATERIALS_NOT_ENOUGH value
         */
        protobuf.ReturnCodeType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "FAILED"] = 0;
            values[valuesById[1] = "SUCCESS"] = 1;
            values[valuesById[2] = "NAME_REPETITION"] = 2;
            values[valuesById[3] = "ITEM_LACK"] = 3;
            values[valuesById[4] = "ROLE_ISHAVE"] = 4;
            values[valuesById[5] = "BODY_NOT_ENOUGH_ISHAVE"] = 5;
            values[valuesById[6] = "NOT_UNLOCK"] = 6;
            values[valuesById[7] = "TARGET_NOT_ONLINE"] = 7;
            values[valuesById[8] = "GANG_NAME_REPEAT"] = 8;
            values[valuesById[9] = "GANG_APPLY_REPEAT"] = 9;
            values[valuesById[10] = "DIAMOND_NOT_ENOUGH"] = 10;
            values[valuesById[11] = "KEY_LOSE_EFFICACY"] = 11;
            values[valuesById[12] = "PACKGRID_INSUFFICIENT"] = 12;
            values[valuesById[13] = "EMAIL_HAVEDRAW"] = 13;
            values[valuesById[14] = "PVE_HAVE_TEAM"] = 14;
            values[valuesById[15] = "PVE_TEAM_NOT_EXIST"] = 15;
            values[valuesById[16] = "PVE_TEAM_MEMBER_EXIST"] = 16;
            values[valuesById[17] = "PVE_TEAM_FULL"] = 17;
            values[valuesById[18] = "LOTTERY_TICKET_NOT_ENOUGH"] = 18;
            values[valuesById[19] = "BEYOND_BUY_TIMES_DAY"] = 19;
            values[valuesById[20] = "BEYOND_BUY_TIMES_WEEK"] = 20;
            values[valuesById[21] = "BEYOND_BUY_TIMES_MONTH"] = 21;
            values[valuesById[22] = "BEYOND_BUY_TIMES_YEAR"] = 22;
            values[valuesById[23] = "REVIVE_TIMES"] = 23;
            values[valuesById[24] = "BURDEN_LIMIT"] = 24;
            values[valuesById[25] = "ADVANCE_MATERIALS_NOT_ENOUGH"] = 25;
            values[valuesById[26] = "SEND_FAILED_CHAT_REQBLACK_LIST"] = 26;
            values[valuesById[27] = "BLACK_LIST_ADD_FAILED"] = 27;
            values[valuesById[28] = "EXIST_FRIEND"] = 28;
            values[valuesById[29] = "NOT_IN_ACTIVITY_TIME"] = 29;
            values[valuesById[30] = "NOT_MINE"] = 30;
            values[valuesById[31] = "PROP_NOT_ENOUGH"] = 31;
            values[valuesById[32] = "GOLD_NOT_ENOUGH"] = 32;
            values[valuesById[33] = "MATERIALS_NOT_ENOUGH"] = 33;
            return values;
        })();

        /**
         * ChatType enum.
         * @name luck.protobuf.ChatType
         * @enum {string}
         * @property {number} privateChat=1 privateChat value
         * @property {number} worldChat=2 worldChat value
         * @property {number} gangChat=3 gangChat value
         * @property {number} teamChat=4 teamChat value
         */
        protobuf.ChatType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "privateChat"] = 1;
            values[valuesById[2] = "worldChat"] = 2;
            values[valuesById[3] = "gangChat"] = 3;
            values[valuesById[4] = "teamChat"] = 4;
            return values;
        })();

        protobuf.LogInReq = (function() {

            /**
             * Properties of a LogInReq.
             * @memberof luck.protobuf
             * @interface ILogInReq
             * @property {string} LogInKey LogInReq LogInKey
             */

            /**
             * Constructs a new LogInReq.
             * @memberof luck.protobuf
             * @classdesc Represents a LogInReq.
             * @implements ILogInReq
             * @constructor
             * @param {luck.protobuf.ILogInReq=} [properties] Properties to set
             */
            function LogInReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LogInReq LogInKey.
             * @member {string} LogInKey
             * @memberof luck.protobuf.LogInReq
             * @instance
             */
            LogInReq.prototype.LogInKey = "";

            /**
             * Creates a new LogInReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.LogInReq
             * @static
             * @param {luck.protobuf.ILogInReq=} [properties] Properties to set
             * @returns {luck.protobuf.LogInReq} LogInReq instance
             */
            LogInReq.create = function create(properties) {
                return new LogInReq(properties);
            };

            /**
             * Encodes the specified LogInReq message. Does not implicitly {@link luck.protobuf.LogInReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.LogInReq
             * @static
             * @param {luck.protobuf.ILogInReq} message LogInReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LogInReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.LogInKey);
                return writer;
            };

            /**
             * Encodes the specified LogInReq message, length delimited. Does not implicitly {@link luck.protobuf.LogInReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.LogInReq
             * @static
             * @param {luck.protobuf.ILogInReq} message LogInReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LogInReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LogInReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.LogInReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.LogInReq} LogInReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LogInReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.LogInReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.LogInKey = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("LogInKey"))
                    throw $util.ProtocolError("missing required 'LogInKey'", { instance: message });
                return message;
            };

            /**
             * Decodes a LogInReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.LogInReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.LogInReq} LogInReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LogInReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LogInReq message.
             * @function verify
             * @memberof luck.protobuf.LogInReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LogInReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.LogInKey))
                    return "LogInKey: string expected";
                return null;
            };

            return LogInReq;
        })();

        protobuf.HeartBeatReq = (function() {

            /**
             * Properties of a HeartBeatReq.
             * @memberof luck.protobuf
             * @interface IHeartBeatReq
             */

            /**
             * Constructs a new HeartBeatReq.
             * @memberof luck.protobuf
             * @classdesc Represents a HeartBeatReq.
             * @implements IHeartBeatReq
             * @constructor
             * @param {luck.protobuf.IHeartBeatReq=} [properties] Properties to set
             */
            function HeartBeatReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new HeartBeatReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.HeartBeatReq
             * @static
             * @param {luck.protobuf.IHeartBeatReq=} [properties] Properties to set
             * @returns {luck.protobuf.HeartBeatReq} HeartBeatReq instance
             */
            HeartBeatReq.create = function create(properties) {
                return new HeartBeatReq(properties);
            };

            /**
             * Encodes the specified HeartBeatReq message. Does not implicitly {@link luck.protobuf.HeartBeatReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.HeartBeatReq
             * @static
             * @param {luck.protobuf.IHeartBeatReq} message HeartBeatReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HeartBeatReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified HeartBeatReq message, length delimited. Does not implicitly {@link luck.protobuf.HeartBeatReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.HeartBeatReq
             * @static
             * @param {luck.protobuf.IHeartBeatReq} message HeartBeatReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HeartBeatReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a HeartBeatReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.HeartBeatReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.HeartBeatReq} HeartBeatReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HeartBeatReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.HeartBeatReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a HeartBeatReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.HeartBeatReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.HeartBeatReq} HeartBeatReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HeartBeatReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a HeartBeatReq message.
             * @function verify
             * @memberof luck.protobuf.HeartBeatReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            HeartBeatReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            return HeartBeatReq;
        })();

        protobuf.PingReq = (function() {

            /**
             * Properties of a PingReq.
             * @memberof luck.protobuf
             * @interface IPingReq
             */

            /**
             * Constructs a new PingReq.
             * @memberof luck.protobuf
             * @classdesc Represents a PingReq.
             * @implements IPingReq
             * @constructor
             * @param {luck.protobuf.IPingReq=} [properties] Properties to set
             */
            function PingReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new PingReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.PingReq
             * @static
             * @param {luck.protobuf.IPingReq=} [properties] Properties to set
             * @returns {luck.protobuf.PingReq} PingReq instance
             */
            PingReq.create = function create(properties) {
                return new PingReq(properties);
            };

            /**
             * Encodes the specified PingReq message. Does not implicitly {@link luck.protobuf.PingReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.PingReq
             * @static
             * @param {luck.protobuf.IPingReq} message PingReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PingReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified PingReq message, length delimited. Does not implicitly {@link luck.protobuf.PingReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.PingReq
             * @static
             * @param {luck.protobuf.IPingReq} message PingReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PingReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PingReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.PingReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.PingReq} PingReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PingReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.PingReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PingReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.PingReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.PingReq} PingReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PingReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PingReq message.
             * @function verify
             * @memberof luck.protobuf.PingReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PingReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            return PingReq;
        })();

        protobuf.BuyItemReq = (function() {

            /**
             * Properties of a BuyItemReq.
             * @memberof luck.protobuf
             * @interface IBuyItemReq
             * @property {number} itemId BuyItemReq itemId
             * @property {number} itemNum BuyItemReq itemNum
             */

            /**
             * Constructs a new BuyItemReq.
             * @memberof luck.protobuf
             * @classdesc Represents a BuyItemReq.
             * @implements IBuyItemReq
             * @constructor
             * @param {luck.protobuf.IBuyItemReq=} [properties] Properties to set
             */
            function BuyItemReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BuyItemReq itemId.
             * @member {number} itemId
             * @memberof luck.protobuf.BuyItemReq
             * @instance
             */
            BuyItemReq.prototype.itemId = 0;

            /**
             * BuyItemReq itemNum.
             * @member {number} itemNum
             * @memberof luck.protobuf.BuyItemReq
             * @instance
             */
            BuyItemReq.prototype.itemNum = 0;

            /**
             * Creates a new BuyItemReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.BuyItemReq
             * @static
             * @param {luck.protobuf.IBuyItemReq=} [properties] Properties to set
             * @returns {luck.protobuf.BuyItemReq} BuyItemReq instance
             */
            BuyItemReq.create = function create(properties) {
                return new BuyItemReq(properties);
            };

            /**
             * Encodes the specified BuyItemReq message. Does not implicitly {@link luck.protobuf.BuyItemReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.BuyItemReq
             * @static
             * @param {luck.protobuf.IBuyItemReq} message BuyItemReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BuyItemReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.itemId);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.itemNum);
                return writer;
            };

            /**
             * Encodes the specified BuyItemReq message, length delimited. Does not implicitly {@link luck.protobuf.BuyItemReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.BuyItemReq
             * @static
             * @param {luck.protobuf.IBuyItemReq} message BuyItemReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BuyItemReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BuyItemReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.BuyItemReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.BuyItemReq} BuyItemReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BuyItemReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.BuyItemReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.itemId = reader.int32();
                        break;
                    case 2:
                        message.itemNum = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("itemId"))
                    throw $util.ProtocolError("missing required 'itemId'", { instance: message });
                if (!message.hasOwnProperty("itemNum"))
                    throw $util.ProtocolError("missing required 'itemNum'", { instance: message });
                return message;
            };

            /**
             * Decodes a BuyItemReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.BuyItemReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.BuyItemReq} BuyItemReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BuyItemReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BuyItemReq message.
             * @function verify
             * @memberof luck.protobuf.BuyItemReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BuyItemReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.itemId))
                    return "itemId: integer expected";
                if (!$util.isInteger(message.itemNum))
                    return "itemNum: integer expected";
                return null;
            };

            return BuyItemReq;
        })();

        protobuf.CreatePlayerReq = (function() {

            /**
             * Properties of a CreatePlayerReq.
             * @memberof luck.protobuf
             * @interface ICreatePlayerReq
             * @property {string} LogInKey CreatePlayerReq LogInKey
             * @property {string} name CreatePlayerReq name
             */

            /**
             * Constructs a new CreatePlayerReq.
             * @memberof luck.protobuf
             * @classdesc Represents a CreatePlayerReq.
             * @implements ICreatePlayerReq
             * @constructor
             * @param {luck.protobuf.ICreatePlayerReq=} [properties] Properties to set
             */
            function CreatePlayerReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CreatePlayerReq LogInKey.
             * @member {string} LogInKey
             * @memberof luck.protobuf.CreatePlayerReq
             * @instance
             */
            CreatePlayerReq.prototype.LogInKey = "";

            /**
             * CreatePlayerReq name.
             * @member {string} name
             * @memberof luck.protobuf.CreatePlayerReq
             * @instance
             */
            CreatePlayerReq.prototype.name = "";

            /**
             * Creates a new CreatePlayerReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.CreatePlayerReq
             * @static
             * @param {luck.protobuf.ICreatePlayerReq=} [properties] Properties to set
             * @returns {luck.protobuf.CreatePlayerReq} CreatePlayerReq instance
             */
            CreatePlayerReq.create = function create(properties) {
                return new CreatePlayerReq(properties);
            };

            /**
             * Encodes the specified CreatePlayerReq message. Does not implicitly {@link luck.protobuf.CreatePlayerReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.CreatePlayerReq
             * @static
             * @param {luck.protobuf.ICreatePlayerReq} message CreatePlayerReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreatePlayerReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.LogInKey);
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                return writer;
            };

            /**
             * Encodes the specified CreatePlayerReq message, length delimited. Does not implicitly {@link luck.protobuf.CreatePlayerReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.CreatePlayerReq
             * @static
             * @param {luck.protobuf.ICreatePlayerReq} message CreatePlayerReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreatePlayerReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CreatePlayerReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.CreatePlayerReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.CreatePlayerReq} CreatePlayerReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreatePlayerReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.CreatePlayerReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.LogInKey = reader.string();
                        break;
                    case 2:
                        message.name = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("LogInKey"))
                    throw $util.ProtocolError("missing required 'LogInKey'", { instance: message });
                if (!message.hasOwnProperty("name"))
                    throw $util.ProtocolError("missing required 'name'", { instance: message });
                return message;
            };

            /**
             * Decodes a CreatePlayerReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.CreatePlayerReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.CreatePlayerReq} CreatePlayerReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreatePlayerReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CreatePlayerReq message.
             * @function verify
             * @memberof luck.protobuf.CreatePlayerReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreatePlayerReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.LogInKey))
                    return "LogInKey: string expected";
                if (!$util.isString(message.name))
                    return "name: string expected";
                return null;
            };

            return CreatePlayerReq;
        })();

        protobuf.GmBuildWeaponReq = (function() {

            /**
             * Properties of a GmBuildWeaponReq.
             * @memberof luck.protobuf
             * @interface IGmBuildWeaponReq
             * @property {number} weaponId GmBuildWeaponReq weaponId
             * @property {number} weaponNum GmBuildWeaponReq weaponNum
             */

            /**
             * Constructs a new GmBuildWeaponReq.
             * @memberof luck.protobuf
             * @classdesc Represents a GmBuildWeaponReq.
             * @implements IGmBuildWeaponReq
             * @constructor
             * @param {luck.protobuf.IGmBuildWeaponReq=} [properties] Properties to set
             */
            function GmBuildWeaponReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GmBuildWeaponReq weaponId.
             * @member {number} weaponId
             * @memberof luck.protobuf.GmBuildWeaponReq
             * @instance
             */
            GmBuildWeaponReq.prototype.weaponId = 0;

            /**
             * GmBuildWeaponReq weaponNum.
             * @member {number} weaponNum
             * @memberof luck.protobuf.GmBuildWeaponReq
             * @instance
             */
            GmBuildWeaponReq.prototype.weaponNum = 0;

            /**
             * Creates a new GmBuildWeaponReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.GmBuildWeaponReq
             * @static
             * @param {luck.protobuf.IGmBuildWeaponReq=} [properties] Properties to set
             * @returns {luck.protobuf.GmBuildWeaponReq} GmBuildWeaponReq instance
             */
            GmBuildWeaponReq.create = function create(properties) {
                return new GmBuildWeaponReq(properties);
            };

            /**
             * Encodes the specified GmBuildWeaponReq message. Does not implicitly {@link luck.protobuf.GmBuildWeaponReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.GmBuildWeaponReq
             * @static
             * @param {luck.protobuf.IGmBuildWeaponReq} message GmBuildWeaponReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GmBuildWeaponReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.weaponId);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.weaponNum);
                return writer;
            };

            /**
             * Encodes the specified GmBuildWeaponReq message, length delimited. Does not implicitly {@link luck.protobuf.GmBuildWeaponReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.GmBuildWeaponReq
             * @static
             * @param {luck.protobuf.IGmBuildWeaponReq} message GmBuildWeaponReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GmBuildWeaponReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GmBuildWeaponReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.GmBuildWeaponReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.GmBuildWeaponReq} GmBuildWeaponReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GmBuildWeaponReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.GmBuildWeaponReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.weaponId = reader.int32();
                        break;
                    case 2:
                        message.weaponNum = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("weaponId"))
                    throw $util.ProtocolError("missing required 'weaponId'", { instance: message });
                if (!message.hasOwnProperty("weaponNum"))
                    throw $util.ProtocolError("missing required 'weaponNum'", { instance: message });
                return message;
            };

            /**
             * Decodes a GmBuildWeaponReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.GmBuildWeaponReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.GmBuildWeaponReq} GmBuildWeaponReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GmBuildWeaponReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GmBuildWeaponReq message.
             * @function verify
             * @memberof luck.protobuf.GmBuildWeaponReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GmBuildWeaponReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.weaponId))
                    return "weaponId: integer expected";
                if (!$util.isInteger(message.weaponNum))
                    return "weaponNum: integer expected";
                return null;
            };

            return GmBuildWeaponReq;
        })();

        protobuf.GmBuildCardReq = (function() {

            /**
             * Properties of a GmBuildCardReq.
             * @memberof luck.protobuf
             * @interface IGmBuildCardReq
             * @property {number} cardId GmBuildCardReq cardId
             * @property {number} cardNum GmBuildCardReq cardNum
             */

            /**
             * Constructs a new GmBuildCardReq.
             * @memberof luck.protobuf
             * @classdesc Represents a GmBuildCardReq.
             * @implements IGmBuildCardReq
             * @constructor
             * @param {luck.protobuf.IGmBuildCardReq=} [properties] Properties to set
             */
            function GmBuildCardReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GmBuildCardReq cardId.
             * @member {number} cardId
             * @memberof luck.protobuf.GmBuildCardReq
             * @instance
             */
            GmBuildCardReq.prototype.cardId = 0;

            /**
             * GmBuildCardReq cardNum.
             * @member {number} cardNum
             * @memberof luck.protobuf.GmBuildCardReq
             * @instance
             */
            GmBuildCardReq.prototype.cardNum = 0;

            /**
             * Creates a new GmBuildCardReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.GmBuildCardReq
             * @static
             * @param {luck.protobuf.IGmBuildCardReq=} [properties] Properties to set
             * @returns {luck.protobuf.GmBuildCardReq} GmBuildCardReq instance
             */
            GmBuildCardReq.create = function create(properties) {
                return new GmBuildCardReq(properties);
            };

            /**
             * Encodes the specified GmBuildCardReq message. Does not implicitly {@link luck.protobuf.GmBuildCardReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.GmBuildCardReq
             * @static
             * @param {luck.protobuf.IGmBuildCardReq} message GmBuildCardReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GmBuildCardReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.cardId);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.cardNum);
                return writer;
            };

            /**
             * Encodes the specified GmBuildCardReq message, length delimited. Does not implicitly {@link luck.protobuf.GmBuildCardReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.GmBuildCardReq
             * @static
             * @param {luck.protobuf.IGmBuildCardReq} message GmBuildCardReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GmBuildCardReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GmBuildCardReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.GmBuildCardReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.GmBuildCardReq} GmBuildCardReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GmBuildCardReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.GmBuildCardReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.cardId = reader.int32();
                        break;
                    case 2:
                        message.cardNum = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("cardId"))
                    throw $util.ProtocolError("missing required 'cardId'", { instance: message });
                if (!message.hasOwnProperty("cardNum"))
                    throw $util.ProtocolError("missing required 'cardNum'", { instance: message });
                return message;
            };

            /**
             * Decodes a GmBuildCardReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.GmBuildCardReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.GmBuildCardReq} GmBuildCardReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GmBuildCardReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GmBuildCardReq message.
             * @function verify
             * @memberof luck.protobuf.GmBuildCardReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GmBuildCardReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.cardId))
                    return "cardId: integer expected";
                if (!$util.isInteger(message.cardNum))
                    return "cardNum: integer expected";
                return null;
            };

            return GmBuildCardReq;
        })();

        protobuf.GmBuildClothesReq = (function() {

            /**
             * Properties of a GmBuildClothesReq.
             * @memberof luck.protobuf
             * @interface IGmBuildClothesReq
             * @property {number} clothesId GmBuildClothesReq clothesId
             * @property {number} clothesNum GmBuildClothesReq clothesNum
             */

            /**
             * Constructs a new GmBuildClothesReq.
             * @memberof luck.protobuf
             * @classdesc Represents a GmBuildClothesReq.
             * @implements IGmBuildClothesReq
             * @constructor
             * @param {luck.protobuf.IGmBuildClothesReq=} [properties] Properties to set
             */
            function GmBuildClothesReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GmBuildClothesReq clothesId.
             * @member {number} clothesId
             * @memberof luck.protobuf.GmBuildClothesReq
             * @instance
             */
            GmBuildClothesReq.prototype.clothesId = 0;

            /**
             * GmBuildClothesReq clothesNum.
             * @member {number} clothesNum
             * @memberof luck.protobuf.GmBuildClothesReq
             * @instance
             */
            GmBuildClothesReq.prototype.clothesNum = 0;

            /**
             * Creates a new GmBuildClothesReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.GmBuildClothesReq
             * @static
             * @param {luck.protobuf.IGmBuildClothesReq=} [properties] Properties to set
             * @returns {luck.protobuf.GmBuildClothesReq} GmBuildClothesReq instance
             */
            GmBuildClothesReq.create = function create(properties) {
                return new GmBuildClothesReq(properties);
            };

            /**
             * Encodes the specified GmBuildClothesReq message. Does not implicitly {@link luck.protobuf.GmBuildClothesReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.GmBuildClothesReq
             * @static
             * @param {luck.protobuf.IGmBuildClothesReq} message GmBuildClothesReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GmBuildClothesReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.clothesId);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.clothesNum);
                return writer;
            };

            /**
             * Encodes the specified GmBuildClothesReq message, length delimited. Does not implicitly {@link luck.protobuf.GmBuildClothesReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.GmBuildClothesReq
             * @static
             * @param {luck.protobuf.IGmBuildClothesReq} message GmBuildClothesReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GmBuildClothesReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GmBuildClothesReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.GmBuildClothesReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.GmBuildClothesReq} GmBuildClothesReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GmBuildClothesReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.GmBuildClothesReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.clothesId = reader.int32();
                        break;
                    case 2:
                        message.clothesNum = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("clothesId"))
                    throw $util.ProtocolError("missing required 'clothesId'", { instance: message });
                if (!message.hasOwnProperty("clothesNum"))
                    throw $util.ProtocolError("missing required 'clothesNum'", { instance: message });
                return message;
            };

            /**
             * Decodes a GmBuildClothesReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.GmBuildClothesReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.GmBuildClothesReq} GmBuildClothesReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GmBuildClothesReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GmBuildClothesReq message.
             * @function verify
             * @memberof luck.protobuf.GmBuildClothesReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GmBuildClothesReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.clothesId))
                    return "clothesId: integer expected";
                if (!$util.isInteger(message.clothesNum))
                    return "clothesNum: integer expected";
                return null;
            };

            return GmBuildClothesReq;
        })();

        protobuf.GmAddGoodsReq = (function() {

            /**
             * Properties of a GmAddGoodsReq.
             * @memberof luck.protobuf
             * @interface IGmAddGoodsReq
             * @property {number} goodsType GmAddGoodsReq goodsType
             * @property {number} goodsId GmAddGoodsReq goodsId
             * @property {number} goodsNum GmAddGoodsReq goodsNum
             */

            /**
             * Constructs a new GmAddGoodsReq.
             * @memberof luck.protobuf
             * @classdesc Represents a GmAddGoodsReq.
             * @implements IGmAddGoodsReq
             * @constructor
             * @param {luck.protobuf.IGmAddGoodsReq=} [properties] Properties to set
             */
            function GmAddGoodsReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GmAddGoodsReq goodsType.
             * @member {number} goodsType
             * @memberof luck.protobuf.GmAddGoodsReq
             * @instance
             */
            GmAddGoodsReq.prototype.goodsType = 0;

            /**
             * GmAddGoodsReq goodsId.
             * @member {number} goodsId
             * @memberof luck.protobuf.GmAddGoodsReq
             * @instance
             */
            GmAddGoodsReq.prototype.goodsId = 0;

            /**
             * GmAddGoodsReq goodsNum.
             * @member {number} goodsNum
             * @memberof luck.protobuf.GmAddGoodsReq
             * @instance
             */
            GmAddGoodsReq.prototype.goodsNum = 0;

            /**
             * Creates a new GmAddGoodsReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.GmAddGoodsReq
             * @static
             * @param {luck.protobuf.IGmAddGoodsReq=} [properties] Properties to set
             * @returns {luck.protobuf.GmAddGoodsReq} GmAddGoodsReq instance
             */
            GmAddGoodsReq.create = function create(properties) {
                return new GmAddGoodsReq(properties);
            };

            /**
             * Encodes the specified GmAddGoodsReq message. Does not implicitly {@link luck.protobuf.GmAddGoodsReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.GmAddGoodsReq
             * @static
             * @param {luck.protobuf.IGmAddGoodsReq} message GmAddGoodsReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GmAddGoodsReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.goodsType);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.goodsId);
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.goodsNum);
                return writer;
            };

            /**
             * Encodes the specified GmAddGoodsReq message, length delimited. Does not implicitly {@link luck.protobuf.GmAddGoodsReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.GmAddGoodsReq
             * @static
             * @param {luck.protobuf.IGmAddGoodsReq} message GmAddGoodsReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GmAddGoodsReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GmAddGoodsReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.GmAddGoodsReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.GmAddGoodsReq} GmAddGoodsReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GmAddGoodsReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.GmAddGoodsReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.goodsType = reader.int32();
                        break;
                    case 2:
                        message.goodsId = reader.int32();
                        break;
                    case 3:
                        message.goodsNum = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("goodsType"))
                    throw $util.ProtocolError("missing required 'goodsType'", { instance: message });
                if (!message.hasOwnProperty("goodsId"))
                    throw $util.ProtocolError("missing required 'goodsId'", { instance: message });
                if (!message.hasOwnProperty("goodsNum"))
                    throw $util.ProtocolError("missing required 'goodsNum'", { instance: message });
                return message;
            };

            /**
             * Decodes a GmAddGoodsReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.GmAddGoodsReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.GmAddGoodsReq} GmAddGoodsReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GmAddGoodsReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GmAddGoodsReq message.
             * @function verify
             * @memberof luck.protobuf.GmAddGoodsReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GmAddGoodsReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.goodsType))
                    return "goodsType: integer expected";
                if (!$util.isInteger(message.goodsId))
                    return "goodsId: integer expected";
                if (!$util.isInteger(message.goodsNum))
                    return "goodsNum: integer expected";
                return null;
            };

            return GmAddGoodsReq;
        })();

        protobuf.ChangeEquipReq = (function() {

            /**
             * Properties of a ChangeEquipReq.
             * @memberof luck.protobuf
             * @interface IChangeEquipReq
             * @property {number} grooveId ChangeEquipReq grooveId
             * @property {number|Long} equipUid ChangeEquipReq equipUid
             * @property {number} changeType ChangeEquipReq changeType
             */

            /**
             * Constructs a new ChangeEquipReq.
             * @memberof luck.protobuf
             * @classdesc Represents a ChangeEquipReq.
             * @implements IChangeEquipReq
             * @constructor
             * @param {luck.protobuf.IChangeEquipReq=} [properties] Properties to set
             */
            function ChangeEquipReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ChangeEquipReq grooveId.
             * @member {number} grooveId
             * @memberof luck.protobuf.ChangeEquipReq
             * @instance
             */
            ChangeEquipReq.prototype.grooveId = 0;

            /**
             * ChangeEquipReq equipUid.
             * @member {number|Long} equipUid
             * @memberof luck.protobuf.ChangeEquipReq
             * @instance
             */
            ChangeEquipReq.prototype.equipUid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * ChangeEquipReq changeType.
             * @member {number} changeType
             * @memberof luck.protobuf.ChangeEquipReq
             * @instance
             */
            ChangeEquipReq.prototype.changeType = 0;

            /**
             * Creates a new ChangeEquipReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.ChangeEquipReq
             * @static
             * @param {luck.protobuf.IChangeEquipReq=} [properties] Properties to set
             * @returns {luck.protobuf.ChangeEquipReq} ChangeEquipReq instance
             */
            ChangeEquipReq.create = function create(properties) {
                return new ChangeEquipReq(properties);
            };

            /**
             * Encodes the specified ChangeEquipReq message. Does not implicitly {@link luck.protobuf.ChangeEquipReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.ChangeEquipReq
             * @static
             * @param {luck.protobuf.IChangeEquipReq} message ChangeEquipReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChangeEquipReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.grooveId);
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.equipUid);
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.changeType);
                return writer;
            };

            /**
             * Encodes the specified ChangeEquipReq message, length delimited. Does not implicitly {@link luck.protobuf.ChangeEquipReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.ChangeEquipReq
             * @static
             * @param {luck.protobuf.IChangeEquipReq} message ChangeEquipReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChangeEquipReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ChangeEquipReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.ChangeEquipReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.ChangeEquipReq} ChangeEquipReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChangeEquipReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.ChangeEquipReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.grooveId = reader.int32();
                        break;
                    case 2:
                        message.equipUid = reader.int64();
                        break;
                    case 3:
                        message.changeType = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("grooveId"))
                    throw $util.ProtocolError("missing required 'grooveId'", { instance: message });
                if (!message.hasOwnProperty("equipUid"))
                    throw $util.ProtocolError("missing required 'equipUid'", { instance: message });
                if (!message.hasOwnProperty("changeType"))
                    throw $util.ProtocolError("missing required 'changeType'", { instance: message });
                return message;
            };

            /**
             * Decodes a ChangeEquipReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.ChangeEquipReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.ChangeEquipReq} ChangeEquipReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChangeEquipReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ChangeEquipReq message.
             * @function verify
             * @memberof luck.protobuf.ChangeEquipReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChangeEquipReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.grooveId))
                    return "grooveId: integer expected";
                if (!$util.isInteger(message.equipUid) && !(message.equipUid && $util.isInteger(message.equipUid.low) && $util.isInteger(message.equipUid.high)))
                    return "equipUid: integer|Long expected";
                if (!$util.isInteger(message.changeType))
                    return "changeType: integer expected";
                return null;
            };

            return ChangeEquipReq;
        })();

        protobuf.BattleReq = (function() {

            /**
             * Properties of a BattleReq.
             * @memberof luck.protobuf
             * @interface IBattleReq
             * @property {luck.protobuf.IOperationPB} operation BattleReq operation
             */

            /**
             * Constructs a new BattleReq.
             * @memberof luck.protobuf
             * @classdesc Represents a BattleReq.
             * @implements IBattleReq
             * @constructor
             * @param {luck.protobuf.IBattleReq=} [properties] Properties to set
             */
            function BattleReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BattleReq operation.
             * @member {luck.protobuf.IOperationPB} operation
             * @memberof luck.protobuf.BattleReq
             * @instance
             */
            BattleReq.prototype.operation = null;

            /**
             * Creates a new BattleReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.BattleReq
             * @static
             * @param {luck.protobuf.IBattleReq=} [properties] Properties to set
             * @returns {luck.protobuf.BattleReq} BattleReq instance
             */
            BattleReq.create = function create(properties) {
                return new BattleReq(properties);
            };

            /**
             * Encodes the specified BattleReq message. Does not implicitly {@link luck.protobuf.BattleReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.BattleReq
             * @static
             * @param {luck.protobuf.IBattleReq} message BattleReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BattleReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                $root.luck.protobuf.OperationPB.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified BattleReq message, length delimited. Does not implicitly {@link luck.protobuf.BattleReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.BattleReq
             * @static
             * @param {luck.protobuf.IBattleReq} message BattleReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BattleReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BattleReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.BattleReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.BattleReq} BattleReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BattleReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.BattleReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.luck.protobuf.OperationPB.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("operation"))
                    throw $util.ProtocolError("missing required 'operation'", { instance: message });
                return message;
            };

            /**
             * Decodes a BattleReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.BattleReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.BattleReq} BattleReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BattleReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BattleReq message.
             * @function verify
             * @memberof luck.protobuf.BattleReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BattleReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                {
                    var error = $root.luck.protobuf.OperationPB.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            return BattleReq;
        })();

        protobuf.CreateRoomReq = (function() {

            /**
             * Properties of a CreateRoomReq.
             * @memberof luck.protobuf
             * @interface ICreateRoomReq
             * @property {string} roomName CreateRoomReq roomName
             * @property {number|Long} playerId CreateRoomReq playerId
             */

            /**
             * Constructs a new CreateRoomReq.
             * @memberof luck.protobuf
             * @classdesc Represents a CreateRoomReq.
             * @implements ICreateRoomReq
             * @constructor
             * @param {luck.protobuf.ICreateRoomReq=} [properties] Properties to set
             */
            function CreateRoomReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CreateRoomReq roomName.
             * @member {string} roomName
             * @memberof luck.protobuf.CreateRoomReq
             * @instance
             */
            CreateRoomReq.prototype.roomName = "";

            /**
             * CreateRoomReq playerId.
             * @member {number|Long} playerId
             * @memberof luck.protobuf.CreateRoomReq
             * @instance
             */
            CreateRoomReq.prototype.playerId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new CreateRoomReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.CreateRoomReq
             * @static
             * @param {luck.protobuf.ICreateRoomReq=} [properties] Properties to set
             * @returns {luck.protobuf.CreateRoomReq} CreateRoomReq instance
             */
            CreateRoomReq.create = function create(properties) {
                return new CreateRoomReq(properties);
            };

            /**
             * Encodes the specified CreateRoomReq message. Does not implicitly {@link luck.protobuf.CreateRoomReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.CreateRoomReq
             * @static
             * @param {luck.protobuf.ICreateRoomReq} message CreateRoomReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateRoomReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.roomName);
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.playerId);
                return writer;
            };

            /**
             * Encodes the specified CreateRoomReq message, length delimited. Does not implicitly {@link luck.protobuf.CreateRoomReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.CreateRoomReq
             * @static
             * @param {luck.protobuf.ICreateRoomReq} message CreateRoomReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateRoomReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CreateRoomReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.CreateRoomReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.CreateRoomReq} CreateRoomReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateRoomReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.CreateRoomReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.roomName = reader.string();
                        break;
                    case 2:
                        message.playerId = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("roomName"))
                    throw $util.ProtocolError("missing required 'roomName'", { instance: message });
                if (!message.hasOwnProperty("playerId"))
                    throw $util.ProtocolError("missing required 'playerId'", { instance: message });
                return message;
            };

            /**
             * Decodes a CreateRoomReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.CreateRoomReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.CreateRoomReq} CreateRoomReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateRoomReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CreateRoomReq message.
             * @function verify
             * @memberof luck.protobuf.CreateRoomReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateRoomReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.roomName))
                    return "roomName: string expected";
                if (!$util.isInteger(message.playerId) && !(message.playerId && $util.isInteger(message.playerId.low) && $util.isInteger(message.playerId.high)))
                    return "playerId: integer|Long expected";
                return null;
            };

            return CreateRoomReq;
        })();

        protobuf.EnterRoomReq = (function() {

            /**
             * Properties of an EnterRoomReq.
             * @memberof luck.protobuf
             * @interface IEnterRoomReq
             * @property {number|Long} playerId EnterRoomReq playerId
             * @property {number|Long} roomId EnterRoomReq roomId
             */

            /**
             * Constructs a new EnterRoomReq.
             * @memberof luck.protobuf
             * @classdesc Represents an EnterRoomReq.
             * @implements IEnterRoomReq
             * @constructor
             * @param {luck.protobuf.IEnterRoomReq=} [properties] Properties to set
             */
            function EnterRoomReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnterRoomReq playerId.
             * @member {number|Long} playerId
             * @memberof luck.protobuf.EnterRoomReq
             * @instance
             */
            EnterRoomReq.prototype.playerId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * EnterRoomReq roomId.
             * @member {number|Long} roomId
             * @memberof luck.protobuf.EnterRoomReq
             * @instance
             */
            EnterRoomReq.prototype.roomId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new EnterRoomReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.EnterRoomReq
             * @static
             * @param {luck.protobuf.IEnterRoomReq=} [properties] Properties to set
             * @returns {luck.protobuf.EnterRoomReq} EnterRoomReq instance
             */
            EnterRoomReq.create = function create(properties) {
                return new EnterRoomReq(properties);
            };

            /**
             * Encodes the specified EnterRoomReq message. Does not implicitly {@link luck.protobuf.EnterRoomReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.EnterRoomReq
             * @static
             * @param {luck.protobuf.IEnterRoomReq} message EnterRoomReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnterRoomReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.playerId);
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.roomId);
                return writer;
            };

            /**
             * Encodes the specified EnterRoomReq message, length delimited. Does not implicitly {@link luck.protobuf.EnterRoomReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.EnterRoomReq
             * @static
             * @param {luck.protobuf.IEnterRoomReq} message EnterRoomReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnterRoomReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnterRoomReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.EnterRoomReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.EnterRoomReq} EnterRoomReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnterRoomReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.EnterRoomReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.playerId = reader.int64();
                        break;
                    case 2:
                        message.roomId = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("playerId"))
                    throw $util.ProtocolError("missing required 'playerId'", { instance: message });
                if (!message.hasOwnProperty("roomId"))
                    throw $util.ProtocolError("missing required 'roomId'", { instance: message });
                return message;
            };

            /**
             * Decodes an EnterRoomReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.EnterRoomReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.EnterRoomReq} EnterRoomReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnterRoomReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnterRoomReq message.
             * @function verify
             * @memberof luck.protobuf.EnterRoomReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnterRoomReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.playerId) && !(message.playerId && $util.isInteger(message.playerId.low) && $util.isInteger(message.playerId.high)))
                    return "playerId: integer|Long expected";
                if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high)))
                    return "roomId: integer|Long expected";
                return null;
            };

            return EnterRoomReq;
        })();

        protobuf.GetRoomListReq = (function() {

            /**
             * Properties of a GetRoomListReq.
             * @memberof luck.protobuf
             * @interface IGetRoomListReq
             */

            /**
             * Constructs a new GetRoomListReq.
             * @memberof luck.protobuf
             * @classdesc Represents a GetRoomListReq.
             * @implements IGetRoomListReq
             * @constructor
             * @param {luck.protobuf.IGetRoomListReq=} [properties] Properties to set
             */
            function GetRoomListReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new GetRoomListReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.GetRoomListReq
             * @static
             * @param {luck.protobuf.IGetRoomListReq=} [properties] Properties to set
             * @returns {luck.protobuf.GetRoomListReq} GetRoomListReq instance
             */
            GetRoomListReq.create = function create(properties) {
                return new GetRoomListReq(properties);
            };

            /**
             * Encodes the specified GetRoomListReq message. Does not implicitly {@link luck.protobuf.GetRoomListReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.GetRoomListReq
             * @static
             * @param {luck.protobuf.IGetRoomListReq} message GetRoomListReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetRoomListReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified GetRoomListReq message, length delimited. Does not implicitly {@link luck.protobuf.GetRoomListReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.GetRoomListReq
             * @static
             * @param {luck.protobuf.IGetRoomListReq} message GetRoomListReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetRoomListReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetRoomListReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.GetRoomListReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.GetRoomListReq} GetRoomListReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetRoomListReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.GetRoomListReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetRoomListReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.GetRoomListReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.GetRoomListReq} GetRoomListReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetRoomListReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetRoomListReq message.
             * @function verify
             * @memberof luck.protobuf.GetRoomListReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetRoomListReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            return GetRoomListReq;
        })();

        protobuf.ExitRoomReq = (function() {

            /**
             * Properties of an ExitRoomReq.
             * @memberof luck.protobuf
             * @interface IExitRoomReq
             * @property {number|Long} playerId ExitRoomReq playerId
             * @property {number|Long} roomId ExitRoomReq roomId
             */

            /**
             * Constructs a new ExitRoomReq.
             * @memberof luck.protobuf
             * @classdesc Represents an ExitRoomReq.
             * @implements IExitRoomReq
             * @constructor
             * @param {luck.protobuf.IExitRoomReq=} [properties] Properties to set
             */
            function ExitRoomReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExitRoomReq playerId.
             * @member {number|Long} playerId
             * @memberof luck.protobuf.ExitRoomReq
             * @instance
             */
            ExitRoomReq.prototype.playerId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * ExitRoomReq roomId.
             * @member {number|Long} roomId
             * @memberof luck.protobuf.ExitRoomReq
             * @instance
             */
            ExitRoomReq.prototype.roomId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new ExitRoomReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.ExitRoomReq
             * @static
             * @param {luck.protobuf.IExitRoomReq=} [properties] Properties to set
             * @returns {luck.protobuf.ExitRoomReq} ExitRoomReq instance
             */
            ExitRoomReq.create = function create(properties) {
                return new ExitRoomReq(properties);
            };

            /**
             * Encodes the specified ExitRoomReq message. Does not implicitly {@link luck.protobuf.ExitRoomReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.ExitRoomReq
             * @static
             * @param {luck.protobuf.IExitRoomReq} message ExitRoomReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExitRoomReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.playerId);
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.roomId);
                return writer;
            };

            /**
             * Encodes the specified ExitRoomReq message, length delimited. Does not implicitly {@link luck.protobuf.ExitRoomReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.ExitRoomReq
             * @static
             * @param {luck.protobuf.IExitRoomReq} message ExitRoomReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExitRoomReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExitRoomReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.ExitRoomReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.ExitRoomReq} ExitRoomReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExitRoomReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.ExitRoomReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.playerId = reader.int64();
                        break;
                    case 2:
                        message.roomId = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("playerId"))
                    throw $util.ProtocolError("missing required 'playerId'", { instance: message });
                if (!message.hasOwnProperty("roomId"))
                    throw $util.ProtocolError("missing required 'roomId'", { instance: message });
                return message;
            };

            /**
             * Decodes an ExitRoomReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.ExitRoomReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.ExitRoomReq} ExitRoomReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExitRoomReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExitRoomReq message.
             * @function verify
             * @memberof luck.protobuf.ExitRoomReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExitRoomReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.playerId) && !(message.playerId && $util.isInteger(message.playerId.low) && $util.isInteger(message.playerId.high)))
                    return "playerId: integer|Long expected";
                if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high)))
                    return "roomId: integer|Long expected";
                return null;
            };

            return ExitRoomReq;
        })();

        protobuf.StartBattleReq = (function() {

            /**
             * Properties of a StartBattleReq.
             * @memberof luck.protobuf
             * @interface IStartBattleReq
             * @property {number|Long} playerId StartBattleReq playerId
             * @property {number|Long} roomId StartBattleReq roomId
             */

            /**
             * Constructs a new StartBattleReq.
             * @memberof luck.protobuf
             * @classdesc Represents a StartBattleReq.
             * @implements IStartBattleReq
             * @constructor
             * @param {luck.protobuf.IStartBattleReq=} [properties] Properties to set
             */
            function StartBattleReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StartBattleReq playerId.
             * @member {number|Long} playerId
             * @memberof luck.protobuf.StartBattleReq
             * @instance
             */
            StartBattleReq.prototype.playerId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * StartBattleReq roomId.
             * @member {number|Long} roomId
             * @memberof luck.protobuf.StartBattleReq
             * @instance
             */
            StartBattleReq.prototype.roomId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new StartBattleReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.StartBattleReq
             * @static
             * @param {luck.protobuf.IStartBattleReq=} [properties] Properties to set
             * @returns {luck.protobuf.StartBattleReq} StartBattleReq instance
             */
            StartBattleReq.create = function create(properties) {
                return new StartBattleReq(properties);
            };

            /**
             * Encodes the specified StartBattleReq message. Does not implicitly {@link luck.protobuf.StartBattleReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.StartBattleReq
             * @static
             * @param {luck.protobuf.IStartBattleReq} message StartBattleReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StartBattleReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.playerId);
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.roomId);
                return writer;
            };

            /**
             * Encodes the specified StartBattleReq message, length delimited. Does not implicitly {@link luck.protobuf.StartBattleReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.StartBattleReq
             * @static
             * @param {luck.protobuf.IStartBattleReq} message StartBattleReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StartBattleReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StartBattleReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.StartBattleReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.StartBattleReq} StartBattleReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StartBattleReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.StartBattleReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.playerId = reader.int64();
                        break;
                    case 2:
                        message.roomId = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("playerId"))
                    throw $util.ProtocolError("missing required 'playerId'", { instance: message });
                if (!message.hasOwnProperty("roomId"))
                    throw $util.ProtocolError("missing required 'roomId'", { instance: message });
                return message;
            };

            /**
             * Decodes a StartBattleReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.StartBattleReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.StartBattleReq} StartBattleReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StartBattleReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StartBattleReq message.
             * @function verify
             * @memberof luck.protobuf.StartBattleReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StartBattleReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.playerId) && !(message.playerId && $util.isInteger(message.playerId.low) && $util.isInteger(message.playerId.high)))
                    return "playerId: integer|Long expected";
                if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high)))
                    return "roomId: integer|Long expected";
                return null;
            };

            return StartBattleReq;
        })();

        protobuf.StartCheckNodeReq = (function() {

            /**
             * Properties of a StartCheckNodeReq.
             * @memberof luck.protobuf
             * @interface IStartCheckNodeReq
             * @property {number} checkNodeId StartCheckNodeReq checkNodeId
             */

            /**
             * Constructs a new StartCheckNodeReq.
             * @memberof luck.protobuf
             * @classdesc Represents a StartCheckNodeReq.
             * @implements IStartCheckNodeReq
             * @constructor
             * @param {luck.protobuf.IStartCheckNodeReq=} [properties] Properties to set
             */
            function StartCheckNodeReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StartCheckNodeReq checkNodeId.
             * @member {number} checkNodeId
             * @memberof luck.protobuf.StartCheckNodeReq
             * @instance
             */
            StartCheckNodeReq.prototype.checkNodeId = 0;

            /**
             * Creates a new StartCheckNodeReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.StartCheckNodeReq
             * @static
             * @param {luck.protobuf.IStartCheckNodeReq=} [properties] Properties to set
             * @returns {luck.protobuf.StartCheckNodeReq} StartCheckNodeReq instance
             */
            StartCheckNodeReq.create = function create(properties) {
                return new StartCheckNodeReq(properties);
            };

            /**
             * Encodes the specified StartCheckNodeReq message. Does not implicitly {@link luck.protobuf.StartCheckNodeReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.StartCheckNodeReq
             * @static
             * @param {luck.protobuf.IStartCheckNodeReq} message StartCheckNodeReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StartCheckNodeReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.checkNodeId);
                return writer;
            };

            /**
             * Encodes the specified StartCheckNodeReq message, length delimited. Does not implicitly {@link luck.protobuf.StartCheckNodeReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.StartCheckNodeReq
             * @static
             * @param {luck.protobuf.IStartCheckNodeReq} message StartCheckNodeReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StartCheckNodeReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StartCheckNodeReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.StartCheckNodeReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.StartCheckNodeReq} StartCheckNodeReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StartCheckNodeReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.StartCheckNodeReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.checkNodeId = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("checkNodeId"))
                    throw $util.ProtocolError("missing required 'checkNodeId'", { instance: message });
                return message;
            };

            /**
             * Decodes a StartCheckNodeReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.StartCheckNodeReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.StartCheckNodeReq} StartCheckNodeReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StartCheckNodeReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StartCheckNodeReq message.
             * @function verify
             * @memberof luck.protobuf.StartCheckNodeReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StartCheckNodeReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.checkNodeId))
                    return "checkNodeId: integer expected";
                return null;
            };

            return StartCheckNodeReq;
        })();

        protobuf.FinishCheckNodeReq = (function() {

            /**
             * Properties of a FinishCheckNodeReq.
             * @memberof luck.protobuf
             * @interface IFinishCheckNodeReq
             * @property {number} checkNodeId FinishCheckNodeReq checkNodeId
             * @property {number} fightResult FinishCheckNodeReq fightResult
             */

            /**
             * Constructs a new FinishCheckNodeReq.
             * @memberof luck.protobuf
             * @classdesc Represents a FinishCheckNodeReq.
             * @implements IFinishCheckNodeReq
             * @constructor
             * @param {luck.protobuf.IFinishCheckNodeReq=} [properties] Properties to set
             */
            function FinishCheckNodeReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FinishCheckNodeReq checkNodeId.
             * @member {number} checkNodeId
             * @memberof luck.protobuf.FinishCheckNodeReq
             * @instance
             */
            FinishCheckNodeReq.prototype.checkNodeId = 0;

            /**
             * FinishCheckNodeReq fightResult.
             * @member {number} fightResult
             * @memberof luck.protobuf.FinishCheckNodeReq
             * @instance
             */
            FinishCheckNodeReq.prototype.fightResult = 0;

            /**
             * Creates a new FinishCheckNodeReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.FinishCheckNodeReq
             * @static
             * @param {luck.protobuf.IFinishCheckNodeReq=} [properties] Properties to set
             * @returns {luck.protobuf.FinishCheckNodeReq} FinishCheckNodeReq instance
             */
            FinishCheckNodeReq.create = function create(properties) {
                return new FinishCheckNodeReq(properties);
            };

            /**
             * Encodes the specified FinishCheckNodeReq message. Does not implicitly {@link luck.protobuf.FinishCheckNodeReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.FinishCheckNodeReq
             * @static
             * @param {luck.protobuf.IFinishCheckNodeReq} message FinishCheckNodeReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FinishCheckNodeReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.checkNodeId);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.fightResult);
                return writer;
            };

            /**
             * Encodes the specified FinishCheckNodeReq message, length delimited. Does not implicitly {@link luck.protobuf.FinishCheckNodeReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.FinishCheckNodeReq
             * @static
             * @param {luck.protobuf.IFinishCheckNodeReq} message FinishCheckNodeReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FinishCheckNodeReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FinishCheckNodeReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.FinishCheckNodeReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.FinishCheckNodeReq} FinishCheckNodeReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FinishCheckNodeReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.FinishCheckNodeReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.checkNodeId = reader.int32();
                        break;
                    case 2:
                        message.fightResult = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("checkNodeId"))
                    throw $util.ProtocolError("missing required 'checkNodeId'", { instance: message });
                if (!message.hasOwnProperty("fightResult"))
                    throw $util.ProtocolError("missing required 'fightResult'", { instance: message });
                return message;
            };

            /**
             * Decodes a FinishCheckNodeReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.FinishCheckNodeReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.FinishCheckNodeReq} FinishCheckNodeReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FinishCheckNodeReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FinishCheckNodeReq message.
             * @function verify
             * @memberof luck.protobuf.FinishCheckNodeReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FinishCheckNodeReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.checkNodeId))
                    return "checkNodeId: integer expected";
                if (!$util.isInteger(message.fightResult))
                    return "fightResult: integer expected";
                return null;
            };

            return FinishCheckNodeReq;
        })();

        protobuf.BattleDropReq = (function() {

            /**
             * Properties of a BattleDropReq.
             * @memberof luck.protobuf
             * @interface IBattleDropReq
             * @property {number} checkNodeId BattleDropReq checkNodeId
             * @property {number} monsterId BattleDropReq monsterId
             */

            /**
             * Constructs a new BattleDropReq.
             * @memberof luck.protobuf
             * @classdesc Represents a BattleDropReq.
             * @implements IBattleDropReq
             * @constructor
             * @param {luck.protobuf.IBattleDropReq=} [properties] Properties to set
             */
            function BattleDropReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BattleDropReq checkNodeId.
             * @member {number} checkNodeId
             * @memberof luck.protobuf.BattleDropReq
             * @instance
             */
            BattleDropReq.prototype.checkNodeId = 0;

            /**
             * BattleDropReq monsterId.
             * @member {number} monsterId
             * @memberof luck.protobuf.BattleDropReq
             * @instance
             */
            BattleDropReq.prototype.monsterId = 0;

            /**
             * Creates a new BattleDropReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.BattleDropReq
             * @static
             * @param {luck.protobuf.IBattleDropReq=} [properties] Properties to set
             * @returns {luck.protobuf.BattleDropReq} BattleDropReq instance
             */
            BattleDropReq.create = function create(properties) {
                return new BattleDropReq(properties);
            };

            /**
             * Encodes the specified BattleDropReq message. Does not implicitly {@link luck.protobuf.BattleDropReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.BattleDropReq
             * @static
             * @param {luck.protobuf.IBattleDropReq} message BattleDropReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BattleDropReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.checkNodeId);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.monsterId);
                return writer;
            };

            /**
             * Encodes the specified BattleDropReq message, length delimited. Does not implicitly {@link luck.protobuf.BattleDropReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.BattleDropReq
             * @static
             * @param {luck.protobuf.IBattleDropReq} message BattleDropReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BattleDropReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BattleDropReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.BattleDropReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.BattleDropReq} BattleDropReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BattleDropReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.BattleDropReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.checkNodeId = reader.int32();
                        break;
                    case 2:
                        message.monsterId = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("checkNodeId"))
                    throw $util.ProtocolError("missing required 'checkNodeId'", { instance: message });
                if (!message.hasOwnProperty("monsterId"))
                    throw $util.ProtocolError("missing required 'monsterId'", { instance: message });
                return message;
            };

            /**
             * Decodes a BattleDropReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.BattleDropReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.BattleDropReq} BattleDropReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BattleDropReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BattleDropReq message.
             * @function verify
             * @memberof luck.protobuf.BattleDropReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BattleDropReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.checkNodeId))
                    return "checkNodeId: integer expected";
                if (!$util.isInteger(message.monsterId))
                    return "monsterId: integer expected";
                return null;
            };

            return BattleDropReq;
        })();

        protobuf.SginInReq = (function() {

            /**
             * Properties of a SginInReq.
             * @memberof luck.protobuf
             * @interface ISginInReq
             */

            /**
             * Constructs a new SginInReq.
             * @memberof luck.protobuf
             * @classdesc Represents a SginInReq.
             * @implements ISginInReq
             * @constructor
             * @param {luck.protobuf.ISginInReq=} [properties] Properties to set
             */
            function SginInReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new SginInReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.SginInReq
             * @static
             * @param {luck.protobuf.ISginInReq=} [properties] Properties to set
             * @returns {luck.protobuf.SginInReq} SginInReq instance
             */
            SginInReq.create = function create(properties) {
                return new SginInReq(properties);
            };

            /**
             * Encodes the specified SginInReq message. Does not implicitly {@link luck.protobuf.SginInReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.SginInReq
             * @static
             * @param {luck.protobuf.ISginInReq} message SginInReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SginInReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified SginInReq message, length delimited. Does not implicitly {@link luck.protobuf.SginInReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.SginInReq
             * @static
             * @param {luck.protobuf.ISginInReq} message SginInReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SginInReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SginInReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.SginInReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.SginInReq} SginInReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SginInReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.SginInReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SginInReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.SginInReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.SginInReq} SginInReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SginInReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SginInReq message.
             * @function verify
             * @memberof luck.protobuf.SginInReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SginInReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            return SginInReq;
        })();

        protobuf.BattlePickUpReq = (function() {

            /**
             * Properties of a BattlePickUpReq.
             * @memberof luck.protobuf
             * @interface IBattlePickUpReq
             * @property {number|null} [gold] BattlePickUpReq gold
             * @property {number|null} [diamond] BattlePickUpReq diamond
             * @property {number|null} [type] BattlePickUpReq type
             * @property {number|null} [id] BattlePickUpReq id
             * @property {number|Long|null} [uid] BattlePickUpReq uid
             */

            /**
             * Constructs a new BattlePickUpReq.
             * @memberof luck.protobuf
             * @classdesc Represents a BattlePickUpReq.
             * @implements IBattlePickUpReq
             * @constructor
             * @param {luck.protobuf.IBattlePickUpReq=} [properties] Properties to set
             */
            function BattlePickUpReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BattlePickUpReq gold.
             * @member {number} gold
             * @memberof luck.protobuf.BattlePickUpReq
             * @instance
             */
            BattlePickUpReq.prototype.gold = 0;

            /**
             * BattlePickUpReq diamond.
             * @member {number} diamond
             * @memberof luck.protobuf.BattlePickUpReq
             * @instance
             */
            BattlePickUpReq.prototype.diamond = 0;

            /**
             * BattlePickUpReq type.
             * @member {number} type
             * @memberof luck.protobuf.BattlePickUpReq
             * @instance
             */
            BattlePickUpReq.prototype.type = 0;

            /**
             * BattlePickUpReq id.
             * @member {number} id
             * @memberof luck.protobuf.BattlePickUpReq
             * @instance
             */
            BattlePickUpReq.prototype.id = 0;

            /**
             * BattlePickUpReq uid.
             * @member {number|Long} uid
             * @memberof luck.protobuf.BattlePickUpReq
             * @instance
             */
            BattlePickUpReq.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new BattlePickUpReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.BattlePickUpReq
             * @static
             * @param {luck.protobuf.IBattlePickUpReq=} [properties] Properties to set
             * @returns {luck.protobuf.BattlePickUpReq} BattlePickUpReq instance
             */
            BattlePickUpReq.create = function create(properties) {
                return new BattlePickUpReq(properties);
            };

            /**
             * Encodes the specified BattlePickUpReq message. Does not implicitly {@link luck.protobuf.BattlePickUpReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.BattlePickUpReq
             * @static
             * @param {luck.protobuf.IBattlePickUpReq} message BattlePickUpReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BattlePickUpReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.gold != null && message.hasOwnProperty("gold"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.gold);
                if (message.diamond != null && message.hasOwnProperty("diamond"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.diamond);
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.id);
                if (message.uid != null && message.hasOwnProperty("uid"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.uid);
                return writer;
            };

            /**
             * Encodes the specified BattlePickUpReq message, length delimited. Does not implicitly {@link luck.protobuf.BattlePickUpReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.BattlePickUpReq
             * @static
             * @param {luck.protobuf.IBattlePickUpReq} message BattlePickUpReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BattlePickUpReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BattlePickUpReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.BattlePickUpReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.BattlePickUpReq} BattlePickUpReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BattlePickUpReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.BattlePickUpReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.gold = reader.int32();
                        break;
                    case 2:
                        message.diamond = reader.int32();
                        break;
                    case 3:
                        message.type = reader.int32();
                        break;
                    case 4:
                        message.id = reader.int32();
                        break;
                    case 5:
                        message.uid = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BattlePickUpReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.BattlePickUpReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.BattlePickUpReq} BattlePickUpReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BattlePickUpReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BattlePickUpReq message.
             * @function verify
             * @memberof luck.protobuf.BattlePickUpReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BattlePickUpReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.gold != null && message.hasOwnProperty("gold"))
                    if (!$util.isInteger(message.gold))
                        return "gold: integer expected";
                if (message.diamond != null && message.hasOwnProperty("diamond"))
                    if (!$util.isInteger(message.diamond))
                        return "diamond: integer expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isInteger(message.type))
                        return "type: integer expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                if (message.uid != null && message.hasOwnProperty("uid"))
                    if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                        return "uid: integer|Long expected";
                return null;
            };

            return BattlePickUpReq;
        })();

        protobuf.LotteryReq = (function() {

            /**
             * Properties of a LotteryReq.
             * @memberof luck.protobuf
             * @interface ILotteryReq
             * @property {number} lotteryType LotteryReq lotteryType
             */

            /**
             * Constructs a new LotteryReq.
             * @memberof luck.protobuf
             * @classdesc Represents a LotteryReq.
             * @implements ILotteryReq
             * @constructor
             * @param {luck.protobuf.ILotteryReq=} [properties] Properties to set
             */
            function LotteryReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LotteryReq lotteryType.
             * @member {number} lotteryType
             * @memberof luck.protobuf.LotteryReq
             * @instance
             */
            LotteryReq.prototype.lotteryType = 0;

            /**
             * Creates a new LotteryReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.LotteryReq
             * @static
             * @param {luck.protobuf.ILotteryReq=} [properties] Properties to set
             * @returns {luck.protobuf.LotteryReq} LotteryReq instance
             */
            LotteryReq.create = function create(properties) {
                return new LotteryReq(properties);
            };

            /**
             * Encodes the specified LotteryReq message. Does not implicitly {@link luck.protobuf.LotteryReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.LotteryReq
             * @static
             * @param {luck.protobuf.ILotteryReq} message LotteryReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LotteryReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.lotteryType);
                return writer;
            };

            /**
             * Encodes the specified LotteryReq message, length delimited. Does not implicitly {@link luck.protobuf.LotteryReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.LotteryReq
             * @static
             * @param {luck.protobuf.ILotteryReq} message LotteryReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LotteryReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LotteryReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.LotteryReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.LotteryReq} LotteryReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LotteryReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.LotteryReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.lotteryType = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("lotteryType"))
                    throw $util.ProtocolError("missing required 'lotteryType'", { instance: message });
                return message;
            };

            /**
             * Decodes a LotteryReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.LotteryReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.LotteryReq} LotteryReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LotteryReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LotteryReq message.
             * @function verify
             * @memberof luck.protobuf.LotteryReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LotteryReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.lotteryType))
                    return "lotteryType: integer expected";
                return null;
            };

            return LotteryReq;
        })();

        protobuf.SynthesisReq = (function() {

            /**
             * Properties of a SynthesisReq.
             * @memberof luck.protobuf
             * @interface ISynthesisReq
             * @property {number} synthesisId SynthesisReq synthesisId
             * @property {Array.<number|Long>|null} [weaponUidList] SynthesisReq weaponUidList
             * @property {Array.<number|Long>|null} [cardUidList] SynthesisReq cardUidList
             * @property {Array.<number|Long>|null} [clothesUidList] SynthesisReq clothesUidList
             * @property {number} synthesisNum SynthesisReq synthesisNum
             */

            /**
             * Constructs a new SynthesisReq.
             * @memberof luck.protobuf
             * @classdesc Represents a SynthesisReq.
             * @implements ISynthesisReq
             * @constructor
             * @param {luck.protobuf.ISynthesisReq=} [properties] Properties to set
             */
            function SynthesisReq(properties) {
                this.weaponUidList = [];
                this.cardUidList = [];
                this.clothesUidList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SynthesisReq synthesisId.
             * @member {number} synthesisId
             * @memberof luck.protobuf.SynthesisReq
             * @instance
             */
            SynthesisReq.prototype.synthesisId = 0;

            /**
             * SynthesisReq weaponUidList.
             * @member {Array.<number|Long>} weaponUidList
             * @memberof luck.protobuf.SynthesisReq
             * @instance
             */
            SynthesisReq.prototype.weaponUidList = $util.emptyArray;

            /**
             * SynthesisReq cardUidList.
             * @member {Array.<number|Long>} cardUidList
             * @memberof luck.protobuf.SynthesisReq
             * @instance
             */
            SynthesisReq.prototype.cardUidList = $util.emptyArray;

            /**
             * SynthesisReq clothesUidList.
             * @member {Array.<number|Long>} clothesUidList
             * @memberof luck.protobuf.SynthesisReq
             * @instance
             */
            SynthesisReq.prototype.clothesUidList = $util.emptyArray;

            /**
             * SynthesisReq synthesisNum.
             * @member {number} synthesisNum
             * @memberof luck.protobuf.SynthesisReq
             * @instance
             */
            SynthesisReq.prototype.synthesisNum = 0;

            /**
             * Creates a new SynthesisReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.SynthesisReq
             * @static
             * @param {luck.protobuf.ISynthesisReq=} [properties] Properties to set
             * @returns {luck.protobuf.SynthesisReq} SynthesisReq instance
             */
            SynthesisReq.create = function create(properties) {
                return new SynthesisReq(properties);
            };

            /**
             * Encodes the specified SynthesisReq message. Does not implicitly {@link luck.protobuf.SynthesisReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.SynthesisReq
             * @static
             * @param {luck.protobuf.ISynthesisReq} message SynthesisReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SynthesisReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.synthesisId);
                if (message.weaponUidList != null && message.weaponUidList.length)
                    for (var i = 0; i < message.weaponUidList.length; ++i)
                        writer.uint32(/* id 2, wireType 0 =*/16).int64(message.weaponUidList[i]);
                if (message.cardUidList != null && message.cardUidList.length)
                    for (var i = 0; i < message.cardUidList.length; ++i)
                        writer.uint32(/* id 3, wireType 0 =*/24).int64(message.cardUidList[i]);
                if (message.clothesUidList != null && message.clothesUidList.length)
                    for (var i = 0; i < message.clothesUidList.length; ++i)
                        writer.uint32(/* id 4, wireType 0 =*/32).int64(message.clothesUidList[i]);
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.synthesisNum);
                return writer;
            };

            /**
             * Encodes the specified SynthesisReq message, length delimited. Does not implicitly {@link luck.protobuf.SynthesisReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.SynthesisReq
             * @static
             * @param {luck.protobuf.ISynthesisReq} message SynthesisReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SynthesisReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SynthesisReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.SynthesisReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.SynthesisReq} SynthesisReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SynthesisReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.SynthesisReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.synthesisId = reader.int32();
                        break;
                    case 2:
                        if (!(message.weaponUidList && message.weaponUidList.length))
                            message.weaponUidList = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.weaponUidList.push(reader.int64());
                        } else
                            message.weaponUidList.push(reader.int64());
                        break;
                    case 3:
                        if (!(message.cardUidList && message.cardUidList.length))
                            message.cardUidList = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.cardUidList.push(reader.int64());
                        } else
                            message.cardUidList.push(reader.int64());
                        break;
                    case 4:
                        if (!(message.clothesUidList && message.clothesUidList.length))
                            message.clothesUidList = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.clothesUidList.push(reader.int64());
                        } else
                            message.clothesUidList.push(reader.int64());
                        break;
                    case 5:
                        message.synthesisNum = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("synthesisId"))
                    throw $util.ProtocolError("missing required 'synthesisId'", { instance: message });
                if (!message.hasOwnProperty("synthesisNum"))
                    throw $util.ProtocolError("missing required 'synthesisNum'", { instance: message });
                return message;
            };

            /**
             * Decodes a SynthesisReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.SynthesisReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.SynthesisReq} SynthesisReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SynthesisReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SynthesisReq message.
             * @function verify
             * @memberof luck.protobuf.SynthesisReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SynthesisReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.synthesisId))
                    return "synthesisId: integer expected";
                if (message.weaponUidList != null && message.hasOwnProperty("weaponUidList")) {
                    if (!Array.isArray(message.weaponUidList))
                        return "weaponUidList: array expected";
                    for (var i = 0; i < message.weaponUidList.length; ++i)
                        if (!$util.isInteger(message.weaponUidList[i]) && !(message.weaponUidList[i] && $util.isInteger(message.weaponUidList[i].low) && $util.isInteger(message.weaponUidList[i].high)))
                            return "weaponUidList: integer|Long[] expected";
                }
                if (message.cardUidList != null && message.hasOwnProperty("cardUidList")) {
                    if (!Array.isArray(message.cardUidList))
                        return "cardUidList: array expected";
                    for (var i = 0; i < message.cardUidList.length; ++i)
                        if (!$util.isInteger(message.cardUidList[i]) && !(message.cardUidList[i] && $util.isInteger(message.cardUidList[i].low) && $util.isInteger(message.cardUidList[i].high)))
                            return "cardUidList: integer|Long[] expected";
                }
                if (message.clothesUidList != null && message.hasOwnProperty("clothesUidList")) {
                    if (!Array.isArray(message.clothesUidList))
                        return "clothesUidList: array expected";
                    for (var i = 0; i < message.clothesUidList.length; ++i)
                        if (!$util.isInteger(message.clothesUidList[i]) && !(message.clothesUidList[i] && $util.isInteger(message.clothesUidList[i].low) && $util.isInteger(message.clothesUidList[i].high)))
                            return "clothesUidList: integer|Long[] expected";
                }
                if (!$util.isInteger(message.synthesisNum))
                    return "synthesisNum: integer expected";
                return null;
            };

            return SynthesisReq;
        })();

        protobuf.SettingReq = (function() {

            /**
             * Properties of a SettingReq.
             * @memberof luck.protobuf
             * @interface ISettingReq
             * @property {string|null} [telePhone] SettingReq telePhone
             * @property {string|null} [email] SettingReq email
             * @property {number} isCheckName SettingReq isCheckName
             * @property {number} refuseFriendReq SettingReq refuseFriendReq
             * @property {number} refuseStrangerNews SettingReq refuseStrangerNews
             * @property {number} refuseClubInvite SettingReq refuseClubInvite
             * @property {number} refuseSysInfo SettingReq refuseSysInfo
             * @property {number} refuseTeamInvite SettingReq refuseTeamInvite
             * @property {number} refuseBattleInvite SettingReq refuseBattleInvite
             * @property {number} closeBarrage SettingReq closeBarrage
             */

            /**
             * Constructs a new SettingReq.
             * @memberof luck.protobuf
             * @classdesc Represents a SettingReq.
             * @implements ISettingReq
             * @constructor
             * @param {luck.protobuf.ISettingReq=} [properties] Properties to set
             */
            function SettingReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SettingReq telePhone.
             * @member {string} telePhone
             * @memberof luck.protobuf.SettingReq
             * @instance
             */
            SettingReq.prototype.telePhone = "";

            /**
             * SettingReq email.
             * @member {string} email
             * @memberof luck.protobuf.SettingReq
             * @instance
             */
            SettingReq.prototype.email = "";

            /**
             * SettingReq isCheckName.
             * @member {number} isCheckName
             * @memberof luck.protobuf.SettingReq
             * @instance
             */
            SettingReq.prototype.isCheckName = 0;

            /**
             * SettingReq refuseFriendReq.
             * @member {number} refuseFriendReq
             * @memberof luck.protobuf.SettingReq
             * @instance
             */
            SettingReq.prototype.refuseFriendReq = 0;

            /**
             * SettingReq refuseStrangerNews.
             * @member {number} refuseStrangerNews
             * @memberof luck.protobuf.SettingReq
             * @instance
             */
            SettingReq.prototype.refuseStrangerNews = 0;

            /**
             * SettingReq refuseClubInvite.
             * @member {number} refuseClubInvite
             * @memberof luck.protobuf.SettingReq
             * @instance
             */
            SettingReq.prototype.refuseClubInvite = 0;

            /**
             * SettingReq refuseSysInfo.
             * @member {number} refuseSysInfo
             * @memberof luck.protobuf.SettingReq
             * @instance
             */
            SettingReq.prototype.refuseSysInfo = 0;

            /**
             * SettingReq refuseTeamInvite.
             * @member {number} refuseTeamInvite
             * @memberof luck.protobuf.SettingReq
             * @instance
             */
            SettingReq.prototype.refuseTeamInvite = 0;

            /**
             * SettingReq refuseBattleInvite.
             * @member {number} refuseBattleInvite
             * @memberof luck.protobuf.SettingReq
             * @instance
             */
            SettingReq.prototype.refuseBattleInvite = 0;

            /**
             * SettingReq closeBarrage.
             * @member {number} closeBarrage
             * @memberof luck.protobuf.SettingReq
             * @instance
             */
            SettingReq.prototype.closeBarrage = 0;

            /**
             * Creates a new SettingReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.SettingReq
             * @static
             * @param {luck.protobuf.ISettingReq=} [properties] Properties to set
             * @returns {luck.protobuf.SettingReq} SettingReq instance
             */
            SettingReq.create = function create(properties) {
                return new SettingReq(properties);
            };

            /**
             * Encodes the specified SettingReq message. Does not implicitly {@link luck.protobuf.SettingReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.SettingReq
             * @static
             * @param {luck.protobuf.ISettingReq} message SettingReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SettingReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.telePhone != null && message.hasOwnProperty("telePhone"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.telePhone);
                if (message.email != null && message.hasOwnProperty("email"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.email);
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.isCheckName);
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.refuseFriendReq);
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.refuseStrangerNews);
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.refuseClubInvite);
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.refuseSysInfo);
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.refuseTeamInvite);
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.refuseBattleInvite);
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.closeBarrage);
                return writer;
            };

            /**
             * Encodes the specified SettingReq message, length delimited. Does not implicitly {@link luck.protobuf.SettingReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.SettingReq
             * @static
             * @param {luck.protobuf.ISettingReq} message SettingReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SettingReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SettingReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.SettingReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.SettingReq} SettingReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SettingReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.SettingReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.telePhone = reader.string();
                        break;
                    case 2:
                        message.email = reader.string();
                        break;
                    case 3:
                        message.isCheckName = reader.int32();
                        break;
                    case 4:
                        message.refuseFriendReq = reader.int32();
                        break;
                    case 5:
                        message.refuseStrangerNews = reader.int32();
                        break;
                    case 6:
                        message.refuseClubInvite = reader.int32();
                        break;
                    case 7:
                        message.refuseSysInfo = reader.int32();
                        break;
                    case 8:
                        message.refuseTeamInvite = reader.int32();
                        break;
                    case 9:
                        message.refuseBattleInvite = reader.int32();
                        break;
                    case 10:
                        message.closeBarrage = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("isCheckName"))
                    throw $util.ProtocolError("missing required 'isCheckName'", { instance: message });
                if (!message.hasOwnProperty("refuseFriendReq"))
                    throw $util.ProtocolError("missing required 'refuseFriendReq'", { instance: message });
                if (!message.hasOwnProperty("refuseStrangerNews"))
                    throw $util.ProtocolError("missing required 'refuseStrangerNews'", { instance: message });
                if (!message.hasOwnProperty("refuseClubInvite"))
                    throw $util.ProtocolError("missing required 'refuseClubInvite'", { instance: message });
                if (!message.hasOwnProperty("refuseSysInfo"))
                    throw $util.ProtocolError("missing required 'refuseSysInfo'", { instance: message });
                if (!message.hasOwnProperty("refuseTeamInvite"))
                    throw $util.ProtocolError("missing required 'refuseTeamInvite'", { instance: message });
                if (!message.hasOwnProperty("refuseBattleInvite"))
                    throw $util.ProtocolError("missing required 'refuseBattleInvite'", { instance: message });
                if (!message.hasOwnProperty("closeBarrage"))
                    throw $util.ProtocolError("missing required 'closeBarrage'", { instance: message });
                return message;
            };

            /**
             * Decodes a SettingReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.SettingReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.SettingReq} SettingReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SettingReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SettingReq message.
             * @function verify
             * @memberof luck.protobuf.SettingReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SettingReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.telePhone != null && message.hasOwnProperty("telePhone"))
                    if (!$util.isString(message.telePhone))
                        return "telePhone: string expected";
                if (message.email != null && message.hasOwnProperty("email"))
                    if (!$util.isString(message.email))
                        return "email: string expected";
                if (!$util.isInteger(message.isCheckName))
                    return "isCheckName: integer expected";
                if (!$util.isInteger(message.refuseFriendReq))
                    return "refuseFriendReq: integer expected";
                if (!$util.isInteger(message.refuseStrangerNews))
                    return "refuseStrangerNews: integer expected";
                if (!$util.isInteger(message.refuseClubInvite))
                    return "refuseClubInvite: integer expected";
                if (!$util.isInteger(message.refuseSysInfo))
                    return "refuseSysInfo: integer expected";
                if (!$util.isInteger(message.refuseTeamInvite))
                    return "refuseTeamInvite: integer expected";
                if (!$util.isInteger(message.refuseBattleInvite))
                    return "refuseBattleInvite: integer expected";
                if (!$util.isInteger(message.closeBarrage))
                    return "closeBarrage: integer expected";
                return null;
            };

            return SettingReq;
        })();

        protobuf.EquipRecastReq = (function() {

            /**
             * Properties of an EquipRecastReq.
             * @memberof luck.protobuf
             * @interface IEquipRecastReq
             * @property {number} equipType EquipRecastReq equipType
             * @property {number|Long} equipUid EquipRecastReq equipUid
             */

            /**
             * Constructs a new EquipRecastReq.
             * @memberof luck.protobuf
             * @classdesc Represents an EquipRecastReq.
             * @implements IEquipRecastReq
             * @constructor
             * @param {luck.protobuf.IEquipRecastReq=} [properties] Properties to set
             */
            function EquipRecastReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EquipRecastReq equipType.
             * @member {number} equipType
             * @memberof luck.protobuf.EquipRecastReq
             * @instance
             */
            EquipRecastReq.prototype.equipType = 0;

            /**
             * EquipRecastReq equipUid.
             * @member {number|Long} equipUid
             * @memberof luck.protobuf.EquipRecastReq
             * @instance
             */
            EquipRecastReq.prototype.equipUid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new EquipRecastReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.EquipRecastReq
             * @static
             * @param {luck.protobuf.IEquipRecastReq=} [properties] Properties to set
             * @returns {luck.protobuf.EquipRecastReq} EquipRecastReq instance
             */
            EquipRecastReq.create = function create(properties) {
                return new EquipRecastReq(properties);
            };

            /**
             * Encodes the specified EquipRecastReq message. Does not implicitly {@link luck.protobuf.EquipRecastReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.EquipRecastReq
             * @static
             * @param {luck.protobuf.IEquipRecastReq} message EquipRecastReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EquipRecastReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.equipType);
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.equipUid);
                return writer;
            };

            /**
             * Encodes the specified EquipRecastReq message, length delimited. Does not implicitly {@link luck.protobuf.EquipRecastReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.EquipRecastReq
             * @static
             * @param {luck.protobuf.IEquipRecastReq} message EquipRecastReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EquipRecastReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EquipRecastReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.EquipRecastReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.EquipRecastReq} EquipRecastReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EquipRecastReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.EquipRecastReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.equipType = reader.int32();
                        break;
                    case 2:
                        message.equipUid = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("equipType"))
                    throw $util.ProtocolError("missing required 'equipType'", { instance: message });
                if (!message.hasOwnProperty("equipUid"))
                    throw $util.ProtocolError("missing required 'equipUid'", { instance: message });
                return message;
            };

            /**
             * Decodes an EquipRecastReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.EquipRecastReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.EquipRecastReq} EquipRecastReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EquipRecastReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EquipRecastReq message.
             * @function verify
             * @memberof luck.protobuf.EquipRecastReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EquipRecastReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.equipType))
                    return "equipType: integer expected";
                if (!$util.isInteger(message.equipUid) && !(message.equipUid && $util.isInteger(message.equipUid.low) && $util.isInteger(message.equipUid.high)))
                    return "equipUid: integer|Long expected";
                return null;
            };

            return EquipRecastReq;
        })();

        protobuf.EquipRecastAffirmReq = (function() {

            /**
             * Properties of an EquipRecastAffirmReq.
             * @memberof luck.protobuf
             * @interface IEquipRecastAffirmReq
             * @property {boolean} isRemould EquipRecastAffirmReq isRemould
             * @property {number} equipType EquipRecastAffirmReq equipType
             * @property {number|Long} equipUid EquipRecastAffirmReq equipUid
             */

            /**
             * Constructs a new EquipRecastAffirmReq.
             * @memberof luck.protobuf
             * @classdesc Represents an EquipRecastAffirmReq.
             * @implements IEquipRecastAffirmReq
             * @constructor
             * @param {luck.protobuf.IEquipRecastAffirmReq=} [properties] Properties to set
             */
            function EquipRecastAffirmReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EquipRecastAffirmReq isRemould.
             * @member {boolean} isRemould
             * @memberof luck.protobuf.EquipRecastAffirmReq
             * @instance
             */
            EquipRecastAffirmReq.prototype.isRemould = false;

            /**
             * EquipRecastAffirmReq equipType.
             * @member {number} equipType
             * @memberof luck.protobuf.EquipRecastAffirmReq
             * @instance
             */
            EquipRecastAffirmReq.prototype.equipType = 0;

            /**
             * EquipRecastAffirmReq equipUid.
             * @member {number|Long} equipUid
             * @memberof luck.protobuf.EquipRecastAffirmReq
             * @instance
             */
            EquipRecastAffirmReq.prototype.equipUid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new EquipRecastAffirmReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.EquipRecastAffirmReq
             * @static
             * @param {luck.protobuf.IEquipRecastAffirmReq=} [properties] Properties to set
             * @returns {luck.protobuf.EquipRecastAffirmReq} EquipRecastAffirmReq instance
             */
            EquipRecastAffirmReq.create = function create(properties) {
                return new EquipRecastAffirmReq(properties);
            };

            /**
             * Encodes the specified EquipRecastAffirmReq message. Does not implicitly {@link luck.protobuf.EquipRecastAffirmReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.EquipRecastAffirmReq
             * @static
             * @param {luck.protobuf.IEquipRecastAffirmReq} message EquipRecastAffirmReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EquipRecastAffirmReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isRemould);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.equipType);
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.equipUid);
                return writer;
            };

            /**
             * Encodes the specified EquipRecastAffirmReq message, length delimited. Does not implicitly {@link luck.protobuf.EquipRecastAffirmReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.EquipRecastAffirmReq
             * @static
             * @param {luck.protobuf.IEquipRecastAffirmReq} message EquipRecastAffirmReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EquipRecastAffirmReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EquipRecastAffirmReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.EquipRecastAffirmReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.EquipRecastAffirmReq} EquipRecastAffirmReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EquipRecastAffirmReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.EquipRecastAffirmReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.isRemould = reader.bool();
                        break;
                    case 2:
                        message.equipType = reader.int32();
                        break;
                    case 3:
                        message.equipUid = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("isRemould"))
                    throw $util.ProtocolError("missing required 'isRemould'", { instance: message });
                if (!message.hasOwnProperty("equipType"))
                    throw $util.ProtocolError("missing required 'equipType'", { instance: message });
                if (!message.hasOwnProperty("equipUid"))
                    throw $util.ProtocolError("missing required 'equipUid'", { instance: message });
                return message;
            };

            /**
             * Decodes an EquipRecastAffirmReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.EquipRecastAffirmReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.EquipRecastAffirmReq} EquipRecastAffirmReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EquipRecastAffirmReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EquipRecastAffirmReq message.
             * @function verify
             * @memberof luck.protobuf.EquipRecastAffirmReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EquipRecastAffirmReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (typeof message.isRemould !== "boolean")
                    return "isRemould: boolean expected";
                if (!$util.isInteger(message.equipType))
                    return "equipType: integer expected";
                if (!$util.isInteger(message.equipUid) && !(message.equipUid && $util.isInteger(message.equipUid.low) && $util.isInteger(message.equipUid.high)))
                    return "equipUid: integer|Long expected";
                return null;
            };

            return EquipRecastAffirmReq;
        })();

        protobuf.GetEmailListReq = (function() {

            /**
             * Properties of a GetEmailListReq.
             * @memberof luck.protobuf
             * @interface IGetEmailListReq
             */

            /**
             * Constructs a new GetEmailListReq.
             * @memberof luck.protobuf
             * @classdesc Represents a GetEmailListReq.
             * @implements IGetEmailListReq
             * @constructor
             * @param {luck.protobuf.IGetEmailListReq=} [properties] Properties to set
             */
            function GetEmailListReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new GetEmailListReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.GetEmailListReq
             * @static
             * @param {luck.protobuf.IGetEmailListReq=} [properties] Properties to set
             * @returns {luck.protobuf.GetEmailListReq} GetEmailListReq instance
             */
            GetEmailListReq.create = function create(properties) {
                return new GetEmailListReq(properties);
            };

            /**
             * Encodes the specified GetEmailListReq message. Does not implicitly {@link luck.protobuf.GetEmailListReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.GetEmailListReq
             * @static
             * @param {luck.protobuf.IGetEmailListReq} message GetEmailListReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetEmailListReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified GetEmailListReq message, length delimited. Does not implicitly {@link luck.protobuf.GetEmailListReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.GetEmailListReq
             * @static
             * @param {luck.protobuf.IGetEmailListReq} message GetEmailListReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetEmailListReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetEmailListReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.GetEmailListReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.GetEmailListReq} GetEmailListReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetEmailListReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.GetEmailListReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetEmailListReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.GetEmailListReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.GetEmailListReq} GetEmailListReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetEmailListReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetEmailListReq message.
             * @function verify
             * @memberof luck.protobuf.GetEmailListReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetEmailListReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            return GetEmailListReq;
        })();

        protobuf.EquipUpgradeReq = (function() {

            /**
             * Properties of an EquipUpgradeReq.
             * @memberof luck.protobuf
             * @interface IEquipUpgradeReq
             * @property {number} equipType EquipUpgradeReq equipType
             * @property {number|Long} equipUid EquipUpgradeReq equipUid
             * @property {Array.<luck.protobuf.IMaterialsPB>|null} [materialsList] EquipUpgradeReq materialsList
             */

            /**
             * Constructs a new EquipUpgradeReq.
             * @memberof luck.protobuf
             * @classdesc Represents an EquipUpgradeReq.
             * @implements IEquipUpgradeReq
             * @constructor
             * @param {luck.protobuf.IEquipUpgradeReq=} [properties] Properties to set
             */
            function EquipUpgradeReq(properties) {
                this.materialsList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EquipUpgradeReq equipType.
             * @member {number} equipType
             * @memberof luck.protobuf.EquipUpgradeReq
             * @instance
             */
            EquipUpgradeReq.prototype.equipType = 0;

            /**
             * EquipUpgradeReq equipUid.
             * @member {number|Long} equipUid
             * @memberof luck.protobuf.EquipUpgradeReq
             * @instance
             */
            EquipUpgradeReq.prototype.equipUid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * EquipUpgradeReq materialsList.
             * @member {Array.<luck.protobuf.IMaterialsPB>} materialsList
             * @memberof luck.protobuf.EquipUpgradeReq
             * @instance
             */
            EquipUpgradeReq.prototype.materialsList = $util.emptyArray;

            /**
             * Creates a new EquipUpgradeReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.EquipUpgradeReq
             * @static
             * @param {luck.protobuf.IEquipUpgradeReq=} [properties] Properties to set
             * @returns {luck.protobuf.EquipUpgradeReq} EquipUpgradeReq instance
             */
            EquipUpgradeReq.create = function create(properties) {
                return new EquipUpgradeReq(properties);
            };

            /**
             * Encodes the specified EquipUpgradeReq message. Does not implicitly {@link luck.protobuf.EquipUpgradeReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.EquipUpgradeReq
             * @static
             * @param {luck.protobuf.IEquipUpgradeReq} message EquipUpgradeReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EquipUpgradeReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.equipType);
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.equipUid);
                if (message.materialsList != null && message.materialsList.length)
                    for (var i = 0; i < message.materialsList.length; ++i)
                        $root.luck.protobuf.MaterialsPB.encode(message.materialsList[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EquipUpgradeReq message, length delimited. Does not implicitly {@link luck.protobuf.EquipUpgradeReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.EquipUpgradeReq
             * @static
             * @param {luck.protobuf.IEquipUpgradeReq} message EquipUpgradeReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EquipUpgradeReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EquipUpgradeReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.EquipUpgradeReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.EquipUpgradeReq} EquipUpgradeReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EquipUpgradeReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.EquipUpgradeReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.equipType = reader.int32();
                        break;
                    case 2:
                        message.equipUid = reader.int64();
                        break;
                    case 3:
                        if (!(message.materialsList && message.materialsList.length))
                            message.materialsList = [];
                        message.materialsList.push($root.luck.protobuf.MaterialsPB.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("equipType"))
                    throw $util.ProtocolError("missing required 'equipType'", { instance: message });
                if (!message.hasOwnProperty("equipUid"))
                    throw $util.ProtocolError("missing required 'equipUid'", { instance: message });
                return message;
            };

            /**
             * Decodes an EquipUpgradeReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.EquipUpgradeReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.EquipUpgradeReq} EquipUpgradeReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EquipUpgradeReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EquipUpgradeReq message.
             * @function verify
             * @memberof luck.protobuf.EquipUpgradeReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EquipUpgradeReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.equipType))
                    return "equipType: integer expected";
                if (!$util.isInteger(message.equipUid) && !(message.equipUid && $util.isInteger(message.equipUid.low) && $util.isInteger(message.equipUid.high)))
                    return "equipUid: integer|Long expected";
                if (message.materialsList != null && message.hasOwnProperty("materialsList")) {
                    if (!Array.isArray(message.materialsList))
                        return "materialsList: array expected";
                    for (var i = 0; i < message.materialsList.length; ++i) {
                        var error = $root.luck.protobuf.MaterialsPB.verify(message.materialsList[i]);
                        if (error)
                            return "materialsList." + error;
                    }
                }
                return null;
            };

            return EquipUpgradeReq;
        })();

        protobuf.EmailDrawReq = (function() {

            /**
             * Properties of an EmailDrawReq.
             * @memberof luck.protobuf
             * @interface IEmailDrawReq
             * @property {number|Long} uid EmailDrawReq uid
             */

            /**
             * Constructs a new EmailDrawReq.
             * @memberof luck.protobuf
             * @classdesc Represents an EmailDrawReq.
             * @implements IEmailDrawReq
             * @constructor
             * @param {luck.protobuf.IEmailDrawReq=} [properties] Properties to set
             */
            function EmailDrawReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EmailDrawReq uid.
             * @member {number|Long} uid
             * @memberof luck.protobuf.EmailDrawReq
             * @instance
             */
            EmailDrawReq.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new EmailDrawReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.EmailDrawReq
             * @static
             * @param {luck.protobuf.IEmailDrawReq=} [properties] Properties to set
             * @returns {luck.protobuf.EmailDrawReq} EmailDrawReq instance
             */
            EmailDrawReq.create = function create(properties) {
                return new EmailDrawReq(properties);
            };

            /**
             * Encodes the specified EmailDrawReq message. Does not implicitly {@link luck.protobuf.EmailDrawReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.EmailDrawReq
             * @static
             * @param {luck.protobuf.IEmailDrawReq} message EmailDrawReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EmailDrawReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.uid);
                return writer;
            };

            /**
             * Encodes the specified EmailDrawReq message, length delimited. Does not implicitly {@link luck.protobuf.EmailDrawReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.EmailDrawReq
             * @static
             * @param {luck.protobuf.IEmailDrawReq} message EmailDrawReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EmailDrawReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EmailDrawReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.EmailDrawReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.EmailDrawReq} EmailDrawReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EmailDrawReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.EmailDrawReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.uid = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("uid"))
                    throw $util.ProtocolError("missing required 'uid'", { instance: message });
                return message;
            };

            /**
             * Decodes an EmailDrawReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.EmailDrawReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.EmailDrawReq} EmailDrawReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EmailDrawReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EmailDrawReq message.
             * @function verify
             * @memberof luck.protobuf.EmailDrawReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EmailDrawReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
                return null;
            };

            return EmailDrawReq;
        })();

        protobuf.DrawAllEmailReq = (function() {

            /**
             * Properties of a DrawAllEmailReq.
             * @memberof luck.protobuf
             * @interface IDrawAllEmailReq
             */

            /**
             * Constructs a new DrawAllEmailReq.
             * @memberof luck.protobuf
             * @classdesc Represents a DrawAllEmailReq.
             * @implements IDrawAllEmailReq
             * @constructor
             * @param {luck.protobuf.IDrawAllEmailReq=} [properties] Properties to set
             */
            function DrawAllEmailReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new DrawAllEmailReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.DrawAllEmailReq
             * @static
             * @param {luck.protobuf.IDrawAllEmailReq=} [properties] Properties to set
             * @returns {luck.protobuf.DrawAllEmailReq} DrawAllEmailReq instance
             */
            DrawAllEmailReq.create = function create(properties) {
                return new DrawAllEmailReq(properties);
            };

            /**
             * Encodes the specified DrawAllEmailReq message. Does not implicitly {@link luck.protobuf.DrawAllEmailReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.DrawAllEmailReq
             * @static
             * @param {luck.protobuf.IDrawAllEmailReq} message DrawAllEmailReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DrawAllEmailReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified DrawAllEmailReq message, length delimited. Does not implicitly {@link luck.protobuf.DrawAllEmailReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.DrawAllEmailReq
             * @static
             * @param {luck.protobuf.IDrawAllEmailReq} message DrawAllEmailReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DrawAllEmailReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DrawAllEmailReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.DrawAllEmailReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.DrawAllEmailReq} DrawAllEmailReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DrawAllEmailReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.DrawAllEmailReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DrawAllEmailReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.DrawAllEmailReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.DrawAllEmailReq} DrawAllEmailReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DrawAllEmailReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DrawAllEmailReq message.
             * @function verify
             * @memberof luck.protobuf.DrawAllEmailReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DrawAllEmailReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            return DrawAllEmailReq;
        })();

        protobuf.EmailDelReq = (function() {

            /**
             * Properties of an EmailDelReq.
             * @memberof luck.protobuf
             * @interface IEmailDelReq
             * @property {number|Long} uid EmailDelReq uid
             */

            /**
             * Constructs a new EmailDelReq.
             * @memberof luck.protobuf
             * @classdesc Represents an EmailDelReq.
             * @implements IEmailDelReq
             * @constructor
             * @param {luck.protobuf.IEmailDelReq=} [properties] Properties to set
             */
            function EmailDelReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EmailDelReq uid.
             * @member {number|Long} uid
             * @memberof luck.protobuf.EmailDelReq
             * @instance
             */
            EmailDelReq.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new EmailDelReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.EmailDelReq
             * @static
             * @param {luck.protobuf.IEmailDelReq=} [properties] Properties to set
             * @returns {luck.protobuf.EmailDelReq} EmailDelReq instance
             */
            EmailDelReq.create = function create(properties) {
                return new EmailDelReq(properties);
            };

            /**
             * Encodes the specified EmailDelReq message. Does not implicitly {@link luck.protobuf.EmailDelReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.EmailDelReq
             * @static
             * @param {luck.protobuf.IEmailDelReq} message EmailDelReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EmailDelReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.uid);
                return writer;
            };

            /**
             * Encodes the specified EmailDelReq message, length delimited. Does not implicitly {@link luck.protobuf.EmailDelReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.EmailDelReq
             * @static
             * @param {luck.protobuf.IEmailDelReq} message EmailDelReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EmailDelReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EmailDelReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.EmailDelReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.EmailDelReq} EmailDelReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EmailDelReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.EmailDelReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.uid = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("uid"))
                    throw $util.ProtocolError("missing required 'uid'", { instance: message });
                return message;
            };

            /**
             * Decodes an EmailDelReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.EmailDelReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.EmailDelReq} EmailDelReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EmailDelReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EmailDelReq message.
             * @function verify
             * @memberof luck.protobuf.EmailDelReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EmailDelReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
                return null;
            };

            return EmailDelReq;
        })();

        protobuf.EquipBaptizeReq = (function() {

            /**
             * Properties of an EquipBaptizeReq.
             * @memberof luck.protobuf
             * @interface IEquipBaptizeReq
             * @property {number} equipType EquipBaptizeReq equipType
             * @property {number|Long} equipUid EquipBaptizeReq equipUid
             */

            /**
             * Constructs a new EquipBaptizeReq.
             * @memberof luck.protobuf
             * @classdesc Represents an EquipBaptizeReq.
             * @implements IEquipBaptizeReq
             * @constructor
             * @param {luck.protobuf.IEquipBaptizeReq=} [properties] Properties to set
             */
            function EquipBaptizeReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EquipBaptizeReq equipType.
             * @member {number} equipType
             * @memberof luck.protobuf.EquipBaptizeReq
             * @instance
             */
            EquipBaptizeReq.prototype.equipType = 0;

            /**
             * EquipBaptizeReq equipUid.
             * @member {number|Long} equipUid
             * @memberof luck.protobuf.EquipBaptizeReq
             * @instance
             */
            EquipBaptizeReq.prototype.equipUid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new EquipBaptizeReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.EquipBaptizeReq
             * @static
             * @param {luck.protobuf.IEquipBaptizeReq=} [properties] Properties to set
             * @returns {luck.protobuf.EquipBaptizeReq} EquipBaptizeReq instance
             */
            EquipBaptizeReq.create = function create(properties) {
                return new EquipBaptizeReq(properties);
            };

            /**
             * Encodes the specified EquipBaptizeReq message. Does not implicitly {@link luck.protobuf.EquipBaptizeReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.EquipBaptizeReq
             * @static
             * @param {luck.protobuf.IEquipBaptizeReq} message EquipBaptizeReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EquipBaptizeReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.equipType);
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.equipUid);
                return writer;
            };

            /**
             * Encodes the specified EquipBaptizeReq message, length delimited. Does not implicitly {@link luck.protobuf.EquipBaptizeReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.EquipBaptizeReq
             * @static
             * @param {luck.protobuf.IEquipBaptizeReq} message EquipBaptizeReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EquipBaptizeReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EquipBaptizeReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.EquipBaptizeReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.EquipBaptizeReq} EquipBaptizeReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EquipBaptizeReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.EquipBaptizeReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.equipType = reader.int32();
                        break;
                    case 2:
                        message.equipUid = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("equipType"))
                    throw $util.ProtocolError("missing required 'equipType'", { instance: message });
                if (!message.hasOwnProperty("equipUid"))
                    throw $util.ProtocolError("missing required 'equipUid'", { instance: message });
                return message;
            };

            /**
             * Decodes an EquipBaptizeReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.EquipBaptizeReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.EquipBaptizeReq} EquipBaptizeReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EquipBaptizeReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EquipBaptizeReq message.
             * @function verify
             * @memberof luck.protobuf.EquipBaptizeReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EquipBaptizeReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.equipType))
                    return "equipType: integer expected";
                if (!$util.isInteger(message.equipUid) && !(message.equipUid && $util.isInteger(message.equipUid.low) && $util.isInteger(message.equipUid.high)))
                    return "equipUid: integer|Long expected";
                return null;
            };

            return EquipBaptizeReq;
        })();

        protobuf.EquipBaptizeAffirmReq = (function() {

            /**
             * Properties of an EquipBaptizeAffirmReq.
             * @memberof luck.protobuf
             * @interface IEquipBaptizeAffirmReq
             * @property {boolean} isBaptize EquipBaptizeAffirmReq isBaptize
             * @property {number} equipType EquipBaptizeAffirmReq equipType
             * @property {number|Long} equipUid EquipBaptizeAffirmReq equipUid
             */

            /**
             * Constructs a new EquipBaptizeAffirmReq.
             * @memberof luck.protobuf
             * @classdesc Represents an EquipBaptizeAffirmReq.
             * @implements IEquipBaptizeAffirmReq
             * @constructor
             * @param {luck.protobuf.IEquipBaptizeAffirmReq=} [properties] Properties to set
             */
            function EquipBaptizeAffirmReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EquipBaptizeAffirmReq isBaptize.
             * @member {boolean} isBaptize
             * @memberof luck.protobuf.EquipBaptizeAffirmReq
             * @instance
             */
            EquipBaptizeAffirmReq.prototype.isBaptize = false;

            /**
             * EquipBaptizeAffirmReq equipType.
             * @member {number} equipType
             * @memberof luck.protobuf.EquipBaptizeAffirmReq
             * @instance
             */
            EquipBaptizeAffirmReq.prototype.equipType = 0;

            /**
             * EquipBaptizeAffirmReq equipUid.
             * @member {number|Long} equipUid
             * @memberof luck.protobuf.EquipBaptizeAffirmReq
             * @instance
             */
            EquipBaptizeAffirmReq.prototype.equipUid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new EquipBaptizeAffirmReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.EquipBaptizeAffirmReq
             * @static
             * @param {luck.protobuf.IEquipBaptizeAffirmReq=} [properties] Properties to set
             * @returns {luck.protobuf.EquipBaptizeAffirmReq} EquipBaptizeAffirmReq instance
             */
            EquipBaptizeAffirmReq.create = function create(properties) {
                return new EquipBaptizeAffirmReq(properties);
            };

            /**
             * Encodes the specified EquipBaptizeAffirmReq message. Does not implicitly {@link luck.protobuf.EquipBaptizeAffirmReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.EquipBaptizeAffirmReq
             * @static
             * @param {luck.protobuf.IEquipBaptizeAffirmReq} message EquipBaptizeAffirmReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EquipBaptizeAffirmReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isBaptize);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.equipType);
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.equipUid);
                return writer;
            };

            /**
             * Encodes the specified EquipBaptizeAffirmReq message, length delimited. Does not implicitly {@link luck.protobuf.EquipBaptizeAffirmReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.EquipBaptizeAffirmReq
             * @static
             * @param {luck.protobuf.IEquipBaptizeAffirmReq} message EquipBaptizeAffirmReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EquipBaptizeAffirmReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EquipBaptizeAffirmReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.EquipBaptizeAffirmReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.EquipBaptizeAffirmReq} EquipBaptizeAffirmReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EquipBaptizeAffirmReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.EquipBaptizeAffirmReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.isBaptize = reader.bool();
                        break;
                    case 2:
                        message.equipType = reader.int32();
                        break;
                    case 3:
                        message.equipUid = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("isBaptize"))
                    throw $util.ProtocolError("missing required 'isBaptize'", { instance: message });
                if (!message.hasOwnProperty("equipType"))
                    throw $util.ProtocolError("missing required 'equipType'", { instance: message });
                if (!message.hasOwnProperty("equipUid"))
                    throw $util.ProtocolError("missing required 'equipUid'", { instance: message });
                return message;
            };

            /**
             * Decodes an EquipBaptizeAffirmReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.EquipBaptizeAffirmReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.EquipBaptizeAffirmReq} EquipBaptizeAffirmReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EquipBaptizeAffirmReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EquipBaptizeAffirmReq message.
             * @function verify
             * @memberof luck.protobuf.EquipBaptizeAffirmReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EquipBaptizeAffirmReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (typeof message.isBaptize !== "boolean")
                    return "isBaptize: boolean expected";
                if (!$util.isInteger(message.equipType))
                    return "equipType: integer expected";
                if (!$util.isInteger(message.equipUid) && !(message.equipUid && $util.isInteger(message.equipUid.low) && $util.isInteger(message.equipUid.high)))
                    return "equipUid: integer|Long expected";
                return null;
            };

            return EquipBaptizeAffirmReq;
        })();

        protobuf.EquipInlayReq = (function() {

            /**
             * Properties of an EquipInlayReq.
             * @memberof luck.protobuf
             * @interface IEquipInlayReq
             * @property {number} equipType EquipInlayReq equipType
             * @property {number|Long} equipUid EquipInlayReq equipUid
             */

            /**
             * Constructs a new EquipInlayReq.
             * @memberof luck.protobuf
             * @classdesc Represents an EquipInlayReq.
             * @implements IEquipInlayReq
             * @constructor
             * @param {luck.protobuf.IEquipInlayReq=} [properties] Properties to set
             */
            function EquipInlayReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EquipInlayReq equipType.
             * @member {number} equipType
             * @memberof luck.protobuf.EquipInlayReq
             * @instance
             */
            EquipInlayReq.prototype.equipType = 0;

            /**
             * EquipInlayReq equipUid.
             * @member {number|Long} equipUid
             * @memberof luck.protobuf.EquipInlayReq
             * @instance
             */
            EquipInlayReq.prototype.equipUid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new EquipInlayReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.EquipInlayReq
             * @static
             * @param {luck.protobuf.IEquipInlayReq=} [properties] Properties to set
             * @returns {luck.protobuf.EquipInlayReq} EquipInlayReq instance
             */
            EquipInlayReq.create = function create(properties) {
                return new EquipInlayReq(properties);
            };

            /**
             * Encodes the specified EquipInlayReq message. Does not implicitly {@link luck.protobuf.EquipInlayReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.EquipInlayReq
             * @static
             * @param {luck.protobuf.IEquipInlayReq} message EquipInlayReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EquipInlayReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.equipType);
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.equipUid);
                return writer;
            };

            /**
             * Encodes the specified EquipInlayReq message, length delimited. Does not implicitly {@link luck.protobuf.EquipInlayReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.EquipInlayReq
             * @static
             * @param {luck.protobuf.IEquipInlayReq} message EquipInlayReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EquipInlayReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EquipInlayReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.EquipInlayReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.EquipInlayReq} EquipInlayReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EquipInlayReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.EquipInlayReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.equipType = reader.int32();
                        break;
                    case 2:
                        message.equipUid = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("equipType"))
                    throw $util.ProtocolError("missing required 'equipType'", { instance: message });
                if (!message.hasOwnProperty("equipUid"))
                    throw $util.ProtocolError("missing required 'equipUid'", { instance: message });
                return message;
            };

            /**
             * Decodes an EquipInlayReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.EquipInlayReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.EquipInlayReq} EquipInlayReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EquipInlayReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EquipInlayReq message.
             * @function verify
             * @memberof luck.protobuf.EquipInlayReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EquipInlayReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.equipType))
                    return "equipType: integer expected";
                if (!$util.isInteger(message.equipUid) && !(message.equipUid && $util.isInteger(message.equipUid.low) && $util.isInteger(message.equipUid.high)))
                    return "equipUid: integer|Long expected";
                return null;
            };

            return EquipInlayReq;
        })();

        protobuf.EquipInlayDismantleReq = (function() {

            /**
             * Properties of an EquipInlayDismantleReq.
             * @memberof luck.protobuf
             * @interface IEquipInlayDismantleReq
             * @property {number} equipType EquipInlayDismantleReq equipType
             * @property {number|Long} equipUid EquipInlayDismantleReq equipUid
             */

            /**
             * Constructs a new EquipInlayDismantleReq.
             * @memberof luck.protobuf
             * @classdesc Represents an EquipInlayDismantleReq.
             * @implements IEquipInlayDismantleReq
             * @constructor
             * @param {luck.protobuf.IEquipInlayDismantleReq=} [properties] Properties to set
             */
            function EquipInlayDismantleReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EquipInlayDismantleReq equipType.
             * @member {number} equipType
             * @memberof luck.protobuf.EquipInlayDismantleReq
             * @instance
             */
            EquipInlayDismantleReq.prototype.equipType = 0;

            /**
             * EquipInlayDismantleReq equipUid.
             * @member {number|Long} equipUid
             * @memberof luck.protobuf.EquipInlayDismantleReq
             * @instance
             */
            EquipInlayDismantleReq.prototype.equipUid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new EquipInlayDismantleReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.EquipInlayDismantleReq
             * @static
             * @param {luck.protobuf.IEquipInlayDismantleReq=} [properties] Properties to set
             * @returns {luck.protobuf.EquipInlayDismantleReq} EquipInlayDismantleReq instance
             */
            EquipInlayDismantleReq.create = function create(properties) {
                return new EquipInlayDismantleReq(properties);
            };

            /**
             * Encodes the specified EquipInlayDismantleReq message. Does not implicitly {@link luck.protobuf.EquipInlayDismantleReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.EquipInlayDismantleReq
             * @static
             * @param {luck.protobuf.IEquipInlayDismantleReq} message EquipInlayDismantleReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EquipInlayDismantleReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.equipType);
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.equipUid);
                return writer;
            };

            /**
             * Encodes the specified EquipInlayDismantleReq message, length delimited. Does not implicitly {@link luck.protobuf.EquipInlayDismantleReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.EquipInlayDismantleReq
             * @static
             * @param {luck.protobuf.IEquipInlayDismantleReq} message EquipInlayDismantleReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EquipInlayDismantleReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EquipInlayDismantleReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.EquipInlayDismantleReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.EquipInlayDismantleReq} EquipInlayDismantleReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EquipInlayDismantleReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.EquipInlayDismantleReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.equipType = reader.int32();
                        break;
                    case 2:
                        message.equipUid = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("equipType"))
                    throw $util.ProtocolError("missing required 'equipType'", { instance: message });
                if (!message.hasOwnProperty("equipUid"))
                    throw $util.ProtocolError("missing required 'equipUid'", { instance: message });
                return message;
            };

            /**
             * Decodes an EquipInlayDismantleReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.EquipInlayDismantleReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.EquipInlayDismantleReq} EquipInlayDismantleReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EquipInlayDismantleReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EquipInlayDismantleReq message.
             * @function verify
             * @memberof luck.protobuf.EquipInlayDismantleReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EquipInlayDismantleReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.equipType))
                    return "equipType: integer expected";
                if (!$util.isInteger(message.equipUid) && !(message.equipUid && $util.isInteger(message.equipUid.low) && $util.isInteger(message.equipUid.high)))
                    return "equipUid: integer|Long expected";
                return null;
            };

            return EquipInlayDismantleReq;
        })();

        protobuf.EquipAdvanceReq = (function() {

            /**
             * Properties of an EquipAdvanceReq.
             * @memberof luck.protobuf
             * @interface IEquipAdvanceReq
             * @property {number} equipType EquipAdvanceReq equipType
             * @property {number|Long} equipUid EquipAdvanceReq equipUid
             */

            /**
             * Constructs a new EquipAdvanceReq.
             * @memberof luck.protobuf
             * @classdesc Represents an EquipAdvanceReq.
             * @implements IEquipAdvanceReq
             * @constructor
             * @param {luck.protobuf.IEquipAdvanceReq=} [properties] Properties to set
             */
            function EquipAdvanceReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EquipAdvanceReq equipType.
             * @member {number} equipType
             * @memberof luck.protobuf.EquipAdvanceReq
             * @instance
             */
            EquipAdvanceReq.prototype.equipType = 0;

            /**
             * EquipAdvanceReq equipUid.
             * @member {number|Long} equipUid
             * @memberof luck.protobuf.EquipAdvanceReq
             * @instance
             */
            EquipAdvanceReq.prototype.equipUid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new EquipAdvanceReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.EquipAdvanceReq
             * @static
             * @param {luck.protobuf.IEquipAdvanceReq=} [properties] Properties to set
             * @returns {luck.protobuf.EquipAdvanceReq} EquipAdvanceReq instance
             */
            EquipAdvanceReq.create = function create(properties) {
                return new EquipAdvanceReq(properties);
            };

            /**
             * Encodes the specified EquipAdvanceReq message. Does not implicitly {@link luck.protobuf.EquipAdvanceReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.EquipAdvanceReq
             * @static
             * @param {luck.protobuf.IEquipAdvanceReq} message EquipAdvanceReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EquipAdvanceReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.equipType);
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.equipUid);
                return writer;
            };

            /**
             * Encodes the specified EquipAdvanceReq message, length delimited. Does not implicitly {@link luck.protobuf.EquipAdvanceReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.EquipAdvanceReq
             * @static
             * @param {luck.protobuf.IEquipAdvanceReq} message EquipAdvanceReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EquipAdvanceReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EquipAdvanceReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.EquipAdvanceReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.EquipAdvanceReq} EquipAdvanceReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EquipAdvanceReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.EquipAdvanceReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.equipType = reader.int32();
                        break;
                    case 2:
                        message.equipUid = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("equipType"))
                    throw $util.ProtocolError("missing required 'equipType'", { instance: message });
                if (!message.hasOwnProperty("equipUid"))
                    throw $util.ProtocolError("missing required 'equipUid'", { instance: message });
                return message;
            };

            /**
             * Decodes an EquipAdvanceReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.EquipAdvanceReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.EquipAdvanceReq} EquipAdvanceReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EquipAdvanceReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EquipAdvanceReq message.
             * @function verify
             * @memberof luck.protobuf.EquipAdvanceReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EquipAdvanceReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.equipType))
                    return "equipType: integer expected";
                if (!$util.isInteger(message.equipUid) && !(message.equipUid && $util.isInteger(message.equipUid.low) && $util.isInteger(message.equipUid.high)))
                    return "equipUid: integer|Long expected";
                return null;
            };

            return EquipAdvanceReq;
        })();

        protobuf.RoleUnlockReq = (function() {

            /**
             * Properties of a RoleUnlockReq.
             * @memberof luck.protobuf
             * @interface IRoleUnlockReq
             * @property {number} roleId RoleUnlockReq roleId
             */

            /**
             * Constructs a new RoleUnlockReq.
             * @memberof luck.protobuf
             * @classdesc Represents a RoleUnlockReq.
             * @implements IRoleUnlockReq
             * @constructor
             * @param {luck.protobuf.IRoleUnlockReq=} [properties] Properties to set
             */
            function RoleUnlockReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RoleUnlockReq roleId.
             * @member {number} roleId
             * @memberof luck.protobuf.RoleUnlockReq
             * @instance
             */
            RoleUnlockReq.prototype.roleId = 0;

            /**
             * Creates a new RoleUnlockReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.RoleUnlockReq
             * @static
             * @param {luck.protobuf.IRoleUnlockReq=} [properties] Properties to set
             * @returns {luck.protobuf.RoleUnlockReq} RoleUnlockReq instance
             */
            RoleUnlockReq.create = function create(properties) {
                return new RoleUnlockReq(properties);
            };

            /**
             * Encodes the specified RoleUnlockReq message. Does not implicitly {@link luck.protobuf.RoleUnlockReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.RoleUnlockReq
             * @static
             * @param {luck.protobuf.IRoleUnlockReq} message RoleUnlockReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RoleUnlockReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.roleId);
                return writer;
            };

            /**
             * Encodes the specified RoleUnlockReq message, length delimited. Does not implicitly {@link luck.protobuf.RoleUnlockReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.RoleUnlockReq
             * @static
             * @param {luck.protobuf.IRoleUnlockReq} message RoleUnlockReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RoleUnlockReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RoleUnlockReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.RoleUnlockReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.RoleUnlockReq} RoleUnlockReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RoleUnlockReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.RoleUnlockReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.roleId = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("roleId"))
                    throw $util.ProtocolError("missing required 'roleId'", { instance: message });
                return message;
            };

            /**
             * Decodes a RoleUnlockReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.RoleUnlockReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.RoleUnlockReq} RoleUnlockReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RoleUnlockReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RoleUnlockReq message.
             * @function verify
             * @memberof luck.protobuf.RoleUnlockReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RoleUnlockReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.roleId))
                    return "roleId: integer expected";
                return null;
            };

            return RoleUnlockReq;
        })();

        protobuf.RoleChangeReq = (function() {

            /**
             * Properties of a RoleChangeReq.
             * @memberof luck.protobuf
             * @interface IRoleChangeReq
             * @property {number} roleId RoleChangeReq roleId
             */

            /**
             * Constructs a new RoleChangeReq.
             * @memberof luck.protobuf
             * @classdesc Represents a RoleChangeReq.
             * @implements IRoleChangeReq
             * @constructor
             * @param {luck.protobuf.IRoleChangeReq=} [properties] Properties to set
             */
            function RoleChangeReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RoleChangeReq roleId.
             * @member {number} roleId
             * @memberof luck.protobuf.RoleChangeReq
             * @instance
             */
            RoleChangeReq.prototype.roleId = 0;

            /**
             * Creates a new RoleChangeReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.RoleChangeReq
             * @static
             * @param {luck.protobuf.IRoleChangeReq=} [properties] Properties to set
             * @returns {luck.protobuf.RoleChangeReq} RoleChangeReq instance
             */
            RoleChangeReq.create = function create(properties) {
                return new RoleChangeReq(properties);
            };

            /**
             * Encodes the specified RoleChangeReq message. Does not implicitly {@link luck.protobuf.RoleChangeReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.RoleChangeReq
             * @static
             * @param {luck.protobuf.IRoleChangeReq} message RoleChangeReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RoleChangeReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.roleId);
                return writer;
            };

            /**
             * Encodes the specified RoleChangeReq message, length delimited. Does not implicitly {@link luck.protobuf.RoleChangeReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.RoleChangeReq
             * @static
             * @param {luck.protobuf.IRoleChangeReq} message RoleChangeReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RoleChangeReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RoleChangeReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.RoleChangeReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.RoleChangeReq} RoleChangeReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RoleChangeReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.RoleChangeReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.roleId = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("roleId"))
                    throw $util.ProtocolError("missing required 'roleId'", { instance: message });
                return message;
            };

            /**
             * Decodes a RoleChangeReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.RoleChangeReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.RoleChangeReq} RoleChangeReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RoleChangeReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RoleChangeReq message.
             * @function verify
             * @memberof luck.protobuf.RoleChangeReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RoleChangeReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.roleId))
                    return "roleId: integer expected";
                return null;
            };

            return RoleChangeReq;
        })();

        protobuf.StaminaBuyReq = (function() {

            /**
             * Properties of a StaminaBuyReq.
             * @memberof luck.protobuf
             * @interface IStaminaBuyReq
             * @property {number} num StaminaBuyReq num
             */

            /**
             * Constructs a new StaminaBuyReq.
             * @memberof luck.protobuf
             * @classdesc Represents a StaminaBuyReq.
             * @implements IStaminaBuyReq
             * @constructor
             * @param {luck.protobuf.IStaminaBuyReq=} [properties] Properties to set
             */
            function StaminaBuyReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StaminaBuyReq num.
             * @member {number} num
             * @memberof luck.protobuf.StaminaBuyReq
             * @instance
             */
            StaminaBuyReq.prototype.num = 0;

            /**
             * Creates a new StaminaBuyReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.StaminaBuyReq
             * @static
             * @param {luck.protobuf.IStaminaBuyReq=} [properties] Properties to set
             * @returns {luck.protobuf.StaminaBuyReq} StaminaBuyReq instance
             */
            StaminaBuyReq.create = function create(properties) {
                return new StaminaBuyReq(properties);
            };

            /**
             * Encodes the specified StaminaBuyReq message. Does not implicitly {@link luck.protobuf.StaminaBuyReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.StaminaBuyReq
             * @static
             * @param {luck.protobuf.IStaminaBuyReq} message StaminaBuyReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StaminaBuyReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.num);
                return writer;
            };

            /**
             * Encodes the specified StaminaBuyReq message, length delimited. Does not implicitly {@link luck.protobuf.StaminaBuyReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.StaminaBuyReq
             * @static
             * @param {luck.protobuf.IStaminaBuyReq} message StaminaBuyReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StaminaBuyReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StaminaBuyReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.StaminaBuyReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.StaminaBuyReq} StaminaBuyReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StaminaBuyReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.StaminaBuyReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.num = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("num"))
                    throw $util.ProtocolError("missing required 'num'", { instance: message });
                return message;
            };

            /**
             * Decodes a StaminaBuyReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.StaminaBuyReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.StaminaBuyReq} StaminaBuyReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StaminaBuyReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StaminaBuyReq message.
             * @function verify
             * @memberof luck.protobuf.StaminaBuyReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StaminaBuyReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.num))
                    return "num: integer expected";
                return null;
            };

            return StaminaBuyReq;
        })();

        protobuf.RecommendFriendsReq = (function() {

            /**
             * Properties of a RecommendFriendsReq.
             * @memberof luck.protobuf
             * @interface IRecommendFriendsReq
             */

            /**
             * Constructs a new RecommendFriendsReq.
             * @memberof luck.protobuf
             * @classdesc Represents a RecommendFriendsReq.
             * @implements IRecommendFriendsReq
             * @constructor
             * @param {luck.protobuf.IRecommendFriendsReq=} [properties] Properties to set
             */
            function RecommendFriendsReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new RecommendFriendsReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.RecommendFriendsReq
             * @static
             * @param {luck.protobuf.IRecommendFriendsReq=} [properties] Properties to set
             * @returns {luck.protobuf.RecommendFriendsReq} RecommendFriendsReq instance
             */
            RecommendFriendsReq.create = function create(properties) {
                return new RecommendFriendsReq(properties);
            };

            /**
             * Encodes the specified RecommendFriendsReq message. Does not implicitly {@link luck.protobuf.RecommendFriendsReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.RecommendFriendsReq
             * @static
             * @param {luck.protobuf.IRecommendFriendsReq} message RecommendFriendsReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RecommendFriendsReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified RecommendFriendsReq message, length delimited. Does not implicitly {@link luck.protobuf.RecommendFriendsReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.RecommendFriendsReq
             * @static
             * @param {luck.protobuf.IRecommendFriendsReq} message RecommendFriendsReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RecommendFriendsReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RecommendFriendsReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.RecommendFriendsReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.RecommendFriendsReq} RecommendFriendsReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RecommendFriendsReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.RecommendFriendsReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RecommendFriendsReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.RecommendFriendsReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.RecommendFriendsReq} RecommendFriendsReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RecommendFriendsReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RecommendFriendsReq message.
             * @function verify
             * @memberof luck.protobuf.RecommendFriendsReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RecommendFriendsReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            return RecommendFriendsReq;
        })();

        protobuf.SearchFriendsReq = (function() {

            /**
             * Properties of a SearchFriendsReq.
             * @memberof luck.protobuf
             * @interface ISearchFriendsReq
             * @property {string} search SearchFriendsReq search
             */

            /**
             * Constructs a new SearchFriendsReq.
             * @memberof luck.protobuf
             * @classdesc Represents a SearchFriendsReq.
             * @implements ISearchFriendsReq
             * @constructor
             * @param {luck.protobuf.ISearchFriendsReq=} [properties] Properties to set
             */
            function SearchFriendsReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SearchFriendsReq search.
             * @member {string} search
             * @memberof luck.protobuf.SearchFriendsReq
             * @instance
             */
            SearchFriendsReq.prototype.search = "";

            /**
             * Creates a new SearchFriendsReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.SearchFriendsReq
             * @static
             * @param {luck.protobuf.ISearchFriendsReq=} [properties] Properties to set
             * @returns {luck.protobuf.SearchFriendsReq} SearchFriendsReq instance
             */
            SearchFriendsReq.create = function create(properties) {
                return new SearchFriendsReq(properties);
            };

            /**
             * Encodes the specified SearchFriendsReq message. Does not implicitly {@link luck.protobuf.SearchFriendsReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.SearchFriendsReq
             * @static
             * @param {luck.protobuf.ISearchFriendsReq} message SearchFriendsReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SearchFriendsReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.search);
                return writer;
            };

            /**
             * Encodes the specified SearchFriendsReq message, length delimited. Does not implicitly {@link luck.protobuf.SearchFriendsReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.SearchFriendsReq
             * @static
             * @param {luck.protobuf.ISearchFriendsReq} message SearchFriendsReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SearchFriendsReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SearchFriendsReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.SearchFriendsReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.SearchFriendsReq} SearchFriendsReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SearchFriendsReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.SearchFriendsReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.search = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("search"))
                    throw $util.ProtocolError("missing required 'search'", { instance: message });
                return message;
            };

            /**
             * Decodes a SearchFriendsReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.SearchFriendsReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.SearchFriendsReq} SearchFriendsReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SearchFriendsReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SearchFriendsReq message.
             * @function verify
             * @memberof luck.protobuf.SearchFriendsReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SearchFriendsReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.search))
                    return "search: string expected";
                return null;
            };

            return SearchFriendsReq;
        })();

        protobuf.ShopBuyReq = (function() {

            /**
             * Properties of a ShopBuyReq.
             * @memberof luck.protobuf
             * @interface IShopBuyReq
             * @property {number} num ShopBuyReq num
             * @property {number} goodsId ShopBuyReq goodsId
             */

            /**
             * Constructs a new ShopBuyReq.
             * @memberof luck.protobuf
             * @classdesc Represents a ShopBuyReq.
             * @implements IShopBuyReq
             * @constructor
             * @param {luck.protobuf.IShopBuyReq=} [properties] Properties to set
             */
            function ShopBuyReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ShopBuyReq num.
             * @member {number} num
             * @memberof luck.protobuf.ShopBuyReq
             * @instance
             */
            ShopBuyReq.prototype.num = 0;

            /**
             * ShopBuyReq goodsId.
             * @member {number} goodsId
             * @memberof luck.protobuf.ShopBuyReq
             * @instance
             */
            ShopBuyReq.prototype.goodsId = 0;

            /**
             * Creates a new ShopBuyReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.ShopBuyReq
             * @static
             * @param {luck.protobuf.IShopBuyReq=} [properties] Properties to set
             * @returns {luck.protobuf.ShopBuyReq} ShopBuyReq instance
             */
            ShopBuyReq.create = function create(properties) {
                return new ShopBuyReq(properties);
            };

            /**
             * Encodes the specified ShopBuyReq message. Does not implicitly {@link luck.protobuf.ShopBuyReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.ShopBuyReq
             * @static
             * @param {luck.protobuf.IShopBuyReq} message ShopBuyReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ShopBuyReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.num);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.goodsId);
                return writer;
            };

            /**
             * Encodes the specified ShopBuyReq message, length delimited. Does not implicitly {@link luck.protobuf.ShopBuyReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.ShopBuyReq
             * @static
             * @param {luck.protobuf.IShopBuyReq} message ShopBuyReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ShopBuyReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ShopBuyReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.ShopBuyReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.ShopBuyReq} ShopBuyReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ShopBuyReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.ShopBuyReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.num = reader.int32();
                        break;
                    case 2:
                        message.goodsId = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("num"))
                    throw $util.ProtocolError("missing required 'num'", { instance: message });
                if (!message.hasOwnProperty("goodsId"))
                    throw $util.ProtocolError("missing required 'goodsId'", { instance: message });
                return message;
            };

            /**
             * Decodes a ShopBuyReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.ShopBuyReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.ShopBuyReq} ShopBuyReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ShopBuyReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ShopBuyReq message.
             * @function verify
             * @memberof luck.protobuf.ShopBuyReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ShopBuyReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.num))
                    return "num: integer expected";
                if (!$util.isInteger(message.goodsId))
                    return "goodsId: integer expected";
                return null;
            };

            return ShopBuyReq;
        })();

        protobuf.ApplyFriendsReq = (function() {

            /**
             * Properties of an ApplyFriendsReq.
             * @memberof luck.protobuf
             * @interface IApplyFriendsReq
             * @property {number|Long} friendId ApplyFriendsReq friendId
             */

            /**
             * Constructs a new ApplyFriendsReq.
             * @memberof luck.protobuf
             * @classdesc Represents an ApplyFriendsReq.
             * @implements IApplyFriendsReq
             * @constructor
             * @param {luck.protobuf.IApplyFriendsReq=} [properties] Properties to set
             */
            function ApplyFriendsReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ApplyFriendsReq friendId.
             * @member {number|Long} friendId
             * @memberof luck.protobuf.ApplyFriendsReq
             * @instance
             */
            ApplyFriendsReq.prototype.friendId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new ApplyFriendsReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.ApplyFriendsReq
             * @static
             * @param {luck.protobuf.IApplyFriendsReq=} [properties] Properties to set
             * @returns {luck.protobuf.ApplyFriendsReq} ApplyFriendsReq instance
             */
            ApplyFriendsReq.create = function create(properties) {
                return new ApplyFriendsReq(properties);
            };

            /**
             * Encodes the specified ApplyFriendsReq message. Does not implicitly {@link luck.protobuf.ApplyFriendsReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.ApplyFriendsReq
             * @static
             * @param {luck.protobuf.IApplyFriendsReq} message ApplyFriendsReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ApplyFriendsReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.friendId);
                return writer;
            };

            /**
             * Encodes the specified ApplyFriendsReq message, length delimited. Does not implicitly {@link luck.protobuf.ApplyFriendsReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.ApplyFriendsReq
             * @static
             * @param {luck.protobuf.IApplyFriendsReq} message ApplyFriendsReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ApplyFriendsReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ApplyFriendsReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.ApplyFriendsReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.ApplyFriendsReq} ApplyFriendsReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ApplyFriendsReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.ApplyFriendsReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.friendId = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("friendId"))
                    throw $util.ProtocolError("missing required 'friendId'", { instance: message });
                return message;
            };

            /**
             * Decodes an ApplyFriendsReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.ApplyFriendsReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.ApplyFriendsReq} ApplyFriendsReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ApplyFriendsReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ApplyFriendsReq message.
             * @function verify
             * @memberof luck.protobuf.ApplyFriendsReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ApplyFriendsReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.friendId) && !(message.friendId && $util.isInteger(message.friendId.low) && $util.isInteger(message.friendId.high)))
                    return "friendId: integer|Long expected";
                return null;
            };

            return ApplyFriendsReq;
        })();

        protobuf.GetFriendsListReq = (function() {

            /**
             * Properties of a GetFriendsListReq.
             * @memberof luck.protobuf
             * @interface IGetFriendsListReq
             */

            /**
             * Constructs a new GetFriendsListReq.
             * @memberof luck.protobuf
             * @classdesc Represents a GetFriendsListReq.
             * @implements IGetFriendsListReq
             * @constructor
             * @param {luck.protobuf.IGetFriendsListReq=} [properties] Properties to set
             */
            function GetFriendsListReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new GetFriendsListReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.GetFriendsListReq
             * @static
             * @param {luck.protobuf.IGetFriendsListReq=} [properties] Properties to set
             * @returns {luck.protobuf.GetFriendsListReq} GetFriendsListReq instance
             */
            GetFriendsListReq.create = function create(properties) {
                return new GetFriendsListReq(properties);
            };

            /**
             * Encodes the specified GetFriendsListReq message. Does not implicitly {@link luck.protobuf.GetFriendsListReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.GetFriendsListReq
             * @static
             * @param {luck.protobuf.IGetFriendsListReq} message GetFriendsListReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetFriendsListReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified GetFriendsListReq message, length delimited. Does not implicitly {@link luck.protobuf.GetFriendsListReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.GetFriendsListReq
             * @static
             * @param {luck.protobuf.IGetFriendsListReq} message GetFriendsListReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetFriendsListReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetFriendsListReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.GetFriendsListReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.GetFriendsListReq} GetFriendsListReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetFriendsListReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.GetFriendsListReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetFriendsListReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.GetFriendsListReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.GetFriendsListReq} GetFriendsListReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetFriendsListReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetFriendsListReq message.
             * @function verify
             * @memberof luck.protobuf.GetFriendsListReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetFriendsListReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            return GetFriendsListReq;
        })();

        protobuf.ApproveFriendApplyReq = (function() {

            /**
             * Properties of an ApproveFriendApplyReq.
             * @memberof luck.protobuf
             * @interface IApproveFriendApplyReq
             * @property {number|Long} friendId ApproveFriendApplyReq friendId
             * @property {boolean} bAgree ApproveFriendApplyReq bAgree
             */

            /**
             * Constructs a new ApproveFriendApplyReq.
             * @memberof luck.protobuf
             * @classdesc Represents an ApproveFriendApplyReq.
             * @implements IApproveFriendApplyReq
             * @constructor
             * @param {luck.protobuf.IApproveFriendApplyReq=} [properties] Properties to set
             */
            function ApproveFriendApplyReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ApproveFriendApplyReq friendId.
             * @member {number|Long} friendId
             * @memberof luck.protobuf.ApproveFriendApplyReq
             * @instance
             */
            ApproveFriendApplyReq.prototype.friendId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * ApproveFriendApplyReq bAgree.
             * @member {boolean} bAgree
             * @memberof luck.protobuf.ApproveFriendApplyReq
             * @instance
             */
            ApproveFriendApplyReq.prototype.bAgree = false;

            /**
             * Creates a new ApproveFriendApplyReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.ApproveFriendApplyReq
             * @static
             * @param {luck.protobuf.IApproveFriendApplyReq=} [properties] Properties to set
             * @returns {luck.protobuf.ApproveFriendApplyReq} ApproveFriendApplyReq instance
             */
            ApproveFriendApplyReq.create = function create(properties) {
                return new ApproveFriendApplyReq(properties);
            };

            /**
             * Encodes the specified ApproveFriendApplyReq message. Does not implicitly {@link luck.protobuf.ApproveFriendApplyReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.ApproveFriendApplyReq
             * @static
             * @param {luck.protobuf.IApproveFriendApplyReq} message ApproveFriendApplyReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ApproveFriendApplyReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.friendId);
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.bAgree);
                return writer;
            };

            /**
             * Encodes the specified ApproveFriendApplyReq message, length delimited. Does not implicitly {@link luck.protobuf.ApproveFriendApplyReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.ApproveFriendApplyReq
             * @static
             * @param {luck.protobuf.IApproveFriendApplyReq} message ApproveFriendApplyReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ApproveFriendApplyReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ApproveFriendApplyReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.ApproveFriendApplyReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.ApproveFriendApplyReq} ApproveFriendApplyReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ApproveFriendApplyReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.ApproveFriendApplyReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.friendId = reader.int64();
                        break;
                    case 2:
                        message.bAgree = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("friendId"))
                    throw $util.ProtocolError("missing required 'friendId'", { instance: message });
                if (!message.hasOwnProperty("bAgree"))
                    throw $util.ProtocolError("missing required 'bAgree'", { instance: message });
                return message;
            };

            /**
             * Decodes an ApproveFriendApplyReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.ApproveFriendApplyReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.ApproveFriendApplyReq} ApproveFriendApplyReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ApproveFriendApplyReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ApproveFriendApplyReq message.
             * @function verify
             * @memberof luck.protobuf.ApproveFriendApplyReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ApproveFriendApplyReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.friendId) && !(message.friendId && $util.isInteger(message.friendId.low) && $util.isInteger(message.friendId.high)))
                    return "friendId: integer|Long expected";
                if (typeof message.bAgree !== "boolean")
                    return "bAgree: boolean expected";
                return null;
            };

            return ApproveFriendApplyReq;
        })();

        protobuf.DeleteFriendReq = (function() {

            /**
             * Properties of a DeleteFriendReq.
             * @memberof luck.protobuf
             * @interface IDeleteFriendReq
             * @property {number|Long} friendId DeleteFriendReq friendId
             */

            /**
             * Constructs a new DeleteFriendReq.
             * @memberof luck.protobuf
             * @classdesc Represents a DeleteFriendReq.
             * @implements IDeleteFriendReq
             * @constructor
             * @param {luck.protobuf.IDeleteFriendReq=} [properties] Properties to set
             */
            function DeleteFriendReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeleteFriendReq friendId.
             * @member {number|Long} friendId
             * @memberof luck.protobuf.DeleteFriendReq
             * @instance
             */
            DeleteFriendReq.prototype.friendId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new DeleteFriendReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.DeleteFriendReq
             * @static
             * @param {luck.protobuf.IDeleteFriendReq=} [properties] Properties to set
             * @returns {luck.protobuf.DeleteFriendReq} DeleteFriendReq instance
             */
            DeleteFriendReq.create = function create(properties) {
                return new DeleteFriendReq(properties);
            };

            /**
             * Encodes the specified DeleteFriendReq message. Does not implicitly {@link luck.protobuf.DeleteFriendReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.DeleteFriendReq
             * @static
             * @param {luck.protobuf.IDeleteFriendReq} message DeleteFriendReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteFriendReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.friendId);
                return writer;
            };

            /**
             * Encodes the specified DeleteFriendReq message, length delimited. Does not implicitly {@link luck.protobuf.DeleteFriendReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.DeleteFriendReq
             * @static
             * @param {luck.protobuf.IDeleteFriendReq} message DeleteFriendReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteFriendReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteFriendReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.DeleteFriendReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.DeleteFriendReq} DeleteFriendReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteFriendReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.DeleteFriendReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.friendId = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("friendId"))
                    throw $util.ProtocolError("missing required 'friendId'", { instance: message });
                return message;
            };

            /**
             * Decodes a DeleteFriendReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.DeleteFriendReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.DeleteFriendReq} DeleteFriendReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteFriendReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteFriendReq message.
             * @function verify
             * @memberof luck.protobuf.DeleteFriendReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteFriendReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.friendId) && !(message.friendId && $util.isInteger(message.friendId.low) && $util.isInteger(message.friendId.high)))
                    return "friendId: integer|Long expected";
                return null;
            };

            return DeleteFriendReq;
        })();

        protobuf.LoadShopReq = (function() {

            /**
             * Properties of a LoadShopReq.
             * @memberof luck.protobuf
             * @interface ILoadShopReq
             */

            /**
             * Constructs a new LoadShopReq.
             * @memberof luck.protobuf
             * @classdesc Represents a LoadShopReq.
             * @implements ILoadShopReq
             * @constructor
             * @param {luck.protobuf.ILoadShopReq=} [properties] Properties to set
             */
            function LoadShopReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new LoadShopReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.LoadShopReq
             * @static
             * @param {luck.protobuf.ILoadShopReq=} [properties] Properties to set
             * @returns {luck.protobuf.LoadShopReq} LoadShopReq instance
             */
            LoadShopReq.create = function create(properties) {
                return new LoadShopReq(properties);
            };

            /**
             * Encodes the specified LoadShopReq message. Does not implicitly {@link luck.protobuf.LoadShopReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.LoadShopReq
             * @static
             * @param {luck.protobuf.ILoadShopReq} message LoadShopReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LoadShopReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified LoadShopReq message, length delimited. Does not implicitly {@link luck.protobuf.LoadShopReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.LoadShopReq
             * @static
             * @param {luck.protobuf.ILoadShopReq} message LoadShopReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LoadShopReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LoadShopReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.LoadShopReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.LoadShopReq} LoadShopReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LoadShopReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.LoadShopReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LoadShopReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.LoadShopReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.LoadShopReq} LoadShopReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LoadShopReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LoadShopReq message.
             * @function verify
             * @memberof luck.protobuf.LoadShopReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LoadShopReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            return LoadShopReq;
        })();

        protobuf.SendChatReq = (function() {

            /**
             * Properties of a SendChatReq.
             * @memberof luck.protobuf
             * @interface ISendChatReq
             * @property {number} type SendChatReq type
             * @property {string} content SendChatReq content
             * @property {number|Long|null} [addresseeId] SendChatReq addresseeId
             * @property {Array.<number|Long>|null} [weaponUidList] SendChatReq weaponUidList
             * @property {Array.<number|Long>|null} [cardUidList] SendChatReq cardUidList
             * @property {Array.<number|Long>|null} [clothesUidList] SendChatReq clothesUidList
             */

            /**
             * Constructs a new SendChatReq.
             * @memberof luck.protobuf
             * @classdesc Represents a SendChatReq.
             * @implements ISendChatReq
             * @constructor
             * @param {luck.protobuf.ISendChatReq=} [properties] Properties to set
             */
            function SendChatReq(properties) {
                this.weaponUidList = [];
                this.cardUidList = [];
                this.clothesUidList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SendChatReq type.
             * @member {number} type
             * @memberof luck.protobuf.SendChatReq
             * @instance
             */
            SendChatReq.prototype.type = 0;

            /**
             * SendChatReq content.
             * @member {string} content
             * @memberof luck.protobuf.SendChatReq
             * @instance
             */
            SendChatReq.prototype.content = "";

            /**
             * SendChatReq addresseeId.
             * @member {number|Long} addresseeId
             * @memberof luck.protobuf.SendChatReq
             * @instance
             */
            SendChatReq.prototype.addresseeId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * SendChatReq weaponUidList.
             * @member {Array.<number|Long>} weaponUidList
             * @memberof luck.protobuf.SendChatReq
             * @instance
             */
            SendChatReq.prototype.weaponUidList = $util.emptyArray;

            /**
             * SendChatReq cardUidList.
             * @member {Array.<number|Long>} cardUidList
             * @memberof luck.protobuf.SendChatReq
             * @instance
             */
            SendChatReq.prototype.cardUidList = $util.emptyArray;

            /**
             * SendChatReq clothesUidList.
             * @member {Array.<number|Long>} clothesUidList
             * @memberof luck.protobuf.SendChatReq
             * @instance
             */
            SendChatReq.prototype.clothesUidList = $util.emptyArray;

            /**
             * Creates a new SendChatReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.SendChatReq
             * @static
             * @param {luck.protobuf.ISendChatReq=} [properties] Properties to set
             * @returns {luck.protobuf.SendChatReq} SendChatReq instance
             */
            SendChatReq.create = function create(properties) {
                return new SendChatReq(properties);
            };

            /**
             * Encodes the specified SendChatReq message. Does not implicitly {@link luck.protobuf.SendChatReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.SendChatReq
             * @static
             * @param {luck.protobuf.ISendChatReq} message SendChatReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendChatReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.content);
                if (message.addresseeId != null && message.hasOwnProperty("addresseeId"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.addresseeId);
                if (message.weaponUidList != null && message.weaponUidList.length)
                    for (var i = 0; i < message.weaponUidList.length; ++i)
                        writer.uint32(/* id 4, wireType 0 =*/32).int64(message.weaponUidList[i]);
                if (message.cardUidList != null && message.cardUidList.length)
                    for (var i = 0; i < message.cardUidList.length; ++i)
                        writer.uint32(/* id 5, wireType 0 =*/40).int64(message.cardUidList[i]);
                if (message.clothesUidList != null && message.clothesUidList.length)
                    for (var i = 0; i < message.clothesUidList.length; ++i)
                        writer.uint32(/* id 6, wireType 0 =*/48).int64(message.clothesUidList[i]);
                return writer;
            };

            /**
             * Encodes the specified SendChatReq message, length delimited. Does not implicitly {@link luck.protobuf.SendChatReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.SendChatReq
             * @static
             * @param {luck.protobuf.ISendChatReq} message SendChatReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendChatReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SendChatReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.SendChatReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.SendChatReq} SendChatReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendChatReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.SendChatReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.content = reader.string();
                        break;
                    case 3:
                        message.addresseeId = reader.int64();
                        break;
                    case 4:
                        if (!(message.weaponUidList && message.weaponUidList.length))
                            message.weaponUidList = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.weaponUidList.push(reader.int64());
                        } else
                            message.weaponUidList.push(reader.int64());
                        break;
                    case 5:
                        if (!(message.cardUidList && message.cardUidList.length))
                            message.cardUidList = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.cardUidList.push(reader.int64());
                        } else
                            message.cardUidList.push(reader.int64());
                        break;
                    case 6:
                        if (!(message.clothesUidList && message.clothesUidList.length))
                            message.clothesUidList = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.clothesUidList.push(reader.int64());
                        } else
                            message.clothesUidList.push(reader.int64());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("type"))
                    throw $util.ProtocolError("missing required 'type'", { instance: message });
                if (!message.hasOwnProperty("content"))
                    throw $util.ProtocolError("missing required 'content'", { instance: message });
                return message;
            };

            /**
             * Decodes a SendChatReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.SendChatReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.SendChatReq} SendChatReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendChatReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SendChatReq message.
             * @function verify
             * @memberof luck.protobuf.SendChatReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SendChatReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
                if (!$util.isString(message.content))
                    return "content: string expected";
                if (message.addresseeId != null && message.hasOwnProperty("addresseeId"))
                    if (!$util.isInteger(message.addresseeId) && !(message.addresseeId && $util.isInteger(message.addresseeId.low) && $util.isInteger(message.addresseeId.high)))
                        return "addresseeId: integer|Long expected";
                if (message.weaponUidList != null && message.hasOwnProperty("weaponUidList")) {
                    if (!Array.isArray(message.weaponUidList))
                        return "weaponUidList: array expected";
                    for (var i = 0; i < message.weaponUidList.length; ++i)
                        if (!$util.isInteger(message.weaponUidList[i]) && !(message.weaponUidList[i] && $util.isInteger(message.weaponUidList[i].low) && $util.isInteger(message.weaponUidList[i].high)))
                            return "weaponUidList: integer|Long[] expected";
                }
                if (message.cardUidList != null && message.hasOwnProperty("cardUidList")) {
                    if (!Array.isArray(message.cardUidList))
                        return "cardUidList: array expected";
                    for (var i = 0; i < message.cardUidList.length; ++i)
                        if (!$util.isInteger(message.cardUidList[i]) && !(message.cardUidList[i] && $util.isInteger(message.cardUidList[i].low) && $util.isInteger(message.cardUidList[i].high)))
                            return "cardUidList: integer|Long[] expected";
                }
                if (message.clothesUidList != null && message.hasOwnProperty("clothesUidList")) {
                    if (!Array.isArray(message.clothesUidList))
                        return "clothesUidList: array expected";
                    for (var i = 0; i < message.clothesUidList.length; ++i)
                        if (!$util.isInteger(message.clothesUidList[i]) && !(message.clothesUidList[i] && $util.isInteger(message.clothesUidList[i].low) && $util.isInteger(message.clothesUidList[i].high)))
                            return "clothesUidList: integer|Long[] expected";
                }
                return null;
            };

            return SendChatReq;
        })();

        protobuf.ExpansionBagReq = (function() {

            /**
             * Properties of an ExpansionBagReq.
             * @memberof luck.protobuf
             * @interface IExpansionBagReq
             * @property {number} gridNum ExpansionBagReq gridNum
             */

            /**
             * Constructs a new ExpansionBagReq.
             * @memberof luck.protobuf
             * @classdesc Represents an ExpansionBagReq.
             * @implements IExpansionBagReq
             * @constructor
             * @param {luck.protobuf.IExpansionBagReq=} [properties] Properties to set
             */
            function ExpansionBagReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExpansionBagReq gridNum.
             * @member {number} gridNum
             * @memberof luck.protobuf.ExpansionBagReq
             * @instance
             */
            ExpansionBagReq.prototype.gridNum = 0;

            /**
             * Creates a new ExpansionBagReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.ExpansionBagReq
             * @static
             * @param {luck.protobuf.IExpansionBagReq=} [properties] Properties to set
             * @returns {luck.protobuf.ExpansionBagReq} ExpansionBagReq instance
             */
            ExpansionBagReq.create = function create(properties) {
                return new ExpansionBagReq(properties);
            };

            /**
             * Encodes the specified ExpansionBagReq message. Does not implicitly {@link luck.protobuf.ExpansionBagReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.ExpansionBagReq
             * @static
             * @param {luck.protobuf.IExpansionBagReq} message ExpansionBagReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExpansionBagReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.gridNum);
                return writer;
            };

            /**
             * Encodes the specified ExpansionBagReq message, length delimited. Does not implicitly {@link luck.protobuf.ExpansionBagReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.ExpansionBagReq
             * @static
             * @param {luck.protobuf.IExpansionBagReq} message ExpansionBagReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExpansionBagReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExpansionBagReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.ExpansionBagReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.ExpansionBagReq} ExpansionBagReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExpansionBagReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.ExpansionBagReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.gridNum = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("gridNum"))
                    throw $util.ProtocolError("missing required 'gridNum'", { instance: message });
                return message;
            };

            /**
             * Decodes an ExpansionBagReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.ExpansionBagReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.ExpansionBagReq} ExpansionBagReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExpansionBagReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExpansionBagReq message.
             * @function verify
             * @memberof luck.protobuf.ExpansionBagReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExpansionBagReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.gridNum))
                    return "gridNum: integer expected";
                return null;
            };

            return ExpansionBagReq;
        })();

        protobuf.ActivityTollgateReq = (function() {

            /**
             * Properties of an ActivityTollgateReq.
             * @memberof luck.protobuf
             * @interface IActivityTollgateReq
             * @property {number} TollgateId ActivityTollgateReq TollgateId
             */

            /**
             * Constructs a new ActivityTollgateReq.
             * @memberof luck.protobuf
             * @classdesc Represents an ActivityTollgateReq.
             * @implements IActivityTollgateReq
             * @constructor
             * @param {luck.protobuf.IActivityTollgateReq=} [properties] Properties to set
             */
            function ActivityTollgateReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ActivityTollgateReq TollgateId.
             * @member {number} TollgateId
             * @memberof luck.protobuf.ActivityTollgateReq
             * @instance
             */
            ActivityTollgateReq.prototype.TollgateId = 0;

            /**
             * Creates a new ActivityTollgateReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.ActivityTollgateReq
             * @static
             * @param {luck.protobuf.IActivityTollgateReq=} [properties] Properties to set
             * @returns {luck.protobuf.ActivityTollgateReq} ActivityTollgateReq instance
             */
            ActivityTollgateReq.create = function create(properties) {
                return new ActivityTollgateReq(properties);
            };

            /**
             * Encodes the specified ActivityTollgateReq message. Does not implicitly {@link luck.protobuf.ActivityTollgateReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.ActivityTollgateReq
             * @static
             * @param {luck.protobuf.IActivityTollgateReq} message ActivityTollgateReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ActivityTollgateReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.TollgateId);
                return writer;
            };

            /**
             * Encodes the specified ActivityTollgateReq message, length delimited. Does not implicitly {@link luck.protobuf.ActivityTollgateReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.ActivityTollgateReq
             * @static
             * @param {luck.protobuf.IActivityTollgateReq} message ActivityTollgateReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ActivityTollgateReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ActivityTollgateReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.ActivityTollgateReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.ActivityTollgateReq} ActivityTollgateReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ActivityTollgateReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.ActivityTollgateReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.TollgateId = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("TollgateId"))
                    throw $util.ProtocolError("missing required 'TollgateId'", { instance: message });
                return message;
            };

            /**
             * Decodes an ActivityTollgateReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.ActivityTollgateReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.ActivityTollgateReq} ActivityTollgateReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ActivityTollgateReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ActivityTollgateReq message.
             * @function verify
             * @memberof luck.protobuf.ActivityTollgateReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ActivityTollgateReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.TollgateId))
                    return "TollgateId: integer expected";
                return null;
            };

            return ActivityTollgateReq;
        })();

        protobuf.SellGoodsReq = (function() {

            /**
             * Properties of a SellGoodsReq.
             * @memberof luck.protobuf
             * @interface ISellGoodsReq
             * @property {Array.<luck.protobuf.IsellGoodsPB>|null} [sellGoodsList] SellGoodsReq sellGoodsList
             */

            /**
             * Constructs a new SellGoodsReq.
             * @memberof luck.protobuf
             * @classdesc Represents a SellGoodsReq.
             * @implements ISellGoodsReq
             * @constructor
             * @param {luck.protobuf.ISellGoodsReq=} [properties] Properties to set
             */
            function SellGoodsReq(properties) {
                this.sellGoodsList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SellGoodsReq sellGoodsList.
             * @member {Array.<luck.protobuf.IsellGoodsPB>} sellGoodsList
             * @memberof luck.protobuf.SellGoodsReq
             * @instance
             */
            SellGoodsReq.prototype.sellGoodsList = $util.emptyArray;

            /**
             * Creates a new SellGoodsReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.SellGoodsReq
             * @static
             * @param {luck.protobuf.ISellGoodsReq=} [properties] Properties to set
             * @returns {luck.protobuf.SellGoodsReq} SellGoodsReq instance
             */
            SellGoodsReq.create = function create(properties) {
                return new SellGoodsReq(properties);
            };

            /**
             * Encodes the specified SellGoodsReq message. Does not implicitly {@link luck.protobuf.SellGoodsReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.SellGoodsReq
             * @static
             * @param {luck.protobuf.ISellGoodsReq} message SellGoodsReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SellGoodsReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sellGoodsList != null && message.sellGoodsList.length)
                    for (var i = 0; i < message.sellGoodsList.length; ++i)
                        $root.luck.protobuf.sellGoodsPB.encode(message.sellGoodsList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SellGoodsReq message, length delimited. Does not implicitly {@link luck.protobuf.SellGoodsReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.SellGoodsReq
             * @static
             * @param {luck.protobuf.ISellGoodsReq} message SellGoodsReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SellGoodsReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SellGoodsReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.SellGoodsReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.SellGoodsReq} SellGoodsReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SellGoodsReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.SellGoodsReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        if (!(message.sellGoodsList && message.sellGoodsList.length))
                            message.sellGoodsList = [];
                        message.sellGoodsList.push($root.luck.protobuf.sellGoodsPB.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SellGoodsReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.SellGoodsReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.SellGoodsReq} SellGoodsReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SellGoodsReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SellGoodsReq message.
             * @function verify
             * @memberof luck.protobuf.SellGoodsReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SellGoodsReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sellGoodsList != null && message.hasOwnProperty("sellGoodsList")) {
                    if (!Array.isArray(message.sellGoodsList))
                        return "sellGoodsList: array expected";
                    for (var i = 0; i < message.sellGoodsList.length; ++i) {
                        var error = $root.luck.protobuf.sellGoodsPB.verify(message.sellGoodsList[i]);
                        if (error)
                            return "sellGoodsList." + error;
                    }
                }
                return null;
            };

            return SellGoodsReq;
        })();

        protobuf.CompleteActivityTollgateReq = (function() {

            /**
             * Properties of a CompleteActivityTollgateReq.
             * @memberof luck.protobuf
             * @interface ICompleteActivityTollgateReq
             * @property {number} TollgateId CompleteActivityTollgateReq TollgateId
             * @property {number} isClear CompleteActivityTollgateReq isClear
             */

            /**
             * Constructs a new CompleteActivityTollgateReq.
             * @memberof luck.protobuf
             * @classdesc Represents a CompleteActivityTollgateReq.
             * @implements ICompleteActivityTollgateReq
             * @constructor
             * @param {luck.protobuf.ICompleteActivityTollgateReq=} [properties] Properties to set
             */
            function CompleteActivityTollgateReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CompleteActivityTollgateReq TollgateId.
             * @member {number} TollgateId
             * @memberof luck.protobuf.CompleteActivityTollgateReq
             * @instance
             */
            CompleteActivityTollgateReq.prototype.TollgateId = 0;

            /**
             * CompleteActivityTollgateReq isClear.
             * @member {number} isClear
             * @memberof luck.protobuf.CompleteActivityTollgateReq
             * @instance
             */
            CompleteActivityTollgateReq.prototype.isClear = 0;

            /**
             * Creates a new CompleteActivityTollgateReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.CompleteActivityTollgateReq
             * @static
             * @param {luck.protobuf.ICompleteActivityTollgateReq=} [properties] Properties to set
             * @returns {luck.protobuf.CompleteActivityTollgateReq} CompleteActivityTollgateReq instance
             */
            CompleteActivityTollgateReq.create = function create(properties) {
                return new CompleteActivityTollgateReq(properties);
            };

            /**
             * Encodes the specified CompleteActivityTollgateReq message. Does not implicitly {@link luck.protobuf.CompleteActivityTollgateReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.CompleteActivityTollgateReq
             * @static
             * @param {luck.protobuf.ICompleteActivityTollgateReq} message CompleteActivityTollgateReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CompleteActivityTollgateReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.TollgateId);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.isClear);
                return writer;
            };

            /**
             * Encodes the specified CompleteActivityTollgateReq message, length delimited. Does not implicitly {@link luck.protobuf.CompleteActivityTollgateReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.CompleteActivityTollgateReq
             * @static
             * @param {luck.protobuf.ICompleteActivityTollgateReq} message CompleteActivityTollgateReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CompleteActivityTollgateReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CompleteActivityTollgateReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.CompleteActivityTollgateReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.CompleteActivityTollgateReq} CompleteActivityTollgateReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CompleteActivityTollgateReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.CompleteActivityTollgateReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.TollgateId = reader.int32();
                        break;
                    case 2:
                        message.isClear = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("TollgateId"))
                    throw $util.ProtocolError("missing required 'TollgateId'", { instance: message });
                if (!message.hasOwnProperty("isClear"))
                    throw $util.ProtocolError("missing required 'isClear'", { instance: message });
                return message;
            };

            /**
             * Decodes a CompleteActivityTollgateReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.CompleteActivityTollgateReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.CompleteActivityTollgateReq} CompleteActivityTollgateReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CompleteActivityTollgateReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CompleteActivityTollgateReq message.
             * @function verify
             * @memberof luck.protobuf.CompleteActivityTollgateReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CompleteActivityTollgateReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.TollgateId))
                    return "TollgateId: integer expected";
                if (!$util.isInteger(message.isClear))
                    return "isClear: integer expected";
                return null;
            };

            return CompleteActivityTollgateReq;
        })();

        protobuf.DrawLoveBentoReq = (function() {

            /**
             * Properties of a DrawLoveBentoReq.
             * @memberof luck.protobuf
             * @interface IDrawLoveBentoReq
             */

            /**
             * Constructs a new DrawLoveBentoReq.
             * @memberof luck.protobuf
             * @classdesc Represents a DrawLoveBentoReq.
             * @implements IDrawLoveBentoReq
             * @constructor
             * @param {luck.protobuf.IDrawLoveBentoReq=} [properties] Properties to set
             */
            function DrawLoveBentoReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new DrawLoveBentoReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.DrawLoveBentoReq
             * @static
             * @param {luck.protobuf.IDrawLoveBentoReq=} [properties] Properties to set
             * @returns {luck.protobuf.DrawLoveBentoReq} DrawLoveBentoReq instance
             */
            DrawLoveBentoReq.create = function create(properties) {
                return new DrawLoveBentoReq(properties);
            };

            /**
             * Encodes the specified DrawLoveBentoReq message. Does not implicitly {@link luck.protobuf.DrawLoveBentoReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.DrawLoveBentoReq
             * @static
             * @param {luck.protobuf.IDrawLoveBentoReq} message DrawLoveBentoReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DrawLoveBentoReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified DrawLoveBentoReq message, length delimited. Does not implicitly {@link luck.protobuf.DrawLoveBentoReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.DrawLoveBentoReq
             * @static
             * @param {luck.protobuf.IDrawLoveBentoReq} message DrawLoveBentoReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DrawLoveBentoReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DrawLoveBentoReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.DrawLoveBentoReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.DrawLoveBentoReq} DrawLoveBentoReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DrawLoveBentoReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.DrawLoveBentoReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DrawLoveBentoReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.DrawLoveBentoReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.DrawLoveBentoReq} DrawLoveBentoReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DrawLoveBentoReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DrawLoveBentoReq message.
             * @function verify
             * @memberof luck.protobuf.DrawLoveBentoReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DrawLoveBentoReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            return DrawLoveBentoReq;
        })();

        protobuf.PropConsumeReq = (function() {

            /**
             * Properties of a PropConsumeReq.
             * @memberof luck.protobuf
             * @interface IPropConsumeReq
             * @property {number} propId PropConsumeReq propId
             * @property {number} propNum PropConsumeReq propNum
             */

            /**
             * Constructs a new PropConsumeReq.
             * @memberof luck.protobuf
             * @classdesc Represents a PropConsumeReq.
             * @implements IPropConsumeReq
             * @constructor
             * @param {luck.protobuf.IPropConsumeReq=} [properties] Properties to set
             */
            function PropConsumeReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PropConsumeReq propId.
             * @member {number} propId
             * @memberof luck.protobuf.PropConsumeReq
             * @instance
             */
            PropConsumeReq.prototype.propId = 0;

            /**
             * PropConsumeReq propNum.
             * @member {number} propNum
             * @memberof luck.protobuf.PropConsumeReq
             * @instance
             */
            PropConsumeReq.prototype.propNum = 0;

            /**
             * Creates a new PropConsumeReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.PropConsumeReq
             * @static
             * @param {luck.protobuf.IPropConsumeReq=} [properties] Properties to set
             * @returns {luck.protobuf.PropConsumeReq} PropConsumeReq instance
             */
            PropConsumeReq.create = function create(properties) {
                return new PropConsumeReq(properties);
            };

            /**
             * Encodes the specified PropConsumeReq message. Does not implicitly {@link luck.protobuf.PropConsumeReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.PropConsumeReq
             * @static
             * @param {luck.protobuf.IPropConsumeReq} message PropConsumeReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PropConsumeReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.propId);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.propNum);
                return writer;
            };

            /**
             * Encodes the specified PropConsumeReq message, length delimited. Does not implicitly {@link luck.protobuf.PropConsumeReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.PropConsumeReq
             * @static
             * @param {luck.protobuf.IPropConsumeReq} message PropConsumeReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PropConsumeReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PropConsumeReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.PropConsumeReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.PropConsumeReq} PropConsumeReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PropConsumeReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.PropConsumeReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.propId = reader.int32();
                        break;
                    case 2:
                        message.propNum = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("propId"))
                    throw $util.ProtocolError("missing required 'propId'", { instance: message });
                if (!message.hasOwnProperty("propNum"))
                    throw $util.ProtocolError("missing required 'propNum'", { instance: message });
                return message;
            };

            /**
             * Decodes a PropConsumeReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.PropConsumeReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.PropConsumeReq} PropConsumeReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PropConsumeReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PropConsumeReq message.
             * @function verify
             * @memberof luck.protobuf.PropConsumeReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PropConsumeReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.propId))
                    return "propId: integer expected";
                if (!$util.isInteger(message.propNum))
                    return "propNum: integer expected";
                return null;
            };

            return PropConsumeReq;
        })();

        protobuf.PullGangInfoReq = (function() {

            /**
             * Properties of a PullGangInfoReq.
             * @memberof luck.protobuf
             * @interface IPullGangInfoReq
             */

            /**
             * Constructs a new PullGangInfoReq.
             * @memberof luck.protobuf
             * @classdesc Represents a PullGangInfoReq.
             * @implements IPullGangInfoReq
             * @constructor
             * @param {luck.protobuf.IPullGangInfoReq=} [properties] Properties to set
             */
            function PullGangInfoReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new PullGangInfoReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.PullGangInfoReq
             * @static
             * @param {luck.protobuf.IPullGangInfoReq=} [properties] Properties to set
             * @returns {luck.protobuf.PullGangInfoReq} PullGangInfoReq instance
             */
            PullGangInfoReq.create = function create(properties) {
                return new PullGangInfoReq(properties);
            };

            /**
             * Encodes the specified PullGangInfoReq message. Does not implicitly {@link luck.protobuf.PullGangInfoReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.PullGangInfoReq
             * @static
             * @param {luck.protobuf.IPullGangInfoReq} message PullGangInfoReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PullGangInfoReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified PullGangInfoReq message, length delimited. Does not implicitly {@link luck.protobuf.PullGangInfoReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.PullGangInfoReq
             * @static
             * @param {luck.protobuf.IPullGangInfoReq} message PullGangInfoReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PullGangInfoReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PullGangInfoReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.PullGangInfoReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.PullGangInfoReq} PullGangInfoReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PullGangInfoReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.PullGangInfoReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PullGangInfoReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.PullGangInfoReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.PullGangInfoReq} PullGangInfoReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PullGangInfoReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PullGangInfoReq message.
             * @function verify
             * @memberof luck.protobuf.PullGangInfoReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PullGangInfoReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            return PullGangInfoReq;
        })();

        protobuf.ChangeGangJobReq = (function() {

            /**
             * Properties of a ChangeGangJobReq.
             * @memberof luck.protobuf
             * @interface IChangeGangJobReq
             * @property {number|Long} changeId ChangeGangJobReq changeId
             * @property {number} job ChangeGangJobReq job
             */

            /**
             * Constructs a new ChangeGangJobReq.
             * @memberof luck.protobuf
             * @classdesc Represents a ChangeGangJobReq.
             * @implements IChangeGangJobReq
             * @constructor
             * @param {luck.protobuf.IChangeGangJobReq=} [properties] Properties to set
             */
            function ChangeGangJobReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ChangeGangJobReq changeId.
             * @member {number|Long} changeId
             * @memberof luck.protobuf.ChangeGangJobReq
             * @instance
             */
            ChangeGangJobReq.prototype.changeId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * ChangeGangJobReq job.
             * @member {number} job
             * @memberof luck.protobuf.ChangeGangJobReq
             * @instance
             */
            ChangeGangJobReq.prototype.job = 0;

            /**
             * Creates a new ChangeGangJobReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.ChangeGangJobReq
             * @static
             * @param {luck.protobuf.IChangeGangJobReq=} [properties] Properties to set
             * @returns {luck.protobuf.ChangeGangJobReq} ChangeGangJobReq instance
             */
            ChangeGangJobReq.create = function create(properties) {
                return new ChangeGangJobReq(properties);
            };

            /**
             * Encodes the specified ChangeGangJobReq message. Does not implicitly {@link luck.protobuf.ChangeGangJobReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.ChangeGangJobReq
             * @static
             * @param {luck.protobuf.IChangeGangJobReq} message ChangeGangJobReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChangeGangJobReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.changeId);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.job);
                return writer;
            };

            /**
             * Encodes the specified ChangeGangJobReq message, length delimited. Does not implicitly {@link luck.protobuf.ChangeGangJobReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.ChangeGangJobReq
             * @static
             * @param {luck.protobuf.IChangeGangJobReq} message ChangeGangJobReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChangeGangJobReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ChangeGangJobReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.ChangeGangJobReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.ChangeGangJobReq} ChangeGangJobReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChangeGangJobReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.ChangeGangJobReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.changeId = reader.int64();
                        break;
                    case 2:
                        message.job = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("changeId"))
                    throw $util.ProtocolError("missing required 'changeId'", { instance: message });
                if (!message.hasOwnProperty("job"))
                    throw $util.ProtocolError("missing required 'job'", { instance: message });
                return message;
            };

            /**
             * Decodes a ChangeGangJobReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.ChangeGangJobReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.ChangeGangJobReq} ChangeGangJobReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChangeGangJobReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ChangeGangJobReq message.
             * @function verify
             * @memberof luck.protobuf.ChangeGangJobReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChangeGangJobReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.changeId) && !(message.changeId && $util.isInteger(message.changeId.low) && $util.isInteger(message.changeId.high)))
                    return "changeId: integer|Long expected";
                if (!$util.isInteger(message.job))
                    return "job: integer expected";
                return null;
            };

            return ChangeGangJobReq;
        })();

        protobuf.QuitGangReq = (function() {

            /**
             * Properties of a QuitGangReq.
             * @memberof luck.protobuf
             * @interface IQuitGangReq
             */

            /**
             * Constructs a new QuitGangReq.
             * @memberof luck.protobuf
             * @classdesc Represents a QuitGangReq.
             * @implements IQuitGangReq
             * @constructor
             * @param {luck.protobuf.IQuitGangReq=} [properties] Properties to set
             */
            function QuitGangReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new QuitGangReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.QuitGangReq
             * @static
             * @param {luck.protobuf.IQuitGangReq=} [properties] Properties to set
             * @returns {luck.protobuf.QuitGangReq} QuitGangReq instance
             */
            QuitGangReq.create = function create(properties) {
                return new QuitGangReq(properties);
            };

            /**
             * Encodes the specified QuitGangReq message. Does not implicitly {@link luck.protobuf.QuitGangReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.QuitGangReq
             * @static
             * @param {luck.protobuf.IQuitGangReq} message QuitGangReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QuitGangReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified QuitGangReq message, length delimited. Does not implicitly {@link luck.protobuf.QuitGangReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.QuitGangReq
             * @static
             * @param {luck.protobuf.IQuitGangReq} message QuitGangReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QuitGangReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QuitGangReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.QuitGangReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.QuitGangReq} QuitGangReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QuitGangReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.QuitGangReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QuitGangReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.QuitGangReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.QuitGangReq} QuitGangReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QuitGangReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QuitGangReq message.
             * @function verify
             * @memberof luck.protobuf.QuitGangReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QuitGangReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            return QuitGangReq;
        })();

        protobuf.KickOutGangReq = (function() {

            /**
             * Properties of a KickOutGangReq.
             * @memberof luck.protobuf
             * @interface IKickOutGangReq
             * @property {number|Long} memberId KickOutGangReq memberId
             */

            /**
             * Constructs a new KickOutGangReq.
             * @memberof luck.protobuf
             * @classdesc Represents a KickOutGangReq.
             * @implements IKickOutGangReq
             * @constructor
             * @param {luck.protobuf.IKickOutGangReq=} [properties] Properties to set
             */
            function KickOutGangReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KickOutGangReq memberId.
             * @member {number|Long} memberId
             * @memberof luck.protobuf.KickOutGangReq
             * @instance
             */
            KickOutGangReq.prototype.memberId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new KickOutGangReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.KickOutGangReq
             * @static
             * @param {luck.protobuf.IKickOutGangReq=} [properties] Properties to set
             * @returns {luck.protobuf.KickOutGangReq} KickOutGangReq instance
             */
            KickOutGangReq.create = function create(properties) {
                return new KickOutGangReq(properties);
            };

            /**
             * Encodes the specified KickOutGangReq message. Does not implicitly {@link luck.protobuf.KickOutGangReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.KickOutGangReq
             * @static
             * @param {luck.protobuf.IKickOutGangReq} message KickOutGangReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KickOutGangReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.memberId);
                return writer;
            };

            /**
             * Encodes the specified KickOutGangReq message, length delimited. Does not implicitly {@link luck.protobuf.KickOutGangReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.KickOutGangReq
             * @static
             * @param {luck.protobuf.IKickOutGangReq} message KickOutGangReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KickOutGangReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KickOutGangReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.KickOutGangReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.KickOutGangReq} KickOutGangReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KickOutGangReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.KickOutGangReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.memberId = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("memberId"))
                    throw $util.ProtocolError("missing required 'memberId'", { instance: message });
                return message;
            };

            /**
             * Decodes a KickOutGangReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.KickOutGangReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.KickOutGangReq} KickOutGangReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KickOutGangReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KickOutGangReq message.
             * @function verify
             * @memberof luck.protobuf.KickOutGangReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KickOutGangReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.memberId) && !(message.memberId && $util.isInteger(message.memberId.low) && $util.isInteger(message.memberId.high)))
                    return "memberId: integer|Long expected";
                return null;
            };

            return KickOutGangReq;
        })();

        protobuf.ApproveJoinGangReq = (function() {

            /**
             * Properties of an ApproveJoinGangReq.
             * @memberof luck.protobuf
             * @interface IApproveJoinGangReq
             * @property {number|Long} applyId ApproveJoinGangReq applyId
             * @property {boolean} approve ApproveJoinGangReq approve
             */

            /**
             * Constructs a new ApproveJoinGangReq.
             * @memberof luck.protobuf
             * @classdesc Represents an ApproveJoinGangReq.
             * @implements IApproveJoinGangReq
             * @constructor
             * @param {luck.protobuf.IApproveJoinGangReq=} [properties] Properties to set
             */
            function ApproveJoinGangReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ApproveJoinGangReq applyId.
             * @member {number|Long} applyId
             * @memberof luck.protobuf.ApproveJoinGangReq
             * @instance
             */
            ApproveJoinGangReq.prototype.applyId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * ApproveJoinGangReq approve.
             * @member {boolean} approve
             * @memberof luck.protobuf.ApproveJoinGangReq
             * @instance
             */
            ApproveJoinGangReq.prototype.approve = false;

            /**
             * Creates a new ApproveJoinGangReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.ApproveJoinGangReq
             * @static
             * @param {luck.protobuf.IApproveJoinGangReq=} [properties] Properties to set
             * @returns {luck.protobuf.ApproveJoinGangReq} ApproveJoinGangReq instance
             */
            ApproveJoinGangReq.create = function create(properties) {
                return new ApproveJoinGangReq(properties);
            };

            /**
             * Encodes the specified ApproveJoinGangReq message. Does not implicitly {@link luck.protobuf.ApproveJoinGangReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.ApproveJoinGangReq
             * @static
             * @param {luck.protobuf.IApproveJoinGangReq} message ApproveJoinGangReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ApproveJoinGangReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.applyId);
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.approve);
                return writer;
            };

            /**
             * Encodes the specified ApproveJoinGangReq message, length delimited. Does not implicitly {@link luck.protobuf.ApproveJoinGangReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.ApproveJoinGangReq
             * @static
             * @param {luck.protobuf.IApproveJoinGangReq} message ApproveJoinGangReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ApproveJoinGangReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ApproveJoinGangReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.ApproveJoinGangReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.ApproveJoinGangReq} ApproveJoinGangReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ApproveJoinGangReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.ApproveJoinGangReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.applyId = reader.int64();
                        break;
                    case 2:
                        message.approve = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("applyId"))
                    throw $util.ProtocolError("missing required 'applyId'", { instance: message });
                if (!message.hasOwnProperty("approve"))
                    throw $util.ProtocolError("missing required 'approve'", { instance: message });
                return message;
            };

            /**
             * Decodes an ApproveJoinGangReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.ApproveJoinGangReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.ApproveJoinGangReq} ApproveJoinGangReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ApproveJoinGangReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ApproveJoinGangReq message.
             * @function verify
             * @memberof luck.protobuf.ApproveJoinGangReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ApproveJoinGangReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.applyId) && !(message.applyId && $util.isInteger(message.applyId.low) && $util.isInteger(message.applyId.high)))
                    return "applyId: integer|Long expected";
                if (typeof message.approve !== "boolean")
                    return "approve: boolean expected";
                return null;
            };

            return ApproveJoinGangReq;
        })();

        protobuf.ApplyJoinGangReq = (function() {

            /**
             * Properties of an ApplyJoinGangReq.
             * @memberof luck.protobuf
             * @interface IApplyJoinGangReq
             * @property {number|Long} gangId ApplyJoinGangReq gangId
             */

            /**
             * Constructs a new ApplyJoinGangReq.
             * @memberof luck.protobuf
             * @classdesc Represents an ApplyJoinGangReq.
             * @implements IApplyJoinGangReq
             * @constructor
             * @param {luck.protobuf.IApplyJoinGangReq=} [properties] Properties to set
             */
            function ApplyJoinGangReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ApplyJoinGangReq gangId.
             * @member {number|Long} gangId
             * @memberof luck.protobuf.ApplyJoinGangReq
             * @instance
             */
            ApplyJoinGangReq.prototype.gangId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new ApplyJoinGangReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.ApplyJoinGangReq
             * @static
             * @param {luck.protobuf.IApplyJoinGangReq=} [properties] Properties to set
             * @returns {luck.protobuf.ApplyJoinGangReq} ApplyJoinGangReq instance
             */
            ApplyJoinGangReq.create = function create(properties) {
                return new ApplyJoinGangReq(properties);
            };

            /**
             * Encodes the specified ApplyJoinGangReq message. Does not implicitly {@link luck.protobuf.ApplyJoinGangReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.ApplyJoinGangReq
             * @static
             * @param {luck.protobuf.IApplyJoinGangReq} message ApplyJoinGangReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ApplyJoinGangReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.gangId);
                return writer;
            };

            /**
             * Encodes the specified ApplyJoinGangReq message, length delimited. Does not implicitly {@link luck.protobuf.ApplyJoinGangReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.ApplyJoinGangReq
             * @static
             * @param {luck.protobuf.IApplyJoinGangReq} message ApplyJoinGangReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ApplyJoinGangReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ApplyJoinGangReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.ApplyJoinGangReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.ApplyJoinGangReq} ApplyJoinGangReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ApplyJoinGangReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.ApplyJoinGangReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.gangId = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("gangId"))
                    throw $util.ProtocolError("missing required 'gangId'", { instance: message });
                return message;
            };

            /**
             * Decodes an ApplyJoinGangReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.ApplyJoinGangReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.ApplyJoinGangReq} ApplyJoinGangReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ApplyJoinGangReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ApplyJoinGangReq message.
             * @function verify
             * @memberof luck.protobuf.ApplyJoinGangReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ApplyJoinGangReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.gangId) && !(message.gangId && $util.isInteger(message.gangId.low) && $util.isInteger(message.gangId.high)))
                    return "gangId: integer|Long expected";
                return null;
            };

            return ApplyJoinGangReq;
        })();

        protobuf.CreateGangReq = (function() {

            /**
             * Properties of a CreateGangReq.
             * @memberof luck.protobuf
             * @interface ICreateGangReq
             * @property {string} gangName CreateGangReq gangName
             * @property {string} manifesto CreateGangReq manifesto
             * @property {number} iconId CreateGangReq iconId
             */

            /**
             * Constructs a new CreateGangReq.
             * @memberof luck.protobuf
             * @classdesc Represents a CreateGangReq.
             * @implements ICreateGangReq
             * @constructor
             * @param {luck.protobuf.ICreateGangReq=} [properties] Properties to set
             */
            function CreateGangReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CreateGangReq gangName.
             * @member {string} gangName
             * @memberof luck.protobuf.CreateGangReq
             * @instance
             */
            CreateGangReq.prototype.gangName = "";

            /**
             * CreateGangReq manifesto.
             * @member {string} manifesto
             * @memberof luck.protobuf.CreateGangReq
             * @instance
             */
            CreateGangReq.prototype.manifesto = "";

            /**
             * CreateGangReq iconId.
             * @member {number} iconId
             * @memberof luck.protobuf.CreateGangReq
             * @instance
             */
            CreateGangReq.prototype.iconId = 0;

            /**
             * Creates a new CreateGangReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.CreateGangReq
             * @static
             * @param {luck.protobuf.ICreateGangReq=} [properties] Properties to set
             * @returns {luck.protobuf.CreateGangReq} CreateGangReq instance
             */
            CreateGangReq.create = function create(properties) {
                return new CreateGangReq(properties);
            };

            /**
             * Encodes the specified CreateGangReq message. Does not implicitly {@link luck.protobuf.CreateGangReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.CreateGangReq
             * @static
             * @param {luck.protobuf.ICreateGangReq} message CreateGangReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateGangReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.gangName);
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.manifesto);
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.iconId);
                return writer;
            };

            /**
             * Encodes the specified CreateGangReq message, length delimited. Does not implicitly {@link luck.protobuf.CreateGangReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.CreateGangReq
             * @static
             * @param {luck.protobuf.ICreateGangReq} message CreateGangReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateGangReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CreateGangReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.CreateGangReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.CreateGangReq} CreateGangReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateGangReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.CreateGangReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.gangName = reader.string();
                        break;
                    case 2:
                        message.manifesto = reader.string();
                        break;
                    case 3:
                        message.iconId = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("gangName"))
                    throw $util.ProtocolError("missing required 'gangName'", { instance: message });
                if (!message.hasOwnProperty("manifesto"))
                    throw $util.ProtocolError("missing required 'manifesto'", { instance: message });
                if (!message.hasOwnProperty("iconId"))
                    throw $util.ProtocolError("missing required 'iconId'", { instance: message });
                return message;
            };

            /**
             * Decodes a CreateGangReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.CreateGangReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.CreateGangReq} CreateGangReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateGangReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CreateGangReq message.
             * @function verify
             * @memberof luck.protobuf.CreateGangReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateGangReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.gangName))
                    return "gangName: string expected";
                if (!$util.isString(message.manifesto))
                    return "manifesto: string expected";
                if (!$util.isInteger(message.iconId))
                    return "iconId: integer expected";
                return null;
            };

            return CreateGangReq;
        })();

        protobuf.PullAllGangInfoReq = (function() {

            /**
             * Properties of a PullAllGangInfoReq.
             * @memberof luck.protobuf
             * @interface IPullAllGangInfoReq
             */

            /**
             * Constructs a new PullAllGangInfoReq.
             * @memberof luck.protobuf
             * @classdesc Represents a PullAllGangInfoReq.
             * @implements IPullAllGangInfoReq
             * @constructor
             * @param {luck.protobuf.IPullAllGangInfoReq=} [properties] Properties to set
             */
            function PullAllGangInfoReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new PullAllGangInfoReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.PullAllGangInfoReq
             * @static
             * @param {luck.protobuf.IPullAllGangInfoReq=} [properties] Properties to set
             * @returns {luck.protobuf.PullAllGangInfoReq} PullAllGangInfoReq instance
             */
            PullAllGangInfoReq.create = function create(properties) {
                return new PullAllGangInfoReq(properties);
            };

            /**
             * Encodes the specified PullAllGangInfoReq message. Does not implicitly {@link luck.protobuf.PullAllGangInfoReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.PullAllGangInfoReq
             * @static
             * @param {luck.protobuf.IPullAllGangInfoReq} message PullAllGangInfoReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PullAllGangInfoReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified PullAllGangInfoReq message, length delimited. Does not implicitly {@link luck.protobuf.PullAllGangInfoReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.PullAllGangInfoReq
             * @static
             * @param {luck.protobuf.IPullAllGangInfoReq} message PullAllGangInfoReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PullAllGangInfoReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PullAllGangInfoReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.PullAllGangInfoReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.PullAllGangInfoReq} PullAllGangInfoReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PullAllGangInfoReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.PullAllGangInfoReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PullAllGangInfoReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.PullAllGangInfoReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.PullAllGangInfoReq} PullAllGangInfoReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PullAllGangInfoReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PullAllGangInfoReq message.
             * @function verify
             * @memberof luck.protobuf.PullAllGangInfoReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PullAllGangInfoReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            return PullAllGangInfoReq;
        })();

        protobuf.SearchGangReq = (function() {

            /**
             * Properties of a SearchGangReq.
             * @memberof luck.protobuf
             * @interface ISearchGangReq
             * @property {string} search SearchGangReq search
             */

            /**
             * Constructs a new SearchGangReq.
             * @memberof luck.protobuf
             * @classdesc Represents a SearchGangReq.
             * @implements ISearchGangReq
             * @constructor
             * @param {luck.protobuf.ISearchGangReq=} [properties] Properties to set
             */
            function SearchGangReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SearchGangReq search.
             * @member {string} search
             * @memberof luck.protobuf.SearchGangReq
             * @instance
             */
            SearchGangReq.prototype.search = "";

            /**
             * Creates a new SearchGangReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.SearchGangReq
             * @static
             * @param {luck.protobuf.ISearchGangReq=} [properties] Properties to set
             * @returns {luck.protobuf.SearchGangReq} SearchGangReq instance
             */
            SearchGangReq.create = function create(properties) {
                return new SearchGangReq(properties);
            };

            /**
             * Encodes the specified SearchGangReq message. Does not implicitly {@link luck.protobuf.SearchGangReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.SearchGangReq
             * @static
             * @param {luck.protobuf.ISearchGangReq} message SearchGangReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SearchGangReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.search);
                return writer;
            };

            /**
             * Encodes the specified SearchGangReq message, length delimited. Does not implicitly {@link luck.protobuf.SearchGangReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.SearchGangReq
             * @static
             * @param {luck.protobuf.ISearchGangReq} message SearchGangReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SearchGangReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SearchGangReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.SearchGangReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.SearchGangReq} SearchGangReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SearchGangReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.SearchGangReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.search = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("search"))
                    throw $util.ProtocolError("missing required 'search'", { instance: message });
                return message;
            };

            /**
             * Decodes a SearchGangReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.SearchGangReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.SearchGangReq} SearchGangReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SearchGangReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SearchGangReq message.
             * @function verify
             * @memberof luck.protobuf.SearchGangReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SearchGangReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.search))
                    return "search: string expected";
                return null;
            };

            return SearchGangReq;
        })();

        protobuf.BattleResurgenceReq = (function() {

            /**
             * Properties of a BattleResurgenceReq.
             * @memberof luck.protobuf
             * @interface IBattleResurgenceReq
             */

            /**
             * Constructs a new BattleResurgenceReq.
             * @memberof luck.protobuf
             * @classdesc Represents a BattleResurgenceReq.
             * @implements IBattleResurgenceReq
             * @constructor
             * @param {luck.protobuf.IBattleResurgenceReq=} [properties] Properties to set
             */
            function BattleResurgenceReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new BattleResurgenceReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.BattleResurgenceReq
             * @static
             * @param {luck.protobuf.IBattleResurgenceReq=} [properties] Properties to set
             * @returns {luck.protobuf.BattleResurgenceReq} BattleResurgenceReq instance
             */
            BattleResurgenceReq.create = function create(properties) {
                return new BattleResurgenceReq(properties);
            };

            /**
             * Encodes the specified BattleResurgenceReq message. Does not implicitly {@link luck.protobuf.BattleResurgenceReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.BattleResurgenceReq
             * @static
             * @param {luck.protobuf.IBattleResurgenceReq} message BattleResurgenceReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BattleResurgenceReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified BattleResurgenceReq message, length delimited. Does not implicitly {@link luck.protobuf.BattleResurgenceReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.BattleResurgenceReq
             * @static
             * @param {luck.protobuf.IBattleResurgenceReq} message BattleResurgenceReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BattleResurgenceReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BattleResurgenceReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.BattleResurgenceReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.BattleResurgenceReq} BattleResurgenceReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BattleResurgenceReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.BattleResurgenceReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BattleResurgenceReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.BattleResurgenceReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.BattleResurgenceReq} BattleResurgenceReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BattleResurgenceReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BattleResurgenceReq message.
             * @function verify
             * @memberof luck.protobuf.BattleResurgenceReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BattleResurgenceReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            return BattleResurgenceReq;
        })();

        protobuf.ReconnectionReq = (function() {

            /**
             * Properties of a ReconnectionReq.
             * @memberof luck.protobuf
             * @interface IReconnectionReq
             * @property {string} LogInKey ReconnectionReq LogInKey
             */

            /**
             * Constructs a new ReconnectionReq.
             * @memberof luck.protobuf
             * @classdesc Represents a ReconnectionReq.
             * @implements IReconnectionReq
             * @constructor
             * @param {luck.protobuf.IReconnectionReq=} [properties] Properties to set
             */
            function ReconnectionReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReconnectionReq LogInKey.
             * @member {string} LogInKey
             * @memberof luck.protobuf.ReconnectionReq
             * @instance
             */
            ReconnectionReq.prototype.LogInKey = "";

            /**
             * Creates a new ReconnectionReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.ReconnectionReq
             * @static
             * @param {luck.protobuf.IReconnectionReq=} [properties] Properties to set
             * @returns {luck.protobuf.ReconnectionReq} ReconnectionReq instance
             */
            ReconnectionReq.create = function create(properties) {
                return new ReconnectionReq(properties);
            };

            /**
             * Encodes the specified ReconnectionReq message. Does not implicitly {@link luck.protobuf.ReconnectionReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.ReconnectionReq
             * @static
             * @param {luck.protobuf.IReconnectionReq} message ReconnectionReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReconnectionReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.LogInKey);
                return writer;
            };

            /**
             * Encodes the specified ReconnectionReq message, length delimited. Does not implicitly {@link luck.protobuf.ReconnectionReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.ReconnectionReq
             * @static
             * @param {luck.protobuf.IReconnectionReq} message ReconnectionReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReconnectionReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReconnectionReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.ReconnectionReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.ReconnectionReq} ReconnectionReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReconnectionReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.ReconnectionReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.LogInKey = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("LogInKey"))
                    throw $util.ProtocolError("missing required 'LogInKey'", { instance: message });
                return message;
            };

            /**
             * Decodes a ReconnectionReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.ReconnectionReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.ReconnectionReq} ReconnectionReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReconnectionReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReconnectionReq message.
             * @function verify
             * @memberof luck.protobuf.ReconnectionReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReconnectionReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.LogInKey))
                    return "LogInKey: string expected";
                return null;
            };

            return ReconnectionReq;
        })();

        protobuf.JiGuangRegisterReq = (function() {

            /**
             * Properties of a JiGuangRegisterReq.
             * @memberof luck.protobuf
             * @interface IJiGuangRegisterReq
             * @property {string|null} [registrationID] JiGuangRegisterReq registrationID
             * @property {string|null} [alias] JiGuangRegisterReq alias
             * @property {Array.<string>|null} [tagList] JiGuangRegisterReq tagList
             */

            /**
             * Constructs a new JiGuangRegisterReq.
             * @memberof luck.protobuf
             * @classdesc Represents a JiGuangRegisterReq.
             * @implements IJiGuangRegisterReq
             * @constructor
             * @param {luck.protobuf.IJiGuangRegisterReq=} [properties] Properties to set
             */
            function JiGuangRegisterReq(properties) {
                this.tagList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * JiGuangRegisterReq registrationID.
             * @member {string} registrationID
             * @memberof luck.protobuf.JiGuangRegisterReq
             * @instance
             */
            JiGuangRegisterReq.prototype.registrationID = "";

            /**
             * JiGuangRegisterReq alias.
             * @member {string} alias
             * @memberof luck.protobuf.JiGuangRegisterReq
             * @instance
             */
            JiGuangRegisterReq.prototype.alias = "";

            /**
             * JiGuangRegisterReq tagList.
             * @member {Array.<string>} tagList
             * @memberof luck.protobuf.JiGuangRegisterReq
             * @instance
             */
            JiGuangRegisterReq.prototype.tagList = $util.emptyArray;

            /**
             * Creates a new JiGuangRegisterReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.JiGuangRegisterReq
             * @static
             * @param {luck.protobuf.IJiGuangRegisterReq=} [properties] Properties to set
             * @returns {luck.protobuf.JiGuangRegisterReq} JiGuangRegisterReq instance
             */
            JiGuangRegisterReq.create = function create(properties) {
                return new JiGuangRegisterReq(properties);
            };

            /**
             * Encodes the specified JiGuangRegisterReq message. Does not implicitly {@link luck.protobuf.JiGuangRegisterReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.JiGuangRegisterReq
             * @static
             * @param {luck.protobuf.IJiGuangRegisterReq} message JiGuangRegisterReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            JiGuangRegisterReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.registrationID != null && message.hasOwnProperty("registrationID"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.registrationID);
                if (message.alias != null && message.hasOwnProperty("alias"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.alias);
                if (message.tagList != null && message.tagList.length)
                    for (var i = 0; i < message.tagList.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.tagList[i]);
                return writer;
            };

            /**
             * Encodes the specified JiGuangRegisterReq message, length delimited. Does not implicitly {@link luck.protobuf.JiGuangRegisterReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.JiGuangRegisterReq
             * @static
             * @param {luck.protobuf.IJiGuangRegisterReq} message JiGuangRegisterReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            JiGuangRegisterReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a JiGuangRegisterReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.JiGuangRegisterReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.JiGuangRegisterReq} JiGuangRegisterReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            JiGuangRegisterReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.JiGuangRegisterReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.registrationID = reader.string();
                        break;
                    case 2:
                        message.alias = reader.string();
                        break;
                    case 3:
                        if (!(message.tagList && message.tagList.length))
                            message.tagList = [];
                        message.tagList.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a JiGuangRegisterReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.JiGuangRegisterReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.JiGuangRegisterReq} JiGuangRegisterReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            JiGuangRegisterReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a JiGuangRegisterReq message.
             * @function verify
             * @memberof luck.protobuf.JiGuangRegisterReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            JiGuangRegisterReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.registrationID != null && message.hasOwnProperty("registrationID"))
                    if (!$util.isString(message.registrationID))
                        return "registrationID: string expected";
                if (message.alias != null && message.hasOwnProperty("alias"))
                    if (!$util.isString(message.alias))
                        return "alias: string expected";
                if (message.tagList != null && message.hasOwnProperty("tagList")) {
                    if (!Array.isArray(message.tagList))
                        return "tagList: array expected";
                    for (var i = 0; i < message.tagList.length; ++i)
                        if (!$util.isString(message.tagList[i]))
                            return "tagList: string[] expected";
                }
                return null;
            };

            return JiGuangRegisterReq;
        })();

        protobuf.drawTaskReq = (function() {

            /**
             * Properties of a drawTaskReq.
             * @memberof luck.protobuf
             * @interface IdrawTaskReq
             * @property {number} taskId drawTaskReq taskId
             * @property {number} type drawTaskReq type
             */

            /**
             * Constructs a new drawTaskReq.
             * @memberof luck.protobuf
             * @classdesc Represents a drawTaskReq.
             * @implements IdrawTaskReq
             * @constructor
             * @param {luck.protobuf.IdrawTaskReq=} [properties] Properties to set
             */
            function drawTaskReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * drawTaskReq taskId.
             * @member {number} taskId
             * @memberof luck.protobuf.drawTaskReq
             * @instance
             */
            drawTaskReq.prototype.taskId = 0;

            /**
             * drawTaskReq type.
             * @member {number} type
             * @memberof luck.protobuf.drawTaskReq
             * @instance
             */
            drawTaskReq.prototype.type = 0;

            /**
             * Creates a new drawTaskReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.drawTaskReq
             * @static
             * @param {luck.protobuf.IdrawTaskReq=} [properties] Properties to set
             * @returns {luck.protobuf.drawTaskReq} drawTaskReq instance
             */
            drawTaskReq.create = function create(properties) {
                return new drawTaskReq(properties);
            };

            /**
             * Encodes the specified drawTaskReq message. Does not implicitly {@link luck.protobuf.drawTaskReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.drawTaskReq
             * @static
             * @param {luck.protobuf.IdrawTaskReq} message drawTaskReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            drawTaskReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.taskId);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                return writer;
            };

            /**
             * Encodes the specified drawTaskReq message, length delimited. Does not implicitly {@link luck.protobuf.drawTaskReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.drawTaskReq
             * @static
             * @param {luck.protobuf.IdrawTaskReq} message drawTaskReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            drawTaskReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a drawTaskReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.drawTaskReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.drawTaskReq} drawTaskReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            drawTaskReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.drawTaskReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.taskId = reader.int32();
                        break;
                    case 2:
                        message.type = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("taskId"))
                    throw $util.ProtocolError("missing required 'taskId'", { instance: message });
                if (!message.hasOwnProperty("type"))
                    throw $util.ProtocolError("missing required 'type'", { instance: message });
                return message;
            };

            /**
             * Decodes a drawTaskReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.drawTaskReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.drawTaskReq} drawTaskReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            drawTaskReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a drawTaskReq message.
             * @function verify
             * @memberof luck.protobuf.drawTaskReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            drawTaskReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.taskId))
                    return "taskId: integer expected";
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
                return null;
            };

            return drawTaskReq;
        })();

        protobuf.drawDailyVitalityRewardReq = (function() {

            /**
             * Properties of a drawDailyVitalityRewardReq.
             * @memberof luck.protobuf
             * @interface IdrawDailyVitalityRewardReq
             * @property {number} dailyVitalityRewardId drawDailyVitalityRewardReq dailyVitalityRewardId
             */

            /**
             * Constructs a new drawDailyVitalityRewardReq.
             * @memberof luck.protobuf
             * @classdesc Represents a drawDailyVitalityRewardReq.
             * @implements IdrawDailyVitalityRewardReq
             * @constructor
             * @param {luck.protobuf.IdrawDailyVitalityRewardReq=} [properties] Properties to set
             */
            function drawDailyVitalityRewardReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * drawDailyVitalityRewardReq dailyVitalityRewardId.
             * @member {number} dailyVitalityRewardId
             * @memberof luck.protobuf.drawDailyVitalityRewardReq
             * @instance
             */
            drawDailyVitalityRewardReq.prototype.dailyVitalityRewardId = 0;

            /**
             * Creates a new drawDailyVitalityRewardReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.drawDailyVitalityRewardReq
             * @static
             * @param {luck.protobuf.IdrawDailyVitalityRewardReq=} [properties] Properties to set
             * @returns {luck.protobuf.drawDailyVitalityRewardReq} drawDailyVitalityRewardReq instance
             */
            drawDailyVitalityRewardReq.create = function create(properties) {
                return new drawDailyVitalityRewardReq(properties);
            };

            /**
             * Encodes the specified drawDailyVitalityRewardReq message. Does not implicitly {@link luck.protobuf.drawDailyVitalityRewardReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.drawDailyVitalityRewardReq
             * @static
             * @param {luck.protobuf.IdrawDailyVitalityRewardReq} message drawDailyVitalityRewardReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            drawDailyVitalityRewardReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.dailyVitalityRewardId);
                return writer;
            };

            /**
             * Encodes the specified drawDailyVitalityRewardReq message, length delimited. Does not implicitly {@link luck.protobuf.drawDailyVitalityRewardReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.drawDailyVitalityRewardReq
             * @static
             * @param {luck.protobuf.IdrawDailyVitalityRewardReq} message drawDailyVitalityRewardReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            drawDailyVitalityRewardReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a drawDailyVitalityRewardReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.drawDailyVitalityRewardReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.drawDailyVitalityRewardReq} drawDailyVitalityRewardReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            drawDailyVitalityRewardReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.drawDailyVitalityRewardReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.dailyVitalityRewardId = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("dailyVitalityRewardId"))
                    throw $util.ProtocolError("missing required 'dailyVitalityRewardId'", { instance: message });
                return message;
            };

            /**
             * Decodes a drawDailyVitalityRewardReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.drawDailyVitalityRewardReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.drawDailyVitalityRewardReq} drawDailyVitalityRewardReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            drawDailyVitalityRewardReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a drawDailyVitalityRewardReq message.
             * @function verify
             * @memberof luck.protobuf.drawDailyVitalityRewardReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            drawDailyVitalityRewardReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.dailyVitalityRewardId))
                    return "dailyVitalityRewardId: integer expected";
                return null;
            };

            return drawDailyVitalityRewardReq;
        })();

        protobuf.createPVETeamReq = (function() {

            /**
             * Properties of a createPVETeamReq.
             * @memberof luck.protobuf
             * @interface IcreatePVETeamReq
             * @property {number} customsType createPVETeamReq customsType
             * @property {number} customsId createPVETeamReq customsId
             */

            /**
             * Constructs a new createPVETeamReq.
             * @memberof luck.protobuf
             * @classdesc Represents a createPVETeamReq.
             * @implements IcreatePVETeamReq
             * @constructor
             * @param {luck.protobuf.IcreatePVETeamReq=} [properties] Properties to set
             */
            function createPVETeamReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * createPVETeamReq customsType.
             * @member {number} customsType
             * @memberof luck.protobuf.createPVETeamReq
             * @instance
             */
            createPVETeamReq.prototype.customsType = 0;

            /**
             * createPVETeamReq customsId.
             * @member {number} customsId
             * @memberof luck.protobuf.createPVETeamReq
             * @instance
             */
            createPVETeamReq.prototype.customsId = 0;

            /**
             * Creates a new createPVETeamReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.createPVETeamReq
             * @static
             * @param {luck.protobuf.IcreatePVETeamReq=} [properties] Properties to set
             * @returns {luck.protobuf.createPVETeamReq} createPVETeamReq instance
             */
            createPVETeamReq.create = function create(properties) {
                return new createPVETeamReq(properties);
            };

            /**
             * Encodes the specified createPVETeamReq message. Does not implicitly {@link luck.protobuf.createPVETeamReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.createPVETeamReq
             * @static
             * @param {luck.protobuf.IcreatePVETeamReq} message createPVETeamReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            createPVETeamReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.customsType);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.customsId);
                return writer;
            };

            /**
             * Encodes the specified createPVETeamReq message, length delimited. Does not implicitly {@link luck.protobuf.createPVETeamReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.createPVETeamReq
             * @static
             * @param {luck.protobuf.IcreatePVETeamReq} message createPVETeamReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            createPVETeamReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a createPVETeamReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.createPVETeamReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.createPVETeamReq} createPVETeamReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            createPVETeamReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.createPVETeamReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.customsType = reader.int32();
                        break;
                    case 2:
                        message.customsId = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("customsType"))
                    throw $util.ProtocolError("missing required 'customsType'", { instance: message });
                if (!message.hasOwnProperty("customsId"))
                    throw $util.ProtocolError("missing required 'customsId'", { instance: message });
                return message;
            };

            /**
             * Decodes a createPVETeamReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.createPVETeamReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.createPVETeamReq} createPVETeamReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            createPVETeamReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a createPVETeamReq message.
             * @function verify
             * @memberof luck.protobuf.createPVETeamReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            createPVETeamReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.customsType))
                    return "customsType: integer expected";
                if (!$util.isInteger(message.customsId))
                    return "customsId: integer expected";
                return null;
            };

            return createPVETeamReq;
        })();

        protobuf.PVEInviteReq = (function() {

            /**
             * Properties of a PVEInviteReq.
             * @memberof luck.protobuf
             * @interface IPVEInviteReq
             * @property {number|Long} inviteId PVEInviteReq inviteId
             */

            /**
             * Constructs a new PVEInviteReq.
             * @memberof luck.protobuf
             * @classdesc Represents a PVEInviteReq.
             * @implements IPVEInviteReq
             * @constructor
             * @param {luck.protobuf.IPVEInviteReq=} [properties] Properties to set
             */
            function PVEInviteReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PVEInviteReq inviteId.
             * @member {number|Long} inviteId
             * @memberof luck.protobuf.PVEInviteReq
             * @instance
             */
            PVEInviteReq.prototype.inviteId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new PVEInviteReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.PVEInviteReq
             * @static
             * @param {luck.protobuf.IPVEInviteReq=} [properties] Properties to set
             * @returns {luck.protobuf.PVEInviteReq} PVEInviteReq instance
             */
            PVEInviteReq.create = function create(properties) {
                return new PVEInviteReq(properties);
            };

            /**
             * Encodes the specified PVEInviteReq message. Does not implicitly {@link luck.protobuf.PVEInviteReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.PVEInviteReq
             * @static
             * @param {luck.protobuf.IPVEInviteReq} message PVEInviteReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PVEInviteReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.inviteId);
                return writer;
            };

            /**
             * Encodes the specified PVEInviteReq message, length delimited. Does not implicitly {@link luck.protobuf.PVEInviteReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.PVEInviteReq
             * @static
             * @param {luck.protobuf.IPVEInviteReq} message PVEInviteReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PVEInviteReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PVEInviteReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.PVEInviteReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.PVEInviteReq} PVEInviteReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PVEInviteReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.PVEInviteReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.inviteId = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("inviteId"))
                    throw $util.ProtocolError("missing required 'inviteId'", { instance: message });
                return message;
            };

            /**
             * Decodes a PVEInviteReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.PVEInviteReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.PVEInviteReq} PVEInviteReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PVEInviteReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PVEInviteReq message.
             * @function verify
             * @memberof luck.protobuf.PVEInviteReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PVEInviteReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.inviteId) && !(message.inviteId && $util.isInteger(message.inviteId.low) && $util.isInteger(message.inviteId.high)))
                    return "inviteId: integer|Long expected";
                return null;
            };

            return PVEInviteReq;
        })();

        protobuf.applyJoinTeamReq = (function() {

            /**
             * Properties of an applyJoinTeamReq.
             * @memberof luck.protobuf
             * @interface IapplyJoinTeamReq
             * @property {number|Long} teamId applyJoinTeamReq teamId
             * @property {string|null} [inviteCode] applyJoinTeamReq inviteCode
             */

            /**
             * Constructs a new applyJoinTeamReq.
             * @memberof luck.protobuf
             * @classdesc Represents an applyJoinTeamReq.
             * @implements IapplyJoinTeamReq
             * @constructor
             * @param {luck.protobuf.IapplyJoinTeamReq=} [properties] Properties to set
             */
            function applyJoinTeamReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * applyJoinTeamReq teamId.
             * @member {number|Long} teamId
             * @memberof luck.protobuf.applyJoinTeamReq
             * @instance
             */
            applyJoinTeamReq.prototype.teamId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * applyJoinTeamReq inviteCode.
             * @member {string} inviteCode
             * @memberof luck.protobuf.applyJoinTeamReq
             * @instance
             */
            applyJoinTeamReq.prototype.inviteCode = "";

            /**
             * Creates a new applyJoinTeamReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.applyJoinTeamReq
             * @static
             * @param {luck.protobuf.IapplyJoinTeamReq=} [properties] Properties to set
             * @returns {luck.protobuf.applyJoinTeamReq} applyJoinTeamReq instance
             */
            applyJoinTeamReq.create = function create(properties) {
                return new applyJoinTeamReq(properties);
            };

            /**
             * Encodes the specified applyJoinTeamReq message. Does not implicitly {@link luck.protobuf.applyJoinTeamReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.applyJoinTeamReq
             * @static
             * @param {luck.protobuf.IapplyJoinTeamReq} message applyJoinTeamReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            applyJoinTeamReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.teamId);
                if (message.inviteCode != null && message.hasOwnProperty("inviteCode"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.inviteCode);
                return writer;
            };

            /**
             * Encodes the specified applyJoinTeamReq message, length delimited. Does not implicitly {@link luck.protobuf.applyJoinTeamReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.applyJoinTeamReq
             * @static
             * @param {luck.protobuf.IapplyJoinTeamReq} message applyJoinTeamReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            applyJoinTeamReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an applyJoinTeamReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.applyJoinTeamReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.applyJoinTeamReq} applyJoinTeamReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            applyJoinTeamReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.applyJoinTeamReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.teamId = reader.int64();
                        break;
                    case 2:
                        message.inviteCode = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("teamId"))
                    throw $util.ProtocolError("missing required 'teamId'", { instance: message });
                return message;
            };

            /**
             * Decodes an applyJoinTeamReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.applyJoinTeamReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.applyJoinTeamReq} applyJoinTeamReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            applyJoinTeamReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an applyJoinTeamReq message.
             * @function verify
             * @memberof luck.protobuf.applyJoinTeamReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            applyJoinTeamReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.teamId) && !(message.teamId && $util.isInteger(message.teamId.low) && $util.isInteger(message.teamId.high)))
                    return "teamId: integer|Long expected";
                if (message.inviteCode != null && message.hasOwnProperty("inviteCode"))
                    if (!$util.isString(message.inviteCode))
                        return "inviteCode: string expected";
                return null;
            };

            return applyJoinTeamReq;
        })();

        protobuf.approveJoinTeamReq = (function() {

            /**
             * Properties of an approveJoinTeamReq.
             * @memberof luck.protobuf
             * @interface IapproveJoinTeamReq
             * @property {number|Long} memberId approveJoinTeamReq memberId
             * @property {boolean} isApprove approveJoinTeamReq isApprove
             */

            /**
             * Constructs a new approveJoinTeamReq.
             * @memberof luck.protobuf
             * @classdesc Represents an approveJoinTeamReq.
             * @implements IapproveJoinTeamReq
             * @constructor
             * @param {luck.protobuf.IapproveJoinTeamReq=} [properties] Properties to set
             */
            function approveJoinTeamReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * approveJoinTeamReq memberId.
             * @member {number|Long} memberId
             * @memberof luck.protobuf.approveJoinTeamReq
             * @instance
             */
            approveJoinTeamReq.prototype.memberId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * approveJoinTeamReq isApprove.
             * @member {boolean} isApprove
             * @memberof luck.protobuf.approveJoinTeamReq
             * @instance
             */
            approveJoinTeamReq.prototype.isApprove = false;

            /**
             * Creates a new approveJoinTeamReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.approveJoinTeamReq
             * @static
             * @param {luck.protobuf.IapproveJoinTeamReq=} [properties] Properties to set
             * @returns {luck.protobuf.approveJoinTeamReq} approveJoinTeamReq instance
             */
            approveJoinTeamReq.create = function create(properties) {
                return new approveJoinTeamReq(properties);
            };

            /**
             * Encodes the specified approveJoinTeamReq message. Does not implicitly {@link luck.protobuf.approveJoinTeamReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.approveJoinTeamReq
             * @static
             * @param {luck.protobuf.IapproveJoinTeamReq} message approveJoinTeamReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            approveJoinTeamReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.memberId);
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isApprove);
                return writer;
            };

            /**
             * Encodes the specified approveJoinTeamReq message, length delimited. Does not implicitly {@link luck.protobuf.approveJoinTeamReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.approveJoinTeamReq
             * @static
             * @param {luck.protobuf.IapproveJoinTeamReq} message approveJoinTeamReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            approveJoinTeamReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an approveJoinTeamReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.approveJoinTeamReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.approveJoinTeamReq} approveJoinTeamReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            approveJoinTeamReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.approveJoinTeamReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.memberId = reader.int64();
                        break;
                    case 2:
                        message.isApprove = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("memberId"))
                    throw $util.ProtocolError("missing required 'memberId'", { instance: message });
                if (!message.hasOwnProperty("isApprove"))
                    throw $util.ProtocolError("missing required 'isApprove'", { instance: message });
                return message;
            };

            /**
             * Decodes an approveJoinTeamReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.approveJoinTeamReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.approveJoinTeamReq} approveJoinTeamReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            approveJoinTeamReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an approveJoinTeamReq message.
             * @function verify
             * @memberof luck.protobuf.approveJoinTeamReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            approveJoinTeamReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.memberId) && !(message.memberId && $util.isInteger(message.memberId.low) && $util.isInteger(message.memberId.high)))
                    return "memberId: integer|Long expected";
                if (typeof message.isApprove !== "boolean")
                    return "isApprove: boolean expected";
                return null;
            };

            return approveJoinTeamReq;
        })();

        protobuf.PVEPrepareReq = (function() {

            /**
             * Properties of a PVEPrepareReq.
             * @memberof luck.protobuf
             * @interface IPVEPrepareReq
             */

            /**
             * Constructs a new PVEPrepareReq.
             * @memberof luck.protobuf
             * @classdesc Represents a PVEPrepareReq.
             * @implements IPVEPrepareReq
             * @constructor
             * @param {luck.protobuf.IPVEPrepareReq=} [properties] Properties to set
             */
            function PVEPrepareReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new PVEPrepareReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.PVEPrepareReq
             * @static
             * @param {luck.protobuf.IPVEPrepareReq=} [properties] Properties to set
             * @returns {luck.protobuf.PVEPrepareReq} PVEPrepareReq instance
             */
            PVEPrepareReq.create = function create(properties) {
                return new PVEPrepareReq(properties);
            };

            /**
             * Encodes the specified PVEPrepareReq message. Does not implicitly {@link luck.protobuf.PVEPrepareReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.PVEPrepareReq
             * @static
             * @param {luck.protobuf.IPVEPrepareReq} message PVEPrepareReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PVEPrepareReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified PVEPrepareReq message, length delimited. Does not implicitly {@link luck.protobuf.PVEPrepareReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.PVEPrepareReq
             * @static
             * @param {luck.protobuf.IPVEPrepareReq} message PVEPrepareReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PVEPrepareReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PVEPrepareReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.PVEPrepareReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.PVEPrepareReq} PVEPrepareReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PVEPrepareReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.PVEPrepareReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PVEPrepareReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.PVEPrepareReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.PVEPrepareReq} PVEPrepareReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PVEPrepareReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PVEPrepareReq message.
             * @function verify
             * @memberof luck.protobuf.PVEPrepareReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PVEPrepareReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            return PVEPrepareReq;
        })();

        protobuf.PVESelectCustomsReq = (function() {

            /**
             * Properties of a PVESelectCustomsReq.
             * @memberof luck.protobuf
             * @interface IPVESelectCustomsReq
             * @property {number} customsType PVESelectCustomsReq customsType
             * @property {number} customsId PVESelectCustomsReq customsId
             */

            /**
             * Constructs a new PVESelectCustomsReq.
             * @memberof luck.protobuf
             * @classdesc Represents a PVESelectCustomsReq.
             * @implements IPVESelectCustomsReq
             * @constructor
             * @param {luck.protobuf.IPVESelectCustomsReq=} [properties] Properties to set
             */
            function PVESelectCustomsReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PVESelectCustomsReq customsType.
             * @member {number} customsType
             * @memberof luck.protobuf.PVESelectCustomsReq
             * @instance
             */
            PVESelectCustomsReq.prototype.customsType = 0;

            /**
             * PVESelectCustomsReq customsId.
             * @member {number} customsId
             * @memberof luck.protobuf.PVESelectCustomsReq
             * @instance
             */
            PVESelectCustomsReq.prototype.customsId = 0;

            /**
             * Creates a new PVESelectCustomsReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.PVESelectCustomsReq
             * @static
             * @param {luck.protobuf.IPVESelectCustomsReq=} [properties] Properties to set
             * @returns {luck.protobuf.PVESelectCustomsReq} PVESelectCustomsReq instance
             */
            PVESelectCustomsReq.create = function create(properties) {
                return new PVESelectCustomsReq(properties);
            };

            /**
             * Encodes the specified PVESelectCustomsReq message. Does not implicitly {@link luck.protobuf.PVESelectCustomsReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.PVESelectCustomsReq
             * @static
             * @param {luck.protobuf.IPVESelectCustomsReq} message PVESelectCustomsReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PVESelectCustomsReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.customsType);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.customsId);
                return writer;
            };

            /**
             * Encodes the specified PVESelectCustomsReq message, length delimited. Does not implicitly {@link luck.protobuf.PVESelectCustomsReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.PVESelectCustomsReq
             * @static
             * @param {luck.protobuf.IPVESelectCustomsReq} message PVESelectCustomsReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PVESelectCustomsReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PVESelectCustomsReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.PVESelectCustomsReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.PVESelectCustomsReq} PVESelectCustomsReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PVESelectCustomsReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.PVESelectCustomsReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.customsType = reader.int32();
                        break;
                    case 2:
                        message.customsId = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("customsType"))
                    throw $util.ProtocolError("missing required 'customsType'", { instance: message });
                if (!message.hasOwnProperty("customsId"))
                    throw $util.ProtocolError("missing required 'customsId'", { instance: message });
                return message;
            };

            /**
             * Decodes a PVESelectCustomsReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.PVESelectCustomsReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.PVESelectCustomsReq} PVESelectCustomsReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PVESelectCustomsReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PVESelectCustomsReq message.
             * @function verify
             * @memberof luck.protobuf.PVESelectCustomsReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PVESelectCustomsReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.customsType))
                    return "customsType: integer expected";
                if (!$util.isInteger(message.customsId))
                    return "customsId: integer expected";
                return null;
            };

            return PVESelectCustomsReq;
        })();

        protobuf.QuitPVETeamReq = (function() {

            /**
             * Properties of a QuitPVETeamReq.
             * @memberof luck.protobuf
             * @interface IQuitPVETeamReq
             */

            /**
             * Constructs a new QuitPVETeamReq.
             * @memberof luck.protobuf
             * @classdesc Represents a QuitPVETeamReq.
             * @implements IQuitPVETeamReq
             * @constructor
             * @param {luck.protobuf.IQuitPVETeamReq=} [properties] Properties to set
             */
            function QuitPVETeamReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new QuitPVETeamReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.QuitPVETeamReq
             * @static
             * @param {luck.protobuf.IQuitPVETeamReq=} [properties] Properties to set
             * @returns {luck.protobuf.QuitPVETeamReq} QuitPVETeamReq instance
             */
            QuitPVETeamReq.create = function create(properties) {
                return new QuitPVETeamReq(properties);
            };

            /**
             * Encodes the specified QuitPVETeamReq message. Does not implicitly {@link luck.protobuf.QuitPVETeamReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.QuitPVETeamReq
             * @static
             * @param {luck.protobuf.IQuitPVETeamReq} message QuitPVETeamReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QuitPVETeamReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified QuitPVETeamReq message, length delimited. Does not implicitly {@link luck.protobuf.QuitPVETeamReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.QuitPVETeamReq
             * @static
             * @param {luck.protobuf.IQuitPVETeamReq} message QuitPVETeamReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QuitPVETeamReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QuitPVETeamReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.QuitPVETeamReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.QuitPVETeamReq} QuitPVETeamReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QuitPVETeamReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.QuitPVETeamReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QuitPVETeamReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.QuitPVETeamReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.QuitPVETeamReq} QuitPVETeamReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QuitPVETeamReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QuitPVETeamReq message.
             * @function verify
             * @memberof luck.protobuf.QuitPVETeamReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QuitPVETeamReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            return QuitPVETeamReq;
        })();

        protobuf.LoadGangShopReq = (function() {

            /**
             * Properties of a LoadGangShopReq.
             * @memberof luck.protobuf
             * @interface ILoadGangShopReq
             */

            /**
             * Constructs a new LoadGangShopReq.
             * @memberof luck.protobuf
             * @classdesc Represents a LoadGangShopReq.
             * @implements ILoadGangShopReq
             * @constructor
             * @param {luck.protobuf.ILoadGangShopReq=} [properties] Properties to set
             */
            function LoadGangShopReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new LoadGangShopReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.LoadGangShopReq
             * @static
             * @param {luck.protobuf.ILoadGangShopReq=} [properties] Properties to set
             * @returns {luck.protobuf.LoadGangShopReq} LoadGangShopReq instance
             */
            LoadGangShopReq.create = function create(properties) {
                return new LoadGangShopReq(properties);
            };

            /**
             * Encodes the specified LoadGangShopReq message. Does not implicitly {@link luck.protobuf.LoadGangShopReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.LoadGangShopReq
             * @static
             * @param {luck.protobuf.ILoadGangShopReq} message LoadGangShopReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LoadGangShopReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified LoadGangShopReq message, length delimited. Does not implicitly {@link luck.protobuf.LoadGangShopReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.LoadGangShopReq
             * @static
             * @param {luck.protobuf.ILoadGangShopReq} message LoadGangShopReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LoadGangShopReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LoadGangShopReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.LoadGangShopReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.LoadGangShopReq} LoadGangShopReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LoadGangShopReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.LoadGangShopReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LoadGangShopReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.LoadGangShopReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.LoadGangShopReq} LoadGangShopReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LoadGangShopReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LoadGangShopReq message.
             * @function verify
             * @memberof luck.protobuf.LoadGangShopReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LoadGangShopReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            return LoadGangShopReq;
        })();

        protobuf.GetPlayerInfoReq = (function() {

            /**
             * Properties of a GetPlayerInfoReq.
             * @memberof luck.protobuf
             * @interface IGetPlayerInfoReq
             * @property {Array.<number|Long>|null} [playerIdList] GetPlayerInfoReq playerIdList
             */

            /**
             * Constructs a new GetPlayerInfoReq.
             * @memberof luck.protobuf
             * @classdesc Represents a GetPlayerInfoReq.
             * @implements IGetPlayerInfoReq
             * @constructor
             * @param {luck.protobuf.IGetPlayerInfoReq=} [properties] Properties to set
             */
            function GetPlayerInfoReq(properties) {
                this.playerIdList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetPlayerInfoReq playerIdList.
             * @member {Array.<number|Long>} playerIdList
             * @memberof luck.protobuf.GetPlayerInfoReq
             * @instance
             */
            GetPlayerInfoReq.prototype.playerIdList = $util.emptyArray;

            /**
             * Creates a new GetPlayerInfoReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.GetPlayerInfoReq
             * @static
             * @param {luck.protobuf.IGetPlayerInfoReq=} [properties] Properties to set
             * @returns {luck.protobuf.GetPlayerInfoReq} GetPlayerInfoReq instance
             */
            GetPlayerInfoReq.create = function create(properties) {
                return new GetPlayerInfoReq(properties);
            };

            /**
             * Encodes the specified GetPlayerInfoReq message. Does not implicitly {@link luck.protobuf.GetPlayerInfoReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.GetPlayerInfoReq
             * @static
             * @param {luck.protobuf.IGetPlayerInfoReq} message GetPlayerInfoReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetPlayerInfoReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.playerIdList != null && message.playerIdList.length)
                    for (var i = 0; i < message.playerIdList.length; ++i)
                        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.playerIdList[i]);
                return writer;
            };

            /**
             * Encodes the specified GetPlayerInfoReq message, length delimited. Does not implicitly {@link luck.protobuf.GetPlayerInfoReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.GetPlayerInfoReq
             * @static
             * @param {luck.protobuf.IGetPlayerInfoReq} message GetPlayerInfoReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetPlayerInfoReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetPlayerInfoReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.GetPlayerInfoReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.GetPlayerInfoReq} GetPlayerInfoReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetPlayerInfoReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.GetPlayerInfoReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.playerIdList && message.playerIdList.length))
                            message.playerIdList = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.playerIdList.push(reader.int64());
                        } else
                            message.playerIdList.push(reader.int64());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetPlayerInfoReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.GetPlayerInfoReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.GetPlayerInfoReq} GetPlayerInfoReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetPlayerInfoReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetPlayerInfoReq message.
             * @function verify
             * @memberof luck.protobuf.GetPlayerInfoReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetPlayerInfoReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.playerIdList != null && message.hasOwnProperty("playerIdList")) {
                    if (!Array.isArray(message.playerIdList))
                        return "playerIdList: array expected";
                    for (var i = 0; i < message.playerIdList.length; ++i)
                        if (!$util.isInteger(message.playerIdList[i]) && !(message.playerIdList[i] && $util.isInteger(message.playerIdList[i].low) && $util.isInteger(message.playerIdList[i].high)))
                            return "playerIdList: integer|Long[] expected";
                }
                return null;
            };

            return GetPlayerInfoReq;
        })();

        protobuf.PVETeamStartBattleReq = (function() {

            /**
             * Properties of a PVETeamStartBattleReq.
             * @memberof luck.protobuf
             * @interface IPVETeamStartBattleReq
             */

            /**
             * Constructs a new PVETeamStartBattleReq.
             * @memberof luck.protobuf
             * @classdesc Represents a PVETeamStartBattleReq.
             * @implements IPVETeamStartBattleReq
             * @constructor
             * @param {luck.protobuf.IPVETeamStartBattleReq=} [properties] Properties to set
             */
            function PVETeamStartBattleReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new PVETeamStartBattleReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.PVETeamStartBattleReq
             * @static
             * @param {luck.protobuf.IPVETeamStartBattleReq=} [properties] Properties to set
             * @returns {luck.protobuf.PVETeamStartBattleReq} PVETeamStartBattleReq instance
             */
            PVETeamStartBattleReq.create = function create(properties) {
                return new PVETeamStartBattleReq(properties);
            };

            /**
             * Encodes the specified PVETeamStartBattleReq message. Does not implicitly {@link luck.protobuf.PVETeamStartBattleReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.PVETeamStartBattleReq
             * @static
             * @param {luck.protobuf.IPVETeamStartBattleReq} message PVETeamStartBattleReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PVETeamStartBattleReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified PVETeamStartBattleReq message, length delimited. Does not implicitly {@link luck.protobuf.PVETeamStartBattleReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.PVETeamStartBattleReq
             * @static
             * @param {luck.protobuf.IPVETeamStartBattleReq} message PVETeamStartBattleReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PVETeamStartBattleReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PVETeamStartBattleReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.PVETeamStartBattleReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.PVETeamStartBattleReq} PVETeamStartBattleReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PVETeamStartBattleReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.PVETeamStartBattleReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PVETeamStartBattleReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.PVETeamStartBattleReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.PVETeamStartBattleReq} PVETeamStartBattleReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PVETeamStartBattleReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PVETeamStartBattleReq message.
             * @function verify
             * @memberof luck.protobuf.PVETeamStartBattleReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PVETeamStartBattleReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            return PVETeamStartBattleReq;
        })();

        protobuf.gangShopBuyReq = (function() {

            /**
             * Properties of a gangShopBuyReq.
             * @memberof luck.protobuf
             * @interface IgangShopBuyReq
             * @property {number} num gangShopBuyReq num
             * @property {number} goodsId gangShopBuyReq goodsId
             */

            /**
             * Constructs a new gangShopBuyReq.
             * @memberof luck.protobuf
             * @classdesc Represents a gangShopBuyReq.
             * @implements IgangShopBuyReq
             * @constructor
             * @param {luck.protobuf.IgangShopBuyReq=} [properties] Properties to set
             */
            function gangShopBuyReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * gangShopBuyReq num.
             * @member {number} num
             * @memberof luck.protobuf.gangShopBuyReq
             * @instance
             */
            gangShopBuyReq.prototype.num = 0;

            /**
             * gangShopBuyReq goodsId.
             * @member {number} goodsId
             * @memberof luck.protobuf.gangShopBuyReq
             * @instance
             */
            gangShopBuyReq.prototype.goodsId = 0;

            /**
             * Creates a new gangShopBuyReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.gangShopBuyReq
             * @static
             * @param {luck.protobuf.IgangShopBuyReq=} [properties] Properties to set
             * @returns {luck.protobuf.gangShopBuyReq} gangShopBuyReq instance
             */
            gangShopBuyReq.create = function create(properties) {
                return new gangShopBuyReq(properties);
            };

            /**
             * Encodes the specified gangShopBuyReq message. Does not implicitly {@link luck.protobuf.gangShopBuyReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.gangShopBuyReq
             * @static
             * @param {luck.protobuf.IgangShopBuyReq} message gangShopBuyReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            gangShopBuyReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.num);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.goodsId);
                return writer;
            };

            /**
             * Encodes the specified gangShopBuyReq message, length delimited. Does not implicitly {@link luck.protobuf.gangShopBuyReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.gangShopBuyReq
             * @static
             * @param {luck.protobuf.IgangShopBuyReq} message gangShopBuyReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            gangShopBuyReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a gangShopBuyReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.gangShopBuyReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.gangShopBuyReq} gangShopBuyReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            gangShopBuyReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.gangShopBuyReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.num = reader.int32();
                        break;
                    case 2:
                        message.goodsId = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("num"))
                    throw $util.ProtocolError("missing required 'num'", { instance: message });
                if (!message.hasOwnProperty("goodsId"))
                    throw $util.ProtocolError("missing required 'goodsId'", { instance: message });
                return message;
            };

            /**
             * Decodes a gangShopBuyReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.gangShopBuyReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.gangShopBuyReq} gangShopBuyReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            gangShopBuyReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a gangShopBuyReq message.
             * @function verify
             * @memberof luck.protobuf.gangShopBuyReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            gangShopBuyReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.num))
                    return "num: integer expected";
                if (!$util.isInteger(message.goodsId))
                    return "goodsId: integer expected";
                return null;
            };

            return gangShopBuyReq;
        })();

        protobuf.playerFightingReq = (function() {

            /**
             * Properties of a playerFightingReq.
             * @memberof luck.protobuf
             * @interface IplayerFightingReq
             */

            /**
             * Constructs a new playerFightingReq.
             * @memberof luck.protobuf
             * @classdesc Represents a playerFightingReq.
             * @implements IplayerFightingReq
             * @constructor
             * @param {luck.protobuf.IplayerFightingReq=} [properties] Properties to set
             */
            function playerFightingReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new playerFightingReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.playerFightingReq
             * @static
             * @param {luck.protobuf.IplayerFightingReq=} [properties] Properties to set
             * @returns {luck.protobuf.playerFightingReq} playerFightingReq instance
             */
            playerFightingReq.create = function create(properties) {
                return new playerFightingReq(properties);
            };

            /**
             * Encodes the specified playerFightingReq message. Does not implicitly {@link luck.protobuf.playerFightingReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.playerFightingReq
             * @static
             * @param {luck.protobuf.IplayerFightingReq} message playerFightingReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            playerFightingReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified playerFightingReq message, length delimited. Does not implicitly {@link luck.protobuf.playerFightingReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.playerFightingReq
             * @static
             * @param {luck.protobuf.IplayerFightingReq} message playerFightingReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            playerFightingReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a playerFightingReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.playerFightingReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.playerFightingReq} playerFightingReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            playerFightingReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.playerFightingReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a playerFightingReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.playerFightingReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.playerFightingReq} playerFightingReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            playerFightingReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a playerFightingReq message.
             * @function verify
             * @memberof luck.protobuf.playerFightingReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            playerFightingReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            return playerFightingReq;
        })();

        protobuf.playerEquipFightingReq = (function() {

            /**
             * Properties of a playerEquipFightingReq.
             * @memberof luck.protobuf
             * @interface IplayerEquipFightingReq
             * @property {number|Long|null} [uid] playerEquipFightingReq uid
             * @property {number|null} [type] playerEquipFightingReq type
             * @property {number|null} [roleId] playerEquipFightingReq roleId
             */

            /**
             * Constructs a new playerEquipFightingReq.
             * @memberof luck.protobuf
             * @classdesc Represents a playerEquipFightingReq.
             * @implements IplayerEquipFightingReq
             * @constructor
             * @param {luck.protobuf.IplayerEquipFightingReq=} [properties] Properties to set
             */
            function playerEquipFightingReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * playerEquipFightingReq uid.
             * @member {number|Long} uid
             * @memberof luck.protobuf.playerEquipFightingReq
             * @instance
             */
            playerEquipFightingReq.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * playerEquipFightingReq type.
             * @member {number} type
             * @memberof luck.protobuf.playerEquipFightingReq
             * @instance
             */
            playerEquipFightingReq.prototype.type = 0;

            /**
             * playerEquipFightingReq roleId.
             * @member {number} roleId
             * @memberof luck.protobuf.playerEquipFightingReq
             * @instance
             */
            playerEquipFightingReq.prototype.roleId = 0;

            /**
             * Creates a new playerEquipFightingReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.playerEquipFightingReq
             * @static
             * @param {luck.protobuf.IplayerEquipFightingReq=} [properties] Properties to set
             * @returns {luck.protobuf.playerEquipFightingReq} playerEquipFightingReq instance
             */
            playerEquipFightingReq.create = function create(properties) {
                return new playerEquipFightingReq(properties);
            };

            /**
             * Encodes the specified playerEquipFightingReq message. Does not implicitly {@link luck.protobuf.playerEquipFightingReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.playerEquipFightingReq
             * @static
             * @param {luck.protobuf.IplayerEquipFightingReq} message playerEquipFightingReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            playerEquipFightingReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uid != null && message.hasOwnProperty("uid"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.uid);
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                if (message.roleId != null && message.hasOwnProperty("roleId"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.roleId);
                return writer;
            };

            /**
             * Encodes the specified playerEquipFightingReq message, length delimited. Does not implicitly {@link luck.protobuf.playerEquipFightingReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.playerEquipFightingReq
             * @static
             * @param {luck.protobuf.IplayerEquipFightingReq} message playerEquipFightingReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            playerEquipFightingReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a playerEquipFightingReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.playerEquipFightingReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.playerEquipFightingReq} playerEquipFightingReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            playerEquipFightingReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.playerEquipFightingReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.uid = reader.int64();
                        break;
                    case 2:
                        message.type = reader.int32();
                        break;
                    case 3:
                        message.roleId = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a playerEquipFightingReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.playerEquipFightingReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.playerEquipFightingReq} playerEquipFightingReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            playerEquipFightingReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a playerEquipFightingReq message.
             * @function verify
             * @memberof luck.protobuf.playerEquipFightingReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            playerEquipFightingReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.uid != null && message.hasOwnProperty("uid"))
                    if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                        return "uid: integer|Long expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isInteger(message.type))
                        return "type: integer expected";
                if (message.roleId != null && message.hasOwnProperty("roleId"))
                    if (!$util.isInteger(message.roleId))
                        return "roleId: integer expected";
                return null;
            };

            return playerEquipFightingReq;
        })();

        protobuf.rankingReq = (function() {

            /**
             * Properties of a rankingReq.
             * @memberof luck.protobuf
             * @interface IrankingReq
             * @property {number} type rankingReq type
             */

            /**
             * Constructs a new rankingReq.
             * @memberof luck.protobuf
             * @classdesc Represents a rankingReq.
             * @implements IrankingReq
             * @constructor
             * @param {luck.protobuf.IrankingReq=} [properties] Properties to set
             */
            function rankingReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * rankingReq type.
             * @member {number} type
             * @memberof luck.protobuf.rankingReq
             * @instance
             */
            rankingReq.prototype.type = 0;

            /**
             * Creates a new rankingReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.rankingReq
             * @static
             * @param {luck.protobuf.IrankingReq=} [properties] Properties to set
             * @returns {luck.protobuf.rankingReq} rankingReq instance
             */
            rankingReq.create = function create(properties) {
                return new rankingReq(properties);
            };

            /**
             * Encodes the specified rankingReq message. Does not implicitly {@link luck.protobuf.rankingReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.rankingReq
             * @static
             * @param {luck.protobuf.IrankingReq} message rankingReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            rankingReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                return writer;
            };

            /**
             * Encodes the specified rankingReq message, length delimited. Does not implicitly {@link luck.protobuf.rankingReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.rankingReq
             * @static
             * @param {luck.protobuf.IrankingReq} message rankingReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            rankingReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a rankingReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.rankingReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.rankingReq} rankingReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            rankingReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.rankingReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("type"))
                    throw $util.ProtocolError("missing required 'type'", { instance: message });
                return message;
            };

            /**
             * Decodes a rankingReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.rankingReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.rankingReq} rankingReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            rankingReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a rankingReq message.
             * @function verify
             * @memberof luck.protobuf.rankingReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            rankingReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
                return null;
            };

            return rankingReq;
        })();

        protobuf.gainAchievementSeriesAwardReq = (function() {

            /**
             * Properties of a gainAchievementSeriesAwardReq.
             * @memberof luck.protobuf
             * @interface IgainAchievementSeriesAwardReq
             * @property {number} achievementSeriesId gainAchievementSeriesAwardReq achievementSeriesId
             * @property {number} type gainAchievementSeriesAwardReq type
             */

            /**
             * Constructs a new gainAchievementSeriesAwardReq.
             * @memberof luck.protobuf
             * @classdesc Represents a gainAchievementSeriesAwardReq.
             * @implements IgainAchievementSeriesAwardReq
             * @constructor
             * @param {luck.protobuf.IgainAchievementSeriesAwardReq=} [properties] Properties to set
             */
            function gainAchievementSeriesAwardReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * gainAchievementSeriesAwardReq achievementSeriesId.
             * @member {number} achievementSeriesId
             * @memberof luck.protobuf.gainAchievementSeriesAwardReq
             * @instance
             */
            gainAchievementSeriesAwardReq.prototype.achievementSeriesId = 0;

            /**
             * gainAchievementSeriesAwardReq type.
             * @member {number} type
             * @memberof luck.protobuf.gainAchievementSeriesAwardReq
             * @instance
             */
            gainAchievementSeriesAwardReq.prototype.type = 0;

            /**
             * Creates a new gainAchievementSeriesAwardReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.gainAchievementSeriesAwardReq
             * @static
             * @param {luck.protobuf.IgainAchievementSeriesAwardReq=} [properties] Properties to set
             * @returns {luck.protobuf.gainAchievementSeriesAwardReq} gainAchievementSeriesAwardReq instance
             */
            gainAchievementSeriesAwardReq.create = function create(properties) {
                return new gainAchievementSeriesAwardReq(properties);
            };

            /**
             * Encodes the specified gainAchievementSeriesAwardReq message. Does not implicitly {@link luck.protobuf.gainAchievementSeriesAwardReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.gainAchievementSeriesAwardReq
             * @static
             * @param {luck.protobuf.IgainAchievementSeriesAwardReq} message gainAchievementSeriesAwardReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            gainAchievementSeriesAwardReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.achievementSeriesId);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                return writer;
            };

            /**
             * Encodes the specified gainAchievementSeriesAwardReq message, length delimited. Does not implicitly {@link luck.protobuf.gainAchievementSeriesAwardReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.gainAchievementSeriesAwardReq
             * @static
             * @param {luck.protobuf.IgainAchievementSeriesAwardReq} message gainAchievementSeriesAwardReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            gainAchievementSeriesAwardReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a gainAchievementSeriesAwardReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.gainAchievementSeriesAwardReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.gainAchievementSeriesAwardReq} gainAchievementSeriesAwardReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            gainAchievementSeriesAwardReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.gainAchievementSeriesAwardReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.achievementSeriesId = reader.int32();
                        break;
                    case 2:
                        message.type = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("achievementSeriesId"))
                    throw $util.ProtocolError("missing required 'achievementSeriesId'", { instance: message });
                if (!message.hasOwnProperty("type"))
                    throw $util.ProtocolError("missing required 'type'", { instance: message });
                return message;
            };

            /**
             * Decodes a gainAchievementSeriesAwardReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.gainAchievementSeriesAwardReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.gainAchievementSeriesAwardReq} gainAchievementSeriesAwardReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            gainAchievementSeriesAwardReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a gainAchievementSeriesAwardReq message.
             * @function verify
             * @memberof luck.protobuf.gainAchievementSeriesAwardReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            gainAchievementSeriesAwardReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.achievementSeriesId))
                    return "achievementSeriesId: integer expected";
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
                return null;
            };

            return gainAchievementSeriesAwardReq;
        })();

        protobuf.drawVipRewardReq = (function() {

            /**
             * Properties of a drawVipRewardReq.
             * @memberof luck.protobuf
             * @interface IdrawVipRewardReq
             * @property {number} type drawVipRewardReq type
             */

            /**
             * Constructs a new drawVipRewardReq.
             * @memberof luck.protobuf
             * @classdesc Represents a drawVipRewardReq.
             * @implements IdrawVipRewardReq
             * @constructor
             * @param {luck.protobuf.IdrawVipRewardReq=} [properties] Properties to set
             */
            function drawVipRewardReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * drawVipRewardReq type.
             * @member {number} type
             * @memberof luck.protobuf.drawVipRewardReq
             * @instance
             */
            drawVipRewardReq.prototype.type = 0;

            /**
             * Creates a new drawVipRewardReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.drawVipRewardReq
             * @static
             * @param {luck.protobuf.IdrawVipRewardReq=} [properties] Properties to set
             * @returns {luck.protobuf.drawVipRewardReq} drawVipRewardReq instance
             */
            drawVipRewardReq.create = function create(properties) {
                return new drawVipRewardReq(properties);
            };

            /**
             * Encodes the specified drawVipRewardReq message. Does not implicitly {@link luck.protobuf.drawVipRewardReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.drawVipRewardReq
             * @static
             * @param {luck.protobuf.IdrawVipRewardReq} message drawVipRewardReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            drawVipRewardReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                return writer;
            };

            /**
             * Encodes the specified drawVipRewardReq message, length delimited. Does not implicitly {@link luck.protobuf.drawVipRewardReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.drawVipRewardReq
             * @static
             * @param {luck.protobuf.IdrawVipRewardReq} message drawVipRewardReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            drawVipRewardReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a drawVipRewardReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.drawVipRewardReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.drawVipRewardReq} drawVipRewardReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            drawVipRewardReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.drawVipRewardReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("type"))
                    throw $util.ProtocolError("missing required 'type'", { instance: message });
                return message;
            };

            /**
             * Decodes a drawVipRewardReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.drawVipRewardReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.drawVipRewardReq} drawVipRewardReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            drawVipRewardReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a drawVipRewardReq message.
             * @function verify
             * @memberof luck.protobuf.drawVipRewardReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            drawVipRewardReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
                return null;
            };

            return drawVipRewardReq;
        })();

        protobuf.rechargeReq = (function() {

            /**
             * Properties of a rechargeReq.
             * @memberof luck.protobuf
             * @interface IrechargeReq
             * @property {number} rechargeId rechargeReq rechargeId
             */

            /**
             * Constructs a new rechargeReq.
             * @memberof luck.protobuf
             * @classdesc Represents a rechargeReq.
             * @implements IrechargeReq
             * @constructor
             * @param {luck.protobuf.IrechargeReq=} [properties] Properties to set
             */
            function rechargeReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * rechargeReq rechargeId.
             * @member {number} rechargeId
             * @memberof luck.protobuf.rechargeReq
             * @instance
             */
            rechargeReq.prototype.rechargeId = 0;

            /**
             * Creates a new rechargeReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.rechargeReq
             * @static
             * @param {luck.protobuf.IrechargeReq=} [properties] Properties to set
             * @returns {luck.protobuf.rechargeReq} rechargeReq instance
             */
            rechargeReq.create = function create(properties) {
                return new rechargeReq(properties);
            };

            /**
             * Encodes the specified rechargeReq message. Does not implicitly {@link luck.protobuf.rechargeReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.rechargeReq
             * @static
             * @param {luck.protobuf.IrechargeReq} message rechargeReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            rechargeReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.rechargeId);
                return writer;
            };

            /**
             * Encodes the specified rechargeReq message, length delimited. Does not implicitly {@link luck.protobuf.rechargeReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.rechargeReq
             * @static
             * @param {luck.protobuf.IrechargeReq} message rechargeReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            rechargeReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a rechargeReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.rechargeReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.rechargeReq} rechargeReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            rechargeReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.rechargeReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.rechargeId = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("rechargeId"))
                    throw $util.ProtocolError("missing required 'rechargeId'", { instance: message });
                return message;
            };

            /**
             * Decodes a rechargeReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.rechargeReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.rechargeReq} rechargeReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            rechargeReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a rechargeReq message.
             * @function verify
             * @memberof luck.protobuf.rechargeReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            rechargeReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.rechargeId))
                    return "rechargeId: integer expected";
                return null;
            };

            return rechargeReq;
        })();

        protobuf.noticeReq = (function() {

            /**
             * Properties of a noticeReq.
             * @memberof luck.protobuf
             * @interface InoticeReq
             */

            /**
             * Constructs a new noticeReq.
             * @memberof luck.protobuf
             * @classdesc Represents a noticeReq.
             * @implements InoticeReq
             * @constructor
             * @param {luck.protobuf.InoticeReq=} [properties] Properties to set
             */
            function noticeReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new noticeReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.noticeReq
             * @static
             * @param {luck.protobuf.InoticeReq=} [properties] Properties to set
             * @returns {luck.protobuf.noticeReq} noticeReq instance
             */
            noticeReq.create = function create(properties) {
                return new noticeReq(properties);
            };

            /**
             * Encodes the specified noticeReq message. Does not implicitly {@link luck.protobuf.noticeReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.noticeReq
             * @static
             * @param {luck.protobuf.InoticeReq} message noticeReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            noticeReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified noticeReq message, length delimited. Does not implicitly {@link luck.protobuf.noticeReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.noticeReq
             * @static
             * @param {luck.protobuf.InoticeReq} message noticeReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            noticeReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a noticeReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.noticeReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.noticeReq} noticeReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            noticeReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.noticeReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a noticeReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.noticeReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.noticeReq} noticeReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            noticeReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a noticeReq message.
             * @function verify
             * @memberof luck.protobuf.noticeReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            noticeReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            return noticeReq;
        })();

        protobuf.addBlackListReq = (function() {

            /**
             * Properties of an addBlackListReq.
             * @memberof luck.protobuf
             * @interface IaddBlackListReq
             * @property {number|Long} blackLId addBlackListReq blackLId
             */

            /**
             * Constructs a new addBlackListReq.
             * @memberof luck.protobuf
             * @classdesc Represents an addBlackListReq.
             * @implements IaddBlackListReq
             * @constructor
             * @param {luck.protobuf.IaddBlackListReq=} [properties] Properties to set
             */
            function addBlackListReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * addBlackListReq blackLId.
             * @member {number|Long} blackLId
             * @memberof luck.protobuf.addBlackListReq
             * @instance
             */
            addBlackListReq.prototype.blackLId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new addBlackListReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.addBlackListReq
             * @static
             * @param {luck.protobuf.IaddBlackListReq=} [properties] Properties to set
             * @returns {luck.protobuf.addBlackListReq} addBlackListReq instance
             */
            addBlackListReq.create = function create(properties) {
                return new addBlackListReq(properties);
            };

            /**
             * Encodes the specified addBlackListReq message. Does not implicitly {@link luck.protobuf.addBlackListReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.addBlackListReq
             * @static
             * @param {luck.protobuf.IaddBlackListReq} message addBlackListReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            addBlackListReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.blackLId);
                return writer;
            };

            /**
             * Encodes the specified addBlackListReq message, length delimited. Does not implicitly {@link luck.protobuf.addBlackListReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.addBlackListReq
             * @static
             * @param {luck.protobuf.IaddBlackListReq} message addBlackListReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            addBlackListReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an addBlackListReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.addBlackListReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.addBlackListReq} addBlackListReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            addBlackListReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.addBlackListReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.blackLId = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("blackLId"))
                    throw $util.ProtocolError("missing required 'blackLId'", { instance: message });
                return message;
            };

            /**
             * Decodes an addBlackListReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.addBlackListReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.addBlackListReq} addBlackListReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            addBlackListReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an addBlackListReq message.
             * @function verify
             * @memberof luck.protobuf.addBlackListReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            addBlackListReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.blackLId) && !(message.blackLId && $util.isInteger(message.blackLId.low) && $util.isInteger(message.blackLId.high)))
                    return "blackLId: integer|Long expected";
                return null;
            };

            return addBlackListReq;
        })();

        protobuf.delBlackListReq = (function() {

            /**
             * Properties of a delBlackListReq.
             * @memberof luck.protobuf
             * @interface IdelBlackListReq
             * @property {number|Long} blackLId delBlackListReq blackLId
             */

            /**
             * Constructs a new delBlackListReq.
             * @memberof luck.protobuf
             * @classdesc Represents a delBlackListReq.
             * @implements IdelBlackListReq
             * @constructor
             * @param {luck.protobuf.IdelBlackListReq=} [properties] Properties to set
             */
            function delBlackListReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * delBlackListReq blackLId.
             * @member {number|Long} blackLId
             * @memberof luck.protobuf.delBlackListReq
             * @instance
             */
            delBlackListReq.prototype.blackLId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new delBlackListReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.delBlackListReq
             * @static
             * @param {luck.protobuf.IdelBlackListReq=} [properties] Properties to set
             * @returns {luck.protobuf.delBlackListReq} delBlackListReq instance
             */
            delBlackListReq.create = function create(properties) {
                return new delBlackListReq(properties);
            };

            /**
             * Encodes the specified delBlackListReq message. Does not implicitly {@link luck.protobuf.delBlackListReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.delBlackListReq
             * @static
             * @param {luck.protobuf.IdelBlackListReq} message delBlackListReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            delBlackListReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.blackLId);
                return writer;
            };

            /**
             * Encodes the specified delBlackListReq message, length delimited. Does not implicitly {@link luck.protobuf.delBlackListReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.delBlackListReq
             * @static
             * @param {luck.protobuf.IdelBlackListReq} message delBlackListReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            delBlackListReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a delBlackListReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.delBlackListReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.delBlackListReq} delBlackListReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            delBlackListReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.delBlackListReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.blackLId = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("blackLId"))
                    throw $util.ProtocolError("missing required 'blackLId'", { instance: message });
                return message;
            };

            /**
             * Decodes a delBlackListReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.delBlackListReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.delBlackListReq} delBlackListReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            delBlackListReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a delBlackListReq message.
             * @function verify
             * @memberof luck.protobuf.delBlackListReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            delBlackListReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.blackLId) && !(message.blackLId && $util.isInteger(message.blackLId.low) && $util.isInteger(message.blackLId.high)))
                    return "blackLId: integer|Long expected";
                return null;
            };

            return delBlackListReq;
        })();

        protobuf.buyGrowthCapitalReq = (function() {

            /**
             * Properties of a buyGrowthCapitalReq.
             * @memberof luck.protobuf
             * @interface IbuyGrowthCapitalReq
             */

            /**
             * Constructs a new buyGrowthCapitalReq.
             * @memberof luck.protobuf
             * @classdesc Represents a buyGrowthCapitalReq.
             * @implements IbuyGrowthCapitalReq
             * @constructor
             * @param {luck.protobuf.IbuyGrowthCapitalReq=} [properties] Properties to set
             */
            function buyGrowthCapitalReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new buyGrowthCapitalReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.buyGrowthCapitalReq
             * @static
             * @param {luck.protobuf.IbuyGrowthCapitalReq=} [properties] Properties to set
             * @returns {luck.protobuf.buyGrowthCapitalReq} buyGrowthCapitalReq instance
             */
            buyGrowthCapitalReq.create = function create(properties) {
                return new buyGrowthCapitalReq(properties);
            };

            /**
             * Encodes the specified buyGrowthCapitalReq message. Does not implicitly {@link luck.protobuf.buyGrowthCapitalReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.buyGrowthCapitalReq
             * @static
             * @param {luck.protobuf.IbuyGrowthCapitalReq} message buyGrowthCapitalReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            buyGrowthCapitalReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified buyGrowthCapitalReq message, length delimited. Does not implicitly {@link luck.protobuf.buyGrowthCapitalReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.buyGrowthCapitalReq
             * @static
             * @param {luck.protobuf.IbuyGrowthCapitalReq} message buyGrowthCapitalReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            buyGrowthCapitalReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a buyGrowthCapitalReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.buyGrowthCapitalReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.buyGrowthCapitalReq} buyGrowthCapitalReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            buyGrowthCapitalReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.buyGrowthCapitalReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a buyGrowthCapitalReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.buyGrowthCapitalReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.buyGrowthCapitalReq} buyGrowthCapitalReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            buyGrowthCapitalReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a buyGrowthCapitalReq message.
             * @function verify
             * @memberof luck.protobuf.buyGrowthCapitalReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            buyGrowthCapitalReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            return buyGrowthCapitalReq;
        })();

        protobuf.loadActivityShopReq = (function() {

            /**
             * Properties of a loadActivityShopReq.
             * @memberof luck.protobuf
             * @interface IloadActivityShopReq
             */

            /**
             * Constructs a new loadActivityShopReq.
             * @memberof luck.protobuf
             * @classdesc Represents a loadActivityShopReq.
             * @implements IloadActivityShopReq
             * @constructor
             * @param {luck.protobuf.IloadActivityShopReq=} [properties] Properties to set
             */
            function loadActivityShopReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new loadActivityShopReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.loadActivityShopReq
             * @static
             * @param {luck.protobuf.IloadActivityShopReq=} [properties] Properties to set
             * @returns {luck.protobuf.loadActivityShopReq} loadActivityShopReq instance
             */
            loadActivityShopReq.create = function create(properties) {
                return new loadActivityShopReq(properties);
            };

            /**
             * Encodes the specified loadActivityShopReq message. Does not implicitly {@link luck.protobuf.loadActivityShopReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.loadActivityShopReq
             * @static
             * @param {luck.protobuf.IloadActivityShopReq} message loadActivityShopReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            loadActivityShopReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified loadActivityShopReq message, length delimited. Does not implicitly {@link luck.protobuf.loadActivityShopReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.loadActivityShopReq
             * @static
             * @param {luck.protobuf.IloadActivityShopReq} message loadActivityShopReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            loadActivityShopReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a loadActivityShopReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.loadActivityShopReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.loadActivityShopReq} loadActivityShopReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            loadActivityShopReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.loadActivityShopReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a loadActivityShopReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.loadActivityShopReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.loadActivityShopReq} loadActivityShopReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            loadActivityShopReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a loadActivityShopReq message.
             * @function verify
             * @memberof luck.protobuf.loadActivityShopReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            loadActivityShopReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            return loadActivityShopReq;
        })();

        protobuf.activityShopBuyReq = (function() {

            /**
             * Properties of an activityShopBuyReq.
             * @memberof luck.protobuf
             * @interface IactivityShopBuyReq
             * @property {number} num activityShopBuyReq num
             * @property {number} goodsId activityShopBuyReq goodsId
             */

            /**
             * Constructs a new activityShopBuyReq.
             * @memberof luck.protobuf
             * @classdesc Represents an activityShopBuyReq.
             * @implements IactivityShopBuyReq
             * @constructor
             * @param {luck.protobuf.IactivityShopBuyReq=} [properties] Properties to set
             */
            function activityShopBuyReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * activityShopBuyReq num.
             * @member {number} num
             * @memberof luck.protobuf.activityShopBuyReq
             * @instance
             */
            activityShopBuyReq.prototype.num = 0;

            /**
             * activityShopBuyReq goodsId.
             * @member {number} goodsId
             * @memberof luck.protobuf.activityShopBuyReq
             * @instance
             */
            activityShopBuyReq.prototype.goodsId = 0;

            /**
             * Creates a new activityShopBuyReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.activityShopBuyReq
             * @static
             * @param {luck.protobuf.IactivityShopBuyReq=} [properties] Properties to set
             * @returns {luck.protobuf.activityShopBuyReq} activityShopBuyReq instance
             */
            activityShopBuyReq.create = function create(properties) {
                return new activityShopBuyReq(properties);
            };

            /**
             * Encodes the specified activityShopBuyReq message. Does not implicitly {@link luck.protobuf.activityShopBuyReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.activityShopBuyReq
             * @static
             * @param {luck.protobuf.IactivityShopBuyReq} message activityShopBuyReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            activityShopBuyReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.num);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.goodsId);
                return writer;
            };

            /**
             * Encodes the specified activityShopBuyReq message, length delimited. Does not implicitly {@link luck.protobuf.activityShopBuyReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.activityShopBuyReq
             * @static
             * @param {luck.protobuf.IactivityShopBuyReq} message activityShopBuyReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            activityShopBuyReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an activityShopBuyReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.activityShopBuyReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.activityShopBuyReq} activityShopBuyReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            activityShopBuyReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.activityShopBuyReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.num = reader.int32();
                        break;
                    case 2:
                        message.goodsId = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("num"))
                    throw $util.ProtocolError("missing required 'num'", { instance: message });
                if (!message.hasOwnProperty("goodsId"))
                    throw $util.ProtocolError("missing required 'goodsId'", { instance: message });
                return message;
            };

            /**
             * Decodes an activityShopBuyReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.activityShopBuyReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.activityShopBuyReq} activityShopBuyReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            activityShopBuyReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an activityShopBuyReq message.
             * @function verify
             * @memberof luck.protobuf.activityShopBuyReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            activityShopBuyReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.num))
                    return "num: integer expected";
                if (!$util.isInteger(message.goodsId))
                    return "goodsId: integer expected";
                return null;
            };

            return activityShopBuyReq;
        })();

        protobuf.getDiggingReq = (function() {

            /**
             * Properties of a getDiggingReq.
             * @memberof luck.protobuf
             * @interface IgetDiggingReq
             */

            /**
             * Constructs a new getDiggingReq.
             * @memberof luck.protobuf
             * @classdesc Represents a getDiggingReq.
             * @implements IgetDiggingReq
             * @constructor
             * @param {luck.protobuf.IgetDiggingReq=} [properties] Properties to set
             */
            function getDiggingReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new getDiggingReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.getDiggingReq
             * @static
             * @param {luck.protobuf.IgetDiggingReq=} [properties] Properties to set
             * @returns {luck.protobuf.getDiggingReq} getDiggingReq instance
             */
            getDiggingReq.create = function create(properties) {
                return new getDiggingReq(properties);
            };

            /**
             * Encodes the specified getDiggingReq message. Does not implicitly {@link luck.protobuf.getDiggingReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.getDiggingReq
             * @static
             * @param {luck.protobuf.IgetDiggingReq} message getDiggingReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            getDiggingReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified getDiggingReq message, length delimited. Does not implicitly {@link luck.protobuf.getDiggingReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.getDiggingReq
             * @static
             * @param {luck.protobuf.IgetDiggingReq} message getDiggingReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            getDiggingReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a getDiggingReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.getDiggingReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.getDiggingReq} getDiggingReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            getDiggingReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.getDiggingReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a getDiggingReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.getDiggingReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.getDiggingReq} getDiggingReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            getDiggingReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a getDiggingReq message.
             * @function verify
             * @memberof luck.protobuf.getDiggingReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            getDiggingReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            return getDiggingReq;
        })();

        protobuf.refreshDiggingReq = (function() {

            /**
             * Properties of a refreshDiggingReq.
             * @memberof luck.protobuf
             * @interface IrefreshDiggingReq
             * @property {number} mineId refreshDiggingReq mineId
             */

            /**
             * Constructs a new refreshDiggingReq.
             * @memberof luck.protobuf
             * @classdesc Represents a refreshDiggingReq.
             * @implements IrefreshDiggingReq
             * @constructor
             * @param {luck.protobuf.IrefreshDiggingReq=} [properties] Properties to set
             */
            function refreshDiggingReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * refreshDiggingReq mineId.
             * @member {number} mineId
             * @memberof luck.protobuf.refreshDiggingReq
             * @instance
             */
            refreshDiggingReq.prototype.mineId = 0;

            /**
             * Creates a new refreshDiggingReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.refreshDiggingReq
             * @static
             * @param {luck.protobuf.IrefreshDiggingReq=} [properties] Properties to set
             * @returns {luck.protobuf.refreshDiggingReq} refreshDiggingReq instance
             */
            refreshDiggingReq.create = function create(properties) {
                return new refreshDiggingReq(properties);
            };

            /**
             * Encodes the specified refreshDiggingReq message. Does not implicitly {@link luck.protobuf.refreshDiggingReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.refreshDiggingReq
             * @static
             * @param {luck.protobuf.IrefreshDiggingReq} message refreshDiggingReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            refreshDiggingReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.mineId);
                return writer;
            };

            /**
             * Encodes the specified refreshDiggingReq message, length delimited. Does not implicitly {@link luck.protobuf.refreshDiggingReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.refreshDiggingReq
             * @static
             * @param {luck.protobuf.IrefreshDiggingReq} message refreshDiggingReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            refreshDiggingReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a refreshDiggingReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.refreshDiggingReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.refreshDiggingReq} refreshDiggingReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            refreshDiggingReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.refreshDiggingReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.mineId = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("mineId"))
                    throw $util.ProtocolError("missing required 'mineId'", { instance: message });
                return message;
            };

            /**
             * Decodes a refreshDiggingReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.refreshDiggingReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.refreshDiggingReq} refreshDiggingReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            refreshDiggingReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a refreshDiggingReq message.
             * @function verify
             * @memberof luck.protobuf.refreshDiggingReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            refreshDiggingReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.mineId))
                    return "mineId: integer expected";
                return null;
            };

            return refreshDiggingReq;
        })();

        protobuf.getDiggingAwardReq = (function() {

            /**
             * Properties of a getDiggingAwardReq.
             * @memberof luck.protobuf
             * @interface IgetDiggingAwardReq
             * @property {number} mineId getDiggingAwardReq mineId
             */

            /**
             * Constructs a new getDiggingAwardReq.
             * @memberof luck.protobuf
             * @classdesc Represents a getDiggingAwardReq.
             * @implements IgetDiggingAwardReq
             * @constructor
             * @param {luck.protobuf.IgetDiggingAwardReq=} [properties] Properties to set
             */
            function getDiggingAwardReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * getDiggingAwardReq mineId.
             * @member {number} mineId
             * @memberof luck.protobuf.getDiggingAwardReq
             * @instance
             */
            getDiggingAwardReq.prototype.mineId = 0;

            /**
             * Creates a new getDiggingAwardReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.getDiggingAwardReq
             * @static
             * @param {luck.protobuf.IgetDiggingAwardReq=} [properties] Properties to set
             * @returns {luck.protobuf.getDiggingAwardReq} getDiggingAwardReq instance
             */
            getDiggingAwardReq.create = function create(properties) {
                return new getDiggingAwardReq(properties);
            };

            /**
             * Encodes the specified getDiggingAwardReq message. Does not implicitly {@link luck.protobuf.getDiggingAwardReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.getDiggingAwardReq
             * @static
             * @param {luck.protobuf.IgetDiggingAwardReq} message getDiggingAwardReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            getDiggingAwardReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.mineId);
                return writer;
            };

            /**
             * Encodes the specified getDiggingAwardReq message, length delimited. Does not implicitly {@link luck.protobuf.getDiggingAwardReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.getDiggingAwardReq
             * @static
             * @param {luck.protobuf.IgetDiggingAwardReq} message getDiggingAwardReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            getDiggingAwardReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a getDiggingAwardReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.getDiggingAwardReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.getDiggingAwardReq} getDiggingAwardReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            getDiggingAwardReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.getDiggingAwardReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.mineId = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("mineId"))
                    throw $util.ProtocolError("missing required 'mineId'", { instance: message });
                return message;
            };

            /**
             * Decodes a getDiggingAwardReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.getDiggingAwardReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.getDiggingAwardReq} getDiggingAwardReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            getDiggingAwardReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a getDiggingAwardReq message.
             * @function verify
             * @memberof luck.protobuf.getDiggingAwardReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            getDiggingAwardReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.mineId))
                    return "mineId: integer expected";
                return null;
            };

            return getDiggingAwardReq;
        })();

        protobuf.StartDiggingPointReq = (function() {

            /**
             * Properties of a StartDiggingPointReq.
             * @memberof luck.protobuf
             * @interface IStartDiggingPointReq
             * @property {number} checkNodeId StartDiggingPointReq checkNodeId
             * @property {number} mineId StartDiggingPointReq mineId
             */

            /**
             * Constructs a new StartDiggingPointReq.
             * @memberof luck.protobuf
             * @classdesc Represents a StartDiggingPointReq.
             * @implements IStartDiggingPointReq
             * @constructor
             * @param {luck.protobuf.IStartDiggingPointReq=} [properties] Properties to set
             */
            function StartDiggingPointReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StartDiggingPointReq checkNodeId.
             * @member {number} checkNodeId
             * @memberof luck.protobuf.StartDiggingPointReq
             * @instance
             */
            StartDiggingPointReq.prototype.checkNodeId = 0;

            /**
             * StartDiggingPointReq mineId.
             * @member {number} mineId
             * @memberof luck.protobuf.StartDiggingPointReq
             * @instance
             */
            StartDiggingPointReq.prototype.mineId = 0;

            /**
             * Creates a new StartDiggingPointReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.StartDiggingPointReq
             * @static
             * @param {luck.protobuf.IStartDiggingPointReq=} [properties] Properties to set
             * @returns {luck.protobuf.StartDiggingPointReq} StartDiggingPointReq instance
             */
            StartDiggingPointReq.create = function create(properties) {
                return new StartDiggingPointReq(properties);
            };

            /**
             * Encodes the specified StartDiggingPointReq message. Does not implicitly {@link luck.protobuf.StartDiggingPointReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.StartDiggingPointReq
             * @static
             * @param {luck.protobuf.IStartDiggingPointReq} message StartDiggingPointReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StartDiggingPointReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.checkNodeId);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.mineId);
                return writer;
            };

            /**
             * Encodes the specified StartDiggingPointReq message, length delimited. Does not implicitly {@link luck.protobuf.StartDiggingPointReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.StartDiggingPointReq
             * @static
             * @param {luck.protobuf.IStartDiggingPointReq} message StartDiggingPointReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StartDiggingPointReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StartDiggingPointReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.StartDiggingPointReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.StartDiggingPointReq} StartDiggingPointReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StartDiggingPointReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.StartDiggingPointReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.checkNodeId = reader.int32();
                        break;
                    case 2:
                        message.mineId = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("checkNodeId"))
                    throw $util.ProtocolError("missing required 'checkNodeId'", { instance: message });
                if (!message.hasOwnProperty("mineId"))
                    throw $util.ProtocolError("missing required 'mineId'", { instance: message });
                return message;
            };

            /**
             * Decodes a StartDiggingPointReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.StartDiggingPointReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.StartDiggingPointReq} StartDiggingPointReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StartDiggingPointReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StartDiggingPointReq message.
             * @function verify
             * @memberof luck.protobuf.StartDiggingPointReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StartDiggingPointReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.checkNodeId))
                    return "checkNodeId: integer expected";
                if (!$util.isInteger(message.mineId))
                    return "mineId: integer expected";
                return null;
            };

            return StartDiggingPointReq;
        })();

        protobuf.FinishDiggingPointReq = (function() {

            /**
             * Properties of a FinishDiggingPointReq.
             * @memberof luck.protobuf
             * @interface IFinishDiggingPointReq
             * @property {number} checkNodeId FinishDiggingPointReq checkNodeId
             * @property {number} fightResult FinishDiggingPointReq fightResult
             * @property {number} mineId FinishDiggingPointReq mineId
             */

            /**
             * Constructs a new FinishDiggingPointReq.
             * @memberof luck.protobuf
             * @classdesc Represents a FinishDiggingPointReq.
             * @implements IFinishDiggingPointReq
             * @constructor
             * @param {luck.protobuf.IFinishDiggingPointReq=} [properties] Properties to set
             */
            function FinishDiggingPointReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FinishDiggingPointReq checkNodeId.
             * @member {number} checkNodeId
             * @memberof luck.protobuf.FinishDiggingPointReq
             * @instance
             */
            FinishDiggingPointReq.prototype.checkNodeId = 0;

            /**
             * FinishDiggingPointReq fightResult.
             * @member {number} fightResult
             * @memberof luck.protobuf.FinishDiggingPointReq
             * @instance
             */
            FinishDiggingPointReq.prototype.fightResult = 0;

            /**
             * FinishDiggingPointReq mineId.
             * @member {number} mineId
             * @memberof luck.protobuf.FinishDiggingPointReq
             * @instance
             */
            FinishDiggingPointReq.prototype.mineId = 0;

            /**
             * Creates a new FinishDiggingPointReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.FinishDiggingPointReq
             * @static
             * @param {luck.protobuf.IFinishDiggingPointReq=} [properties] Properties to set
             * @returns {luck.protobuf.FinishDiggingPointReq} FinishDiggingPointReq instance
             */
            FinishDiggingPointReq.create = function create(properties) {
                return new FinishDiggingPointReq(properties);
            };

            /**
             * Encodes the specified FinishDiggingPointReq message. Does not implicitly {@link luck.protobuf.FinishDiggingPointReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.FinishDiggingPointReq
             * @static
             * @param {luck.protobuf.IFinishDiggingPointReq} message FinishDiggingPointReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FinishDiggingPointReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.checkNodeId);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.fightResult);
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.mineId);
                return writer;
            };

            /**
             * Encodes the specified FinishDiggingPointReq message, length delimited. Does not implicitly {@link luck.protobuf.FinishDiggingPointReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.FinishDiggingPointReq
             * @static
             * @param {luck.protobuf.IFinishDiggingPointReq} message FinishDiggingPointReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FinishDiggingPointReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FinishDiggingPointReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.FinishDiggingPointReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.FinishDiggingPointReq} FinishDiggingPointReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FinishDiggingPointReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.FinishDiggingPointReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.checkNodeId = reader.int32();
                        break;
                    case 2:
                        message.fightResult = reader.int32();
                        break;
                    case 3:
                        message.mineId = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("checkNodeId"))
                    throw $util.ProtocolError("missing required 'checkNodeId'", { instance: message });
                if (!message.hasOwnProperty("fightResult"))
                    throw $util.ProtocolError("missing required 'fightResult'", { instance: message });
                if (!message.hasOwnProperty("mineId"))
                    throw $util.ProtocolError("missing required 'mineId'", { instance: message });
                return message;
            };

            /**
             * Decodes a FinishDiggingPointReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.FinishDiggingPointReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.FinishDiggingPointReq} FinishDiggingPointReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FinishDiggingPointReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FinishDiggingPointReq message.
             * @function verify
             * @memberof luck.protobuf.FinishDiggingPointReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FinishDiggingPointReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.checkNodeId))
                    return "checkNodeId: integer expected";
                if (!$util.isInteger(message.fightResult))
                    return "fightResult: integer expected";
                if (!$util.isInteger(message.mineId))
                    return "mineId: integer expected";
                return null;
            };

            return FinishDiggingPointReq;
        })();

        protobuf.drawActivityTaskRewardReq = (function() {

            /**
             * Properties of a drawActivityTaskRewardReq.
             * @memberof luck.protobuf
             * @interface IdrawActivityTaskRewardReq
             * @property {number} activityId drawActivityTaskRewardReq activityId
             */

            /**
             * Constructs a new drawActivityTaskRewardReq.
             * @memberof luck.protobuf
             * @classdesc Represents a drawActivityTaskRewardReq.
             * @implements IdrawActivityTaskRewardReq
             * @constructor
             * @param {luck.protobuf.IdrawActivityTaskRewardReq=} [properties] Properties to set
             */
            function drawActivityTaskRewardReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * drawActivityTaskRewardReq activityId.
             * @member {number} activityId
             * @memberof luck.protobuf.drawActivityTaskRewardReq
             * @instance
             */
            drawActivityTaskRewardReq.prototype.activityId = 0;

            /**
             * Creates a new drawActivityTaskRewardReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.drawActivityTaskRewardReq
             * @static
             * @param {luck.protobuf.IdrawActivityTaskRewardReq=} [properties] Properties to set
             * @returns {luck.protobuf.drawActivityTaskRewardReq} drawActivityTaskRewardReq instance
             */
            drawActivityTaskRewardReq.create = function create(properties) {
                return new drawActivityTaskRewardReq(properties);
            };

            /**
             * Encodes the specified drawActivityTaskRewardReq message. Does not implicitly {@link luck.protobuf.drawActivityTaskRewardReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.drawActivityTaskRewardReq
             * @static
             * @param {luck.protobuf.IdrawActivityTaskRewardReq} message drawActivityTaskRewardReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            drawActivityTaskRewardReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.activityId);
                return writer;
            };

            /**
             * Encodes the specified drawActivityTaskRewardReq message, length delimited. Does not implicitly {@link luck.protobuf.drawActivityTaskRewardReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.drawActivityTaskRewardReq
             * @static
             * @param {luck.protobuf.IdrawActivityTaskRewardReq} message drawActivityTaskRewardReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            drawActivityTaskRewardReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a drawActivityTaskRewardReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.drawActivityTaskRewardReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.drawActivityTaskRewardReq} drawActivityTaskRewardReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            drawActivityTaskRewardReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.drawActivityTaskRewardReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.activityId = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("activityId"))
                    throw $util.ProtocolError("missing required 'activityId'", { instance: message });
                return message;
            };

            /**
             * Decodes a drawActivityTaskRewardReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.drawActivityTaskRewardReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.drawActivityTaskRewardReq} drawActivityTaskRewardReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            drawActivityTaskRewardReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a drawActivityTaskRewardReq message.
             * @function verify
             * @memberof luck.protobuf.drawActivityTaskRewardReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            drawActivityTaskRewardReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.activityId))
                    return "activityId: integer expected";
                return null;
            };

            return drawActivityTaskRewardReq;
        })();

        protobuf.activityLotteryReq = (function() {

            /**
             * Properties of an activityLotteryReq.
             * @memberof luck.protobuf
             * @interface IactivityLotteryReq
             * @property {number} activityId activityLotteryReq activityId
             */

            /**
             * Constructs a new activityLotteryReq.
             * @memberof luck.protobuf
             * @classdesc Represents an activityLotteryReq.
             * @implements IactivityLotteryReq
             * @constructor
             * @param {luck.protobuf.IactivityLotteryReq=} [properties] Properties to set
             */
            function activityLotteryReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * activityLotteryReq activityId.
             * @member {number} activityId
             * @memberof luck.protobuf.activityLotteryReq
             * @instance
             */
            activityLotteryReq.prototype.activityId = 0;

            /**
             * Creates a new activityLotteryReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.activityLotteryReq
             * @static
             * @param {luck.protobuf.IactivityLotteryReq=} [properties] Properties to set
             * @returns {luck.protobuf.activityLotteryReq} activityLotteryReq instance
             */
            activityLotteryReq.create = function create(properties) {
                return new activityLotteryReq(properties);
            };

            /**
             * Encodes the specified activityLotteryReq message. Does not implicitly {@link luck.protobuf.activityLotteryReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.activityLotteryReq
             * @static
             * @param {luck.protobuf.IactivityLotteryReq} message activityLotteryReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            activityLotteryReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.activityId);
                return writer;
            };

            /**
             * Encodes the specified activityLotteryReq message, length delimited. Does not implicitly {@link luck.protobuf.activityLotteryReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.activityLotteryReq
             * @static
             * @param {luck.protobuf.IactivityLotteryReq} message activityLotteryReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            activityLotteryReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an activityLotteryReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.activityLotteryReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.activityLotteryReq} activityLotteryReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            activityLotteryReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.activityLotteryReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.activityId = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("activityId"))
                    throw $util.ProtocolError("missing required 'activityId'", { instance: message });
                return message;
            };

            /**
             * Decodes an activityLotteryReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.activityLotteryReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.activityLotteryReq} activityLotteryReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            activityLotteryReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an activityLotteryReq message.
             * @function verify
             * @memberof luck.protobuf.activityLotteryReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            activityLotteryReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.activityId))
                    return "activityId: integer expected";
                return null;
            };

            return activityLotteryReq;
        })();

        protobuf.changeNameReq = (function() {

            /**
             * Properties of a changeNameReq.
             * @memberof luck.protobuf
             * @interface IchangeNameReq
             * @property {string} name changeNameReq name
             */

            /**
             * Constructs a new changeNameReq.
             * @memberof luck.protobuf
             * @classdesc Represents a changeNameReq.
             * @implements IchangeNameReq
             * @constructor
             * @param {luck.protobuf.IchangeNameReq=} [properties] Properties to set
             */
            function changeNameReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * changeNameReq name.
             * @member {string} name
             * @memberof luck.protobuf.changeNameReq
             * @instance
             */
            changeNameReq.prototype.name = "";

            /**
             * Creates a new changeNameReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.changeNameReq
             * @static
             * @param {luck.protobuf.IchangeNameReq=} [properties] Properties to set
             * @returns {luck.protobuf.changeNameReq} changeNameReq instance
             */
            changeNameReq.create = function create(properties) {
                return new changeNameReq(properties);
            };

            /**
             * Encodes the specified changeNameReq message. Does not implicitly {@link luck.protobuf.changeNameReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.changeNameReq
             * @static
             * @param {luck.protobuf.IchangeNameReq} message changeNameReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            changeNameReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                return writer;
            };

            /**
             * Encodes the specified changeNameReq message, length delimited. Does not implicitly {@link luck.protobuf.changeNameReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.changeNameReq
             * @static
             * @param {luck.protobuf.IchangeNameReq} message changeNameReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            changeNameReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a changeNameReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.changeNameReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.changeNameReq} changeNameReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            changeNameReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.changeNameReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("name"))
                    throw $util.ProtocolError("missing required 'name'", { instance: message });
                return message;
            };

            /**
             * Decodes a changeNameReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.changeNameReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.changeNameReq} changeNameReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            changeNameReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a changeNameReq message.
             * @function verify
             * @memberof luck.protobuf.changeNameReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            changeNameReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.name))
                    return "name: string expected";
                return null;
            };

            return changeNameReq;
        })();

        protobuf.saveNoviceGuideNumReq = (function() {

            /**
             * Properties of a saveNoviceGuideNumReq.
             * @memberof luck.protobuf
             * @interface IsaveNoviceGuideNumReq
             * @property {number} num saveNoviceGuideNumReq num
             */

            /**
             * Constructs a new saveNoviceGuideNumReq.
             * @memberof luck.protobuf
             * @classdesc Represents a saveNoviceGuideNumReq.
             * @implements IsaveNoviceGuideNumReq
             * @constructor
             * @param {luck.protobuf.IsaveNoviceGuideNumReq=} [properties] Properties to set
             */
            function saveNoviceGuideNumReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * saveNoviceGuideNumReq num.
             * @member {number} num
             * @memberof luck.protobuf.saveNoviceGuideNumReq
             * @instance
             */
            saveNoviceGuideNumReq.prototype.num = 0;

            /**
             * Creates a new saveNoviceGuideNumReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.saveNoviceGuideNumReq
             * @static
             * @param {luck.protobuf.IsaveNoviceGuideNumReq=} [properties] Properties to set
             * @returns {luck.protobuf.saveNoviceGuideNumReq} saveNoviceGuideNumReq instance
             */
            saveNoviceGuideNumReq.create = function create(properties) {
                return new saveNoviceGuideNumReq(properties);
            };

            /**
             * Encodes the specified saveNoviceGuideNumReq message. Does not implicitly {@link luck.protobuf.saveNoviceGuideNumReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.saveNoviceGuideNumReq
             * @static
             * @param {luck.protobuf.IsaveNoviceGuideNumReq} message saveNoviceGuideNumReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            saveNoviceGuideNumReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.num);
                return writer;
            };

            /**
             * Encodes the specified saveNoviceGuideNumReq message, length delimited. Does not implicitly {@link luck.protobuf.saveNoviceGuideNumReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.saveNoviceGuideNumReq
             * @static
             * @param {luck.protobuf.IsaveNoviceGuideNumReq} message saveNoviceGuideNumReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            saveNoviceGuideNumReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a saveNoviceGuideNumReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.saveNoviceGuideNumReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.saveNoviceGuideNumReq} saveNoviceGuideNumReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            saveNoviceGuideNumReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.saveNoviceGuideNumReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.num = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("num"))
                    throw $util.ProtocolError("missing required 'num'", { instance: message });
                return message;
            };

            /**
             * Decodes a saveNoviceGuideNumReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.saveNoviceGuideNumReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.saveNoviceGuideNumReq} saveNoviceGuideNumReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            saveNoviceGuideNumReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a saveNoviceGuideNumReq message.
             * @function verify
             * @memberof luck.protobuf.saveNoviceGuideNumReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            saveNoviceGuideNumReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.num))
                    return "num: integer expected";
                return null;
            };

            return saveNoviceGuideNumReq;
        })();

        protobuf.drawMonthCardReq = (function() {

            /**
             * Properties of a drawMonthCardReq.
             * @memberof luck.protobuf
             * @interface IdrawMonthCardReq
             * @property {number} type drawMonthCardReq type
             */

            /**
             * Constructs a new drawMonthCardReq.
             * @memberof luck.protobuf
             * @classdesc Represents a drawMonthCardReq.
             * @implements IdrawMonthCardReq
             * @constructor
             * @param {luck.protobuf.IdrawMonthCardReq=} [properties] Properties to set
             */
            function drawMonthCardReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * drawMonthCardReq type.
             * @member {number} type
             * @memberof luck.protobuf.drawMonthCardReq
             * @instance
             */
            drawMonthCardReq.prototype.type = 0;

            /**
             * Creates a new drawMonthCardReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.drawMonthCardReq
             * @static
             * @param {luck.protobuf.IdrawMonthCardReq=} [properties] Properties to set
             * @returns {luck.protobuf.drawMonthCardReq} drawMonthCardReq instance
             */
            drawMonthCardReq.create = function create(properties) {
                return new drawMonthCardReq(properties);
            };

            /**
             * Encodes the specified drawMonthCardReq message. Does not implicitly {@link luck.protobuf.drawMonthCardReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.drawMonthCardReq
             * @static
             * @param {luck.protobuf.IdrawMonthCardReq} message drawMonthCardReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            drawMonthCardReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                return writer;
            };

            /**
             * Encodes the specified drawMonthCardReq message, length delimited. Does not implicitly {@link luck.protobuf.drawMonthCardReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.drawMonthCardReq
             * @static
             * @param {luck.protobuf.IdrawMonthCardReq} message drawMonthCardReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            drawMonthCardReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a drawMonthCardReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.drawMonthCardReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.drawMonthCardReq} drawMonthCardReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            drawMonthCardReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.drawMonthCardReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("type"))
                    throw $util.ProtocolError("missing required 'type'", { instance: message });
                return message;
            };

            /**
             * Decodes a drawMonthCardReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.drawMonthCardReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.drawMonthCardReq} drawMonthCardReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            drawMonthCardReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a drawMonthCardReq message.
             * @function verify
             * @memberof luck.protobuf.drawMonthCardReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            drawMonthCardReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
                return null;
            };

            return drawMonthCardReq;
        })();

        protobuf.roleChatReq = (function() {

            /**
             * Properties of a roleChatReq.
             * @memberof luck.protobuf
             * @interface IroleChatReq
             * @property {number} roleId roleChatReq roleId
             * @property {number} startId roleChatReq startId
             * @property {number} nowId roleChatReq nowId
             */

            /**
             * Constructs a new roleChatReq.
             * @memberof luck.protobuf
             * @classdesc Represents a roleChatReq.
             * @implements IroleChatReq
             * @constructor
             * @param {luck.protobuf.IroleChatReq=} [properties] Properties to set
             */
            function roleChatReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * roleChatReq roleId.
             * @member {number} roleId
             * @memberof luck.protobuf.roleChatReq
             * @instance
             */
            roleChatReq.prototype.roleId = 0;

            /**
             * roleChatReq startId.
             * @member {number} startId
             * @memberof luck.protobuf.roleChatReq
             * @instance
             */
            roleChatReq.prototype.startId = 0;

            /**
             * roleChatReq nowId.
             * @member {number} nowId
             * @memberof luck.protobuf.roleChatReq
             * @instance
             */
            roleChatReq.prototype.nowId = 0;

            /**
             * Creates a new roleChatReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.roleChatReq
             * @static
             * @param {luck.protobuf.IroleChatReq=} [properties] Properties to set
             * @returns {luck.protobuf.roleChatReq} roleChatReq instance
             */
            roleChatReq.create = function create(properties) {
                return new roleChatReq(properties);
            };

            /**
             * Encodes the specified roleChatReq message. Does not implicitly {@link luck.protobuf.roleChatReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.roleChatReq
             * @static
             * @param {luck.protobuf.IroleChatReq} message roleChatReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            roleChatReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.roleId);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.startId);
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.nowId);
                return writer;
            };

            /**
             * Encodes the specified roleChatReq message, length delimited. Does not implicitly {@link luck.protobuf.roleChatReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.roleChatReq
             * @static
             * @param {luck.protobuf.IroleChatReq} message roleChatReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            roleChatReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a roleChatReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.roleChatReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.roleChatReq} roleChatReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            roleChatReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.roleChatReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.roleId = reader.int32();
                        break;
                    case 2:
                        message.startId = reader.int32();
                        break;
                    case 3:
                        message.nowId = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("roleId"))
                    throw $util.ProtocolError("missing required 'roleId'", { instance: message });
                if (!message.hasOwnProperty("startId"))
                    throw $util.ProtocolError("missing required 'startId'", { instance: message });
                if (!message.hasOwnProperty("nowId"))
                    throw $util.ProtocolError("missing required 'nowId'", { instance: message });
                return message;
            };

            /**
             * Decodes a roleChatReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.roleChatReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.roleChatReq} roleChatReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            roleChatReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a roleChatReq message.
             * @function verify
             * @memberof luck.protobuf.roleChatReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            roleChatReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.roleId))
                    return "roleId: integer expected";
                if (!$util.isInteger(message.startId))
                    return "startId: integer expected";
                if (!$util.isInteger(message.nowId))
                    return "nowId: integer expected";
                return null;
            };

            return roleChatReq;
        })();

        protobuf.roleInteractionReq = (function() {

            /**
             * Properties of a roleInteractionReq.
             * @memberof luck.protobuf
             * @interface IroleInteractionReq
             * @property {number} roleId roleInteractionReq roleId
             * @property {number} roleInteractionId roleInteractionReq roleInteractionId
             * @property {number} interactionId roleInteractionReq interactionId
             * @property {number} num roleInteractionReq num
             */

            /**
             * Constructs a new roleInteractionReq.
             * @memberof luck.protobuf
             * @classdesc Represents a roleInteractionReq.
             * @implements IroleInteractionReq
             * @constructor
             * @param {luck.protobuf.IroleInteractionReq=} [properties] Properties to set
             */
            function roleInteractionReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * roleInteractionReq roleId.
             * @member {number} roleId
             * @memberof luck.protobuf.roleInteractionReq
             * @instance
             */
            roleInteractionReq.prototype.roleId = 0;

            /**
             * roleInteractionReq roleInteractionId.
             * @member {number} roleInteractionId
             * @memberof luck.protobuf.roleInteractionReq
             * @instance
             */
            roleInteractionReq.prototype.roleInteractionId = 0;

            /**
             * roleInteractionReq interactionId.
             * @member {number} interactionId
             * @memberof luck.protobuf.roleInteractionReq
             * @instance
             */
            roleInteractionReq.prototype.interactionId = 0;

            /**
             * roleInteractionReq num.
             * @member {number} num
             * @memberof luck.protobuf.roleInteractionReq
             * @instance
             */
            roleInteractionReq.prototype.num = 0;

            /**
             * Creates a new roleInteractionReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.roleInteractionReq
             * @static
             * @param {luck.protobuf.IroleInteractionReq=} [properties] Properties to set
             * @returns {luck.protobuf.roleInteractionReq} roleInteractionReq instance
             */
            roleInteractionReq.create = function create(properties) {
                return new roleInteractionReq(properties);
            };

            /**
             * Encodes the specified roleInteractionReq message. Does not implicitly {@link luck.protobuf.roleInteractionReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.roleInteractionReq
             * @static
             * @param {luck.protobuf.IroleInteractionReq} message roleInteractionReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            roleInteractionReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.roleId);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.roleInteractionId);
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.interactionId);
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.num);
                return writer;
            };

            /**
             * Encodes the specified roleInteractionReq message, length delimited. Does not implicitly {@link luck.protobuf.roleInteractionReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.roleInteractionReq
             * @static
             * @param {luck.protobuf.IroleInteractionReq} message roleInteractionReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            roleInteractionReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a roleInteractionReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.roleInteractionReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.roleInteractionReq} roleInteractionReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            roleInteractionReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.roleInteractionReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.roleId = reader.int32();
                        break;
                    case 2:
                        message.roleInteractionId = reader.int32();
                        break;
                    case 3:
                        message.interactionId = reader.int32();
                        break;
                    case 4:
                        message.num = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("roleId"))
                    throw $util.ProtocolError("missing required 'roleId'", { instance: message });
                if (!message.hasOwnProperty("roleInteractionId"))
                    throw $util.ProtocolError("missing required 'roleInteractionId'", { instance: message });
                if (!message.hasOwnProperty("interactionId"))
                    throw $util.ProtocolError("missing required 'interactionId'", { instance: message });
                if (!message.hasOwnProperty("num"))
                    throw $util.ProtocolError("missing required 'num'", { instance: message });
                return message;
            };

            /**
             * Decodes a roleInteractionReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.roleInteractionReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.roleInteractionReq} roleInteractionReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            roleInteractionReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a roleInteractionReq message.
             * @function verify
             * @memberof luck.protobuf.roleInteractionReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            roleInteractionReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.roleId))
                    return "roleId: integer expected";
                if (!$util.isInteger(message.roleInteractionId))
                    return "roleInteractionId: integer expected";
                if (!$util.isInteger(message.interactionId))
                    return "interactionId: integer expected";
                if (!$util.isInteger(message.num))
                    return "num: integer expected";
                return null;
            };

            return roleInteractionReq;
        })();

        protobuf.strokeRoleReq = (function() {

            /**
             * Properties of a strokeRoleReq.
             * @memberof luck.protobuf
             * @interface IstrokeRoleReq
             * @property {number} roleId strokeRoleReq roleId
             * @property {number} actionId strokeRoleReq actionId
             */

            /**
             * Constructs a new strokeRoleReq.
             * @memberof luck.protobuf
             * @classdesc Represents a strokeRoleReq.
             * @implements IstrokeRoleReq
             * @constructor
             * @param {luck.protobuf.IstrokeRoleReq=} [properties] Properties to set
             */
            function strokeRoleReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * strokeRoleReq roleId.
             * @member {number} roleId
             * @memberof luck.protobuf.strokeRoleReq
             * @instance
             */
            strokeRoleReq.prototype.roleId = 0;

            /**
             * strokeRoleReq actionId.
             * @member {number} actionId
             * @memberof luck.protobuf.strokeRoleReq
             * @instance
             */
            strokeRoleReq.prototype.actionId = 0;

            /**
             * Creates a new strokeRoleReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.strokeRoleReq
             * @static
             * @param {luck.protobuf.IstrokeRoleReq=} [properties] Properties to set
             * @returns {luck.protobuf.strokeRoleReq} strokeRoleReq instance
             */
            strokeRoleReq.create = function create(properties) {
                return new strokeRoleReq(properties);
            };

            /**
             * Encodes the specified strokeRoleReq message. Does not implicitly {@link luck.protobuf.strokeRoleReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.strokeRoleReq
             * @static
             * @param {luck.protobuf.IstrokeRoleReq} message strokeRoleReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            strokeRoleReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.roleId);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.actionId);
                return writer;
            };

            /**
             * Encodes the specified strokeRoleReq message, length delimited. Does not implicitly {@link luck.protobuf.strokeRoleReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.strokeRoleReq
             * @static
             * @param {luck.protobuf.IstrokeRoleReq} message strokeRoleReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            strokeRoleReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a strokeRoleReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.strokeRoleReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.strokeRoleReq} strokeRoleReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            strokeRoleReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.strokeRoleReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.roleId = reader.int32();
                        break;
                    case 2:
                        message.actionId = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("roleId"))
                    throw $util.ProtocolError("missing required 'roleId'", { instance: message });
                if (!message.hasOwnProperty("actionId"))
                    throw $util.ProtocolError("missing required 'actionId'", { instance: message });
                return message;
            };

            /**
             * Decodes a strokeRoleReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.strokeRoleReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.strokeRoleReq} strokeRoleReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            strokeRoleReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a strokeRoleReq message.
             * @function verify
             * @memberof luck.protobuf.strokeRoleReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            strokeRoleReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.roleId))
                    return "roleId: integer expected";
                if (!$util.isInteger(message.actionId))
                    return "actionId: integer expected";
                return null;
            };

            return strokeRoleReq;
        })();

        protobuf.changeRoleImageReq = (function() {

            /**
             * Properties of a changeRoleImageReq.
             * @memberof luck.protobuf
             * @interface IchangeRoleImageReq
             * @property {number} roleId changeRoleImageReq roleId
             * @property {number} imageId changeRoleImageReq imageId
             */

            /**
             * Constructs a new changeRoleImageReq.
             * @memberof luck.protobuf
             * @classdesc Represents a changeRoleImageReq.
             * @implements IchangeRoleImageReq
             * @constructor
             * @param {luck.protobuf.IchangeRoleImageReq=} [properties] Properties to set
             */
            function changeRoleImageReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * changeRoleImageReq roleId.
             * @member {number} roleId
             * @memberof luck.protobuf.changeRoleImageReq
             * @instance
             */
            changeRoleImageReq.prototype.roleId = 0;

            /**
             * changeRoleImageReq imageId.
             * @member {number} imageId
             * @memberof luck.protobuf.changeRoleImageReq
             * @instance
             */
            changeRoleImageReq.prototype.imageId = 0;

            /**
             * Creates a new changeRoleImageReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.changeRoleImageReq
             * @static
             * @param {luck.protobuf.IchangeRoleImageReq=} [properties] Properties to set
             * @returns {luck.protobuf.changeRoleImageReq} changeRoleImageReq instance
             */
            changeRoleImageReq.create = function create(properties) {
                return new changeRoleImageReq(properties);
            };

            /**
             * Encodes the specified changeRoleImageReq message. Does not implicitly {@link luck.protobuf.changeRoleImageReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.changeRoleImageReq
             * @static
             * @param {luck.protobuf.IchangeRoleImageReq} message changeRoleImageReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            changeRoleImageReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.roleId);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.imageId);
                return writer;
            };

            /**
             * Encodes the specified changeRoleImageReq message, length delimited. Does not implicitly {@link luck.protobuf.changeRoleImageReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.changeRoleImageReq
             * @static
             * @param {luck.protobuf.IchangeRoleImageReq} message changeRoleImageReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            changeRoleImageReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a changeRoleImageReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.changeRoleImageReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.changeRoleImageReq} changeRoleImageReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            changeRoleImageReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.changeRoleImageReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.roleId = reader.int32();
                        break;
                    case 2:
                        message.imageId = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("roleId"))
                    throw $util.ProtocolError("missing required 'roleId'", { instance: message });
                if (!message.hasOwnProperty("imageId"))
                    throw $util.ProtocolError("missing required 'imageId'", { instance: message });
                return message;
            };

            /**
             * Decodes a changeRoleImageReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.changeRoleImageReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.changeRoleImageReq} changeRoleImageReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            changeRoleImageReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a changeRoleImageReq message.
             * @function verify
             * @memberof luck.protobuf.changeRoleImageReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            changeRoleImageReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.roleId))
                    return "roleId: integer expected";
                if (!$util.isInteger(message.imageId))
                    return "imageId: integer expected";
                return null;
            };

            return changeRoleImageReq;
        })();

        protobuf.changeHeadPortraitReq = (function() {

            /**
             * Properties of a changeHeadPortraitReq.
             * @memberof luck.protobuf
             * @interface IchangeHeadPortraitReq
             * @property {number} headPortraitId changeHeadPortraitReq headPortraitId
             */

            /**
             * Constructs a new changeHeadPortraitReq.
             * @memberof luck.protobuf
             * @classdesc Represents a changeHeadPortraitReq.
             * @implements IchangeHeadPortraitReq
             * @constructor
             * @param {luck.protobuf.IchangeHeadPortraitReq=} [properties] Properties to set
             */
            function changeHeadPortraitReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * changeHeadPortraitReq headPortraitId.
             * @member {number} headPortraitId
             * @memberof luck.protobuf.changeHeadPortraitReq
             * @instance
             */
            changeHeadPortraitReq.prototype.headPortraitId = 0;

            /**
             * Creates a new changeHeadPortraitReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.changeHeadPortraitReq
             * @static
             * @param {luck.protobuf.IchangeHeadPortraitReq=} [properties] Properties to set
             * @returns {luck.protobuf.changeHeadPortraitReq} changeHeadPortraitReq instance
             */
            changeHeadPortraitReq.create = function create(properties) {
                return new changeHeadPortraitReq(properties);
            };

            /**
             * Encodes the specified changeHeadPortraitReq message. Does not implicitly {@link luck.protobuf.changeHeadPortraitReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.changeHeadPortraitReq
             * @static
             * @param {luck.protobuf.IchangeHeadPortraitReq} message changeHeadPortraitReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            changeHeadPortraitReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.headPortraitId);
                return writer;
            };

            /**
             * Encodes the specified changeHeadPortraitReq message, length delimited. Does not implicitly {@link luck.protobuf.changeHeadPortraitReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.changeHeadPortraitReq
             * @static
             * @param {luck.protobuf.IchangeHeadPortraitReq} message changeHeadPortraitReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            changeHeadPortraitReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a changeHeadPortraitReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.changeHeadPortraitReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.changeHeadPortraitReq} changeHeadPortraitReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            changeHeadPortraitReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.changeHeadPortraitReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.headPortraitId = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("headPortraitId"))
                    throw $util.ProtocolError("missing required 'headPortraitId'", { instance: message });
                return message;
            };

            /**
             * Decodes a changeHeadPortraitReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.changeHeadPortraitReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.changeHeadPortraitReq} changeHeadPortraitReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            changeHeadPortraitReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a changeHeadPortraitReq message.
             * @function verify
             * @memberof luck.protobuf.changeHeadPortraitReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            changeHeadPortraitReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.headPortraitId))
                    return "headPortraitId: integer expected";
                return null;
            };

            return changeHeadPortraitReq;
        })();

        protobuf.changeRahmenReq = (function() {

            /**
             * Properties of a changeRahmenReq.
             * @memberof luck.protobuf
             * @interface IchangeRahmenReq
             * @property {number} RahmenId changeRahmenReq RahmenId
             */

            /**
             * Constructs a new changeRahmenReq.
             * @memberof luck.protobuf
             * @classdesc Represents a changeRahmenReq.
             * @implements IchangeRahmenReq
             * @constructor
             * @param {luck.protobuf.IchangeRahmenReq=} [properties] Properties to set
             */
            function changeRahmenReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * changeRahmenReq RahmenId.
             * @member {number} RahmenId
             * @memberof luck.protobuf.changeRahmenReq
             * @instance
             */
            changeRahmenReq.prototype.RahmenId = 0;

            /**
             * Creates a new changeRahmenReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.changeRahmenReq
             * @static
             * @param {luck.protobuf.IchangeRahmenReq=} [properties] Properties to set
             * @returns {luck.protobuf.changeRahmenReq} changeRahmenReq instance
             */
            changeRahmenReq.create = function create(properties) {
                return new changeRahmenReq(properties);
            };

            /**
             * Encodes the specified changeRahmenReq message. Does not implicitly {@link luck.protobuf.changeRahmenReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.changeRahmenReq
             * @static
             * @param {luck.protobuf.IchangeRahmenReq} message changeRahmenReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            changeRahmenReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.RahmenId);
                return writer;
            };

            /**
             * Encodes the specified changeRahmenReq message, length delimited. Does not implicitly {@link luck.protobuf.changeRahmenReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.changeRahmenReq
             * @static
             * @param {luck.protobuf.IchangeRahmenReq} message changeRahmenReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            changeRahmenReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a changeRahmenReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.changeRahmenReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.changeRahmenReq} changeRahmenReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            changeRahmenReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.changeRahmenReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.RahmenId = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("RahmenId"))
                    throw $util.ProtocolError("missing required 'RahmenId'", { instance: message });
                return message;
            };

            /**
             * Decodes a changeRahmenReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.changeRahmenReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.changeRahmenReq} changeRahmenReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            changeRahmenReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a changeRahmenReq message.
             * @function verify
             * @memberof luck.protobuf.changeRahmenReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            changeRahmenReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.RahmenId))
                    return "RahmenId: integer expected";
                return null;
            };

            return changeRahmenReq;
        })();

        protobuf.giveRoleGiftReq = (function() {

            /**
             * Properties of a giveRoleGiftReq.
             * @memberof luck.protobuf
             * @interface IgiveRoleGiftReq
             * @property {number} roleId giveRoleGiftReq roleId
             * @property {number} giftId giveRoleGiftReq giftId
             * @property {number} num giveRoleGiftReq num
             */

            /**
             * Constructs a new giveRoleGiftReq.
             * @memberof luck.protobuf
             * @classdesc Represents a giveRoleGiftReq.
             * @implements IgiveRoleGiftReq
             * @constructor
             * @param {luck.protobuf.IgiveRoleGiftReq=} [properties] Properties to set
             */
            function giveRoleGiftReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * giveRoleGiftReq roleId.
             * @member {number} roleId
             * @memberof luck.protobuf.giveRoleGiftReq
             * @instance
             */
            giveRoleGiftReq.prototype.roleId = 0;

            /**
             * giveRoleGiftReq giftId.
             * @member {number} giftId
             * @memberof luck.protobuf.giveRoleGiftReq
             * @instance
             */
            giveRoleGiftReq.prototype.giftId = 0;

            /**
             * giveRoleGiftReq num.
             * @member {number} num
             * @memberof luck.protobuf.giveRoleGiftReq
             * @instance
             */
            giveRoleGiftReq.prototype.num = 0;

            /**
             * Creates a new giveRoleGiftReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.giveRoleGiftReq
             * @static
             * @param {luck.protobuf.IgiveRoleGiftReq=} [properties] Properties to set
             * @returns {luck.protobuf.giveRoleGiftReq} giveRoleGiftReq instance
             */
            giveRoleGiftReq.create = function create(properties) {
                return new giveRoleGiftReq(properties);
            };

            /**
             * Encodes the specified giveRoleGiftReq message. Does not implicitly {@link luck.protobuf.giveRoleGiftReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.giveRoleGiftReq
             * @static
             * @param {luck.protobuf.IgiveRoleGiftReq} message giveRoleGiftReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            giveRoleGiftReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.roleId);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.giftId);
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.num);
                return writer;
            };

            /**
             * Encodes the specified giveRoleGiftReq message, length delimited. Does not implicitly {@link luck.protobuf.giveRoleGiftReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.giveRoleGiftReq
             * @static
             * @param {luck.protobuf.IgiveRoleGiftReq} message giveRoleGiftReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            giveRoleGiftReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a giveRoleGiftReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.giveRoleGiftReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.giveRoleGiftReq} giveRoleGiftReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            giveRoleGiftReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.giveRoleGiftReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.roleId = reader.int32();
                        break;
                    case 2:
                        message.giftId = reader.int32();
                        break;
                    case 3:
                        message.num = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("roleId"))
                    throw $util.ProtocolError("missing required 'roleId'", { instance: message });
                if (!message.hasOwnProperty("giftId"))
                    throw $util.ProtocolError("missing required 'giftId'", { instance: message });
                if (!message.hasOwnProperty("num"))
                    throw $util.ProtocolError("missing required 'num'", { instance: message });
                return message;
            };

            /**
             * Decodes a giveRoleGiftReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.giveRoleGiftReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.giveRoleGiftReq} giveRoleGiftReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            giveRoleGiftReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a giveRoleGiftReq message.
             * @function verify
             * @memberof luck.protobuf.giveRoleGiftReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            giveRoleGiftReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.roleId))
                    return "roleId: integer expected";
                if (!$util.isInteger(message.giftId))
                    return "giftId: integer expected";
                if (!$util.isInteger(message.num))
                    return "num: integer expected";
                return null;
            };

            return giveRoleGiftReq;
        })();

        protobuf.gangSginInReq = (function() {

            /**
             * Properties of a gangSginInReq.
             * @memberof luck.protobuf
             * @interface IgangSginInReq
             */

            /**
             * Constructs a new gangSginInReq.
             * @memberof luck.protobuf
             * @classdesc Represents a gangSginInReq.
             * @implements IgangSginInReq
             * @constructor
             * @param {luck.protobuf.IgangSginInReq=} [properties] Properties to set
             */
            function gangSginInReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new gangSginInReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.gangSginInReq
             * @static
             * @param {luck.protobuf.IgangSginInReq=} [properties] Properties to set
             * @returns {luck.protobuf.gangSginInReq} gangSginInReq instance
             */
            gangSginInReq.create = function create(properties) {
                return new gangSginInReq(properties);
            };

            /**
             * Encodes the specified gangSginInReq message. Does not implicitly {@link luck.protobuf.gangSginInReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.gangSginInReq
             * @static
             * @param {luck.protobuf.IgangSginInReq} message gangSginInReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            gangSginInReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified gangSginInReq message, length delimited. Does not implicitly {@link luck.protobuf.gangSginInReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.gangSginInReq
             * @static
             * @param {luck.protobuf.IgangSginInReq} message gangSginInReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            gangSginInReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a gangSginInReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.gangSginInReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.gangSginInReq} gangSginInReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            gangSginInReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.gangSginInReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a gangSginInReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.gangSginInReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.gangSginInReq} gangSginInReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            gangSginInReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a gangSginInReq message.
             * @function verify
             * @memberof luck.protobuf.gangSginInReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            gangSginInReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            return gangSginInReq;
        })();

        protobuf.drawGangVitalityRewardReq = (function() {

            /**
             * Properties of a drawGangVitalityRewardReq.
             * @memberof luck.protobuf
             * @interface IdrawGangVitalityRewardReq
             * @property {number} gangVitalityRewardId drawGangVitalityRewardReq gangVitalityRewardId
             */

            /**
             * Constructs a new drawGangVitalityRewardReq.
             * @memberof luck.protobuf
             * @classdesc Represents a drawGangVitalityRewardReq.
             * @implements IdrawGangVitalityRewardReq
             * @constructor
             * @param {luck.protobuf.IdrawGangVitalityRewardReq=} [properties] Properties to set
             */
            function drawGangVitalityRewardReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * drawGangVitalityRewardReq gangVitalityRewardId.
             * @member {number} gangVitalityRewardId
             * @memberof luck.protobuf.drawGangVitalityRewardReq
             * @instance
             */
            drawGangVitalityRewardReq.prototype.gangVitalityRewardId = 0;

            /**
             * Creates a new drawGangVitalityRewardReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.drawGangVitalityRewardReq
             * @static
             * @param {luck.protobuf.IdrawGangVitalityRewardReq=} [properties] Properties to set
             * @returns {luck.protobuf.drawGangVitalityRewardReq} drawGangVitalityRewardReq instance
             */
            drawGangVitalityRewardReq.create = function create(properties) {
                return new drawGangVitalityRewardReq(properties);
            };

            /**
             * Encodes the specified drawGangVitalityRewardReq message. Does not implicitly {@link luck.protobuf.drawGangVitalityRewardReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.drawGangVitalityRewardReq
             * @static
             * @param {luck.protobuf.IdrawGangVitalityRewardReq} message drawGangVitalityRewardReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            drawGangVitalityRewardReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.gangVitalityRewardId);
                return writer;
            };

            /**
             * Encodes the specified drawGangVitalityRewardReq message, length delimited. Does not implicitly {@link luck.protobuf.drawGangVitalityRewardReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.drawGangVitalityRewardReq
             * @static
             * @param {luck.protobuf.IdrawGangVitalityRewardReq} message drawGangVitalityRewardReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            drawGangVitalityRewardReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a drawGangVitalityRewardReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.drawGangVitalityRewardReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.drawGangVitalityRewardReq} drawGangVitalityRewardReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            drawGangVitalityRewardReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.drawGangVitalityRewardReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.gangVitalityRewardId = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("gangVitalityRewardId"))
                    throw $util.ProtocolError("missing required 'gangVitalityRewardId'", { instance: message });
                return message;
            };

            /**
             * Decodes a drawGangVitalityRewardReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.drawGangVitalityRewardReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.drawGangVitalityRewardReq} drawGangVitalityRewardReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            drawGangVitalityRewardReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a drawGangVitalityRewardReq message.
             * @function verify
             * @memberof luck.protobuf.drawGangVitalityRewardReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            drawGangVitalityRewardReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.gangVitalityRewardId))
                    return "gangVitalityRewardId: integer expected";
                return null;
            };

            return drawGangVitalityRewardReq;
        })();

        protobuf.savePersonMessageReq = (function() {

            /**
             * Properties of a savePersonMessageReq.
             * @memberof luck.protobuf
             * @interface IsavePersonMessageReq
             * @property {string|null} [personManifesto] savePersonMessageReq personManifesto
             */

            /**
             * Constructs a new savePersonMessageReq.
             * @memberof luck.protobuf
             * @classdesc Represents a savePersonMessageReq.
             * @implements IsavePersonMessageReq
             * @constructor
             * @param {luck.protobuf.IsavePersonMessageReq=} [properties] Properties to set
             */
            function savePersonMessageReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * savePersonMessageReq personManifesto.
             * @member {string} personManifesto
             * @memberof luck.protobuf.savePersonMessageReq
             * @instance
             */
            savePersonMessageReq.prototype.personManifesto = "";

            /**
             * Creates a new savePersonMessageReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.savePersonMessageReq
             * @static
             * @param {luck.protobuf.IsavePersonMessageReq=} [properties] Properties to set
             * @returns {luck.protobuf.savePersonMessageReq} savePersonMessageReq instance
             */
            savePersonMessageReq.create = function create(properties) {
                return new savePersonMessageReq(properties);
            };

            /**
             * Encodes the specified savePersonMessageReq message. Does not implicitly {@link luck.protobuf.savePersonMessageReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.savePersonMessageReq
             * @static
             * @param {luck.protobuf.IsavePersonMessageReq} message savePersonMessageReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            savePersonMessageReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.personManifesto != null && message.hasOwnProperty("personManifesto"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.personManifesto);
                return writer;
            };

            /**
             * Encodes the specified savePersonMessageReq message, length delimited. Does not implicitly {@link luck.protobuf.savePersonMessageReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.savePersonMessageReq
             * @static
             * @param {luck.protobuf.IsavePersonMessageReq} message savePersonMessageReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            savePersonMessageReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a savePersonMessageReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.savePersonMessageReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.savePersonMessageReq} savePersonMessageReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            savePersonMessageReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.savePersonMessageReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.personManifesto = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a savePersonMessageReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.savePersonMessageReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.savePersonMessageReq} savePersonMessageReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            savePersonMessageReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a savePersonMessageReq message.
             * @function verify
             * @memberof luck.protobuf.savePersonMessageReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            savePersonMessageReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.personManifesto != null && message.hasOwnProperty("personManifesto"))
                    if (!$util.isString(message.personManifesto))
                        return "personManifesto: string expected";
                return null;
            };

            return savePersonMessageReq;
        })();

        protobuf.SendGameDataReq = (function() {

            /**
             * Properties of a SendGameDataReq.
             * @memberof luck.protobuf
             * @interface ISendGameDataReq
             * @property {luck.protobuf.IGameBulletDataPB} gameBulletDataPb SendGameDataReq gameBulletDataPb
             */

            /**
             * Constructs a new SendGameDataReq.
             * @memberof luck.protobuf
             * @classdesc Represents a SendGameDataReq.
             * @implements ISendGameDataReq
             * @constructor
             * @param {luck.protobuf.ISendGameDataReq=} [properties] Properties to set
             */
            function SendGameDataReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SendGameDataReq gameBulletDataPb.
             * @member {luck.protobuf.IGameBulletDataPB} gameBulletDataPb
             * @memberof luck.protobuf.SendGameDataReq
             * @instance
             */
            SendGameDataReq.prototype.gameBulletDataPb = null;

            /**
             * Creates a new SendGameDataReq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.SendGameDataReq
             * @static
             * @param {luck.protobuf.ISendGameDataReq=} [properties] Properties to set
             * @returns {luck.protobuf.SendGameDataReq} SendGameDataReq instance
             */
            SendGameDataReq.create = function create(properties) {
                return new SendGameDataReq(properties);
            };

            /**
             * Encodes the specified SendGameDataReq message. Does not implicitly {@link luck.protobuf.SendGameDataReq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.SendGameDataReq
             * @static
             * @param {luck.protobuf.ISendGameDataReq} message SendGameDataReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendGameDataReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                $root.luck.protobuf.GameBulletDataPB.encode(message.gameBulletDataPb, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SendGameDataReq message, length delimited. Does not implicitly {@link luck.protobuf.SendGameDataReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.SendGameDataReq
             * @static
             * @param {luck.protobuf.ISendGameDataReq} message SendGameDataReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendGameDataReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SendGameDataReq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.SendGameDataReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.SendGameDataReq} SendGameDataReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendGameDataReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.SendGameDataReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.gameBulletDataPb = $root.luck.protobuf.GameBulletDataPB.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("gameBulletDataPb"))
                    throw $util.ProtocolError("missing required 'gameBulletDataPb'", { instance: message });
                return message;
            };

            /**
             * Decodes a SendGameDataReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.SendGameDataReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.SendGameDataReq} SendGameDataReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendGameDataReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SendGameDataReq message.
             * @function verify
             * @memberof luck.protobuf.SendGameDataReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SendGameDataReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                {
                    var error = $root.luck.protobuf.GameBulletDataPB.verify(message.gameBulletDataPb);
                    if (error)
                        return "gameBulletDataPb." + error;
                }
                return null;
            };

            return SendGameDataReq;
        })();

        protobuf.LogInResp = (function() {

            /**
             * Properties of a LogInResp.
             * @memberof luck.protobuf
             * @interface ILogInResp
             * @property {number} result LogInResp result
             * @property {luck.protobuf.IPlayerPB|null} [playerPB] LogInResp playerPB
             */

            /**
             * Constructs a new LogInResp.
             * @memberof luck.protobuf
             * @classdesc Represents a LogInResp.
             * @implements ILogInResp
             * @constructor
             * @param {luck.protobuf.ILogInResp=} [properties] Properties to set
             */
            function LogInResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LogInResp result.
             * @member {number} result
             * @memberof luck.protobuf.LogInResp
             * @instance
             */
            LogInResp.prototype.result = 0;

            /**
             * LogInResp playerPB.
             * @member {luck.protobuf.IPlayerPB|null|undefined} playerPB
             * @memberof luck.protobuf.LogInResp
             * @instance
             */
            LogInResp.prototype.playerPB = null;

            /**
             * Creates a new LogInResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.LogInResp
             * @static
             * @param {luck.protobuf.ILogInResp=} [properties] Properties to set
             * @returns {luck.protobuf.LogInResp} LogInResp instance
             */
            LogInResp.create = function create(properties) {
                return new LogInResp(properties);
            };

            /**
             * Encodes the specified LogInResp message. Does not implicitly {@link luck.protobuf.LogInResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.LogInResp
             * @static
             * @param {luck.protobuf.ILogInResp} message LogInResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LogInResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.playerPB != null && message.hasOwnProperty("playerPB"))
                    $root.luck.protobuf.PlayerPB.encode(message.playerPB, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified LogInResp message, length delimited. Does not implicitly {@link luck.protobuf.LogInResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.LogInResp
             * @static
             * @param {luck.protobuf.ILogInResp} message LogInResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LogInResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LogInResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.LogInResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.LogInResp} LogInResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LogInResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.LogInResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.playerPB = $root.luck.protobuf.PlayerPB.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a LogInResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.LogInResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.LogInResp} LogInResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LogInResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LogInResp message.
             * @function verify
             * @memberof luck.protobuf.LogInResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LogInResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.playerPB != null && message.hasOwnProperty("playerPB")) {
                    var error = $root.luck.protobuf.PlayerPB.verify(message.playerPB);
                    if (error)
                        return "playerPB." + error;
                }
                return null;
            };

            return LogInResp;
        })();

        protobuf.HeartBeatRsep = (function() {

            /**
             * Properties of a HeartBeatRsep.
             * @memberof luck.protobuf
             * @interface IHeartBeatRsep
             * @property {number} result HeartBeatRsep result
             */

            /**
             * Constructs a new HeartBeatRsep.
             * @memberof luck.protobuf
             * @classdesc Represents a HeartBeatRsep.
             * @implements IHeartBeatRsep
             * @constructor
             * @param {luck.protobuf.IHeartBeatRsep=} [properties] Properties to set
             */
            function HeartBeatRsep(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * HeartBeatRsep result.
             * @member {number} result
             * @memberof luck.protobuf.HeartBeatRsep
             * @instance
             */
            HeartBeatRsep.prototype.result = 0;

            /**
             * Creates a new HeartBeatRsep instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.HeartBeatRsep
             * @static
             * @param {luck.protobuf.IHeartBeatRsep=} [properties] Properties to set
             * @returns {luck.protobuf.HeartBeatRsep} HeartBeatRsep instance
             */
            HeartBeatRsep.create = function create(properties) {
                return new HeartBeatRsep(properties);
            };

            /**
             * Encodes the specified HeartBeatRsep message. Does not implicitly {@link luck.protobuf.HeartBeatRsep.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.HeartBeatRsep
             * @static
             * @param {luck.protobuf.IHeartBeatRsep} message HeartBeatRsep message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HeartBeatRsep.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                return writer;
            };

            /**
             * Encodes the specified HeartBeatRsep message, length delimited. Does not implicitly {@link luck.protobuf.HeartBeatRsep.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.HeartBeatRsep
             * @static
             * @param {luck.protobuf.IHeartBeatRsep} message HeartBeatRsep message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HeartBeatRsep.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a HeartBeatRsep message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.HeartBeatRsep
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.HeartBeatRsep} HeartBeatRsep
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HeartBeatRsep.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.HeartBeatRsep();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a HeartBeatRsep message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.HeartBeatRsep
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.HeartBeatRsep} HeartBeatRsep
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HeartBeatRsep.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a HeartBeatRsep message.
             * @function verify
             * @memberof luck.protobuf.HeartBeatRsep
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            HeartBeatRsep.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                return null;
            };

            return HeartBeatRsep;
        })();

        protobuf.PingResp = (function() {

            /**
             * Properties of a PingResp.
             * @memberof luck.protobuf
             * @interface IPingResp
             */

            /**
             * Constructs a new PingResp.
             * @memberof luck.protobuf
             * @classdesc Represents a PingResp.
             * @implements IPingResp
             * @constructor
             * @param {luck.protobuf.IPingResp=} [properties] Properties to set
             */
            function PingResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new PingResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.PingResp
             * @static
             * @param {luck.protobuf.IPingResp=} [properties] Properties to set
             * @returns {luck.protobuf.PingResp} PingResp instance
             */
            PingResp.create = function create(properties) {
                return new PingResp(properties);
            };

            /**
             * Encodes the specified PingResp message. Does not implicitly {@link luck.protobuf.PingResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.PingResp
             * @static
             * @param {luck.protobuf.IPingResp} message PingResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PingResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified PingResp message, length delimited. Does not implicitly {@link luck.protobuf.PingResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.PingResp
             * @static
             * @param {luck.protobuf.IPingResp} message PingResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PingResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PingResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.PingResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.PingResp} PingResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PingResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.PingResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PingResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.PingResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.PingResp} PingResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PingResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PingResp message.
             * @function verify
             * @memberof luck.protobuf.PingResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PingResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            return PingResp;
        })();

        protobuf.CreatePlayerResp = (function() {

            /**
             * Properties of a CreatePlayerResp.
             * @memberof luck.protobuf
             * @interface ICreatePlayerResp
             * @property {number} result CreatePlayerResp result
             * @property {luck.protobuf.IPlayerPB|null} [playerPB] CreatePlayerResp playerPB
             */

            /**
             * Constructs a new CreatePlayerResp.
             * @memberof luck.protobuf
             * @classdesc Represents a CreatePlayerResp.
             * @implements ICreatePlayerResp
             * @constructor
             * @param {luck.protobuf.ICreatePlayerResp=} [properties] Properties to set
             */
            function CreatePlayerResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CreatePlayerResp result.
             * @member {number} result
             * @memberof luck.protobuf.CreatePlayerResp
             * @instance
             */
            CreatePlayerResp.prototype.result = 0;

            /**
             * CreatePlayerResp playerPB.
             * @member {luck.protobuf.IPlayerPB|null|undefined} playerPB
             * @memberof luck.protobuf.CreatePlayerResp
             * @instance
             */
            CreatePlayerResp.prototype.playerPB = null;

            /**
             * Creates a new CreatePlayerResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.CreatePlayerResp
             * @static
             * @param {luck.protobuf.ICreatePlayerResp=} [properties] Properties to set
             * @returns {luck.protobuf.CreatePlayerResp} CreatePlayerResp instance
             */
            CreatePlayerResp.create = function create(properties) {
                return new CreatePlayerResp(properties);
            };

            /**
             * Encodes the specified CreatePlayerResp message. Does not implicitly {@link luck.protobuf.CreatePlayerResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.CreatePlayerResp
             * @static
             * @param {luck.protobuf.ICreatePlayerResp} message CreatePlayerResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreatePlayerResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.playerPB != null && message.hasOwnProperty("playerPB"))
                    $root.luck.protobuf.PlayerPB.encode(message.playerPB, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CreatePlayerResp message, length delimited. Does not implicitly {@link luck.protobuf.CreatePlayerResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.CreatePlayerResp
             * @static
             * @param {luck.protobuf.ICreatePlayerResp} message CreatePlayerResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreatePlayerResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CreatePlayerResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.CreatePlayerResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.CreatePlayerResp} CreatePlayerResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreatePlayerResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.CreatePlayerResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.playerPB = $root.luck.protobuf.PlayerPB.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a CreatePlayerResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.CreatePlayerResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.CreatePlayerResp} CreatePlayerResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreatePlayerResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CreatePlayerResp message.
             * @function verify
             * @memberof luck.protobuf.CreatePlayerResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreatePlayerResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.playerPB != null && message.hasOwnProperty("playerPB")) {
                    var error = $root.luck.protobuf.PlayerPB.verify(message.playerPB);
                    if (error)
                        return "playerPB." + error;
                }
                return null;
            };

            return CreatePlayerResp;
        })();

        protobuf.GmBuildWeaponResp = (function() {

            /**
             * Properties of a GmBuildWeaponResp.
             * @memberof luck.protobuf
             * @interface IGmBuildWeaponResp
             * @property {number} result GmBuildWeaponResp result
             * @property {Array.<luck.protobuf.IWeaponPB>|null} [weaponList] GmBuildWeaponResp weaponList
             */

            /**
             * Constructs a new GmBuildWeaponResp.
             * @memberof luck.protobuf
             * @classdesc Represents a GmBuildWeaponResp.
             * @implements IGmBuildWeaponResp
             * @constructor
             * @param {luck.protobuf.IGmBuildWeaponResp=} [properties] Properties to set
             */
            function GmBuildWeaponResp(properties) {
                this.weaponList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GmBuildWeaponResp result.
             * @member {number} result
             * @memberof luck.protobuf.GmBuildWeaponResp
             * @instance
             */
            GmBuildWeaponResp.prototype.result = 0;

            /**
             * GmBuildWeaponResp weaponList.
             * @member {Array.<luck.protobuf.IWeaponPB>} weaponList
             * @memberof luck.protobuf.GmBuildWeaponResp
             * @instance
             */
            GmBuildWeaponResp.prototype.weaponList = $util.emptyArray;

            /**
             * Creates a new GmBuildWeaponResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.GmBuildWeaponResp
             * @static
             * @param {luck.protobuf.IGmBuildWeaponResp=} [properties] Properties to set
             * @returns {luck.protobuf.GmBuildWeaponResp} GmBuildWeaponResp instance
             */
            GmBuildWeaponResp.create = function create(properties) {
                return new GmBuildWeaponResp(properties);
            };

            /**
             * Encodes the specified GmBuildWeaponResp message. Does not implicitly {@link luck.protobuf.GmBuildWeaponResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.GmBuildWeaponResp
             * @static
             * @param {luck.protobuf.IGmBuildWeaponResp} message GmBuildWeaponResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GmBuildWeaponResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.weaponList != null && message.weaponList.length)
                    for (var i = 0; i < message.weaponList.length; ++i)
                        $root.luck.protobuf.WeaponPB.encode(message.weaponList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GmBuildWeaponResp message, length delimited. Does not implicitly {@link luck.protobuf.GmBuildWeaponResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.GmBuildWeaponResp
             * @static
             * @param {luck.protobuf.IGmBuildWeaponResp} message GmBuildWeaponResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GmBuildWeaponResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GmBuildWeaponResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.GmBuildWeaponResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.GmBuildWeaponResp} GmBuildWeaponResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GmBuildWeaponResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.GmBuildWeaponResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        if (!(message.weaponList && message.weaponList.length))
                            message.weaponList = [];
                        message.weaponList.push($root.luck.protobuf.WeaponPB.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a GmBuildWeaponResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.GmBuildWeaponResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.GmBuildWeaponResp} GmBuildWeaponResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GmBuildWeaponResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GmBuildWeaponResp message.
             * @function verify
             * @memberof luck.protobuf.GmBuildWeaponResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GmBuildWeaponResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.weaponList != null && message.hasOwnProperty("weaponList")) {
                    if (!Array.isArray(message.weaponList))
                        return "weaponList: array expected";
                    for (var i = 0; i < message.weaponList.length; ++i) {
                        var error = $root.luck.protobuf.WeaponPB.verify(message.weaponList[i]);
                        if (error)
                            return "weaponList." + error;
                    }
                }
                return null;
            };

            return GmBuildWeaponResp;
        })();

        protobuf.GmBuildCardResp = (function() {

            /**
             * Properties of a GmBuildCardResp.
             * @memberof luck.protobuf
             * @interface IGmBuildCardResp
             * @property {number} result GmBuildCardResp result
             * @property {Array.<luck.protobuf.ICardPB>|null} [cardList] GmBuildCardResp cardList
             */

            /**
             * Constructs a new GmBuildCardResp.
             * @memberof luck.protobuf
             * @classdesc Represents a GmBuildCardResp.
             * @implements IGmBuildCardResp
             * @constructor
             * @param {luck.protobuf.IGmBuildCardResp=} [properties] Properties to set
             */
            function GmBuildCardResp(properties) {
                this.cardList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GmBuildCardResp result.
             * @member {number} result
             * @memberof luck.protobuf.GmBuildCardResp
             * @instance
             */
            GmBuildCardResp.prototype.result = 0;

            /**
             * GmBuildCardResp cardList.
             * @member {Array.<luck.protobuf.ICardPB>} cardList
             * @memberof luck.protobuf.GmBuildCardResp
             * @instance
             */
            GmBuildCardResp.prototype.cardList = $util.emptyArray;

            /**
             * Creates a new GmBuildCardResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.GmBuildCardResp
             * @static
             * @param {luck.protobuf.IGmBuildCardResp=} [properties] Properties to set
             * @returns {luck.protobuf.GmBuildCardResp} GmBuildCardResp instance
             */
            GmBuildCardResp.create = function create(properties) {
                return new GmBuildCardResp(properties);
            };

            /**
             * Encodes the specified GmBuildCardResp message. Does not implicitly {@link luck.protobuf.GmBuildCardResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.GmBuildCardResp
             * @static
             * @param {luck.protobuf.IGmBuildCardResp} message GmBuildCardResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GmBuildCardResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.cardList != null && message.cardList.length)
                    for (var i = 0; i < message.cardList.length; ++i)
                        $root.luck.protobuf.CardPB.encode(message.cardList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GmBuildCardResp message, length delimited. Does not implicitly {@link luck.protobuf.GmBuildCardResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.GmBuildCardResp
             * @static
             * @param {luck.protobuf.IGmBuildCardResp} message GmBuildCardResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GmBuildCardResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GmBuildCardResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.GmBuildCardResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.GmBuildCardResp} GmBuildCardResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GmBuildCardResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.GmBuildCardResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        if (!(message.cardList && message.cardList.length))
                            message.cardList = [];
                        message.cardList.push($root.luck.protobuf.CardPB.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a GmBuildCardResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.GmBuildCardResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.GmBuildCardResp} GmBuildCardResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GmBuildCardResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GmBuildCardResp message.
             * @function verify
             * @memberof luck.protobuf.GmBuildCardResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GmBuildCardResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.cardList != null && message.hasOwnProperty("cardList")) {
                    if (!Array.isArray(message.cardList))
                        return "cardList: array expected";
                    for (var i = 0; i < message.cardList.length; ++i) {
                        var error = $root.luck.protobuf.CardPB.verify(message.cardList[i]);
                        if (error)
                            return "cardList." + error;
                    }
                }
                return null;
            };

            return GmBuildCardResp;
        })();

        protobuf.GmBuildClothesResp = (function() {

            /**
             * Properties of a GmBuildClothesResp.
             * @memberof luck.protobuf
             * @interface IGmBuildClothesResp
             * @property {number} result GmBuildClothesResp result
             * @property {Array.<luck.protobuf.IClothesPB>|null} [clothesList] GmBuildClothesResp clothesList
             */

            /**
             * Constructs a new GmBuildClothesResp.
             * @memberof luck.protobuf
             * @classdesc Represents a GmBuildClothesResp.
             * @implements IGmBuildClothesResp
             * @constructor
             * @param {luck.protobuf.IGmBuildClothesResp=} [properties] Properties to set
             */
            function GmBuildClothesResp(properties) {
                this.clothesList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GmBuildClothesResp result.
             * @member {number} result
             * @memberof luck.protobuf.GmBuildClothesResp
             * @instance
             */
            GmBuildClothesResp.prototype.result = 0;

            /**
             * GmBuildClothesResp clothesList.
             * @member {Array.<luck.protobuf.IClothesPB>} clothesList
             * @memberof luck.protobuf.GmBuildClothesResp
             * @instance
             */
            GmBuildClothesResp.prototype.clothesList = $util.emptyArray;

            /**
             * Creates a new GmBuildClothesResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.GmBuildClothesResp
             * @static
             * @param {luck.protobuf.IGmBuildClothesResp=} [properties] Properties to set
             * @returns {luck.protobuf.GmBuildClothesResp} GmBuildClothesResp instance
             */
            GmBuildClothesResp.create = function create(properties) {
                return new GmBuildClothesResp(properties);
            };

            /**
             * Encodes the specified GmBuildClothesResp message. Does not implicitly {@link luck.protobuf.GmBuildClothesResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.GmBuildClothesResp
             * @static
             * @param {luck.protobuf.IGmBuildClothesResp} message GmBuildClothesResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GmBuildClothesResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.clothesList != null && message.clothesList.length)
                    for (var i = 0; i < message.clothesList.length; ++i)
                        $root.luck.protobuf.ClothesPB.encode(message.clothesList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GmBuildClothesResp message, length delimited. Does not implicitly {@link luck.protobuf.GmBuildClothesResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.GmBuildClothesResp
             * @static
             * @param {luck.protobuf.IGmBuildClothesResp} message GmBuildClothesResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GmBuildClothesResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GmBuildClothesResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.GmBuildClothesResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.GmBuildClothesResp} GmBuildClothesResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GmBuildClothesResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.GmBuildClothesResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        if (!(message.clothesList && message.clothesList.length))
                            message.clothesList = [];
                        message.clothesList.push($root.luck.protobuf.ClothesPB.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a GmBuildClothesResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.GmBuildClothesResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.GmBuildClothesResp} GmBuildClothesResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GmBuildClothesResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GmBuildClothesResp message.
             * @function verify
             * @memberof luck.protobuf.GmBuildClothesResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GmBuildClothesResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.clothesList != null && message.hasOwnProperty("clothesList")) {
                    if (!Array.isArray(message.clothesList))
                        return "clothesList: array expected";
                    for (var i = 0; i < message.clothesList.length; ++i) {
                        var error = $root.luck.protobuf.ClothesPB.verify(message.clothesList[i]);
                        if (error)
                            return "clothesList." + error;
                    }
                }
                return null;
            };

            return GmBuildClothesResp;
        })();

        protobuf.GmAddGoodsResp = (function() {

            /**
             * Properties of a GmAddGoodsResp.
             * @memberof luck.protobuf
             * @interface IGmAddGoodsResp
             * @property {number} result GmAddGoodsResp result
             */

            /**
             * Constructs a new GmAddGoodsResp.
             * @memberof luck.protobuf
             * @classdesc Represents a GmAddGoodsResp.
             * @implements IGmAddGoodsResp
             * @constructor
             * @param {luck.protobuf.IGmAddGoodsResp=} [properties] Properties to set
             */
            function GmAddGoodsResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GmAddGoodsResp result.
             * @member {number} result
             * @memberof luck.protobuf.GmAddGoodsResp
             * @instance
             */
            GmAddGoodsResp.prototype.result = 0;

            /**
             * Creates a new GmAddGoodsResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.GmAddGoodsResp
             * @static
             * @param {luck.protobuf.IGmAddGoodsResp=} [properties] Properties to set
             * @returns {luck.protobuf.GmAddGoodsResp} GmAddGoodsResp instance
             */
            GmAddGoodsResp.create = function create(properties) {
                return new GmAddGoodsResp(properties);
            };

            /**
             * Encodes the specified GmAddGoodsResp message. Does not implicitly {@link luck.protobuf.GmAddGoodsResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.GmAddGoodsResp
             * @static
             * @param {luck.protobuf.IGmAddGoodsResp} message GmAddGoodsResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GmAddGoodsResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                return writer;
            };

            /**
             * Encodes the specified GmAddGoodsResp message, length delimited. Does not implicitly {@link luck.protobuf.GmAddGoodsResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.GmAddGoodsResp
             * @static
             * @param {luck.protobuf.IGmAddGoodsResp} message GmAddGoodsResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GmAddGoodsResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GmAddGoodsResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.GmAddGoodsResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.GmAddGoodsResp} GmAddGoodsResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GmAddGoodsResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.GmAddGoodsResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a GmAddGoodsResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.GmAddGoodsResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.GmAddGoodsResp} GmAddGoodsResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GmAddGoodsResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GmAddGoodsResp message.
             * @function verify
             * @memberof luck.protobuf.GmAddGoodsResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GmAddGoodsResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                return null;
            };

            return GmAddGoodsResp;
        })();

        protobuf.ChangeEquipResp = (function() {

            /**
             * Properties of a ChangeEquipResp.
             * @memberof luck.protobuf
             * @interface IChangeEquipResp
             * @property {number} result ChangeEquipResp result
             * @property {luck.protobuf.IPlayerBasePB|null} [playerBase] ChangeEquipResp playerBase
             */

            /**
             * Constructs a new ChangeEquipResp.
             * @memberof luck.protobuf
             * @classdesc Represents a ChangeEquipResp.
             * @implements IChangeEquipResp
             * @constructor
             * @param {luck.protobuf.IChangeEquipResp=} [properties] Properties to set
             */
            function ChangeEquipResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ChangeEquipResp result.
             * @member {number} result
             * @memberof luck.protobuf.ChangeEquipResp
             * @instance
             */
            ChangeEquipResp.prototype.result = 0;

            /**
             * ChangeEquipResp playerBase.
             * @member {luck.protobuf.IPlayerBasePB|null|undefined} playerBase
             * @memberof luck.protobuf.ChangeEquipResp
             * @instance
             */
            ChangeEquipResp.prototype.playerBase = null;

            /**
             * Creates a new ChangeEquipResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.ChangeEquipResp
             * @static
             * @param {luck.protobuf.IChangeEquipResp=} [properties] Properties to set
             * @returns {luck.protobuf.ChangeEquipResp} ChangeEquipResp instance
             */
            ChangeEquipResp.create = function create(properties) {
                return new ChangeEquipResp(properties);
            };

            /**
             * Encodes the specified ChangeEquipResp message. Does not implicitly {@link luck.protobuf.ChangeEquipResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.ChangeEquipResp
             * @static
             * @param {luck.protobuf.IChangeEquipResp} message ChangeEquipResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChangeEquipResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.playerBase != null && message.hasOwnProperty("playerBase"))
                    $root.luck.protobuf.PlayerBasePB.encode(message.playerBase, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ChangeEquipResp message, length delimited. Does not implicitly {@link luck.protobuf.ChangeEquipResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.ChangeEquipResp
             * @static
             * @param {luck.protobuf.IChangeEquipResp} message ChangeEquipResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChangeEquipResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ChangeEquipResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.ChangeEquipResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.ChangeEquipResp} ChangeEquipResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChangeEquipResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.ChangeEquipResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.playerBase = $root.luck.protobuf.PlayerBasePB.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a ChangeEquipResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.ChangeEquipResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.ChangeEquipResp} ChangeEquipResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChangeEquipResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ChangeEquipResp message.
             * @function verify
             * @memberof luck.protobuf.ChangeEquipResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChangeEquipResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.playerBase != null && message.hasOwnProperty("playerBase")) {
                    var error = $root.luck.protobuf.PlayerBasePB.verify(message.playerBase);
                    if (error)
                        return "playerBase." + error;
                }
                return null;
            };

            return ChangeEquipResp;
        })();

        protobuf.GoodsUpdatePushResp = (function() {

            /**
             * Properties of a GoodsUpdatePushResp.
             * @memberof luck.protobuf
             * @interface IGoodsUpdatePushResp
             * @property {Array.<luck.protobuf.IWeaponPB>|null} [addWeaponList] GoodsUpdatePushResp addWeaponList
             * @property {Array.<luck.protobuf.IWeaponPB>|null} [updateWeaponList] GoodsUpdatePushResp updateWeaponList
             * @property {Array.<number|Long>|null} [delWeaponUidList] GoodsUpdatePushResp delWeaponUidList
             * @property {Array.<luck.protobuf.ICardPB>|null} [addCardList] GoodsUpdatePushResp addCardList
             * @property {Array.<luck.protobuf.ICardPB>|null} [updateCardList] GoodsUpdatePushResp updateCardList
             * @property {Array.<number|Long>|null} [delCardUidList] GoodsUpdatePushResp delCardUidList
             * @property {Array.<luck.protobuf.IClothesPB>|null} [addClothesList] GoodsUpdatePushResp addClothesList
             * @property {Array.<luck.protobuf.IClothesPB>|null} [updateClothesList] GoodsUpdatePushResp updateClothesList
             * @property {Array.<number|Long>|null} [delClothesUidList] GoodsUpdatePushResp delClothesUidList
             * @property {luck.protobuf.IItemBagPB|null} [updateItemBag] GoodsUpdatePushResp updateItemBag
             * @property {luck.protobuf.IPlayerBasePB|null} [updatePlayerBase] GoodsUpdatePushResp updatePlayerBase
             * @property {luck.protobuf.IPlayerExtraPB|null} [updatePlayerExtra] GoodsUpdatePushResp updatePlayerExtra
             * @property {Array.<luck.protobuf.IRolePB>|null} [updateRoleList] GoodsUpdatePushResp updateRoleList
             */

            /**
             * Constructs a new GoodsUpdatePushResp.
             * @memberof luck.protobuf
             * @classdesc Represents a GoodsUpdatePushResp.
             * @implements IGoodsUpdatePushResp
             * @constructor
             * @param {luck.protobuf.IGoodsUpdatePushResp=} [properties] Properties to set
             */
            function GoodsUpdatePushResp(properties) {
                this.addWeaponList = [];
                this.updateWeaponList = [];
                this.delWeaponUidList = [];
                this.addCardList = [];
                this.updateCardList = [];
                this.delCardUidList = [];
                this.addClothesList = [];
                this.updateClothesList = [];
                this.delClothesUidList = [];
                this.updateRoleList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GoodsUpdatePushResp addWeaponList.
             * @member {Array.<luck.protobuf.IWeaponPB>} addWeaponList
             * @memberof luck.protobuf.GoodsUpdatePushResp
             * @instance
             */
            GoodsUpdatePushResp.prototype.addWeaponList = $util.emptyArray;

            /**
             * GoodsUpdatePushResp updateWeaponList.
             * @member {Array.<luck.protobuf.IWeaponPB>} updateWeaponList
             * @memberof luck.protobuf.GoodsUpdatePushResp
             * @instance
             */
            GoodsUpdatePushResp.prototype.updateWeaponList = $util.emptyArray;

            /**
             * GoodsUpdatePushResp delWeaponUidList.
             * @member {Array.<number|Long>} delWeaponUidList
             * @memberof luck.protobuf.GoodsUpdatePushResp
             * @instance
             */
            GoodsUpdatePushResp.prototype.delWeaponUidList = $util.emptyArray;

            /**
             * GoodsUpdatePushResp addCardList.
             * @member {Array.<luck.protobuf.ICardPB>} addCardList
             * @memberof luck.protobuf.GoodsUpdatePushResp
             * @instance
             */
            GoodsUpdatePushResp.prototype.addCardList = $util.emptyArray;

            /**
             * GoodsUpdatePushResp updateCardList.
             * @member {Array.<luck.protobuf.ICardPB>} updateCardList
             * @memberof luck.protobuf.GoodsUpdatePushResp
             * @instance
             */
            GoodsUpdatePushResp.prototype.updateCardList = $util.emptyArray;

            /**
             * GoodsUpdatePushResp delCardUidList.
             * @member {Array.<number|Long>} delCardUidList
             * @memberof luck.protobuf.GoodsUpdatePushResp
             * @instance
             */
            GoodsUpdatePushResp.prototype.delCardUidList = $util.emptyArray;

            /**
             * GoodsUpdatePushResp addClothesList.
             * @member {Array.<luck.protobuf.IClothesPB>} addClothesList
             * @memberof luck.protobuf.GoodsUpdatePushResp
             * @instance
             */
            GoodsUpdatePushResp.prototype.addClothesList = $util.emptyArray;

            /**
             * GoodsUpdatePushResp updateClothesList.
             * @member {Array.<luck.protobuf.IClothesPB>} updateClothesList
             * @memberof luck.protobuf.GoodsUpdatePushResp
             * @instance
             */
            GoodsUpdatePushResp.prototype.updateClothesList = $util.emptyArray;

            /**
             * GoodsUpdatePushResp delClothesUidList.
             * @member {Array.<number|Long>} delClothesUidList
             * @memberof luck.protobuf.GoodsUpdatePushResp
             * @instance
             */
            GoodsUpdatePushResp.prototype.delClothesUidList = $util.emptyArray;

            /**
             * GoodsUpdatePushResp updateItemBag.
             * @member {luck.protobuf.IItemBagPB|null|undefined} updateItemBag
             * @memberof luck.protobuf.GoodsUpdatePushResp
             * @instance
             */
            GoodsUpdatePushResp.prototype.updateItemBag = null;

            /**
             * GoodsUpdatePushResp updatePlayerBase.
             * @member {luck.protobuf.IPlayerBasePB|null|undefined} updatePlayerBase
             * @memberof luck.protobuf.GoodsUpdatePushResp
             * @instance
             */
            GoodsUpdatePushResp.prototype.updatePlayerBase = null;

            /**
             * GoodsUpdatePushResp updatePlayerExtra.
             * @member {luck.protobuf.IPlayerExtraPB|null|undefined} updatePlayerExtra
             * @memberof luck.protobuf.GoodsUpdatePushResp
             * @instance
             */
            GoodsUpdatePushResp.prototype.updatePlayerExtra = null;

            /**
             * GoodsUpdatePushResp updateRoleList.
             * @member {Array.<luck.protobuf.IRolePB>} updateRoleList
             * @memberof luck.protobuf.GoodsUpdatePushResp
             * @instance
             */
            GoodsUpdatePushResp.prototype.updateRoleList = $util.emptyArray;

            /**
             * Creates a new GoodsUpdatePushResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.GoodsUpdatePushResp
             * @static
             * @param {luck.protobuf.IGoodsUpdatePushResp=} [properties] Properties to set
             * @returns {luck.protobuf.GoodsUpdatePushResp} GoodsUpdatePushResp instance
             */
            GoodsUpdatePushResp.create = function create(properties) {
                return new GoodsUpdatePushResp(properties);
            };

            /**
             * Encodes the specified GoodsUpdatePushResp message. Does not implicitly {@link luck.protobuf.GoodsUpdatePushResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.GoodsUpdatePushResp
             * @static
             * @param {luck.protobuf.IGoodsUpdatePushResp} message GoodsUpdatePushResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GoodsUpdatePushResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.addWeaponList != null && message.addWeaponList.length)
                    for (var i = 0; i < message.addWeaponList.length; ++i)
                        $root.luck.protobuf.WeaponPB.encode(message.addWeaponList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.updateWeaponList != null && message.updateWeaponList.length)
                    for (var i = 0; i < message.updateWeaponList.length; ++i)
                        $root.luck.protobuf.WeaponPB.encode(message.updateWeaponList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.delWeaponUidList != null && message.delWeaponUidList.length)
                    for (var i = 0; i < message.delWeaponUidList.length; ++i)
                        writer.uint32(/* id 3, wireType 0 =*/24).int64(message.delWeaponUidList[i]);
                if (message.addCardList != null && message.addCardList.length)
                    for (var i = 0; i < message.addCardList.length; ++i)
                        $root.luck.protobuf.CardPB.encode(message.addCardList[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.updateCardList != null && message.updateCardList.length)
                    for (var i = 0; i < message.updateCardList.length; ++i)
                        $root.luck.protobuf.CardPB.encode(message.updateCardList[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.delCardUidList != null && message.delCardUidList.length)
                    for (var i = 0; i < message.delCardUidList.length; ++i)
                        writer.uint32(/* id 6, wireType 0 =*/48).int64(message.delCardUidList[i]);
                if (message.addClothesList != null && message.addClothesList.length)
                    for (var i = 0; i < message.addClothesList.length; ++i)
                        $root.luck.protobuf.ClothesPB.encode(message.addClothesList[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.updateClothesList != null && message.updateClothesList.length)
                    for (var i = 0; i < message.updateClothesList.length; ++i)
                        $root.luck.protobuf.ClothesPB.encode(message.updateClothesList[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.delClothesUidList != null && message.delClothesUidList.length)
                    for (var i = 0; i < message.delClothesUidList.length; ++i)
                        writer.uint32(/* id 9, wireType 0 =*/72).int64(message.delClothesUidList[i]);
                if (message.updateItemBag != null && message.hasOwnProperty("updateItemBag"))
                    $root.luck.protobuf.ItemBagPB.encode(message.updateItemBag, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.updatePlayerBase != null && message.hasOwnProperty("updatePlayerBase"))
                    $root.luck.protobuf.PlayerBasePB.encode(message.updatePlayerBase, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.updatePlayerExtra != null && message.hasOwnProperty("updatePlayerExtra"))
                    $root.luck.protobuf.PlayerExtraPB.encode(message.updatePlayerExtra, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                if (message.updateRoleList != null && message.updateRoleList.length)
                    for (var i = 0; i < message.updateRoleList.length; ++i)
                        $root.luck.protobuf.RolePB.encode(message.updateRoleList[i], writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GoodsUpdatePushResp message, length delimited. Does not implicitly {@link luck.protobuf.GoodsUpdatePushResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.GoodsUpdatePushResp
             * @static
             * @param {luck.protobuf.IGoodsUpdatePushResp} message GoodsUpdatePushResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GoodsUpdatePushResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GoodsUpdatePushResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.GoodsUpdatePushResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.GoodsUpdatePushResp} GoodsUpdatePushResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GoodsUpdatePushResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.GoodsUpdatePushResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.addWeaponList && message.addWeaponList.length))
                            message.addWeaponList = [];
                        message.addWeaponList.push($root.luck.protobuf.WeaponPB.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        if (!(message.updateWeaponList && message.updateWeaponList.length))
                            message.updateWeaponList = [];
                        message.updateWeaponList.push($root.luck.protobuf.WeaponPB.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.delWeaponUidList && message.delWeaponUidList.length))
                            message.delWeaponUidList = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.delWeaponUidList.push(reader.int64());
                        } else
                            message.delWeaponUidList.push(reader.int64());
                        break;
                    case 4:
                        if (!(message.addCardList && message.addCardList.length))
                            message.addCardList = [];
                        message.addCardList.push($root.luck.protobuf.CardPB.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.updateCardList && message.updateCardList.length))
                            message.updateCardList = [];
                        message.updateCardList.push($root.luck.protobuf.CardPB.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.delCardUidList && message.delCardUidList.length))
                            message.delCardUidList = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.delCardUidList.push(reader.int64());
                        } else
                            message.delCardUidList.push(reader.int64());
                        break;
                    case 7:
                        if (!(message.addClothesList && message.addClothesList.length))
                            message.addClothesList = [];
                        message.addClothesList.push($root.luck.protobuf.ClothesPB.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        if (!(message.updateClothesList && message.updateClothesList.length))
                            message.updateClothesList = [];
                        message.updateClothesList.push($root.luck.protobuf.ClothesPB.decode(reader, reader.uint32()));
                        break;
                    case 9:
                        if (!(message.delClothesUidList && message.delClothesUidList.length))
                            message.delClothesUidList = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.delClothesUidList.push(reader.int64());
                        } else
                            message.delClothesUidList.push(reader.int64());
                        break;
                    case 10:
                        message.updateItemBag = $root.luck.protobuf.ItemBagPB.decode(reader, reader.uint32());
                        break;
                    case 11:
                        message.updatePlayerBase = $root.luck.protobuf.PlayerBasePB.decode(reader, reader.uint32());
                        break;
                    case 12:
                        message.updatePlayerExtra = $root.luck.protobuf.PlayerExtraPB.decode(reader, reader.uint32());
                        break;
                    case 13:
                        if (!(message.updateRoleList && message.updateRoleList.length))
                            message.updateRoleList = [];
                        message.updateRoleList.push($root.luck.protobuf.RolePB.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GoodsUpdatePushResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.GoodsUpdatePushResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.GoodsUpdatePushResp} GoodsUpdatePushResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GoodsUpdatePushResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GoodsUpdatePushResp message.
             * @function verify
             * @memberof luck.protobuf.GoodsUpdatePushResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GoodsUpdatePushResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.addWeaponList != null && message.hasOwnProperty("addWeaponList")) {
                    if (!Array.isArray(message.addWeaponList))
                        return "addWeaponList: array expected";
                    for (var i = 0; i < message.addWeaponList.length; ++i) {
                        var error = $root.luck.protobuf.WeaponPB.verify(message.addWeaponList[i]);
                        if (error)
                            return "addWeaponList." + error;
                    }
                }
                if (message.updateWeaponList != null && message.hasOwnProperty("updateWeaponList")) {
                    if (!Array.isArray(message.updateWeaponList))
                        return "updateWeaponList: array expected";
                    for (var i = 0; i < message.updateWeaponList.length; ++i) {
                        var error = $root.luck.protobuf.WeaponPB.verify(message.updateWeaponList[i]);
                        if (error)
                            return "updateWeaponList." + error;
                    }
                }
                if (message.delWeaponUidList != null && message.hasOwnProperty("delWeaponUidList")) {
                    if (!Array.isArray(message.delWeaponUidList))
                        return "delWeaponUidList: array expected";
                    for (var i = 0; i < message.delWeaponUidList.length; ++i)
                        if (!$util.isInteger(message.delWeaponUidList[i]) && !(message.delWeaponUidList[i] && $util.isInteger(message.delWeaponUidList[i].low) && $util.isInteger(message.delWeaponUidList[i].high)))
                            return "delWeaponUidList: integer|Long[] expected";
                }
                if (message.addCardList != null && message.hasOwnProperty("addCardList")) {
                    if (!Array.isArray(message.addCardList))
                        return "addCardList: array expected";
                    for (var i = 0; i < message.addCardList.length; ++i) {
                        var error = $root.luck.protobuf.CardPB.verify(message.addCardList[i]);
                        if (error)
                            return "addCardList." + error;
                    }
                }
                if (message.updateCardList != null && message.hasOwnProperty("updateCardList")) {
                    if (!Array.isArray(message.updateCardList))
                        return "updateCardList: array expected";
                    for (var i = 0; i < message.updateCardList.length; ++i) {
                        var error = $root.luck.protobuf.CardPB.verify(message.updateCardList[i]);
                        if (error)
                            return "updateCardList." + error;
                    }
                }
                if (message.delCardUidList != null && message.hasOwnProperty("delCardUidList")) {
                    if (!Array.isArray(message.delCardUidList))
                        return "delCardUidList: array expected";
                    for (var i = 0; i < message.delCardUidList.length; ++i)
                        if (!$util.isInteger(message.delCardUidList[i]) && !(message.delCardUidList[i] && $util.isInteger(message.delCardUidList[i].low) && $util.isInteger(message.delCardUidList[i].high)))
                            return "delCardUidList: integer|Long[] expected";
                }
                if (message.addClothesList != null && message.hasOwnProperty("addClothesList")) {
                    if (!Array.isArray(message.addClothesList))
                        return "addClothesList: array expected";
                    for (var i = 0; i < message.addClothesList.length; ++i) {
                        var error = $root.luck.protobuf.ClothesPB.verify(message.addClothesList[i]);
                        if (error)
                            return "addClothesList." + error;
                    }
                }
                if (message.updateClothesList != null && message.hasOwnProperty("updateClothesList")) {
                    if (!Array.isArray(message.updateClothesList))
                        return "updateClothesList: array expected";
                    for (var i = 0; i < message.updateClothesList.length; ++i) {
                        var error = $root.luck.protobuf.ClothesPB.verify(message.updateClothesList[i]);
                        if (error)
                            return "updateClothesList." + error;
                    }
                }
                if (message.delClothesUidList != null && message.hasOwnProperty("delClothesUidList")) {
                    if (!Array.isArray(message.delClothesUidList))
                        return "delClothesUidList: array expected";
                    for (var i = 0; i < message.delClothesUidList.length; ++i)
                        if (!$util.isInteger(message.delClothesUidList[i]) && !(message.delClothesUidList[i] && $util.isInteger(message.delClothesUidList[i].low) && $util.isInteger(message.delClothesUidList[i].high)))
                            return "delClothesUidList: integer|Long[] expected";
                }
                if (message.updateItemBag != null && message.hasOwnProperty("updateItemBag")) {
                    var error = $root.luck.protobuf.ItemBagPB.verify(message.updateItemBag);
                    if (error)
                        return "updateItemBag." + error;
                }
                if (message.updatePlayerBase != null && message.hasOwnProperty("updatePlayerBase")) {
                    var error = $root.luck.protobuf.PlayerBasePB.verify(message.updatePlayerBase);
                    if (error)
                        return "updatePlayerBase." + error;
                }
                if (message.updatePlayerExtra != null && message.hasOwnProperty("updatePlayerExtra")) {
                    var error = $root.luck.protobuf.PlayerExtraPB.verify(message.updatePlayerExtra);
                    if (error)
                        return "updatePlayerExtra." + error;
                }
                if (message.updateRoleList != null && message.hasOwnProperty("updateRoleList")) {
                    if (!Array.isArray(message.updateRoleList))
                        return "updateRoleList: array expected";
                    for (var i = 0; i < message.updateRoleList.length; ++i) {
                        var error = $root.luck.protobuf.RolePB.verify(message.updateRoleList[i]);
                        if (error)
                            return "updateRoleList." + error;
                    }
                }
                return null;
            };

            return GoodsUpdatePushResp;
        })();

        protobuf.BattleResp = (function() {

            /**
             * Properties of a BattleResp.
             * @memberof luck.protobuf
             * @interface IBattleResp
             * @property {Array.<luck.protobuf.IOperationPB>|null} [operationList] BattleResp operationList
             * @property {number} frameId BattleResp frameId
             */

            /**
             * Constructs a new BattleResp.
             * @memberof luck.protobuf
             * @classdesc Represents a BattleResp.
             * @implements IBattleResp
             * @constructor
             * @param {luck.protobuf.IBattleResp=} [properties] Properties to set
             */
            function BattleResp(properties) {
                this.operationList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BattleResp operationList.
             * @member {Array.<luck.protobuf.IOperationPB>} operationList
             * @memberof luck.protobuf.BattleResp
             * @instance
             */
            BattleResp.prototype.operationList = $util.emptyArray;

            /**
             * BattleResp frameId.
             * @member {number} frameId
             * @memberof luck.protobuf.BattleResp
             * @instance
             */
            BattleResp.prototype.frameId = 0;

            /**
             * Creates a new BattleResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.BattleResp
             * @static
             * @param {luck.protobuf.IBattleResp=} [properties] Properties to set
             * @returns {luck.protobuf.BattleResp} BattleResp instance
             */
            BattleResp.create = function create(properties) {
                return new BattleResp(properties);
            };

            /**
             * Encodes the specified BattleResp message. Does not implicitly {@link luck.protobuf.BattleResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.BattleResp
             * @static
             * @param {luck.protobuf.IBattleResp} message BattleResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BattleResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operationList != null && message.operationList.length)
                    for (var i = 0; i < message.operationList.length; ++i)
                        $root.luck.protobuf.OperationPB.encode(message.operationList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.frameId);
                return writer;
            };

            /**
             * Encodes the specified BattleResp message, length delimited. Does not implicitly {@link luck.protobuf.BattleResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.BattleResp
             * @static
             * @param {luck.protobuf.IBattleResp} message BattleResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BattleResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BattleResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.BattleResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.BattleResp} BattleResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BattleResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.BattleResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.operationList && message.operationList.length))
                            message.operationList = [];
                        message.operationList.push($root.luck.protobuf.OperationPB.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.frameId = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("frameId"))
                    throw $util.ProtocolError("missing required 'frameId'", { instance: message });
                return message;
            };

            /**
             * Decodes a BattleResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.BattleResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.BattleResp} BattleResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BattleResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BattleResp message.
             * @function verify
             * @memberof luck.protobuf.BattleResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BattleResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operationList != null && message.hasOwnProperty("operationList")) {
                    if (!Array.isArray(message.operationList))
                        return "operationList: array expected";
                    for (var i = 0; i < message.operationList.length; ++i) {
                        var error = $root.luck.protobuf.OperationPB.verify(message.operationList[i]);
                        if (error)
                            return "operationList." + error;
                    }
                }
                if (!$util.isInteger(message.frameId))
                    return "frameId: integer expected";
                return null;
            };

            return BattleResp;
        })();

        protobuf.GetRoomListResp = (function() {

            /**
             * Properties of a GetRoomListResp.
             * @memberof luck.protobuf
             * @interface IGetRoomListResp
             * @property {Array.<luck.protobuf.IRoomPB>|null} [roomList] GetRoomListResp roomList
             */

            /**
             * Constructs a new GetRoomListResp.
             * @memberof luck.protobuf
             * @classdesc Represents a GetRoomListResp.
             * @implements IGetRoomListResp
             * @constructor
             * @param {luck.protobuf.IGetRoomListResp=} [properties] Properties to set
             */
            function GetRoomListResp(properties) {
                this.roomList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetRoomListResp roomList.
             * @member {Array.<luck.protobuf.IRoomPB>} roomList
             * @memberof luck.protobuf.GetRoomListResp
             * @instance
             */
            GetRoomListResp.prototype.roomList = $util.emptyArray;

            /**
             * Creates a new GetRoomListResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.GetRoomListResp
             * @static
             * @param {luck.protobuf.IGetRoomListResp=} [properties] Properties to set
             * @returns {luck.protobuf.GetRoomListResp} GetRoomListResp instance
             */
            GetRoomListResp.create = function create(properties) {
                return new GetRoomListResp(properties);
            };

            /**
             * Encodes the specified GetRoomListResp message. Does not implicitly {@link luck.protobuf.GetRoomListResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.GetRoomListResp
             * @static
             * @param {luck.protobuf.IGetRoomListResp} message GetRoomListResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetRoomListResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.roomList != null && message.roomList.length)
                    for (var i = 0; i < message.roomList.length; ++i)
                        $root.luck.protobuf.RoomPB.encode(message.roomList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetRoomListResp message, length delimited. Does not implicitly {@link luck.protobuf.GetRoomListResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.GetRoomListResp
             * @static
             * @param {luck.protobuf.IGetRoomListResp} message GetRoomListResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetRoomListResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetRoomListResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.GetRoomListResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.GetRoomListResp} GetRoomListResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetRoomListResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.GetRoomListResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.roomList && message.roomList.length))
                            message.roomList = [];
                        message.roomList.push($root.luck.protobuf.RoomPB.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetRoomListResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.GetRoomListResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.GetRoomListResp} GetRoomListResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetRoomListResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetRoomListResp message.
             * @function verify
             * @memberof luck.protobuf.GetRoomListResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetRoomListResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.roomList != null && message.hasOwnProperty("roomList")) {
                    if (!Array.isArray(message.roomList))
                        return "roomList: array expected";
                    for (var i = 0; i < message.roomList.length; ++i) {
                        var error = $root.luck.protobuf.RoomPB.verify(message.roomList[i]);
                        if (error)
                            return "roomList." + error;
                    }
                }
                return null;
            };

            return GetRoomListResp;
        })();

        protobuf.EnterRoomResp = (function() {

            /**
             * Properties of an EnterRoomResp.
             * @memberof luck.protobuf
             * @interface IEnterRoomResp
             * @property {number} result EnterRoomResp result
             * @property {luck.protobuf.IRoomPB|null} [room] EnterRoomResp room
             */

            /**
             * Constructs a new EnterRoomResp.
             * @memberof luck.protobuf
             * @classdesc Represents an EnterRoomResp.
             * @implements IEnterRoomResp
             * @constructor
             * @param {luck.protobuf.IEnterRoomResp=} [properties] Properties to set
             */
            function EnterRoomResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnterRoomResp result.
             * @member {number} result
             * @memberof luck.protobuf.EnterRoomResp
             * @instance
             */
            EnterRoomResp.prototype.result = 0;

            /**
             * EnterRoomResp room.
             * @member {luck.protobuf.IRoomPB|null|undefined} room
             * @memberof luck.protobuf.EnterRoomResp
             * @instance
             */
            EnterRoomResp.prototype.room = null;

            /**
             * Creates a new EnterRoomResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.EnterRoomResp
             * @static
             * @param {luck.protobuf.IEnterRoomResp=} [properties] Properties to set
             * @returns {luck.protobuf.EnterRoomResp} EnterRoomResp instance
             */
            EnterRoomResp.create = function create(properties) {
                return new EnterRoomResp(properties);
            };

            /**
             * Encodes the specified EnterRoomResp message. Does not implicitly {@link luck.protobuf.EnterRoomResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.EnterRoomResp
             * @static
             * @param {luck.protobuf.IEnterRoomResp} message EnterRoomResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnterRoomResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.room != null && message.hasOwnProperty("room"))
                    $root.luck.protobuf.RoomPB.encode(message.room, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EnterRoomResp message, length delimited. Does not implicitly {@link luck.protobuf.EnterRoomResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.EnterRoomResp
             * @static
             * @param {luck.protobuf.IEnterRoomResp} message EnterRoomResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnterRoomResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnterRoomResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.EnterRoomResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.EnterRoomResp} EnterRoomResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnterRoomResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.EnterRoomResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.room = $root.luck.protobuf.RoomPB.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes an EnterRoomResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.EnterRoomResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.EnterRoomResp} EnterRoomResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnterRoomResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnterRoomResp message.
             * @function verify
             * @memberof luck.protobuf.EnterRoomResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnterRoomResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.room != null && message.hasOwnProperty("room")) {
                    var error = $root.luck.protobuf.RoomPB.verify(message.room);
                    if (error)
                        return "room." + error;
                }
                return null;
            };

            return EnterRoomResp;
        })();

        protobuf.ExitRoomResp = (function() {

            /**
             * Properties of an ExitRoomResp.
             * @memberof luck.protobuf
             * @interface IExitRoomResp
             * @property {number|Long} roomId ExitRoomResp roomId
             * @property {luck.protobuf.IRoomPB|null} [room] ExitRoomResp room
             * @property {number|Long|null} [playerId] ExitRoomResp playerId
             */

            /**
             * Constructs a new ExitRoomResp.
             * @memberof luck.protobuf
             * @classdesc Represents an ExitRoomResp.
             * @implements IExitRoomResp
             * @constructor
             * @param {luck.protobuf.IExitRoomResp=} [properties] Properties to set
             */
            function ExitRoomResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExitRoomResp roomId.
             * @member {number|Long} roomId
             * @memberof luck.protobuf.ExitRoomResp
             * @instance
             */
            ExitRoomResp.prototype.roomId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * ExitRoomResp room.
             * @member {luck.protobuf.IRoomPB|null|undefined} room
             * @memberof luck.protobuf.ExitRoomResp
             * @instance
             */
            ExitRoomResp.prototype.room = null;

            /**
             * ExitRoomResp playerId.
             * @member {number|Long} playerId
             * @memberof luck.protobuf.ExitRoomResp
             * @instance
             */
            ExitRoomResp.prototype.playerId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new ExitRoomResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.ExitRoomResp
             * @static
             * @param {luck.protobuf.IExitRoomResp=} [properties] Properties to set
             * @returns {luck.protobuf.ExitRoomResp} ExitRoomResp instance
             */
            ExitRoomResp.create = function create(properties) {
                return new ExitRoomResp(properties);
            };

            /**
             * Encodes the specified ExitRoomResp message. Does not implicitly {@link luck.protobuf.ExitRoomResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.ExitRoomResp
             * @static
             * @param {luck.protobuf.IExitRoomResp} message ExitRoomResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExitRoomResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.roomId);
                if (message.room != null && message.hasOwnProperty("room"))
                    $root.luck.protobuf.RoomPB.encode(message.room, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.playerId != null && message.hasOwnProperty("playerId"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.playerId);
                return writer;
            };

            /**
             * Encodes the specified ExitRoomResp message, length delimited. Does not implicitly {@link luck.protobuf.ExitRoomResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.ExitRoomResp
             * @static
             * @param {luck.protobuf.IExitRoomResp} message ExitRoomResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExitRoomResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExitRoomResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.ExitRoomResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.ExitRoomResp} ExitRoomResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExitRoomResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.ExitRoomResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.roomId = reader.int64();
                        break;
                    case 2:
                        message.room = $root.luck.protobuf.RoomPB.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.playerId = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("roomId"))
                    throw $util.ProtocolError("missing required 'roomId'", { instance: message });
                return message;
            };

            /**
             * Decodes an ExitRoomResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.ExitRoomResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.ExitRoomResp} ExitRoomResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExitRoomResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExitRoomResp message.
             * @function verify
             * @memberof luck.protobuf.ExitRoomResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExitRoomResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.roomId) && !(message.roomId && $util.isInteger(message.roomId.low) && $util.isInteger(message.roomId.high)))
                    return "roomId: integer|Long expected";
                if (message.room != null && message.hasOwnProperty("room")) {
                    var error = $root.luck.protobuf.RoomPB.verify(message.room);
                    if (error)
                        return "room." + error;
                }
                if (message.playerId != null && message.hasOwnProperty("playerId"))
                    if (!$util.isInteger(message.playerId) && !(message.playerId && $util.isInteger(message.playerId.low) && $util.isInteger(message.playerId.high)))
                        return "playerId: integer|Long expected";
                return null;
            };

            return ExitRoomResp;
        })();

        protobuf.CreateRoomResp = (function() {

            /**
             * Properties of a CreateRoomResp.
             * @memberof luck.protobuf
             * @interface ICreateRoomResp
             * @property {luck.protobuf.IRoomPB|null} [room] CreateRoomResp room
             * @property {number} result CreateRoomResp result
             */

            /**
             * Constructs a new CreateRoomResp.
             * @memberof luck.protobuf
             * @classdesc Represents a CreateRoomResp.
             * @implements ICreateRoomResp
             * @constructor
             * @param {luck.protobuf.ICreateRoomResp=} [properties] Properties to set
             */
            function CreateRoomResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CreateRoomResp room.
             * @member {luck.protobuf.IRoomPB|null|undefined} room
             * @memberof luck.protobuf.CreateRoomResp
             * @instance
             */
            CreateRoomResp.prototype.room = null;

            /**
             * CreateRoomResp result.
             * @member {number} result
             * @memberof luck.protobuf.CreateRoomResp
             * @instance
             */
            CreateRoomResp.prototype.result = 0;

            /**
             * Creates a new CreateRoomResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.CreateRoomResp
             * @static
             * @param {luck.protobuf.ICreateRoomResp=} [properties] Properties to set
             * @returns {luck.protobuf.CreateRoomResp} CreateRoomResp instance
             */
            CreateRoomResp.create = function create(properties) {
                return new CreateRoomResp(properties);
            };

            /**
             * Encodes the specified CreateRoomResp message. Does not implicitly {@link luck.protobuf.CreateRoomResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.CreateRoomResp
             * @static
             * @param {luck.protobuf.ICreateRoomResp} message CreateRoomResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateRoomResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.room != null && message.hasOwnProperty("room"))
                    $root.luck.protobuf.RoomPB.encode(message.room, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.result);
                return writer;
            };

            /**
             * Encodes the specified CreateRoomResp message, length delimited. Does not implicitly {@link luck.protobuf.CreateRoomResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.CreateRoomResp
             * @static
             * @param {luck.protobuf.ICreateRoomResp} message CreateRoomResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateRoomResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CreateRoomResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.CreateRoomResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.CreateRoomResp} CreateRoomResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateRoomResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.CreateRoomResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.room = $root.luck.protobuf.RoomPB.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.result = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a CreateRoomResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.CreateRoomResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.CreateRoomResp} CreateRoomResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateRoomResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CreateRoomResp message.
             * @function verify
             * @memberof luck.protobuf.CreateRoomResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateRoomResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.room != null && message.hasOwnProperty("room")) {
                    var error = $root.luck.protobuf.RoomPB.verify(message.room);
                    if (error)
                        return "room." + error;
                }
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                return null;
            };

            return CreateRoomResp;
        })();

        protobuf.StartBattleResp = (function() {

            /**
             * Properties of a StartBattleResp.
             * @memberof luck.protobuf
             * @interface IStartBattleResp
             * @property {boolean} isStart StartBattleResp isStart
             */

            /**
             * Constructs a new StartBattleResp.
             * @memberof luck.protobuf
             * @classdesc Represents a StartBattleResp.
             * @implements IStartBattleResp
             * @constructor
             * @param {luck.protobuf.IStartBattleResp=} [properties] Properties to set
             */
            function StartBattleResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StartBattleResp isStart.
             * @member {boolean} isStart
             * @memberof luck.protobuf.StartBattleResp
             * @instance
             */
            StartBattleResp.prototype.isStart = false;

            /**
             * Creates a new StartBattleResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.StartBattleResp
             * @static
             * @param {luck.protobuf.IStartBattleResp=} [properties] Properties to set
             * @returns {luck.protobuf.StartBattleResp} StartBattleResp instance
             */
            StartBattleResp.create = function create(properties) {
                return new StartBattleResp(properties);
            };

            /**
             * Encodes the specified StartBattleResp message. Does not implicitly {@link luck.protobuf.StartBattleResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.StartBattleResp
             * @static
             * @param {luck.protobuf.IStartBattleResp} message StartBattleResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StartBattleResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isStart);
                return writer;
            };

            /**
             * Encodes the specified StartBattleResp message, length delimited. Does not implicitly {@link luck.protobuf.StartBattleResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.StartBattleResp
             * @static
             * @param {luck.protobuf.IStartBattleResp} message StartBattleResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StartBattleResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StartBattleResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.StartBattleResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.StartBattleResp} StartBattleResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StartBattleResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.StartBattleResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.isStart = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("isStart"))
                    throw $util.ProtocolError("missing required 'isStart'", { instance: message });
                return message;
            };

            /**
             * Decodes a StartBattleResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.StartBattleResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.StartBattleResp} StartBattleResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StartBattleResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StartBattleResp message.
             * @function verify
             * @memberof luck.protobuf.StartBattleResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StartBattleResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (typeof message.isStart !== "boolean")
                    return "isStart: boolean expected";
                return null;
            };

            return StartBattleResp;
        })();

        protobuf.StartCheckNodeResp = (function() {

            /**
             * Properties of a StartCheckNodeResp.
             * @memberof luck.protobuf
             * @interface IStartCheckNodeResp
             * @property {number} result StartCheckNodeResp result
             */

            /**
             * Constructs a new StartCheckNodeResp.
             * @memberof luck.protobuf
             * @classdesc Represents a StartCheckNodeResp.
             * @implements IStartCheckNodeResp
             * @constructor
             * @param {luck.protobuf.IStartCheckNodeResp=} [properties] Properties to set
             */
            function StartCheckNodeResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StartCheckNodeResp result.
             * @member {number} result
             * @memberof luck.protobuf.StartCheckNodeResp
             * @instance
             */
            StartCheckNodeResp.prototype.result = 0;

            /**
             * Creates a new StartCheckNodeResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.StartCheckNodeResp
             * @static
             * @param {luck.protobuf.IStartCheckNodeResp=} [properties] Properties to set
             * @returns {luck.protobuf.StartCheckNodeResp} StartCheckNodeResp instance
             */
            StartCheckNodeResp.create = function create(properties) {
                return new StartCheckNodeResp(properties);
            };

            /**
             * Encodes the specified StartCheckNodeResp message. Does not implicitly {@link luck.protobuf.StartCheckNodeResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.StartCheckNodeResp
             * @static
             * @param {luck.protobuf.IStartCheckNodeResp} message StartCheckNodeResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StartCheckNodeResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                return writer;
            };

            /**
             * Encodes the specified StartCheckNodeResp message, length delimited. Does not implicitly {@link luck.protobuf.StartCheckNodeResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.StartCheckNodeResp
             * @static
             * @param {luck.protobuf.IStartCheckNodeResp} message StartCheckNodeResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StartCheckNodeResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StartCheckNodeResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.StartCheckNodeResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.StartCheckNodeResp} StartCheckNodeResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StartCheckNodeResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.StartCheckNodeResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a StartCheckNodeResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.StartCheckNodeResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.StartCheckNodeResp} StartCheckNodeResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StartCheckNodeResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StartCheckNodeResp message.
             * @function verify
             * @memberof luck.protobuf.StartCheckNodeResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StartCheckNodeResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                return null;
            };

            return StartCheckNodeResp;
        })();

        protobuf.FinishCheckNodeResp = (function() {

            /**
             * Properties of a FinishCheckNodeResp.
             * @memberof luck.protobuf
             * @interface IFinishCheckNodeResp
             * @property {number} result FinishCheckNodeResp result
             * @property {Array.<luck.protobuf.IpveBallteFinishReward>|null} [rewardList] FinishCheckNodeResp rewardList
             * @property {Array.<luck.protobuf.ICheckNode>|null} [checkNodeList] FinishCheckNodeResp checkNodeList
             * @property {number|null} [gainExp] FinishCheckNodeResp gainExp
             * @property {number|null} [lv] FinishCheckNodeResp lv
             */

            /**
             * Constructs a new FinishCheckNodeResp.
             * @memberof luck.protobuf
             * @classdesc Represents a FinishCheckNodeResp.
             * @implements IFinishCheckNodeResp
             * @constructor
             * @param {luck.protobuf.IFinishCheckNodeResp=} [properties] Properties to set
             */
            function FinishCheckNodeResp(properties) {
                this.rewardList = [];
                this.checkNodeList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FinishCheckNodeResp result.
             * @member {number} result
             * @memberof luck.protobuf.FinishCheckNodeResp
             * @instance
             */
            FinishCheckNodeResp.prototype.result = 0;

            /**
             * FinishCheckNodeResp rewardList.
             * @member {Array.<luck.protobuf.IpveBallteFinishReward>} rewardList
             * @memberof luck.protobuf.FinishCheckNodeResp
             * @instance
             */
            FinishCheckNodeResp.prototype.rewardList = $util.emptyArray;

            /**
             * FinishCheckNodeResp checkNodeList.
             * @member {Array.<luck.protobuf.ICheckNode>} checkNodeList
             * @memberof luck.protobuf.FinishCheckNodeResp
             * @instance
             */
            FinishCheckNodeResp.prototype.checkNodeList = $util.emptyArray;

            /**
             * FinishCheckNodeResp gainExp.
             * @member {number} gainExp
             * @memberof luck.protobuf.FinishCheckNodeResp
             * @instance
             */
            FinishCheckNodeResp.prototype.gainExp = 0;

            /**
             * FinishCheckNodeResp lv.
             * @member {number} lv
             * @memberof luck.protobuf.FinishCheckNodeResp
             * @instance
             */
            FinishCheckNodeResp.prototype.lv = 0;

            /**
             * Creates a new FinishCheckNodeResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.FinishCheckNodeResp
             * @static
             * @param {luck.protobuf.IFinishCheckNodeResp=} [properties] Properties to set
             * @returns {luck.protobuf.FinishCheckNodeResp} FinishCheckNodeResp instance
             */
            FinishCheckNodeResp.create = function create(properties) {
                return new FinishCheckNodeResp(properties);
            };

            /**
             * Encodes the specified FinishCheckNodeResp message. Does not implicitly {@link luck.protobuf.FinishCheckNodeResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.FinishCheckNodeResp
             * @static
             * @param {luck.protobuf.IFinishCheckNodeResp} message FinishCheckNodeResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FinishCheckNodeResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.rewardList != null && message.rewardList.length)
                    for (var i = 0; i < message.rewardList.length; ++i)
                        $root.luck.protobuf.pveBallteFinishReward.encode(message.rewardList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.checkNodeList != null && message.checkNodeList.length)
                    for (var i = 0; i < message.checkNodeList.length; ++i)
                        $root.luck.protobuf.CheckNode.encode(message.checkNodeList[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.gainExp != null && message.hasOwnProperty("gainExp"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.gainExp);
                if (message.lv != null && message.hasOwnProperty("lv"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.lv);
                return writer;
            };

            /**
             * Encodes the specified FinishCheckNodeResp message, length delimited. Does not implicitly {@link luck.protobuf.FinishCheckNodeResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.FinishCheckNodeResp
             * @static
             * @param {luck.protobuf.IFinishCheckNodeResp} message FinishCheckNodeResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FinishCheckNodeResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FinishCheckNodeResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.FinishCheckNodeResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.FinishCheckNodeResp} FinishCheckNodeResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FinishCheckNodeResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.FinishCheckNodeResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        if (!(message.rewardList && message.rewardList.length))
                            message.rewardList = [];
                        message.rewardList.push($root.luck.protobuf.pveBallteFinishReward.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.checkNodeList && message.checkNodeList.length))
                            message.checkNodeList = [];
                        message.checkNodeList.push($root.luck.protobuf.CheckNode.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        message.gainExp = reader.int32();
                        break;
                    case 5:
                        message.lv = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a FinishCheckNodeResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.FinishCheckNodeResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.FinishCheckNodeResp} FinishCheckNodeResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FinishCheckNodeResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FinishCheckNodeResp message.
             * @function verify
             * @memberof luck.protobuf.FinishCheckNodeResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FinishCheckNodeResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.rewardList != null && message.hasOwnProperty("rewardList")) {
                    if (!Array.isArray(message.rewardList))
                        return "rewardList: array expected";
                    for (var i = 0; i < message.rewardList.length; ++i) {
                        var error = $root.luck.protobuf.pveBallteFinishReward.verify(message.rewardList[i]);
                        if (error)
                            return "rewardList." + error;
                    }
                }
                if (message.checkNodeList != null && message.hasOwnProperty("checkNodeList")) {
                    if (!Array.isArray(message.checkNodeList))
                        return "checkNodeList: array expected";
                    for (var i = 0; i < message.checkNodeList.length; ++i) {
                        var error = $root.luck.protobuf.CheckNode.verify(message.checkNodeList[i]);
                        if (error)
                            return "checkNodeList." + error;
                    }
                }
                if (message.gainExp != null && message.hasOwnProperty("gainExp"))
                    if (!$util.isInteger(message.gainExp))
                        return "gainExp: integer expected";
                if (message.lv != null && message.hasOwnProperty("lv"))
                    if (!$util.isInteger(message.lv))
                        return "lv: integer expected";
                return null;
            };

            return FinishCheckNodeResp;
        })();

        protobuf.BattleDropResp = (function() {

            /**
             * Properties of a BattleDropResp.
             * @memberof luck.protobuf
             * @interface IBattleDropResp
             * @property {number} result BattleDropResp result
             * @property {number|Long|null} [gold] BattleDropResp gold
             * @property {number|Long|null} [diamond] BattleDropResp diamond
             * @property {Array.<luck.protobuf.IWeaponPB>|null} [weaponList] BattleDropResp weaponList
             * @property {Array.<luck.protobuf.ICardPB>|null} [cardList] BattleDropResp cardList
             * @property {Array.<luck.protobuf.IClothesPB>|null} [clothesList] BattleDropResp clothesList
             * @property {Array.<luck.protobuf.IPropPB>|null} [propList] BattleDropResp propList
             * @property {Array.<luck.protobuf.IMaterialsPB>|null} [materialsList] BattleDropResp materialsList
             */

            /**
             * Constructs a new BattleDropResp.
             * @memberof luck.protobuf
             * @classdesc Represents a BattleDropResp.
             * @implements IBattleDropResp
             * @constructor
             * @param {luck.protobuf.IBattleDropResp=} [properties] Properties to set
             */
            function BattleDropResp(properties) {
                this.weaponList = [];
                this.cardList = [];
                this.clothesList = [];
                this.propList = [];
                this.materialsList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BattleDropResp result.
             * @member {number} result
             * @memberof luck.protobuf.BattleDropResp
             * @instance
             */
            BattleDropResp.prototype.result = 0;

            /**
             * BattleDropResp gold.
             * @member {number|Long} gold
             * @memberof luck.protobuf.BattleDropResp
             * @instance
             */
            BattleDropResp.prototype.gold = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * BattleDropResp diamond.
             * @member {number|Long} diamond
             * @memberof luck.protobuf.BattleDropResp
             * @instance
             */
            BattleDropResp.prototype.diamond = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * BattleDropResp weaponList.
             * @member {Array.<luck.protobuf.IWeaponPB>} weaponList
             * @memberof luck.protobuf.BattleDropResp
             * @instance
             */
            BattleDropResp.prototype.weaponList = $util.emptyArray;

            /**
             * BattleDropResp cardList.
             * @member {Array.<luck.protobuf.ICardPB>} cardList
             * @memberof luck.protobuf.BattleDropResp
             * @instance
             */
            BattleDropResp.prototype.cardList = $util.emptyArray;

            /**
             * BattleDropResp clothesList.
             * @member {Array.<luck.protobuf.IClothesPB>} clothesList
             * @memberof luck.protobuf.BattleDropResp
             * @instance
             */
            BattleDropResp.prototype.clothesList = $util.emptyArray;

            /**
             * BattleDropResp propList.
             * @member {Array.<luck.protobuf.IPropPB>} propList
             * @memberof luck.protobuf.BattleDropResp
             * @instance
             */
            BattleDropResp.prototype.propList = $util.emptyArray;

            /**
             * BattleDropResp materialsList.
             * @member {Array.<luck.protobuf.IMaterialsPB>} materialsList
             * @memberof luck.protobuf.BattleDropResp
             * @instance
             */
            BattleDropResp.prototype.materialsList = $util.emptyArray;

            /**
             * Creates a new BattleDropResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.BattleDropResp
             * @static
             * @param {luck.protobuf.IBattleDropResp=} [properties] Properties to set
             * @returns {luck.protobuf.BattleDropResp} BattleDropResp instance
             */
            BattleDropResp.create = function create(properties) {
                return new BattleDropResp(properties);
            };

            /**
             * Encodes the specified BattleDropResp message. Does not implicitly {@link luck.protobuf.BattleDropResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.BattleDropResp
             * @static
             * @param {luck.protobuf.IBattleDropResp} message BattleDropResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BattleDropResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.gold != null && message.hasOwnProperty("gold"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.gold);
                if (message.diamond != null && message.hasOwnProperty("diamond"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.diamond);
                if (message.weaponList != null && message.weaponList.length)
                    for (var i = 0; i < message.weaponList.length; ++i)
                        $root.luck.protobuf.WeaponPB.encode(message.weaponList[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.cardList != null && message.cardList.length)
                    for (var i = 0; i < message.cardList.length; ++i)
                        $root.luck.protobuf.CardPB.encode(message.cardList[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.clothesList != null && message.clothesList.length)
                    for (var i = 0; i < message.clothesList.length; ++i)
                        $root.luck.protobuf.ClothesPB.encode(message.clothesList[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.propList != null && message.propList.length)
                    for (var i = 0; i < message.propList.length; ++i)
                        $root.luck.protobuf.PropPB.encode(message.propList[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.materialsList != null && message.materialsList.length)
                    for (var i = 0; i < message.materialsList.length; ++i)
                        $root.luck.protobuf.MaterialsPB.encode(message.materialsList[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified BattleDropResp message, length delimited. Does not implicitly {@link luck.protobuf.BattleDropResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.BattleDropResp
             * @static
             * @param {luck.protobuf.IBattleDropResp} message BattleDropResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BattleDropResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BattleDropResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.BattleDropResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.BattleDropResp} BattleDropResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BattleDropResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.BattleDropResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.gold = reader.int64();
                        break;
                    case 3:
                        message.diamond = reader.int64();
                        break;
                    case 4:
                        if (!(message.weaponList && message.weaponList.length))
                            message.weaponList = [];
                        message.weaponList.push($root.luck.protobuf.WeaponPB.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.cardList && message.cardList.length))
                            message.cardList = [];
                        message.cardList.push($root.luck.protobuf.CardPB.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.clothesList && message.clothesList.length))
                            message.clothesList = [];
                        message.clothesList.push($root.luck.protobuf.ClothesPB.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        if (!(message.propList && message.propList.length))
                            message.propList = [];
                        message.propList.push($root.luck.protobuf.PropPB.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        if (!(message.materialsList && message.materialsList.length))
                            message.materialsList = [];
                        message.materialsList.push($root.luck.protobuf.MaterialsPB.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a BattleDropResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.BattleDropResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.BattleDropResp} BattleDropResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BattleDropResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BattleDropResp message.
             * @function verify
             * @memberof luck.protobuf.BattleDropResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BattleDropResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.gold != null && message.hasOwnProperty("gold"))
                    if (!$util.isInteger(message.gold) && !(message.gold && $util.isInteger(message.gold.low) && $util.isInteger(message.gold.high)))
                        return "gold: integer|Long expected";
                if (message.diamond != null && message.hasOwnProperty("diamond"))
                    if (!$util.isInteger(message.diamond) && !(message.diamond && $util.isInteger(message.diamond.low) && $util.isInteger(message.diamond.high)))
                        return "diamond: integer|Long expected";
                if (message.weaponList != null && message.hasOwnProperty("weaponList")) {
                    if (!Array.isArray(message.weaponList))
                        return "weaponList: array expected";
                    for (var i = 0; i < message.weaponList.length; ++i) {
                        var error = $root.luck.protobuf.WeaponPB.verify(message.weaponList[i]);
                        if (error)
                            return "weaponList." + error;
                    }
                }
                if (message.cardList != null && message.hasOwnProperty("cardList")) {
                    if (!Array.isArray(message.cardList))
                        return "cardList: array expected";
                    for (var i = 0; i < message.cardList.length; ++i) {
                        var error = $root.luck.protobuf.CardPB.verify(message.cardList[i]);
                        if (error)
                            return "cardList." + error;
                    }
                }
                if (message.clothesList != null && message.hasOwnProperty("clothesList")) {
                    if (!Array.isArray(message.clothesList))
                        return "clothesList: array expected";
                    for (var i = 0; i < message.clothesList.length; ++i) {
                        var error = $root.luck.protobuf.ClothesPB.verify(message.clothesList[i]);
                        if (error)
                            return "clothesList." + error;
                    }
                }
                if (message.propList != null && message.hasOwnProperty("propList")) {
                    if (!Array.isArray(message.propList))
                        return "propList: array expected";
                    for (var i = 0; i < message.propList.length; ++i) {
                        var error = $root.luck.protobuf.PropPB.verify(message.propList[i]);
                        if (error)
                            return "propList." + error;
                    }
                }
                if (message.materialsList != null && message.hasOwnProperty("materialsList")) {
                    if (!Array.isArray(message.materialsList))
                        return "materialsList: array expected";
                    for (var i = 0; i < message.materialsList.length; ++i) {
                        var error = $root.luck.protobuf.MaterialsPB.verify(message.materialsList[i]);
                        if (error)
                            return "materialsList." + error;
                    }
                }
                return null;
            };

            return BattleDropResp;
        })();

        protobuf.SginInResp = (function() {

            /**
             * Properties of a SginInResp.
             * @memberof luck.protobuf
             * @interface ISginInResp
             * @property {number} result SginInResp result
             * @property {number|Long|null} [sginInTime] SginInResp sginInTime
             * @property {number|null} [sginCount] SginInResp sginCount
             * @property {number|Long|null} [gold] SginInResp gold
             * @property {number|Long|null} [diamond] SginInResp diamond
             * @property {Array.<luck.protobuf.IWeaponPB>|null} [weaponList] SginInResp weaponList
             * @property {Array.<luck.protobuf.ICardPB>|null} [cardList] SginInResp cardList
             * @property {Array.<luck.protobuf.IClothesPB>|null} [clothesList] SginInResp clothesList
             * @property {Array.<luck.protobuf.IPropPB>|null} [propList] SginInResp propList
             * @property {Array.<luck.protobuf.IMaterialsPB>|null} [materialsList] SginInResp materialsList
             * @property {number|null} [allCount] SginInResp allCount
             */

            /**
             * Constructs a new SginInResp.
             * @memberof luck.protobuf
             * @classdesc Represents a SginInResp.
             * @implements ISginInResp
             * @constructor
             * @param {luck.protobuf.ISginInResp=} [properties] Properties to set
             */
            function SginInResp(properties) {
                this.weaponList = [];
                this.cardList = [];
                this.clothesList = [];
                this.propList = [];
                this.materialsList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SginInResp result.
             * @member {number} result
             * @memberof luck.protobuf.SginInResp
             * @instance
             */
            SginInResp.prototype.result = 0;

            /**
             * SginInResp sginInTime.
             * @member {number|Long} sginInTime
             * @memberof luck.protobuf.SginInResp
             * @instance
             */
            SginInResp.prototype.sginInTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * SginInResp sginCount.
             * @member {number} sginCount
             * @memberof luck.protobuf.SginInResp
             * @instance
             */
            SginInResp.prototype.sginCount = 0;

            /**
             * SginInResp gold.
             * @member {number|Long} gold
             * @memberof luck.protobuf.SginInResp
             * @instance
             */
            SginInResp.prototype.gold = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * SginInResp diamond.
             * @member {number|Long} diamond
             * @memberof luck.protobuf.SginInResp
             * @instance
             */
            SginInResp.prototype.diamond = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * SginInResp weaponList.
             * @member {Array.<luck.protobuf.IWeaponPB>} weaponList
             * @memberof luck.protobuf.SginInResp
             * @instance
             */
            SginInResp.prototype.weaponList = $util.emptyArray;

            /**
             * SginInResp cardList.
             * @member {Array.<luck.protobuf.ICardPB>} cardList
             * @memberof luck.protobuf.SginInResp
             * @instance
             */
            SginInResp.prototype.cardList = $util.emptyArray;

            /**
             * SginInResp clothesList.
             * @member {Array.<luck.protobuf.IClothesPB>} clothesList
             * @memberof luck.protobuf.SginInResp
             * @instance
             */
            SginInResp.prototype.clothesList = $util.emptyArray;

            /**
             * SginInResp propList.
             * @member {Array.<luck.protobuf.IPropPB>} propList
             * @memberof luck.protobuf.SginInResp
             * @instance
             */
            SginInResp.prototype.propList = $util.emptyArray;

            /**
             * SginInResp materialsList.
             * @member {Array.<luck.protobuf.IMaterialsPB>} materialsList
             * @memberof luck.protobuf.SginInResp
             * @instance
             */
            SginInResp.prototype.materialsList = $util.emptyArray;

            /**
             * SginInResp allCount.
             * @member {number} allCount
             * @memberof luck.protobuf.SginInResp
             * @instance
             */
            SginInResp.prototype.allCount = 0;

            /**
             * Creates a new SginInResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.SginInResp
             * @static
             * @param {luck.protobuf.ISginInResp=} [properties] Properties to set
             * @returns {luck.protobuf.SginInResp} SginInResp instance
             */
            SginInResp.create = function create(properties) {
                return new SginInResp(properties);
            };

            /**
             * Encodes the specified SginInResp message. Does not implicitly {@link luck.protobuf.SginInResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.SginInResp
             * @static
             * @param {luck.protobuf.ISginInResp} message SginInResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SginInResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.sginInTime != null && message.hasOwnProperty("sginInTime"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.sginInTime);
                if (message.sginCount != null && message.hasOwnProperty("sginCount"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.sginCount);
                if (message.gold != null && message.hasOwnProperty("gold"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.gold);
                if (message.diamond != null && message.hasOwnProperty("diamond"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.diamond);
                if (message.weaponList != null && message.weaponList.length)
                    for (var i = 0; i < message.weaponList.length; ++i)
                        $root.luck.protobuf.WeaponPB.encode(message.weaponList[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.cardList != null && message.cardList.length)
                    for (var i = 0; i < message.cardList.length; ++i)
                        $root.luck.protobuf.CardPB.encode(message.cardList[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.clothesList != null && message.clothesList.length)
                    for (var i = 0; i < message.clothesList.length; ++i)
                        $root.luck.protobuf.ClothesPB.encode(message.clothesList[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.propList != null && message.propList.length)
                    for (var i = 0; i < message.propList.length; ++i)
                        $root.luck.protobuf.PropPB.encode(message.propList[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.materialsList != null && message.materialsList.length)
                    for (var i = 0; i < message.materialsList.length; ++i)
                        $root.luck.protobuf.MaterialsPB.encode(message.materialsList[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.allCount != null && message.hasOwnProperty("allCount"))
                    writer.uint32(/* id 11, wireType 0 =*/88).int32(message.allCount);
                return writer;
            };

            /**
             * Encodes the specified SginInResp message, length delimited. Does not implicitly {@link luck.protobuf.SginInResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.SginInResp
             * @static
             * @param {luck.protobuf.ISginInResp} message SginInResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SginInResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SginInResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.SginInResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.SginInResp} SginInResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SginInResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.SginInResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.sginInTime = reader.int64();
                        break;
                    case 3:
                        message.sginCount = reader.int32();
                        break;
                    case 4:
                        message.gold = reader.int64();
                        break;
                    case 5:
                        message.diamond = reader.int64();
                        break;
                    case 6:
                        if (!(message.weaponList && message.weaponList.length))
                            message.weaponList = [];
                        message.weaponList.push($root.luck.protobuf.WeaponPB.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        if (!(message.cardList && message.cardList.length))
                            message.cardList = [];
                        message.cardList.push($root.luck.protobuf.CardPB.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        if (!(message.clothesList && message.clothesList.length))
                            message.clothesList = [];
                        message.clothesList.push($root.luck.protobuf.ClothesPB.decode(reader, reader.uint32()));
                        break;
                    case 9:
                        if (!(message.propList && message.propList.length))
                            message.propList = [];
                        message.propList.push($root.luck.protobuf.PropPB.decode(reader, reader.uint32()));
                        break;
                    case 10:
                        if (!(message.materialsList && message.materialsList.length))
                            message.materialsList = [];
                        message.materialsList.push($root.luck.protobuf.MaterialsPB.decode(reader, reader.uint32()));
                        break;
                    case 11:
                        message.allCount = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a SginInResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.SginInResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.SginInResp} SginInResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SginInResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SginInResp message.
             * @function verify
             * @memberof luck.protobuf.SginInResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SginInResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.sginInTime != null && message.hasOwnProperty("sginInTime"))
                    if (!$util.isInteger(message.sginInTime) && !(message.sginInTime && $util.isInteger(message.sginInTime.low) && $util.isInteger(message.sginInTime.high)))
                        return "sginInTime: integer|Long expected";
                if (message.sginCount != null && message.hasOwnProperty("sginCount"))
                    if (!$util.isInteger(message.sginCount))
                        return "sginCount: integer expected";
                if (message.gold != null && message.hasOwnProperty("gold"))
                    if (!$util.isInteger(message.gold) && !(message.gold && $util.isInteger(message.gold.low) && $util.isInteger(message.gold.high)))
                        return "gold: integer|Long expected";
                if (message.diamond != null && message.hasOwnProperty("diamond"))
                    if (!$util.isInteger(message.diamond) && !(message.diamond && $util.isInteger(message.diamond.low) && $util.isInteger(message.diamond.high)))
                        return "diamond: integer|Long expected";
                if (message.weaponList != null && message.hasOwnProperty("weaponList")) {
                    if (!Array.isArray(message.weaponList))
                        return "weaponList: array expected";
                    for (var i = 0; i < message.weaponList.length; ++i) {
                        var error = $root.luck.protobuf.WeaponPB.verify(message.weaponList[i]);
                        if (error)
                            return "weaponList." + error;
                    }
                }
                if (message.cardList != null && message.hasOwnProperty("cardList")) {
                    if (!Array.isArray(message.cardList))
                        return "cardList: array expected";
                    for (var i = 0; i < message.cardList.length; ++i) {
                        var error = $root.luck.protobuf.CardPB.verify(message.cardList[i]);
                        if (error)
                            return "cardList." + error;
                    }
                }
                if (message.clothesList != null && message.hasOwnProperty("clothesList")) {
                    if (!Array.isArray(message.clothesList))
                        return "clothesList: array expected";
                    for (var i = 0; i < message.clothesList.length; ++i) {
                        var error = $root.luck.protobuf.ClothesPB.verify(message.clothesList[i]);
                        if (error)
                            return "clothesList." + error;
                    }
                }
                if (message.propList != null && message.hasOwnProperty("propList")) {
                    if (!Array.isArray(message.propList))
                        return "propList: array expected";
                    for (var i = 0; i < message.propList.length; ++i) {
                        var error = $root.luck.protobuf.PropPB.verify(message.propList[i]);
                        if (error)
                            return "propList." + error;
                    }
                }
                if (message.materialsList != null && message.hasOwnProperty("materialsList")) {
                    if (!Array.isArray(message.materialsList))
                        return "materialsList: array expected";
                    for (var i = 0; i < message.materialsList.length; ++i) {
                        var error = $root.luck.protobuf.MaterialsPB.verify(message.materialsList[i]);
                        if (error)
                            return "materialsList." + error;
                    }
                }
                if (message.allCount != null && message.hasOwnProperty("allCount"))
                    if (!$util.isInteger(message.allCount))
                        return "allCount: integer expected";
                return null;
            };

            return SginInResp;
        })();

        protobuf.LotteryResp = (function() {

            /**
             * Properties of a LotteryResp.
             * @memberof luck.protobuf
             * @interface ILotteryResp
             * @property {number} result LotteryResp result
             * @property {number|Long|null} [gold] LotteryResp gold
             * @property {number|Long|null} [diamond] LotteryResp diamond
             * @property {Array.<luck.protobuf.IWeaponPB>|null} [weaponList] LotteryResp weaponList
             * @property {Array.<luck.protobuf.ICardPB>|null} [cardList] LotteryResp cardList
             * @property {Array.<luck.protobuf.IClothesPB>|null} [clothesList] LotteryResp clothesList
             * @property {Array.<luck.protobuf.IPropPB>|null} [propList] LotteryResp propList
             * @property {Array.<luck.protobuf.IMaterialsPB>|null} [materialsList] LotteryResp materialsList
             * @property {Array.<number>|null} [itemId] LotteryResp itemId
             */

            /**
             * Constructs a new LotteryResp.
             * @memberof luck.protobuf
             * @classdesc Represents a LotteryResp.
             * @implements ILotteryResp
             * @constructor
             * @param {luck.protobuf.ILotteryResp=} [properties] Properties to set
             */
            function LotteryResp(properties) {
                this.weaponList = [];
                this.cardList = [];
                this.clothesList = [];
                this.propList = [];
                this.materialsList = [];
                this.itemId = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LotteryResp result.
             * @member {number} result
             * @memberof luck.protobuf.LotteryResp
             * @instance
             */
            LotteryResp.prototype.result = 0;

            /**
             * LotteryResp gold.
             * @member {number|Long} gold
             * @memberof luck.protobuf.LotteryResp
             * @instance
             */
            LotteryResp.prototype.gold = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * LotteryResp diamond.
             * @member {number|Long} diamond
             * @memberof luck.protobuf.LotteryResp
             * @instance
             */
            LotteryResp.prototype.diamond = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * LotteryResp weaponList.
             * @member {Array.<luck.protobuf.IWeaponPB>} weaponList
             * @memberof luck.protobuf.LotteryResp
             * @instance
             */
            LotteryResp.prototype.weaponList = $util.emptyArray;

            /**
             * LotteryResp cardList.
             * @member {Array.<luck.protobuf.ICardPB>} cardList
             * @memberof luck.protobuf.LotteryResp
             * @instance
             */
            LotteryResp.prototype.cardList = $util.emptyArray;

            /**
             * LotteryResp clothesList.
             * @member {Array.<luck.protobuf.IClothesPB>} clothesList
             * @memberof luck.protobuf.LotteryResp
             * @instance
             */
            LotteryResp.prototype.clothesList = $util.emptyArray;

            /**
             * LotteryResp propList.
             * @member {Array.<luck.protobuf.IPropPB>} propList
             * @memberof luck.protobuf.LotteryResp
             * @instance
             */
            LotteryResp.prototype.propList = $util.emptyArray;

            /**
             * LotteryResp materialsList.
             * @member {Array.<luck.protobuf.IMaterialsPB>} materialsList
             * @memberof luck.protobuf.LotteryResp
             * @instance
             */
            LotteryResp.prototype.materialsList = $util.emptyArray;

            /**
             * LotteryResp itemId.
             * @member {Array.<number>} itemId
             * @memberof luck.protobuf.LotteryResp
             * @instance
             */
            LotteryResp.prototype.itemId = $util.emptyArray;

            /**
             * Creates a new LotteryResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.LotteryResp
             * @static
             * @param {luck.protobuf.ILotteryResp=} [properties] Properties to set
             * @returns {luck.protobuf.LotteryResp} LotteryResp instance
             */
            LotteryResp.create = function create(properties) {
                return new LotteryResp(properties);
            };

            /**
             * Encodes the specified LotteryResp message. Does not implicitly {@link luck.protobuf.LotteryResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.LotteryResp
             * @static
             * @param {luck.protobuf.ILotteryResp} message LotteryResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LotteryResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.gold != null && message.hasOwnProperty("gold"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.gold);
                if (message.diamond != null && message.hasOwnProperty("diamond"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.diamond);
                if (message.weaponList != null && message.weaponList.length)
                    for (var i = 0; i < message.weaponList.length; ++i)
                        $root.luck.protobuf.WeaponPB.encode(message.weaponList[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.cardList != null && message.cardList.length)
                    for (var i = 0; i < message.cardList.length; ++i)
                        $root.luck.protobuf.CardPB.encode(message.cardList[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.clothesList != null && message.clothesList.length)
                    for (var i = 0; i < message.clothesList.length; ++i)
                        $root.luck.protobuf.ClothesPB.encode(message.clothesList[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.propList != null && message.propList.length)
                    for (var i = 0; i < message.propList.length; ++i)
                        $root.luck.protobuf.PropPB.encode(message.propList[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.materialsList != null && message.materialsList.length)
                    for (var i = 0; i < message.materialsList.length; ++i)
                        $root.luck.protobuf.MaterialsPB.encode(message.materialsList[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.itemId != null && message.itemId.length)
                    for (var i = 0; i < message.itemId.length; ++i)
                        writer.uint32(/* id 9, wireType 0 =*/72).int32(message.itemId[i]);
                return writer;
            };

            /**
             * Encodes the specified LotteryResp message, length delimited. Does not implicitly {@link luck.protobuf.LotteryResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.LotteryResp
             * @static
             * @param {luck.protobuf.ILotteryResp} message LotteryResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LotteryResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LotteryResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.LotteryResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.LotteryResp} LotteryResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LotteryResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.LotteryResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.gold = reader.int64();
                        break;
                    case 3:
                        message.diamond = reader.int64();
                        break;
                    case 4:
                        if (!(message.weaponList && message.weaponList.length))
                            message.weaponList = [];
                        message.weaponList.push($root.luck.protobuf.WeaponPB.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.cardList && message.cardList.length))
                            message.cardList = [];
                        message.cardList.push($root.luck.protobuf.CardPB.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.clothesList && message.clothesList.length))
                            message.clothesList = [];
                        message.clothesList.push($root.luck.protobuf.ClothesPB.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        if (!(message.propList && message.propList.length))
                            message.propList = [];
                        message.propList.push($root.luck.protobuf.PropPB.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        if (!(message.materialsList && message.materialsList.length))
                            message.materialsList = [];
                        message.materialsList.push($root.luck.protobuf.MaterialsPB.decode(reader, reader.uint32()));
                        break;
                    case 9:
                        if (!(message.itemId && message.itemId.length))
                            message.itemId = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.itemId.push(reader.int32());
                        } else
                            message.itemId.push(reader.int32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a LotteryResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.LotteryResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.LotteryResp} LotteryResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LotteryResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LotteryResp message.
             * @function verify
             * @memberof luck.protobuf.LotteryResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LotteryResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.gold != null && message.hasOwnProperty("gold"))
                    if (!$util.isInteger(message.gold) && !(message.gold && $util.isInteger(message.gold.low) && $util.isInteger(message.gold.high)))
                        return "gold: integer|Long expected";
                if (message.diamond != null && message.hasOwnProperty("diamond"))
                    if (!$util.isInteger(message.diamond) && !(message.diamond && $util.isInteger(message.diamond.low) && $util.isInteger(message.diamond.high)))
                        return "diamond: integer|Long expected";
                if (message.weaponList != null && message.hasOwnProperty("weaponList")) {
                    if (!Array.isArray(message.weaponList))
                        return "weaponList: array expected";
                    for (var i = 0; i < message.weaponList.length; ++i) {
                        var error = $root.luck.protobuf.WeaponPB.verify(message.weaponList[i]);
                        if (error)
                            return "weaponList." + error;
                    }
                }
                if (message.cardList != null && message.hasOwnProperty("cardList")) {
                    if (!Array.isArray(message.cardList))
                        return "cardList: array expected";
                    for (var i = 0; i < message.cardList.length; ++i) {
                        var error = $root.luck.protobuf.CardPB.verify(message.cardList[i]);
                        if (error)
                            return "cardList." + error;
                    }
                }
                if (message.clothesList != null && message.hasOwnProperty("clothesList")) {
                    if (!Array.isArray(message.clothesList))
                        return "clothesList: array expected";
                    for (var i = 0; i < message.clothesList.length; ++i) {
                        var error = $root.luck.protobuf.ClothesPB.verify(message.clothesList[i]);
                        if (error)
                            return "clothesList." + error;
                    }
                }
                if (message.propList != null && message.hasOwnProperty("propList")) {
                    if (!Array.isArray(message.propList))
                        return "propList: array expected";
                    for (var i = 0; i < message.propList.length; ++i) {
                        var error = $root.luck.protobuf.PropPB.verify(message.propList[i]);
                        if (error)
                            return "propList." + error;
                    }
                }
                if (message.materialsList != null && message.hasOwnProperty("materialsList")) {
                    if (!Array.isArray(message.materialsList))
                        return "materialsList: array expected";
                    for (var i = 0; i < message.materialsList.length; ++i) {
                        var error = $root.luck.protobuf.MaterialsPB.verify(message.materialsList[i]);
                        if (error)
                            return "materialsList." + error;
                    }
                }
                if (message.itemId != null && message.hasOwnProperty("itemId")) {
                    if (!Array.isArray(message.itemId))
                        return "itemId: array expected";
                    for (var i = 0; i < message.itemId.length; ++i)
                        if (!$util.isInteger(message.itemId[i]))
                            return "itemId: integer[] expected";
                }
                return null;
            };

            return LotteryResp;
        })();

        protobuf.SynthesisResp = (function() {

            /**
             * Properties of a SynthesisResp.
             * @memberof luck.protobuf
             * @interface ISynthesisResp
             * @property {number} result SynthesisResp result
             * @property {Array.<luck.protobuf.IWeaponPB>|null} [weaponList] SynthesisResp weaponList
             * @property {Array.<luck.protobuf.ICardPB>|null} [cardList] SynthesisResp cardList
             * @property {Array.<luck.protobuf.IClothesPB>|null} [clothesList] SynthesisResp clothesList
             * @property {Array.<luck.protobuf.IPropPB>|null} [propList] SynthesisResp propList
             * @property {Array.<luck.protobuf.IMaterialsPB>|null} [materialsList] SynthesisResp materialsList
             */

            /**
             * Constructs a new SynthesisResp.
             * @memberof luck.protobuf
             * @classdesc Represents a SynthesisResp.
             * @implements ISynthesisResp
             * @constructor
             * @param {luck.protobuf.ISynthesisResp=} [properties] Properties to set
             */
            function SynthesisResp(properties) {
                this.weaponList = [];
                this.cardList = [];
                this.clothesList = [];
                this.propList = [];
                this.materialsList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SynthesisResp result.
             * @member {number} result
             * @memberof luck.protobuf.SynthesisResp
             * @instance
             */
            SynthesisResp.prototype.result = 0;

            /**
             * SynthesisResp weaponList.
             * @member {Array.<luck.protobuf.IWeaponPB>} weaponList
             * @memberof luck.protobuf.SynthesisResp
             * @instance
             */
            SynthesisResp.prototype.weaponList = $util.emptyArray;

            /**
             * SynthesisResp cardList.
             * @member {Array.<luck.protobuf.ICardPB>} cardList
             * @memberof luck.protobuf.SynthesisResp
             * @instance
             */
            SynthesisResp.prototype.cardList = $util.emptyArray;

            /**
             * SynthesisResp clothesList.
             * @member {Array.<luck.protobuf.IClothesPB>} clothesList
             * @memberof luck.protobuf.SynthesisResp
             * @instance
             */
            SynthesisResp.prototype.clothesList = $util.emptyArray;

            /**
             * SynthesisResp propList.
             * @member {Array.<luck.protobuf.IPropPB>} propList
             * @memberof luck.protobuf.SynthesisResp
             * @instance
             */
            SynthesisResp.prototype.propList = $util.emptyArray;

            /**
             * SynthesisResp materialsList.
             * @member {Array.<luck.protobuf.IMaterialsPB>} materialsList
             * @memberof luck.protobuf.SynthesisResp
             * @instance
             */
            SynthesisResp.prototype.materialsList = $util.emptyArray;

            /**
             * Creates a new SynthesisResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.SynthesisResp
             * @static
             * @param {luck.protobuf.ISynthesisResp=} [properties] Properties to set
             * @returns {luck.protobuf.SynthesisResp} SynthesisResp instance
             */
            SynthesisResp.create = function create(properties) {
                return new SynthesisResp(properties);
            };

            /**
             * Encodes the specified SynthesisResp message. Does not implicitly {@link luck.protobuf.SynthesisResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.SynthesisResp
             * @static
             * @param {luck.protobuf.ISynthesisResp} message SynthesisResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SynthesisResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.weaponList != null && message.weaponList.length)
                    for (var i = 0; i < message.weaponList.length; ++i)
                        $root.luck.protobuf.WeaponPB.encode(message.weaponList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.cardList != null && message.cardList.length)
                    for (var i = 0; i < message.cardList.length; ++i)
                        $root.luck.protobuf.CardPB.encode(message.cardList[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.clothesList != null && message.clothesList.length)
                    for (var i = 0; i < message.clothesList.length; ++i)
                        $root.luck.protobuf.ClothesPB.encode(message.clothesList[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.propList != null && message.propList.length)
                    for (var i = 0; i < message.propList.length; ++i)
                        $root.luck.protobuf.PropPB.encode(message.propList[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.materialsList != null && message.materialsList.length)
                    for (var i = 0; i < message.materialsList.length; ++i)
                        $root.luck.protobuf.MaterialsPB.encode(message.materialsList[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SynthesisResp message, length delimited. Does not implicitly {@link luck.protobuf.SynthesisResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.SynthesisResp
             * @static
             * @param {luck.protobuf.ISynthesisResp} message SynthesisResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SynthesisResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SynthesisResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.SynthesisResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.SynthesisResp} SynthesisResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SynthesisResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.SynthesisResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        if (!(message.weaponList && message.weaponList.length))
                            message.weaponList = [];
                        message.weaponList.push($root.luck.protobuf.WeaponPB.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.cardList && message.cardList.length))
                            message.cardList = [];
                        message.cardList.push($root.luck.protobuf.CardPB.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        if (!(message.clothesList && message.clothesList.length))
                            message.clothesList = [];
                        message.clothesList.push($root.luck.protobuf.ClothesPB.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.propList && message.propList.length))
                            message.propList = [];
                        message.propList.push($root.luck.protobuf.PropPB.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.materialsList && message.materialsList.length))
                            message.materialsList = [];
                        message.materialsList.push($root.luck.protobuf.MaterialsPB.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a SynthesisResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.SynthesisResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.SynthesisResp} SynthesisResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SynthesisResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SynthesisResp message.
             * @function verify
             * @memberof luck.protobuf.SynthesisResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SynthesisResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.weaponList != null && message.hasOwnProperty("weaponList")) {
                    if (!Array.isArray(message.weaponList))
                        return "weaponList: array expected";
                    for (var i = 0; i < message.weaponList.length; ++i) {
                        var error = $root.luck.protobuf.WeaponPB.verify(message.weaponList[i]);
                        if (error)
                            return "weaponList." + error;
                    }
                }
                if (message.cardList != null && message.hasOwnProperty("cardList")) {
                    if (!Array.isArray(message.cardList))
                        return "cardList: array expected";
                    for (var i = 0; i < message.cardList.length; ++i) {
                        var error = $root.luck.protobuf.CardPB.verify(message.cardList[i]);
                        if (error)
                            return "cardList." + error;
                    }
                }
                if (message.clothesList != null && message.hasOwnProperty("clothesList")) {
                    if (!Array.isArray(message.clothesList))
                        return "clothesList: array expected";
                    for (var i = 0; i < message.clothesList.length; ++i) {
                        var error = $root.luck.protobuf.ClothesPB.verify(message.clothesList[i]);
                        if (error)
                            return "clothesList." + error;
                    }
                }
                if (message.propList != null && message.hasOwnProperty("propList")) {
                    if (!Array.isArray(message.propList))
                        return "propList: array expected";
                    for (var i = 0; i < message.propList.length; ++i) {
                        var error = $root.luck.protobuf.PropPB.verify(message.propList[i]);
                        if (error)
                            return "propList." + error;
                    }
                }
                if (message.materialsList != null && message.hasOwnProperty("materialsList")) {
                    if (!Array.isArray(message.materialsList))
                        return "materialsList: array expected";
                    for (var i = 0; i < message.materialsList.length; ++i) {
                        var error = $root.luck.protobuf.MaterialsPB.verify(message.materialsList[i]);
                        if (error)
                            return "materialsList." + error;
                    }
                }
                return null;
            };

            return SynthesisResp;
        })();

        protobuf.BattlePickUpResp = (function() {

            /**
             * Properties of a BattlePickUpResp.
             * @memberof luck.protobuf
             * @interface IBattlePickUpResp
             * @property {number} result BattlePickUpResp result
             */

            /**
             * Constructs a new BattlePickUpResp.
             * @memberof luck.protobuf
             * @classdesc Represents a BattlePickUpResp.
             * @implements IBattlePickUpResp
             * @constructor
             * @param {luck.protobuf.IBattlePickUpResp=} [properties] Properties to set
             */
            function BattlePickUpResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BattlePickUpResp result.
             * @member {number} result
             * @memberof luck.protobuf.BattlePickUpResp
             * @instance
             */
            BattlePickUpResp.prototype.result = 0;

            /**
             * Creates a new BattlePickUpResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.BattlePickUpResp
             * @static
             * @param {luck.protobuf.IBattlePickUpResp=} [properties] Properties to set
             * @returns {luck.protobuf.BattlePickUpResp} BattlePickUpResp instance
             */
            BattlePickUpResp.create = function create(properties) {
                return new BattlePickUpResp(properties);
            };

            /**
             * Encodes the specified BattlePickUpResp message. Does not implicitly {@link luck.protobuf.BattlePickUpResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.BattlePickUpResp
             * @static
             * @param {luck.protobuf.IBattlePickUpResp} message BattlePickUpResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BattlePickUpResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                return writer;
            };

            /**
             * Encodes the specified BattlePickUpResp message, length delimited. Does not implicitly {@link luck.protobuf.BattlePickUpResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.BattlePickUpResp
             * @static
             * @param {luck.protobuf.IBattlePickUpResp} message BattlePickUpResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BattlePickUpResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BattlePickUpResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.BattlePickUpResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.BattlePickUpResp} BattlePickUpResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BattlePickUpResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.BattlePickUpResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a BattlePickUpResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.BattlePickUpResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.BattlePickUpResp} BattlePickUpResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BattlePickUpResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BattlePickUpResp message.
             * @function verify
             * @memberof luck.protobuf.BattlePickUpResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BattlePickUpResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                return null;
            };

            return BattlePickUpResp;
        })();

        protobuf.SettingResp = (function() {

            /**
             * Properties of a SettingResp.
             * @memberof luck.protobuf
             * @interface ISettingResp
             * @property {number} result SettingResp result
             * @property {luck.protobuf.IPlayerExtraPB|null} [playerExtra] SettingResp playerExtra
             */

            /**
             * Constructs a new SettingResp.
             * @memberof luck.protobuf
             * @classdesc Represents a SettingResp.
             * @implements ISettingResp
             * @constructor
             * @param {luck.protobuf.ISettingResp=} [properties] Properties to set
             */
            function SettingResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SettingResp result.
             * @member {number} result
             * @memberof luck.protobuf.SettingResp
             * @instance
             */
            SettingResp.prototype.result = 0;

            /**
             * SettingResp playerExtra.
             * @member {luck.protobuf.IPlayerExtraPB|null|undefined} playerExtra
             * @memberof luck.protobuf.SettingResp
             * @instance
             */
            SettingResp.prototype.playerExtra = null;

            /**
             * Creates a new SettingResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.SettingResp
             * @static
             * @param {luck.protobuf.ISettingResp=} [properties] Properties to set
             * @returns {luck.protobuf.SettingResp} SettingResp instance
             */
            SettingResp.create = function create(properties) {
                return new SettingResp(properties);
            };

            /**
             * Encodes the specified SettingResp message. Does not implicitly {@link luck.protobuf.SettingResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.SettingResp
             * @static
             * @param {luck.protobuf.ISettingResp} message SettingResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SettingResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.playerExtra != null && message.hasOwnProperty("playerExtra"))
                    $root.luck.protobuf.PlayerExtraPB.encode(message.playerExtra, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SettingResp message, length delimited. Does not implicitly {@link luck.protobuf.SettingResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.SettingResp
             * @static
             * @param {luck.protobuf.ISettingResp} message SettingResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SettingResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SettingResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.SettingResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.SettingResp} SettingResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SettingResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.SettingResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.playerExtra = $root.luck.protobuf.PlayerExtraPB.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a SettingResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.SettingResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.SettingResp} SettingResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SettingResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SettingResp message.
             * @function verify
             * @memberof luck.protobuf.SettingResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SettingResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.playerExtra != null && message.hasOwnProperty("playerExtra")) {
                    var error = $root.luck.protobuf.PlayerExtraPB.verify(message.playerExtra);
                    if (error)
                        return "playerExtra." + error;
                }
                return null;
            };

            return SettingResp;
        })();

        protobuf.EquipRecastResp = (function() {

            /**
             * Properties of an EquipRecastResp.
             * @memberof luck.protobuf
             * @interface IEquipRecastResp
             * @property {number} result EquipRecastResp result
             * @property {luck.protobuf.IWeaponPB|null} [weapon] EquipRecastResp weapon
             * @property {luck.protobuf.IClothesPB|null} [clothes] EquipRecastResp clothes
             */

            /**
             * Constructs a new EquipRecastResp.
             * @memberof luck.protobuf
             * @classdesc Represents an EquipRecastResp.
             * @implements IEquipRecastResp
             * @constructor
             * @param {luck.protobuf.IEquipRecastResp=} [properties] Properties to set
             */
            function EquipRecastResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EquipRecastResp result.
             * @member {number} result
             * @memberof luck.protobuf.EquipRecastResp
             * @instance
             */
            EquipRecastResp.prototype.result = 0;

            /**
             * EquipRecastResp weapon.
             * @member {luck.protobuf.IWeaponPB|null|undefined} weapon
             * @memberof luck.protobuf.EquipRecastResp
             * @instance
             */
            EquipRecastResp.prototype.weapon = null;

            /**
             * EquipRecastResp clothes.
             * @member {luck.protobuf.IClothesPB|null|undefined} clothes
             * @memberof luck.protobuf.EquipRecastResp
             * @instance
             */
            EquipRecastResp.prototype.clothes = null;

            /**
             * Creates a new EquipRecastResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.EquipRecastResp
             * @static
             * @param {luck.protobuf.IEquipRecastResp=} [properties] Properties to set
             * @returns {luck.protobuf.EquipRecastResp} EquipRecastResp instance
             */
            EquipRecastResp.create = function create(properties) {
                return new EquipRecastResp(properties);
            };

            /**
             * Encodes the specified EquipRecastResp message. Does not implicitly {@link luck.protobuf.EquipRecastResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.EquipRecastResp
             * @static
             * @param {luck.protobuf.IEquipRecastResp} message EquipRecastResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EquipRecastResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.weapon != null && message.hasOwnProperty("weapon"))
                    $root.luck.protobuf.WeaponPB.encode(message.weapon, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.clothes != null && message.hasOwnProperty("clothes"))
                    $root.luck.protobuf.ClothesPB.encode(message.clothes, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EquipRecastResp message, length delimited. Does not implicitly {@link luck.protobuf.EquipRecastResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.EquipRecastResp
             * @static
             * @param {luck.protobuf.IEquipRecastResp} message EquipRecastResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EquipRecastResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EquipRecastResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.EquipRecastResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.EquipRecastResp} EquipRecastResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EquipRecastResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.EquipRecastResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.weapon = $root.luck.protobuf.WeaponPB.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.clothes = $root.luck.protobuf.ClothesPB.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes an EquipRecastResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.EquipRecastResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.EquipRecastResp} EquipRecastResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EquipRecastResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EquipRecastResp message.
             * @function verify
             * @memberof luck.protobuf.EquipRecastResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EquipRecastResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.weapon != null && message.hasOwnProperty("weapon")) {
                    var error = $root.luck.protobuf.WeaponPB.verify(message.weapon);
                    if (error)
                        return "weapon." + error;
                }
                if (message.clothes != null && message.hasOwnProperty("clothes")) {
                    var error = $root.luck.protobuf.ClothesPB.verify(message.clothes);
                    if (error)
                        return "clothes." + error;
                }
                return null;
            };

            return EquipRecastResp;
        })();

        protobuf.EquipRecastAffirmResp = (function() {

            /**
             * Properties of an EquipRecastAffirmResp.
             * @memberof luck.protobuf
             * @interface IEquipRecastAffirmResp
             * @property {number} result EquipRecastAffirmResp result
             * @property {luck.protobuf.IWeaponPB|null} [weapon] EquipRecastAffirmResp weapon
             * @property {luck.protobuf.IClothesPB|null} [clothes] EquipRecastAffirmResp clothes
             */

            /**
             * Constructs a new EquipRecastAffirmResp.
             * @memberof luck.protobuf
             * @classdesc Represents an EquipRecastAffirmResp.
             * @implements IEquipRecastAffirmResp
             * @constructor
             * @param {luck.protobuf.IEquipRecastAffirmResp=} [properties] Properties to set
             */
            function EquipRecastAffirmResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EquipRecastAffirmResp result.
             * @member {number} result
             * @memberof luck.protobuf.EquipRecastAffirmResp
             * @instance
             */
            EquipRecastAffirmResp.prototype.result = 0;

            /**
             * EquipRecastAffirmResp weapon.
             * @member {luck.protobuf.IWeaponPB|null|undefined} weapon
             * @memberof luck.protobuf.EquipRecastAffirmResp
             * @instance
             */
            EquipRecastAffirmResp.prototype.weapon = null;

            /**
             * EquipRecastAffirmResp clothes.
             * @member {luck.protobuf.IClothesPB|null|undefined} clothes
             * @memberof luck.protobuf.EquipRecastAffirmResp
             * @instance
             */
            EquipRecastAffirmResp.prototype.clothes = null;

            /**
             * Creates a new EquipRecastAffirmResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.EquipRecastAffirmResp
             * @static
             * @param {luck.protobuf.IEquipRecastAffirmResp=} [properties] Properties to set
             * @returns {luck.protobuf.EquipRecastAffirmResp} EquipRecastAffirmResp instance
             */
            EquipRecastAffirmResp.create = function create(properties) {
                return new EquipRecastAffirmResp(properties);
            };

            /**
             * Encodes the specified EquipRecastAffirmResp message. Does not implicitly {@link luck.protobuf.EquipRecastAffirmResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.EquipRecastAffirmResp
             * @static
             * @param {luck.protobuf.IEquipRecastAffirmResp} message EquipRecastAffirmResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EquipRecastAffirmResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.weapon != null && message.hasOwnProperty("weapon"))
                    $root.luck.protobuf.WeaponPB.encode(message.weapon, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.clothes != null && message.hasOwnProperty("clothes"))
                    $root.luck.protobuf.ClothesPB.encode(message.clothes, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EquipRecastAffirmResp message, length delimited. Does not implicitly {@link luck.protobuf.EquipRecastAffirmResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.EquipRecastAffirmResp
             * @static
             * @param {luck.protobuf.IEquipRecastAffirmResp} message EquipRecastAffirmResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EquipRecastAffirmResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EquipRecastAffirmResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.EquipRecastAffirmResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.EquipRecastAffirmResp} EquipRecastAffirmResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EquipRecastAffirmResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.EquipRecastAffirmResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.weapon = $root.luck.protobuf.WeaponPB.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.clothes = $root.luck.protobuf.ClothesPB.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes an EquipRecastAffirmResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.EquipRecastAffirmResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.EquipRecastAffirmResp} EquipRecastAffirmResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EquipRecastAffirmResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EquipRecastAffirmResp message.
             * @function verify
             * @memberof luck.protobuf.EquipRecastAffirmResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EquipRecastAffirmResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.weapon != null && message.hasOwnProperty("weapon")) {
                    var error = $root.luck.protobuf.WeaponPB.verify(message.weapon);
                    if (error)
                        return "weapon." + error;
                }
                if (message.clothes != null && message.hasOwnProperty("clothes")) {
                    var error = $root.luck.protobuf.ClothesPB.verify(message.clothes);
                    if (error)
                        return "clothes." + error;
                }
                return null;
            };

            return EquipRecastAffirmResp;
        })();

        protobuf.GetEmailListResp = (function() {

            /**
             * Properties of a GetEmailListResp.
             * @memberof luck.protobuf
             * @interface IGetEmailListResp
             * @property {number} result GetEmailListResp result
             * @property {Array.<luck.protobuf.IEmailPB>|null} [emailList] GetEmailListResp emailList
             */

            /**
             * Constructs a new GetEmailListResp.
             * @memberof luck.protobuf
             * @classdesc Represents a GetEmailListResp.
             * @implements IGetEmailListResp
             * @constructor
             * @param {luck.protobuf.IGetEmailListResp=} [properties] Properties to set
             */
            function GetEmailListResp(properties) {
                this.emailList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetEmailListResp result.
             * @member {number} result
             * @memberof luck.protobuf.GetEmailListResp
             * @instance
             */
            GetEmailListResp.prototype.result = 0;

            /**
             * GetEmailListResp emailList.
             * @member {Array.<luck.protobuf.IEmailPB>} emailList
             * @memberof luck.protobuf.GetEmailListResp
             * @instance
             */
            GetEmailListResp.prototype.emailList = $util.emptyArray;

            /**
             * Creates a new GetEmailListResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.GetEmailListResp
             * @static
             * @param {luck.protobuf.IGetEmailListResp=} [properties] Properties to set
             * @returns {luck.protobuf.GetEmailListResp} GetEmailListResp instance
             */
            GetEmailListResp.create = function create(properties) {
                return new GetEmailListResp(properties);
            };

            /**
             * Encodes the specified GetEmailListResp message. Does not implicitly {@link luck.protobuf.GetEmailListResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.GetEmailListResp
             * @static
             * @param {luck.protobuf.IGetEmailListResp} message GetEmailListResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetEmailListResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.emailList != null && message.emailList.length)
                    for (var i = 0; i < message.emailList.length; ++i)
                        $root.luck.protobuf.EmailPB.encode(message.emailList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetEmailListResp message, length delimited. Does not implicitly {@link luck.protobuf.GetEmailListResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.GetEmailListResp
             * @static
             * @param {luck.protobuf.IGetEmailListResp} message GetEmailListResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetEmailListResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetEmailListResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.GetEmailListResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.GetEmailListResp} GetEmailListResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetEmailListResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.GetEmailListResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        if (!(message.emailList && message.emailList.length))
                            message.emailList = [];
                        message.emailList.push($root.luck.protobuf.EmailPB.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a GetEmailListResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.GetEmailListResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.GetEmailListResp} GetEmailListResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetEmailListResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetEmailListResp message.
             * @function verify
             * @memberof luck.protobuf.GetEmailListResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetEmailListResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.emailList != null && message.hasOwnProperty("emailList")) {
                    if (!Array.isArray(message.emailList))
                        return "emailList: array expected";
                    for (var i = 0; i < message.emailList.length; ++i) {
                        var error = $root.luck.protobuf.EmailPB.verify(message.emailList[i]);
                        if (error)
                            return "emailList." + error;
                    }
                }
                return null;
            };

            return GetEmailListResp;
        })();

        protobuf.EmailPushResp = (function() {

            /**
             * Properties of an EmailPushResp.
             * @memberof luck.protobuf
             * @interface IEmailPushResp
             * @property {number} result EmailPushResp result
             * @property {luck.protobuf.IEmailPB|null} [email] EmailPushResp email
             */

            /**
             * Constructs a new EmailPushResp.
             * @memberof luck.protobuf
             * @classdesc Represents an EmailPushResp.
             * @implements IEmailPushResp
             * @constructor
             * @param {luck.protobuf.IEmailPushResp=} [properties] Properties to set
             */
            function EmailPushResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EmailPushResp result.
             * @member {number} result
             * @memberof luck.protobuf.EmailPushResp
             * @instance
             */
            EmailPushResp.prototype.result = 0;

            /**
             * EmailPushResp email.
             * @member {luck.protobuf.IEmailPB|null|undefined} email
             * @memberof luck.protobuf.EmailPushResp
             * @instance
             */
            EmailPushResp.prototype.email = null;

            /**
             * Creates a new EmailPushResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.EmailPushResp
             * @static
             * @param {luck.protobuf.IEmailPushResp=} [properties] Properties to set
             * @returns {luck.protobuf.EmailPushResp} EmailPushResp instance
             */
            EmailPushResp.create = function create(properties) {
                return new EmailPushResp(properties);
            };

            /**
             * Encodes the specified EmailPushResp message. Does not implicitly {@link luck.protobuf.EmailPushResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.EmailPushResp
             * @static
             * @param {luck.protobuf.IEmailPushResp} message EmailPushResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EmailPushResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.email != null && message.hasOwnProperty("email"))
                    $root.luck.protobuf.EmailPB.encode(message.email, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EmailPushResp message, length delimited. Does not implicitly {@link luck.protobuf.EmailPushResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.EmailPushResp
             * @static
             * @param {luck.protobuf.IEmailPushResp} message EmailPushResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EmailPushResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EmailPushResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.EmailPushResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.EmailPushResp} EmailPushResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EmailPushResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.EmailPushResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.email = $root.luck.protobuf.EmailPB.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes an EmailPushResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.EmailPushResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.EmailPushResp} EmailPushResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EmailPushResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EmailPushResp message.
             * @function verify
             * @memberof luck.protobuf.EmailPushResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EmailPushResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.email != null && message.hasOwnProperty("email")) {
                    var error = $root.luck.protobuf.EmailPB.verify(message.email);
                    if (error)
                        return "email." + error;
                }
                return null;
            };

            return EmailPushResp;
        })();

        protobuf.EmailDrawResp = (function() {

            /**
             * Properties of an EmailDrawResp.
             * @memberof luck.protobuf
             * @interface IEmailDrawResp
             * @property {number} result EmailDrawResp result
             * @property {number|Long|null} [gold] EmailDrawResp gold
             * @property {number|Long|null} [diamond] EmailDrawResp diamond
             * @property {Array.<luck.protobuf.IWeaponPB>|null} [weaponList] EmailDrawResp weaponList
             * @property {Array.<luck.protobuf.ICardPB>|null} [cardList] EmailDrawResp cardList
             * @property {Array.<luck.protobuf.IClothesPB>|null} [clothesList] EmailDrawResp clothesList
             * @property {Array.<luck.protobuf.IPropPB>|null} [propList] EmailDrawResp propList
             * @property {Array.<luck.protobuf.IMaterialsPB>|null} [materialsList] EmailDrawResp materialsList
             */

            /**
             * Constructs a new EmailDrawResp.
             * @memberof luck.protobuf
             * @classdesc Represents an EmailDrawResp.
             * @implements IEmailDrawResp
             * @constructor
             * @param {luck.protobuf.IEmailDrawResp=} [properties] Properties to set
             */
            function EmailDrawResp(properties) {
                this.weaponList = [];
                this.cardList = [];
                this.clothesList = [];
                this.propList = [];
                this.materialsList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EmailDrawResp result.
             * @member {number} result
             * @memberof luck.protobuf.EmailDrawResp
             * @instance
             */
            EmailDrawResp.prototype.result = 0;

            /**
             * EmailDrawResp gold.
             * @member {number|Long} gold
             * @memberof luck.protobuf.EmailDrawResp
             * @instance
             */
            EmailDrawResp.prototype.gold = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * EmailDrawResp diamond.
             * @member {number|Long} diamond
             * @memberof luck.protobuf.EmailDrawResp
             * @instance
             */
            EmailDrawResp.prototype.diamond = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * EmailDrawResp weaponList.
             * @member {Array.<luck.protobuf.IWeaponPB>} weaponList
             * @memberof luck.protobuf.EmailDrawResp
             * @instance
             */
            EmailDrawResp.prototype.weaponList = $util.emptyArray;

            /**
             * EmailDrawResp cardList.
             * @member {Array.<luck.protobuf.ICardPB>} cardList
             * @memberof luck.protobuf.EmailDrawResp
             * @instance
             */
            EmailDrawResp.prototype.cardList = $util.emptyArray;

            /**
             * EmailDrawResp clothesList.
             * @member {Array.<luck.protobuf.IClothesPB>} clothesList
             * @memberof luck.protobuf.EmailDrawResp
             * @instance
             */
            EmailDrawResp.prototype.clothesList = $util.emptyArray;

            /**
             * EmailDrawResp propList.
             * @member {Array.<luck.protobuf.IPropPB>} propList
             * @memberof luck.protobuf.EmailDrawResp
             * @instance
             */
            EmailDrawResp.prototype.propList = $util.emptyArray;

            /**
             * EmailDrawResp materialsList.
             * @member {Array.<luck.protobuf.IMaterialsPB>} materialsList
             * @memberof luck.protobuf.EmailDrawResp
             * @instance
             */
            EmailDrawResp.prototype.materialsList = $util.emptyArray;

            /**
             * Creates a new EmailDrawResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.EmailDrawResp
             * @static
             * @param {luck.protobuf.IEmailDrawResp=} [properties] Properties to set
             * @returns {luck.protobuf.EmailDrawResp} EmailDrawResp instance
             */
            EmailDrawResp.create = function create(properties) {
                return new EmailDrawResp(properties);
            };

            /**
             * Encodes the specified EmailDrawResp message. Does not implicitly {@link luck.protobuf.EmailDrawResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.EmailDrawResp
             * @static
             * @param {luck.protobuf.IEmailDrawResp} message EmailDrawResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EmailDrawResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.gold != null && message.hasOwnProperty("gold"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.gold);
                if (message.diamond != null && message.hasOwnProperty("diamond"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.diamond);
                if (message.weaponList != null && message.weaponList.length)
                    for (var i = 0; i < message.weaponList.length; ++i)
                        $root.luck.protobuf.WeaponPB.encode(message.weaponList[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.cardList != null && message.cardList.length)
                    for (var i = 0; i < message.cardList.length; ++i)
                        $root.luck.protobuf.CardPB.encode(message.cardList[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.clothesList != null && message.clothesList.length)
                    for (var i = 0; i < message.clothesList.length; ++i)
                        $root.luck.protobuf.ClothesPB.encode(message.clothesList[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.propList != null && message.propList.length)
                    for (var i = 0; i < message.propList.length; ++i)
                        $root.luck.protobuf.PropPB.encode(message.propList[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.materialsList != null && message.materialsList.length)
                    for (var i = 0; i < message.materialsList.length; ++i)
                        $root.luck.protobuf.MaterialsPB.encode(message.materialsList[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EmailDrawResp message, length delimited. Does not implicitly {@link luck.protobuf.EmailDrawResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.EmailDrawResp
             * @static
             * @param {luck.protobuf.IEmailDrawResp} message EmailDrawResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EmailDrawResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EmailDrawResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.EmailDrawResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.EmailDrawResp} EmailDrawResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EmailDrawResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.EmailDrawResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.gold = reader.int64();
                        break;
                    case 3:
                        message.diamond = reader.int64();
                        break;
                    case 4:
                        if (!(message.weaponList && message.weaponList.length))
                            message.weaponList = [];
                        message.weaponList.push($root.luck.protobuf.WeaponPB.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.cardList && message.cardList.length))
                            message.cardList = [];
                        message.cardList.push($root.luck.protobuf.CardPB.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.clothesList && message.clothesList.length))
                            message.clothesList = [];
                        message.clothesList.push($root.luck.protobuf.ClothesPB.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        if (!(message.propList && message.propList.length))
                            message.propList = [];
                        message.propList.push($root.luck.protobuf.PropPB.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        if (!(message.materialsList && message.materialsList.length))
                            message.materialsList = [];
                        message.materialsList.push($root.luck.protobuf.MaterialsPB.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes an EmailDrawResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.EmailDrawResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.EmailDrawResp} EmailDrawResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EmailDrawResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EmailDrawResp message.
             * @function verify
             * @memberof luck.protobuf.EmailDrawResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EmailDrawResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.gold != null && message.hasOwnProperty("gold"))
                    if (!$util.isInteger(message.gold) && !(message.gold && $util.isInteger(message.gold.low) && $util.isInteger(message.gold.high)))
                        return "gold: integer|Long expected";
                if (message.diamond != null && message.hasOwnProperty("diamond"))
                    if (!$util.isInteger(message.diamond) && !(message.diamond && $util.isInteger(message.diamond.low) && $util.isInteger(message.diamond.high)))
                        return "diamond: integer|Long expected";
                if (message.weaponList != null && message.hasOwnProperty("weaponList")) {
                    if (!Array.isArray(message.weaponList))
                        return "weaponList: array expected";
                    for (var i = 0; i < message.weaponList.length; ++i) {
                        var error = $root.luck.protobuf.WeaponPB.verify(message.weaponList[i]);
                        if (error)
                            return "weaponList." + error;
                    }
                }
                if (message.cardList != null && message.hasOwnProperty("cardList")) {
                    if (!Array.isArray(message.cardList))
                        return "cardList: array expected";
                    for (var i = 0; i < message.cardList.length; ++i) {
                        var error = $root.luck.protobuf.CardPB.verify(message.cardList[i]);
                        if (error)
                            return "cardList." + error;
                    }
                }
                if (message.clothesList != null && message.hasOwnProperty("clothesList")) {
                    if (!Array.isArray(message.clothesList))
                        return "clothesList: array expected";
                    for (var i = 0; i < message.clothesList.length; ++i) {
                        var error = $root.luck.protobuf.ClothesPB.verify(message.clothesList[i]);
                        if (error)
                            return "clothesList." + error;
                    }
                }
                if (message.propList != null && message.hasOwnProperty("propList")) {
                    if (!Array.isArray(message.propList))
                        return "propList: array expected";
                    for (var i = 0; i < message.propList.length; ++i) {
                        var error = $root.luck.protobuf.PropPB.verify(message.propList[i]);
                        if (error)
                            return "propList." + error;
                    }
                }
                if (message.materialsList != null && message.hasOwnProperty("materialsList")) {
                    if (!Array.isArray(message.materialsList))
                        return "materialsList: array expected";
                    for (var i = 0; i < message.materialsList.length; ++i) {
                        var error = $root.luck.protobuf.MaterialsPB.verify(message.materialsList[i]);
                        if (error)
                            return "materialsList." + error;
                    }
                }
                return null;
            };

            return EmailDrawResp;
        })();

        protobuf.DrawAllEmailResp = (function() {

            /**
             * Properties of a DrawAllEmailResp.
             * @memberof luck.protobuf
             * @interface IDrawAllEmailResp
             * @property {number} result DrawAllEmailResp result
             * @property {number|Long|null} [gold] DrawAllEmailResp gold
             * @property {number|Long|null} [diamond] DrawAllEmailResp diamond
             * @property {Array.<luck.protobuf.IWeaponPB>|null} [weaponList] DrawAllEmailResp weaponList
             * @property {Array.<luck.protobuf.ICardPB>|null} [cardList] DrawAllEmailResp cardList
             * @property {Array.<luck.protobuf.IClothesPB>|null} [clothesList] DrawAllEmailResp clothesList
             * @property {Array.<luck.protobuf.IPropPB>|null} [propList] DrawAllEmailResp propList
             * @property {Array.<luck.protobuf.IMaterialsPB>|null} [materialsList] DrawAllEmailResp materialsList
             * @property {Array.<luck.protobuf.IEmailPB>|null} [emailList] DrawAllEmailResp emailList
             */

            /**
             * Constructs a new DrawAllEmailResp.
             * @memberof luck.protobuf
             * @classdesc Represents a DrawAllEmailResp.
             * @implements IDrawAllEmailResp
             * @constructor
             * @param {luck.protobuf.IDrawAllEmailResp=} [properties] Properties to set
             */
            function DrawAllEmailResp(properties) {
                this.weaponList = [];
                this.cardList = [];
                this.clothesList = [];
                this.propList = [];
                this.materialsList = [];
                this.emailList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DrawAllEmailResp result.
             * @member {number} result
             * @memberof luck.protobuf.DrawAllEmailResp
             * @instance
             */
            DrawAllEmailResp.prototype.result = 0;

            /**
             * DrawAllEmailResp gold.
             * @member {number|Long} gold
             * @memberof luck.protobuf.DrawAllEmailResp
             * @instance
             */
            DrawAllEmailResp.prototype.gold = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * DrawAllEmailResp diamond.
             * @member {number|Long} diamond
             * @memberof luck.protobuf.DrawAllEmailResp
             * @instance
             */
            DrawAllEmailResp.prototype.diamond = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * DrawAllEmailResp weaponList.
             * @member {Array.<luck.protobuf.IWeaponPB>} weaponList
             * @memberof luck.protobuf.DrawAllEmailResp
             * @instance
             */
            DrawAllEmailResp.prototype.weaponList = $util.emptyArray;

            /**
             * DrawAllEmailResp cardList.
             * @member {Array.<luck.protobuf.ICardPB>} cardList
             * @memberof luck.protobuf.DrawAllEmailResp
             * @instance
             */
            DrawAllEmailResp.prototype.cardList = $util.emptyArray;

            /**
             * DrawAllEmailResp clothesList.
             * @member {Array.<luck.protobuf.IClothesPB>} clothesList
             * @memberof luck.protobuf.DrawAllEmailResp
             * @instance
             */
            DrawAllEmailResp.prototype.clothesList = $util.emptyArray;

            /**
             * DrawAllEmailResp propList.
             * @member {Array.<luck.protobuf.IPropPB>} propList
             * @memberof luck.protobuf.DrawAllEmailResp
             * @instance
             */
            DrawAllEmailResp.prototype.propList = $util.emptyArray;

            /**
             * DrawAllEmailResp materialsList.
             * @member {Array.<luck.protobuf.IMaterialsPB>} materialsList
             * @memberof luck.protobuf.DrawAllEmailResp
             * @instance
             */
            DrawAllEmailResp.prototype.materialsList = $util.emptyArray;

            /**
             * DrawAllEmailResp emailList.
             * @member {Array.<luck.protobuf.IEmailPB>} emailList
             * @memberof luck.protobuf.DrawAllEmailResp
             * @instance
             */
            DrawAllEmailResp.prototype.emailList = $util.emptyArray;

            /**
             * Creates a new DrawAllEmailResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.DrawAllEmailResp
             * @static
             * @param {luck.protobuf.IDrawAllEmailResp=} [properties] Properties to set
             * @returns {luck.protobuf.DrawAllEmailResp} DrawAllEmailResp instance
             */
            DrawAllEmailResp.create = function create(properties) {
                return new DrawAllEmailResp(properties);
            };

            /**
             * Encodes the specified DrawAllEmailResp message. Does not implicitly {@link luck.protobuf.DrawAllEmailResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.DrawAllEmailResp
             * @static
             * @param {luck.protobuf.IDrawAllEmailResp} message DrawAllEmailResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DrawAllEmailResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.gold != null && message.hasOwnProperty("gold"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.gold);
                if (message.diamond != null && message.hasOwnProperty("diamond"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.diamond);
                if (message.weaponList != null && message.weaponList.length)
                    for (var i = 0; i < message.weaponList.length; ++i)
                        $root.luck.protobuf.WeaponPB.encode(message.weaponList[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.cardList != null && message.cardList.length)
                    for (var i = 0; i < message.cardList.length; ++i)
                        $root.luck.protobuf.CardPB.encode(message.cardList[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.clothesList != null && message.clothesList.length)
                    for (var i = 0; i < message.clothesList.length; ++i)
                        $root.luck.protobuf.ClothesPB.encode(message.clothesList[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.propList != null && message.propList.length)
                    for (var i = 0; i < message.propList.length; ++i)
                        $root.luck.protobuf.PropPB.encode(message.propList[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.materialsList != null && message.materialsList.length)
                    for (var i = 0; i < message.materialsList.length; ++i)
                        $root.luck.protobuf.MaterialsPB.encode(message.materialsList[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.emailList != null && message.emailList.length)
                    for (var i = 0; i < message.emailList.length; ++i)
                        $root.luck.protobuf.EmailPB.encode(message.emailList[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DrawAllEmailResp message, length delimited. Does not implicitly {@link luck.protobuf.DrawAllEmailResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.DrawAllEmailResp
             * @static
             * @param {luck.protobuf.IDrawAllEmailResp} message DrawAllEmailResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DrawAllEmailResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DrawAllEmailResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.DrawAllEmailResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.DrawAllEmailResp} DrawAllEmailResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DrawAllEmailResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.DrawAllEmailResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.gold = reader.int64();
                        break;
                    case 3:
                        message.diamond = reader.int64();
                        break;
                    case 4:
                        if (!(message.weaponList && message.weaponList.length))
                            message.weaponList = [];
                        message.weaponList.push($root.luck.protobuf.WeaponPB.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.cardList && message.cardList.length))
                            message.cardList = [];
                        message.cardList.push($root.luck.protobuf.CardPB.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.clothesList && message.clothesList.length))
                            message.clothesList = [];
                        message.clothesList.push($root.luck.protobuf.ClothesPB.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        if (!(message.propList && message.propList.length))
                            message.propList = [];
                        message.propList.push($root.luck.protobuf.PropPB.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        if (!(message.materialsList && message.materialsList.length))
                            message.materialsList = [];
                        message.materialsList.push($root.luck.protobuf.MaterialsPB.decode(reader, reader.uint32()));
                        break;
                    case 9:
                        if (!(message.emailList && message.emailList.length))
                            message.emailList = [];
                        message.emailList.push($root.luck.protobuf.EmailPB.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a DrawAllEmailResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.DrawAllEmailResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.DrawAllEmailResp} DrawAllEmailResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DrawAllEmailResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DrawAllEmailResp message.
             * @function verify
             * @memberof luck.protobuf.DrawAllEmailResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DrawAllEmailResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.gold != null && message.hasOwnProperty("gold"))
                    if (!$util.isInteger(message.gold) && !(message.gold && $util.isInteger(message.gold.low) && $util.isInteger(message.gold.high)))
                        return "gold: integer|Long expected";
                if (message.diamond != null && message.hasOwnProperty("diamond"))
                    if (!$util.isInteger(message.diamond) && !(message.diamond && $util.isInteger(message.diamond.low) && $util.isInteger(message.diamond.high)))
                        return "diamond: integer|Long expected";
                if (message.weaponList != null && message.hasOwnProperty("weaponList")) {
                    if (!Array.isArray(message.weaponList))
                        return "weaponList: array expected";
                    for (var i = 0; i < message.weaponList.length; ++i) {
                        var error = $root.luck.protobuf.WeaponPB.verify(message.weaponList[i]);
                        if (error)
                            return "weaponList." + error;
                    }
                }
                if (message.cardList != null && message.hasOwnProperty("cardList")) {
                    if (!Array.isArray(message.cardList))
                        return "cardList: array expected";
                    for (var i = 0; i < message.cardList.length; ++i) {
                        var error = $root.luck.protobuf.CardPB.verify(message.cardList[i]);
                        if (error)
                            return "cardList." + error;
                    }
                }
                if (message.clothesList != null && message.hasOwnProperty("clothesList")) {
                    if (!Array.isArray(message.clothesList))
                        return "clothesList: array expected";
                    for (var i = 0; i < message.clothesList.length; ++i) {
                        var error = $root.luck.protobuf.ClothesPB.verify(message.clothesList[i]);
                        if (error)
                            return "clothesList." + error;
                    }
                }
                if (message.propList != null && message.hasOwnProperty("propList")) {
                    if (!Array.isArray(message.propList))
                        return "propList: array expected";
                    for (var i = 0; i < message.propList.length; ++i) {
                        var error = $root.luck.protobuf.PropPB.verify(message.propList[i]);
                        if (error)
                            return "propList." + error;
                    }
                }
                if (message.materialsList != null && message.hasOwnProperty("materialsList")) {
                    if (!Array.isArray(message.materialsList))
                        return "materialsList: array expected";
                    for (var i = 0; i < message.materialsList.length; ++i) {
                        var error = $root.luck.protobuf.MaterialsPB.verify(message.materialsList[i]);
                        if (error)
                            return "materialsList." + error;
                    }
                }
                if (message.emailList != null && message.hasOwnProperty("emailList")) {
                    if (!Array.isArray(message.emailList))
                        return "emailList: array expected";
                    for (var i = 0; i < message.emailList.length; ++i) {
                        var error = $root.luck.protobuf.EmailPB.verify(message.emailList[i]);
                        if (error)
                            return "emailList." + error;
                    }
                }
                return null;
            };

            return DrawAllEmailResp;
        })();

        protobuf.EmailDelResp = (function() {

            /**
             * Properties of an EmailDelResp.
             * @memberof luck.protobuf
             * @interface IEmailDelResp
             * @property {number} result EmailDelResp result
             */

            /**
             * Constructs a new EmailDelResp.
             * @memberof luck.protobuf
             * @classdesc Represents an EmailDelResp.
             * @implements IEmailDelResp
             * @constructor
             * @param {luck.protobuf.IEmailDelResp=} [properties] Properties to set
             */
            function EmailDelResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EmailDelResp result.
             * @member {number} result
             * @memberof luck.protobuf.EmailDelResp
             * @instance
             */
            EmailDelResp.prototype.result = 0;

            /**
             * Creates a new EmailDelResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.EmailDelResp
             * @static
             * @param {luck.protobuf.IEmailDelResp=} [properties] Properties to set
             * @returns {luck.protobuf.EmailDelResp} EmailDelResp instance
             */
            EmailDelResp.create = function create(properties) {
                return new EmailDelResp(properties);
            };

            /**
             * Encodes the specified EmailDelResp message. Does not implicitly {@link luck.protobuf.EmailDelResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.EmailDelResp
             * @static
             * @param {luck.protobuf.IEmailDelResp} message EmailDelResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EmailDelResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                return writer;
            };

            /**
             * Encodes the specified EmailDelResp message, length delimited. Does not implicitly {@link luck.protobuf.EmailDelResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.EmailDelResp
             * @static
             * @param {luck.protobuf.IEmailDelResp} message EmailDelResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EmailDelResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EmailDelResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.EmailDelResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.EmailDelResp} EmailDelResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EmailDelResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.EmailDelResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes an EmailDelResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.EmailDelResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.EmailDelResp} EmailDelResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EmailDelResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EmailDelResp message.
             * @function verify
             * @memberof luck.protobuf.EmailDelResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EmailDelResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                return null;
            };

            return EmailDelResp;
        })();

        protobuf.EquipUpgradeResp = (function() {

            /**
             * Properties of an EquipUpgradeResp.
             * @memberof luck.protobuf
             * @interface IEquipUpgradeResp
             * @property {number} result EquipUpgradeResp result
             * @property {luck.protobuf.IWeaponPB|null} [weapon] EquipUpgradeResp weapon
             * @property {luck.protobuf.ICardPB|null} [card] EquipUpgradeResp card
             * @property {luck.protobuf.IClothesPB|null} [clothes] EquipUpgradeResp clothes
             */

            /**
             * Constructs a new EquipUpgradeResp.
             * @memberof luck.protobuf
             * @classdesc Represents an EquipUpgradeResp.
             * @implements IEquipUpgradeResp
             * @constructor
             * @param {luck.protobuf.IEquipUpgradeResp=} [properties] Properties to set
             */
            function EquipUpgradeResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EquipUpgradeResp result.
             * @member {number} result
             * @memberof luck.protobuf.EquipUpgradeResp
             * @instance
             */
            EquipUpgradeResp.prototype.result = 0;

            /**
             * EquipUpgradeResp weapon.
             * @member {luck.protobuf.IWeaponPB|null|undefined} weapon
             * @memberof luck.protobuf.EquipUpgradeResp
             * @instance
             */
            EquipUpgradeResp.prototype.weapon = null;

            /**
             * EquipUpgradeResp card.
             * @member {luck.protobuf.ICardPB|null|undefined} card
             * @memberof luck.protobuf.EquipUpgradeResp
             * @instance
             */
            EquipUpgradeResp.prototype.card = null;

            /**
             * EquipUpgradeResp clothes.
             * @member {luck.protobuf.IClothesPB|null|undefined} clothes
             * @memberof luck.protobuf.EquipUpgradeResp
             * @instance
             */
            EquipUpgradeResp.prototype.clothes = null;

            /**
             * Creates a new EquipUpgradeResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.EquipUpgradeResp
             * @static
             * @param {luck.protobuf.IEquipUpgradeResp=} [properties] Properties to set
             * @returns {luck.protobuf.EquipUpgradeResp} EquipUpgradeResp instance
             */
            EquipUpgradeResp.create = function create(properties) {
                return new EquipUpgradeResp(properties);
            };

            /**
             * Encodes the specified EquipUpgradeResp message. Does not implicitly {@link luck.protobuf.EquipUpgradeResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.EquipUpgradeResp
             * @static
             * @param {luck.protobuf.IEquipUpgradeResp} message EquipUpgradeResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EquipUpgradeResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.weapon != null && message.hasOwnProperty("weapon"))
                    $root.luck.protobuf.WeaponPB.encode(message.weapon, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.card != null && message.hasOwnProperty("card"))
                    $root.luck.protobuf.CardPB.encode(message.card, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.clothes != null && message.hasOwnProperty("clothes"))
                    $root.luck.protobuf.ClothesPB.encode(message.clothes, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EquipUpgradeResp message, length delimited. Does not implicitly {@link luck.protobuf.EquipUpgradeResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.EquipUpgradeResp
             * @static
             * @param {luck.protobuf.IEquipUpgradeResp} message EquipUpgradeResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EquipUpgradeResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EquipUpgradeResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.EquipUpgradeResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.EquipUpgradeResp} EquipUpgradeResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EquipUpgradeResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.EquipUpgradeResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.weapon = $root.luck.protobuf.WeaponPB.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.card = $root.luck.protobuf.CardPB.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.clothes = $root.luck.protobuf.ClothesPB.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes an EquipUpgradeResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.EquipUpgradeResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.EquipUpgradeResp} EquipUpgradeResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EquipUpgradeResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EquipUpgradeResp message.
             * @function verify
             * @memberof luck.protobuf.EquipUpgradeResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EquipUpgradeResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.weapon != null && message.hasOwnProperty("weapon")) {
                    var error = $root.luck.protobuf.WeaponPB.verify(message.weapon);
                    if (error)
                        return "weapon." + error;
                }
                if (message.card != null && message.hasOwnProperty("card")) {
                    var error = $root.luck.protobuf.CardPB.verify(message.card);
                    if (error)
                        return "card." + error;
                }
                if (message.clothes != null && message.hasOwnProperty("clothes")) {
                    var error = $root.luck.protobuf.ClothesPB.verify(message.clothes);
                    if (error)
                        return "clothes." + error;
                }
                return null;
            };

            return EquipUpgradeResp;
        })();

        protobuf.EquipBaptizeResp = (function() {

            /**
             * Properties of an EquipBaptizeResp.
             * @memberof luck.protobuf
             * @interface IEquipBaptizeResp
             * @property {number} result EquipBaptizeResp result
             * @property {luck.protobuf.IWeaponPB|null} [weapon] EquipBaptizeResp weapon
             * @property {luck.protobuf.ICardPB|null} [card] EquipBaptizeResp card
             * @property {luck.protobuf.IClothesPB|null} [clothes] EquipBaptizeResp clothes
             */

            /**
             * Constructs a new EquipBaptizeResp.
             * @memberof luck.protobuf
             * @classdesc Represents an EquipBaptizeResp.
             * @implements IEquipBaptizeResp
             * @constructor
             * @param {luck.protobuf.IEquipBaptizeResp=} [properties] Properties to set
             */
            function EquipBaptizeResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EquipBaptizeResp result.
             * @member {number} result
             * @memberof luck.protobuf.EquipBaptizeResp
             * @instance
             */
            EquipBaptizeResp.prototype.result = 0;

            /**
             * EquipBaptizeResp weapon.
             * @member {luck.protobuf.IWeaponPB|null|undefined} weapon
             * @memberof luck.protobuf.EquipBaptizeResp
             * @instance
             */
            EquipBaptizeResp.prototype.weapon = null;

            /**
             * EquipBaptizeResp card.
             * @member {luck.protobuf.ICardPB|null|undefined} card
             * @memberof luck.protobuf.EquipBaptizeResp
             * @instance
             */
            EquipBaptizeResp.prototype.card = null;

            /**
             * EquipBaptizeResp clothes.
             * @member {luck.protobuf.IClothesPB|null|undefined} clothes
             * @memberof luck.protobuf.EquipBaptizeResp
             * @instance
             */
            EquipBaptizeResp.prototype.clothes = null;

            /**
             * Creates a new EquipBaptizeResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.EquipBaptizeResp
             * @static
             * @param {luck.protobuf.IEquipBaptizeResp=} [properties] Properties to set
             * @returns {luck.protobuf.EquipBaptizeResp} EquipBaptizeResp instance
             */
            EquipBaptizeResp.create = function create(properties) {
                return new EquipBaptizeResp(properties);
            };

            /**
             * Encodes the specified EquipBaptizeResp message. Does not implicitly {@link luck.protobuf.EquipBaptizeResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.EquipBaptizeResp
             * @static
             * @param {luck.protobuf.IEquipBaptizeResp} message EquipBaptizeResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EquipBaptizeResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.weapon != null && message.hasOwnProperty("weapon"))
                    $root.luck.protobuf.WeaponPB.encode(message.weapon, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.card != null && message.hasOwnProperty("card"))
                    $root.luck.protobuf.CardPB.encode(message.card, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.clothes != null && message.hasOwnProperty("clothes"))
                    $root.luck.protobuf.ClothesPB.encode(message.clothes, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EquipBaptizeResp message, length delimited. Does not implicitly {@link luck.protobuf.EquipBaptizeResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.EquipBaptizeResp
             * @static
             * @param {luck.protobuf.IEquipBaptizeResp} message EquipBaptizeResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EquipBaptizeResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EquipBaptizeResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.EquipBaptizeResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.EquipBaptizeResp} EquipBaptizeResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EquipBaptizeResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.EquipBaptizeResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.weapon = $root.luck.protobuf.WeaponPB.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.card = $root.luck.protobuf.CardPB.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.clothes = $root.luck.protobuf.ClothesPB.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes an EquipBaptizeResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.EquipBaptizeResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.EquipBaptizeResp} EquipBaptizeResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EquipBaptizeResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EquipBaptizeResp message.
             * @function verify
             * @memberof luck.protobuf.EquipBaptizeResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EquipBaptizeResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.weapon != null && message.hasOwnProperty("weapon")) {
                    var error = $root.luck.protobuf.WeaponPB.verify(message.weapon);
                    if (error)
                        return "weapon." + error;
                }
                if (message.card != null && message.hasOwnProperty("card")) {
                    var error = $root.luck.protobuf.CardPB.verify(message.card);
                    if (error)
                        return "card." + error;
                }
                if (message.clothes != null && message.hasOwnProperty("clothes")) {
                    var error = $root.luck.protobuf.ClothesPB.verify(message.clothes);
                    if (error)
                        return "clothes." + error;
                }
                return null;
            };

            return EquipBaptizeResp;
        })();

        protobuf.EquipBaptizeAffirmResp = (function() {

            /**
             * Properties of an EquipBaptizeAffirmResp.
             * @memberof luck.protobuf
             * @interface IEquipBaptizeAffirmResp
             * @property {number} result EquipBaptizeAffirmResp result
             * @property {luck.protobuf.IWeaponPB|null} [weapon] EquipBaptizeAffirmResp weapon
             * @property {luck.protobuf.ICardPB|null} [card] EquipBaptizeAffirmResp card
             * @property {luck.protobuf.IClothesPB|null} [clothes] EquipBaptizeAffirmResp clothes
             */

            /**
             * Constructs a new EquipBaptizeAffirmResp.
             * @memberof luck.protobuf
             * @classdesc Represents an EquipBaptizeAffirmResp.
             * @implements IEquipBaptizeAffirmResp
             * @constructor
             * @param {luck.protobuf.IEquipBaptizeAffirmResp=} [properties] Properties to set
             */
            function EquipBaptizeAffirmResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EquipBaptizeAffirmResp result.
             * @member {number} result
             * @memberof luck.protobuf.EquipBaptizeAffirmResp
             * @instance
             */
            EquipBaptizeAffirmResp.prototype.result = 0;

            /**
             * EquipBaptizeAffirmResp weapon.
             * @member {luck.protobuf.IWeaponPB|null|undefined} weapon
             * @memberof luck.protobuf.EquipBaptizeAffirmResp
             * @instance
             */
            EquipBaptizeAffirmResp.prototype.weapon = null;

            /**
             * EquipBaptizeAffirmResp card.
             * @member {luck.protobuf.ICardPB|null|undefined} card
             * @memberof luck.protobuf.EquipBaptizeAffirmResp
             * @instance
             */
            EquipBaptizeAffirmResp.prototype.card = null;

            /**
             * EquipBaptizeAffirmResp clothes.
             * @member {luck.protobuf.IClothesPB|null|undefined} clothes
             * @memberof luck.protobuf.EquipBaptizeAffirmResp
             * @instance
             */
            EquipBaptizeAffirmResp.prototype.clothes = null;

            /**
             * Creates a new EquipBaptizeAffirmResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.EquipBaptizeAffirmResp
             * @static
             * @param {luck.protobuf.IEquipBaptizeAffirmResp=} [properties] Properties to set
             * @returns {luck.protobuf.EquipBaptizeAffirmResp} EquipBaptizeAffirmResp instance
             */
            EquipBaptizeAffirmResp.create = function create(properties) {
                return new EquipBaptizeAffirmResp(properties);
            };

            /**
             * Encodes the specified EquipBaptizeAffirmResp message. Does not implicitly {@link luck.protobuf.EquipBaptizeAffirmResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.EquipBaptizeAffirmResp
             * @static
             * @param {luck.protobuf.IEquipBaptizeAffirmResp} message EquipBaptizeAffirmResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EquipBaptizeAffirmResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.weapon != null && message.hasOwnProperty("weapon"))
                    $root.luck.protobuf.WeaponPB.encode(message.weapon, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.card != null && message.hasOwnProperty("card"))
                    $root.luck.protobuf.CardPB.encode(message.card, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.clothes != null && message.hasOwnProperty("clothes"))
                    $root.luck.protobuf.ClothesPB.encode(message.clothes, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EquipBaptizeAffirmResp message, length delimited. Does not implicitly {@link luck.protobuf.EquipBaptizeAffirmResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.EquipBaptizeAffirmResp
             * @static
             * @param {luck.protobuf.IEquipBaptizeAffirmResp} message EquipBaptizeAffirmResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EquipBaptizeAffirmResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EquipBaptizeAffirmResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.EquipBaptizeAffirmResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.EquipBaptizeAffirmResp} EquipBaptizeAffirmResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EquipBaptizeAffirmResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.EquipBaptizeAffirmResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.weapon = $root.luck.protobuf.WeaponPB.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.card = $root.luck.protobuf.CardPB.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.clothes = $root.luck.protobuf.ClothesPB.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes an EquipBaptizeAffirmResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.EquipBaptizeAffirmResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.EquipBaptizeAffirmResp} EquipBaptizeAffirmResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EquipBaptizeAffirmResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EquipBaptizeAffirmResp message.
             * @function verify
             * @memberof luck.protobuf.EquipBaptizeAffirmResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EquipBaptizeAffirmResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.weapon != null && message.hasOwnProperty("weapon")) {
                    var error = $root.luck.protobuf.WeaponPB.verify(message.weapon);
                    if (error)
                        return "weapon." + error;
                }
                if (message.card != null && message.hasOwnProperty("card")) {
                    var error = $root.luck.protobuf.CardPB.verify(message.card);
                    if (error)
                        return "card." + error;
                }
                if (message.clothes != null && message.hasOwnProperty("clothes")) {
                    var error = $root.luck.protobuf.ClothesPB.verify(message.clothes);
                    if (error)
                        return "clothes." + error;
                }
                return null;
            };

            return EquipBaptizeAffirmResp;
        })();

        protobuf.EquipInlayResp = (function() {

            /**
             * Properties of an EquipInlayResp.
             * @memberof luck.protobuf
             * @interface IEquipInlayResp
             * @property {number} result EquipInlayResp result
             * @property {luck.protobuf.IWeaponPB|null} [weapon] EquipInlayResp weapon
             * @property {luck.protobuf.ICardPB|null} [card] EquipInlayResp card
             * @property {luck.protobuf.IClothesPB|null} [clothes] EquipInlayResp clothes
             */

            /**
             * Constructs a new EquipInlayResp.
             * @memberof luck.protobuf
             * @classdesc Represents an EquipInlayResp.
             * @implements IEquipInlayResp
             * @constructor
             * @param {luck.protobuf.IEquipInlayResp=} [properties] Properties to set
             */
            function EquipInlayResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EquipInlayResp result.
             * @member {number} result
             * @memberof luck.protobuf.EquipInlayResp
             * @instance
             */
            EquipInlayResp.prototype.result = 0;

            /**
             * EquipInlayResp weapon.
             * @member {luck.protobuf.IWeaponPB|null|undefined} weapon
             * @memberof luck.protobuf.EquipInlayResp
             * @instance
             */
            EquipInlayResp.prototype.weapon = null;

            /**
             * EquipInlayResp card.
             * @member {luck.protobuf.ICardPB|null|undefined} card
             * @memberof luck.protobuf.EquipInlayResp
             * @instance
             */
            EquipInlayResp.prototype.card = null;

            /**
             * EquipInlayResp clothes.
             * @member {luck.protobuf.IClothesPB|null|undefined} clothes
             * @memberof luck.protobuf.EquipInlayResp
             * @instance
             */
            EquipInlayResp.prototype.clothes = null;

            /**
             * Creates a new EquipInlayResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.EquipInlayResp
             * @static
             * @param {luck.protobuf.IEquipInlayResp=} [properties] Properties to set
             * @returns {luck.protobuf.EquipInlayResp} EquipInlayResp instance
             */
            EquipInlayResp.create = function create(properties) {
                return new EquipInlayResp(properties);
            };

            /**
             * Encodes the specified EquipInlayResp message. Does not implicitly {@link luck.protobuf.EquipInlayResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.EquipInlayResp
             * @static
             * @param {luck.protobuf.IEquipInlayResp} message EquipInlayResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EquipInlayResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.weapon != null && message.hasOwnProperty("weapon"))
                    $root.luck.protobuf.WeaponPB.encode(message.weapon, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.card != null && message.hasOwnProperty("card"))
                    $root.luck.protobuf.CardPB.encode(message.card, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.clothes != null && message.hasOwnProperty("clothes"))
                    $root.luck.protobuf.ClothesPB.encode(message.clothes, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EquipInlayResp message, length delimited. Does not implicitly {@link luck.protobuf.EquipInlayResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.EquipInlayResp
             * @static
             * @param {luck.protobuf.IEquipInlayResp} message EquipInlayResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EquipInlayResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EquipInlayResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.EquipInlayResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.EquipInlayResp} EquipInlayResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EquipInlayResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.EquipInlayResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.weapon = $root.luck.protobuf.WeaponPB.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.card = $root.luck.protobuf.CardPB.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.clothes = $root.luck.protobuf.ClothesPB.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes an EquipInlayResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.EquipInlayResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.EquipInlayResp} EquipInlayResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EquipInlayResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EquipInlayResp message.
             * @function verify
             * @memberof luck.protobuf.EquipInlayResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EquipInlayResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.weapon != null && message.hasOwnProperty("weapon")) {
                    var error = $root.luck.protobuf.WeaponPB.verify(message.weapon);
                    if (error)
                        return "weapon." + error;
                }
                if (message.card != null && message.hasOwnProperty("card")) {
                    var error = $root.luck.protobuf.CardPB.verify(message.card);
                    if (error)
                        return "card." + error;
                }
                if (message.clothes != null && message.hasOwnProperty("clothes")) {
                    var error = $root.luck.protobuf.ClothesPB.verify(message.clothes);
                    if (error)
                        return "clothes." + error;
                }
                return null;
            };

            return EquipInlayResp;
        })();

        protobuf.EquipInlayDismantleResp = (function() {

            /**
             * Properties of an EquipInlayDismantleResp.
             * @memberof luck.protobuf
             * @interface IEquipInlayDismantleResp
             * @property {number} result EquipInlayDismantleResp result
             * @property {luck.protobuf.IWeaponPB|null} [weapon] EquipInlayDismantleResp weapon
             * @property {luck.protobuf.ICardPB|null} [card] EquipInlayDismantleResp card
             * @property {luck.protobuf.IClothesPB|null} [clothes] EquipInlayDismantleResp clothes
             */

            /**
             * Constructs a new EquipInlayDismantleResp.
             * @memberof luck.protobuf
             * @classdesc Represents an EquipInlayDismantleResp.
             * @implements IEquipInlayDismantleResp
             * @constructor
             * @param {luck.protobuf.IEquipInlayDismantleResp=} [properties] Properties to set
             */
            function EquipInlayDismantleResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EquipInlayDismantleResp result.
             * @member {number} result
             * @memberof luck.protobuf.EquipInlayDismantleResp
             * @instance
             */
            EquipInlayDismantleResp.prototype.result = 0;

            /**
             * EquipInlayDismantleResp weapon.
             * @member {luck.protobuf.IWeaponPB|null|undefined} weapon
             * @memberof luck.protobuf.EquipInlayDismantleResp
             * @instance
             */
            EquipInlayDismantleResp.prototype.weapon = null;

            /**
             * EquipInlayDismantleResp card.
             * @member {luck.protobuf.ICardPB|null|undefined} card
             * @memberof luck.protobuf.EquipInlayDismantleResp
             * @instance
             */
            EquipInlayDismantleResp.prototype.card = null;

            /**
             * EquipInlayDismantleResp clothes.
             * @member {luck.protobuf.IClothesPB|null|undefined} clothes
             * @memberof luck.protobuf.EquipInlayDismantleResp
             * @instance
             */
            EquipInlayDismantleResp.prototype.clothes = null;

            /**
             * Creates a new EquipInlayDismantleResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.EquipInlayDismantleResp
             * @static
             * @param {luck.protobuf.IEquipInlayDismantleResp=} [properties] Properties to set
             * @returns {luck.protobuf.EquipInlayDismantleResp} EquipInlayDismantleResp instance
             */
            EquipInlayDismantleResp.create = function create(properties) {
                return new EquipInlayDismantleResp(properties);
            };

            /**
             * Encodes the specified EquipInlayDismantleResp message. Does not implicitly {@link luck.protobuf.EquipInlayDismantleResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.EquipInlayDismantleResp
             * @static
             * @param {luck.protobuf.IEquipInlayDismantleResp} message EquipInlayDismantleResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EquipInlayDismantleResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.weapon != null && message.hasOwnProperty("weapon"))
                    $root.luck.protobuf.WeaponPB.encode(message.weapon, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.card != null && message.hasOwnProperty("card"))
                    $root.luck.protobuf.CardPB.encode(message.card, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.clothes != null && message.hasOwnProperty("clothes"))
                    $root.luck.protobuf.ClothesPB.encode(message.clothes, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EquipInlayDismantleResp message, length delimited. Does not implicitly {@link luck.protobuf.EquipInlayDismantleResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.EquipInlayDismantleResp
             * @static
             * @param {luck.protobuf.IEquipInlayDismantleResp} message EquipInlayDismantleResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EquipInlayDismantleResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EquipInlayDismantleResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.EquipInlayDismantleResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.EquipInlayDismantleResp} EquipInlayDismantleResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EquipInlayDismantleResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.EquipInlayDismantleResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.weapon = $root.luck.protobuf.WeaponPB.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.card = $root.luck.protobuf.CardPB.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.clothes = $root.luck.protobuf.ClothesPB.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes an EquipInlayDismantleResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.EquipInlayDismantleResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.EquipInlayDismantleResp} EquipInlayDismantleResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EquipInlayDismantleResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EquipInlayDismantleResp message.
             * @function verify
             * @memberof luck.protobuf.EquipInlayDismantleResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EquipInlayDismantleResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.weapon != null && message.hasOwnProperty("weapon")) {
                    var error = $root.luck.protobuf.WeaponPB.verify(message.weapon);
                    if (error)
                        return "weapon." + error;
                }
                if (message.card != null && message.hasOwnProperty("card")) {
                    var error = $root.luck.protobuf.CardPB.verify(message.card);
                    if (error)
                        return "card." + error;
                }
                if (message.clothes != null && message.hasOwnProperty("clothes")) {
                    var error = $root.luck.protobuf.ClothesPB.verify(message.clothes);
                    if (error)
                        return "clothes." + error;
                }
                return null;
            };

            return EquipInlayDismantleResp;
        })();

        protobuf.EquipAdvanceResp = (function() {

            /**
             * Properties of an EquipAdvanceResp.
             * @memberof luck.protobuf
             * @interface IEquipAdvanceResp
             * @property {number} result EquipAdvanceResp result
             * @property {luck.protobuf.IWeaponPB|null} [weapon] EquipAdvanceResp weapon
             * @property {luck.protobuf.ICardPB|null} [card] EquipAdvanceResp card
             * @property {luck.protobuf.IClothesPB|null} [clothes] EquipAdvanceResp clothes
             */

            /**
             * Constructs a new EquipAdvanceResp.
             * @memberof luck.protobuf
             * @classdesc Represents an EquipAdvanceResp.
             * @implements IEquipAdvanceResp
             * @constructor
             * @param {luck.protobuf.IEquipAdvanceResp=} [properties] Properties to set
             */
            function EquipAdvanceResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EquipAdvanceResp result.
             * @member {number} result
             * @memberof luck.protobuf.EquipAdvanceResp
             * @instance
             */
            EquipAdvanceResp.prototype.result = 0;

            /**
             * EquipAdvanceResp weapon.
             * @member {luck.protobuf.IWeaponPB|null|undefined} weapon
             * @memberof luck.protobuf.EquipAdvanceResp
             * @instance
             */
            EquipAdvanceResp.prototype.weapon = null;

            /**
             * EquipAdvanceResp card.
             * @member {luck.protobuf.ICardPB|null|undefined} card
             * @memberof luck.protobuf.EquipAdvanceResp
             * @instance
             */
            EquipAdvanceResp.prototype.card = null;

            /**
             * EquipAdvanceResp clothes.
             * @member {luck.protobuf.IClothesPB|null|undefined} clothes
             * @memberof luck.protobuf.EquipAdvanceResp
             * @instance
             */
            EquipAdvanceResp.prototype.clothes = null;

            /**
             * Creates a new EquipAdvanceResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.EquipAdvanceResp
             * @static
             * @param {luck.protobuf.IEquipAdvanceResp=} [properties] Properties to set
             * @returns {luck.protobuf.EquipAdvanceResp} EquipAdvanceResp instance
             */
            EquipAdvanceResp.create = function create(properties) {
                return new EquipAdvanceResp(properties);
            };

            /**
             * Encodes the specified EquipAdvanceResp message. Does not implicitly {@link luck.protobuf.EquipAdvanceResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.EquipAdvanceResp
             * @static
             * @param {luck.protobuf.IEquipAdvanceResp} message EquipAdvanceResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EquipAdvanceResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.weapon != null && message.hasOwnProperty("weapon"))
                    $root.luck.protobuf.WeaponPB.encode(message.weapon, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.card != null && message.hasOwnProperty("card"))
                    $root.luck.protobuf.CardPB.encode(message.card, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.clothes != null && message.hasOwnProperty("clothes"))
                    $root.luck.protobuf.ClothesPB.encode(message.clothes, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EquipAdvanceResp message, length delimited. Does not implicitly {@link luck.protobuf.EquipAdvanceResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.EquipAdvanceResp
             * @static
             * @param {luck.protobuf.IEquipAdvanceResp} message EquipAdvanceResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EquipAdvanceResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EquipAdvanceResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.EquipAdvanceResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.EquipAdvanceResp} EquipAdvanceResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EquipAdvanceResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.EquipAdvanceResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.weapon = $root.luck.protobuf.WeaponPB.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.card = $root.luck.protobuf.CardPB.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.clothes = $root.luck.protobuf.ClothesPB.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes an EquipAdvanceResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.EquipAdvanceResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.EquipAdvanceResp} EquipAdvanceResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EquipAdvanceResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EquipAdvanceResp message.
             * @function verify
             * @memberof luck.protobuf.EquipAdvanceResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EquipAdvanceResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.weapon != null && message.hasOwnProperty("weapon")) {
                    var error = $root.luck.protobuf.WeaponPB.verify(message.weapon);
                    if (error)
                        return "weapon." + error;
                }
                if (message.card != null && message.hasOwnProperty("card")) {
                    var error = $root.luck.protobuf.CardPB.verify(message.card);
                    if (error)
                        return "card." + error;
                }
                if (message.clothes != null && message.hasOwnProperty("clothes")) {
                    var error = $root.luck.protobuf.ClothesPB.verify(message.clothes);
                    if (error)
                        return "clothes." + error;
                }
                return null;
            };

            return EquipAdvanceResp;
        })();

        protobuf.RoleUnlockResp = (function() {

            /**
             * Properties of a RoleUnlockResp.
             * @memberof luck.protobuf
             * @interface IRoleUnlockResp
             * @property {number} result RoleUnlockResp result
             * @property {Array.<number>|null} [roleList] RoleUnlockResp roleList
             */

            /**
             * Constructs a new RoleUnlockResp.
             * @memberof luck.protobuf
             * @classdesc Represents a RoleUnlockResp.
             * @implements IRoleUnlockResp
             * @constructor
             * @param {luck.protobuf.IRoleUnlockResp=} [properties] Properties to set
             */
            function RoleUnlockResp(properties) {
                this.roleList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RoleUnlockResp result.
             * @member {number} result
             * @memberof luck.protobuf.RoleUnlockResp
             * @instance
             */
            RoleUnlockResp.prototype.result = 0;

            /**
             * RoleUnlockResp roleList.
             * @member {Array.<number>} roleList
             * @memberof luck.protobuf.RoleUnlockResp
             * @instance
             */
            RoleUnlockResp.prototype.roleList = $util.emptyArray;

            /**
             * Creates a new RoleUnlockResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.RoleUnlockResp
             * @static
             * @param {luck.protobuf.IRoleUnlockResp=} [properties] Properties to set
             * @returns {luck.protobuf.RoleUnlockResp} RoleUnlockResp instance
             */
            RoleUnlockResp.create = function create(properties) {
                return new RoleUnlockResp(properties);
            };

            /**
             * Encodes the specified RoleUnlockResp message. Does not implicitly {@link luck.protobuf.RoleUnlockResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.RoleUnlockResp
             * @static
             * @param {luck.protobuf.IRoleUnlockResp} message RoleUnlockResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RoleUnlockResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.roleList != null && message.roleList.length)
                    for (var i = 0; i < message.roleList.length; ++i)
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.roleList[i]);
                return writer;
            };

            /**
             * Encodes the specified RoleUnlockResp message, length delimited. Does not implicitly {@link luck.protobuf.RoleUnlockResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.RoleUnlockResp
             * @static
             * @param {luck.protobuf.IRoleUnlockResp} message RoleUnlockResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RoleUnlockResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RoleUnlockResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.RoleUnlockResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.RoleUnlockResp} RoleUnlockResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RoleUnlockResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.RoleUnlockResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        if (!(message.roleList && message.roleList.length))
                            message.roleList = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.roleList.push(reader.int32());
                        } else
                            message.roleList.push(reader.int32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a RoleUnlockResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.RoleUnlockResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.RoleUnlockResp} RoleUnlockResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RoleUnlockResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RoleUnlockResp message.
             * @function verify
             * @memberof luck.protobuf.RoleUnlockResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RoleUnlockResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.roleList != null && message.hasOwnProperty("roleList")) {
                    if (!Array.isArray(message.roleList))
                        return "roleList: array expected";
                    for (var i = 0; i < message.roleList.length; ++i)
                        if (!$util.isInteger(message.roleList[i]))
                            return "roleList: integer[] expected";
                }
                return null;
            };

            return RoleUnlockResp;
        })();

        protobuf.RoleChangeResp = (function() {

            /**
             * Properties of a RoleChangeResp.
             * @memberof luck.protobuf
             * @interface IRoleChangeResp
             * @property {number} result RoleChangeResp result
             */

            /**
             * Constructs a new RoleChangeResp.
             * @memberof luck.protobuf
             * @classdesc Represents a RoleChangeResp.
             * @implements IRoleChangeResp
             * @constructor
             * @param {luck.protobuf.IRoleChangeResp=} [properties] Properties to set
             */
            function RoleChangeResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RoleChangeResp result.
             * @member {number} result
             * @memberof luck.protobuf.RoleChangeResp
             * @instance
             */
            RoleChangeResp.prototype.result = 0;

            /**
             * Creates a new RoleChangeResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.RoleChangeResp
             * @static
             * @param {luck.protobuf.IRoleChangeResp=} [properties] Properties to set
             * @returns {luck.protobuf.RoleChangeResp} RoleChangeResp instance
             */
            RoleChangeResp.create = function create(properties) {
                return new RoleChangeResp(properties);
            };

            /**
             * Encodes the specified RoleChangeResp message. Does not implicitly {@link luck.protobuf.RoleChangeResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.RoleChangeResp
             * @static
             * @param {luck.protobuf.IRoleChangeResp} message RoleChangeResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RoleChangeResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                return writer;
            };

            /**
             * Encodes the specified RoleChangeResp message, length delimited. Does not implicitly {@link luck.protobuf.RoleChangeResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.RoleChangeResp
             * @static
             * @param {luck.protobuf.IRoleChangeResp} message RoleChangeResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RoleChangeResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RoleChangeResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.RoleChangeResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.RoleChangeResp} RoleChangeResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RoleChangeResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.RoleChangeResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a RoleChangeResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.RoleChangeResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.RoleChangeResp} RoleChangeResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RoleChangeResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RoleChangeResp message.
             * @function verify
             * @memberof luck.protobuf.RoleChangeResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RoleChangeResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                return null;
            };

            return RoleChangeResp;
        })();

        protobuf.StaminaBuyResp = (function() {

            /**
             * Properties of a StaminaBuyResp.
             * @memberof luck.protobuf
             * @interface IStaminaBuyResp
             * @property {number} result StaminaBuyResp result
             * @property {luck.protobuf.IPlayerBasePB|null} [updatePlayerBase] StaminaBuyResp updatePlayerBase
             */

            /**
             * Constructs a new StaminaBuyResp.
             * @memberof luck.protobuf
             * @classdesc Represents a StaminaBuyResp.
             * @implements IStaminaBuyResp
             * @constructor
             * @param {luck.protobuf.IStaminaBuyResp=} [properties] Properties to set
             */
            function StaminaBuyResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StaminaBuyResp result.
             * @member {number} result
             * @memberof luck.protobuf.StaminaBuyResp
             * @instance
             */
            StaminaBuyResp.prototype.result = 0;

            /**
             * StaminaBuyResp updatePlayerBase.
             * @member {luck.protobuf.IPlayerBasePB|null|undefined} updatePlayerBase
             * @memberof luck.protobuf.StaminaBuyResp
             * @instance
             */
            StaminaBuyResp.prototype.updatePlayerBase = null;

            /**
             * Creates a new StaminaBuyResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.StaminaBuyResp
             * @static
             * @param {luck.protobuf.IStaminaBuyResp=} [properties] Properties to set
             * @returns {luck.protobuf.StaminaBuyResp} StaminaBuyResp instance
             */
            StaminaBuyResp.create = function create(properties) {
                return new StaminaBuyResp(properties);
            };

            /**
             * Encodes the specified StaminaBuyResp message. Does not implicitly {@link luck.protobuf.StaminaBuyResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.StaminaBuyResp
             * @static
             * @param {luck.protobuf.IStaminaBuyResp} message StaminaBuyResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StaminaBuyResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.updatePlayerBase != null && message.hasOwnProperty("updatePlayerBase"))
                    $root.luck.protobuf.PlayerBasePB.encode(message.updatePlayerBase, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified StaminaBuyResp message, length delimited. Does not implicitly {@link luck.protobuf.StaminaBuyResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.StaminaBuyResp
             * @static
             * @param {luck.protobuf.IStaminaBuyResp} message StaminaBuyResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StaminaBuyResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StaminaBuyResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.StaminaBuyResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.StaminaBuyResp} StaminaBuyResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StaminaBuyResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.StaminaBuyResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.updatePlayerBase = $root.luck.protobuf.PlayerBasePB.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a StaminaBuyResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.StaminaBuyResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.StaminaBuyResp} StaminaBuyResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StaminaBuyResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StaminaBuyResp message.
             * @function verify
             * @memberof luck.protobuf.StaminaBuyResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StaminaBuyResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.updatePlayerBase != null && message.hasOwnProperty("updatePlayerBase")) {
                    var error = $root.luck.protobuf.PlayerBasePB.verify(message.updatePlayerBase);
                    if (error)
                        return "updatePlayerBase." + error;
                }
                return null;
            };

            return StaminaBuyResp;
        })();

        protobuf.ShopBuyResp = (function() {

            /**
             * Properties of a ShopBuyResp.
             * @memberof luck.protobuf
             * @interface IShopBuyResp
             * @property {number} result ShopBuyResp result
             * @property {number|Long|null} [gold] ShopBuyResp gold
             * @property {Array.<luck.protobuf.IWeaponPB>|null} [weaponList] ShopBuyResp weaponList
             * @property {Array.<luck.protobuf.ICardPB>|null} [cardList] ShopBuyResp cardList
             * @property {Array.<luck.protobuf.IClothesPB>|null} [clothesList] ShopBuyResp clothesList
             * @property {Array.<luck.protobuf.IPropPB>|null} [propList] ShopBuyResp propList
             * @property {Array.<luck.protobuf.IMaterialsPB>|null} [materialsList] ShopBuyResp materialsList
             * @property {Array.<luck.protobuf.IShopGoodsPB>|null} [shopGoodsList] ShopBuyResp shopGoodsList
             */

            /**
             * Constructs a new ShopBuyResp.
             * @memberof luck.protobuf
             * @classdesc Represents a ShopBuyResp.
             * @implements IShopBuyResp
             * @constructor
             * @param {luck.protobuf.IShopBuyResp=} [properties] Properties to set
             */
            function ShopBuyResp(properties) {
                this.weaponList = [];
                this.cardList = [];
                this.clothesList = [];
                this.propList = [];
                this.materialsList = [];
                this.shopGoodsList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ShopBuyResp result.
             * @member {number} result
             * @memberof luck.protobuf.ShopBuyResp
             * @instance
             */
            ShopBuyResp.prototype.result = 0;

            /**
             * ShopBuyResp gold.
             * @member {number|Long} gold
             * @memberof luck.protobuf.ShopBuyResp
             * @instance
             */
            ShopBuyResp.prototype.gold = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * ShopBuyResp weaponList.
             * @member {Array.<luck.protobuf.IWeaponPB>} weaponList
             * @memberof luck.protobuf.ShopBuyResp
             * @instance
             */
            ShopBuyResp.prototype.weaponList = $util.emptyArray;

            /**
             * ShopBuyResp cardList.
             * @member {Array.<luck.protobuf.ICardPB>} cardList
             * @memberof luck.protobuf.ShopBuyResp
             * @instance
             */
            ShopBuyResp.prototype.cardList = $util.emptyArray;

            /**
             * ShopBuyResp clothesList.
             * @member {Array.<luck.protobuf.IClothesPB>} clothesList
             * @memberof luck.protobuf.ShopBuyResp
             * @instance
             */
            ShopBuyResp.prototype.clothesList = $util.emptyArray;

            /**
             * ShopBuyResp propList.
             * @member {Array.<luck.protobuf.IPropPB>} propList
             * @memberof luck.protobuf.ShopBuyResp
             * @instance
             */
            ShopBuyResp.prototype.propList = $util.emptyArray;

            /**
             * ShopBuyResp materialsList.
             * @member {Array.<luck.protobuf.IMaterialsPB>} materialsList
             * @memberof luck.protobuf.ShopBuyResp
             * @instance
             */
            ShopBuyResp.prototype.materialsList = $util.emptyArray;

            /**
             * ShopBuyResp shopGoodsList.
             * @member {Array.<luck.protobuf.IShopGoodsPB>} shopGoodsList
             * @memberof luck.protobuf.ShopBuyResp
             * @instance
             */
            ShopBuyResp.prototype.shopGoodsList = $util.emptyArray;

            /**
             * Creates a new ShopBuyResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.ShopBuyResp
             * @static
             * @param {luck.protobuf.IShopBuyResp=} [properties] Properties to set
             * @returns {luck.protobuf.ShopBuyResp} ShopBuyResp instance
             */
            ShopBuyResp.create = function create(properties) {
                return new ShopBuyResp(properties);
            };

            /**
             * Encodes the specified ShopBuyResp message. Does not implicitly {@link luck.protobuf.ShopBuyResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.ShopBuyResp
             * @static
             * @param {luck.protobuf.IShopBuyResp} message ShopBuyResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ShopBuyResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.gold != null && message.hasOwnProperty("gold"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.gold);
                if (message.weaponList != null && message.weaponList.length)
                    for (var i = 0; i < message.weaponList.length; ++i)
                        $root.luck.protobuf.WeaponPB.encode(message.weaponList[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.cardList != null && message.cardList.length)
                    for (var i = 0; i < message.cardList.length; ++i)
                        $root.luck.protobuf.CardPB.encode(message.cardList[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.clothesList != null && message.clothesList.length)
                    for (var i = 0; i < message.clothesList.length; ++i)
                        $root.luck.protobuf.ClothesPB.encode(message.clothesList[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.propList != null && message.propList.length)
                    for (var i = 0; i < message.propList.length; ++i)
                        $root.luck.protobuf.PropPB.encode(message.propList[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.materialsList != null && message.materialsList.length)
                    for (var i = 0; i < message.materialsList.length; ++i)
                        $root.luck.protobuf.MaterialsPB.encode(message.materialsList[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.shopGoodsList != null && message.shopGoodsList.length)
                    for (var i = 0; i < message.shopGoodsList.length; ++i)
                        $root.luck.protobuf.ShopGoodsPB.encode(message.shopGoodsList[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ShopBuyResp message, length delimited. Does not implicitly {@link luck.protobuf.ShopBuyResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.ShopBuyResp
             * @static
             * @param {luck.protobuf.IShopBuyResp} message ShopBuyResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ShopBuyResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ShopBuyResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.ShopBuyResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.ShopBuyResp} ShopBuyResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ShopBuyResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.ShopBuyResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.gold = reader.int64();
                        break;
                    case 3:
                        if (!(message.weaponList && message.weaponList.length))
                            message.weaponList = [];
                        message.weaponList.push($root.luck.protobuf.WeaponPB.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        if (!(message.cardList && message.cardList.length))
                            message.cardList = [];
                        message.cardList.push($root.luck.protobuf.CardPB.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.clothesList && message.clothesList.length))
                            message.clothesList = [];
                        message.clothesList.push($root.luck.protobuf.ClothesPB.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.propList && message.propList.length))
                            message.propList = [];
                        message.propList.push($root.luck.protobuf.PropPB.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        if (!(message.materialsList && message.materialsList.length))
                            message.materialsList = [];
                        message.materialsList.push($root.luck.protobuf.MaterialsPB.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        if (!(message.shopGoodsList && message.shopGoodsList.length))
                            message.shopGoodsList = [];
                        message.shopGoodsList.push($root.luck.protobuf.ShopGoodsPB.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a ShopBuyResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.ShopBuyResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.ShopBuyResp} ShopBuyResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ShopBuyResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ShopBuyResp message.
             * @function verify
             * @memberof luck.protobuf.ShopBuyResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ShopBuyResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.gold != null && message.hasOwnProperty("gold"))
                    if (!$util.isInteger(message.gold) && !(message.gold && $util.isInteger(message.gold.low) && $util.isInteger(message.gold.high)))
                        return "gold: integer|Long expected";
                if (message.weaponList != null && message.hasOwnProperty("weaponList")) {
                    if (!Array.isArray(message.weaponList))
                        return "weaponList: array expected";
                    for (var i = 0; i < message.weaponList.length; ++i) {
                        var error = $root.luck.protobuf.WeaponPB.verify(message.weaponList[i]);
                        if (error)
                            return "weaponList." + error;
                    }
                }
                if (message.cardList != null && message.hasOwnProperty("cardList")) {
                    if (!Array.isArray(message.cardList))
                        return "cardList: array expected";
                    for (var i = 0; i < message.cardList.length; ++i) {
                        var error = $root.luck.protobuf.CardPB.verify(message.cardList[i]);
                        if (error)
                            return "cardList." + error;
                    }
                }
                if (message.clothesList != null && message.hasOwnProperty("clothesList")) {
                    if (!Array.isArray(message.clothesList))
                        return "clothesList: array expected";
                    for (var i = 0; i < message.clothesList.length; ++i) {
                        var error = $root.luck.protobuf.ClothesPB.verify(message.clothesList[i]);
                        if (error)
                            return "clothesList." + error;
                    }
                }
                if (message.propList != null && message.hasOwnProperty("propList")) {
                    if (!Array.isArray(message.propList))
                        return "propList: array expected";
                    for (var i = 0; i < message.propList.length; ++i) {
                        var error = $root.luck.protobuf.PropPB.verify(message.propList[i]);
                        if (error)
                            return "propList." + error;
                    }
                }
                if (message.materialsList != null && message.hasOwnProperty("materialsList")) {
                    if (!Array.isArray(message.materialsList))
                        return "materialsList: array expected";
                    for (var i = 0; i < message.materialsList.length; ++i) {
                        var error = $root.luck.protobuf.MaterialsPB.verify(message.materialsList[i]);
                        if (error)
                            return "materialsList." + error;
                    }
                }
                if (message.shopGoodsList != null && message.hasOwnProperty("shopGoodsList")) {
                    if (!Array.isArray(message.shopGoodsList))
                        return "shopGoodsList: array expected";
                    for (var i = 0; i < message.shopGoodsList.length; ++i) {
                        var error = $root.luck.protobuf.ShopGoodsPB.verify(message.shopGoodsList[i]);
                        if (error)
                            return "shopGoodsList." + error;
                    }
                }
                return null;
            };

            return ShopBuyResp;
        })();

        protobuf.RecommendFriendsResp = (function() {

            /**
             * Properties of a RecommendFriendsResp.
             * @memberof luck.protobuf
             * @interface IRecommendFriendsResp
             * @property {number} result RecommendFriendsResp result
             * @property {Array.<luck.protobuf.ISimplePlayerPB>|null} [simplePlayerList] RecommendFriendsResp simplePlayerList
             */

            /**
             * Constructs a new RecommendFriendsResp.
             * @memberof luck.protobuf
             * @classdesc Represents a RecommendFriendsResp.
             * @implements IRecommendFriendsResp
             * @constructor
             * @param {luck.protobuf.IRecommendFriendsResp=} [properties] Properties to set
             */
            function RecommendFriendsResp(properties) {
                this.simplePlayerList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RecommendFriendsResp result.
             * @member {number} result
             * @memberof luck.protobuf.RecommendFriendsResp
             * @instance
             */
            RecommendFriendsResp.prototype.result = 0;

            /**
             * RecommendFriendsResp simplePlayerList.
             * @member {Array.<luck.protobuf.ISimplePlayerPB>} simplePlayerList
             * @memberof luck.protobuf.RecommendFriendsResp
             * @instance
             */
            RecommendFriendsResp.prototype.simplePlayerList = $util.emptyArray;

            /**
             * Creates a new RecommendFriendsResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.RecommendFriendsResp
             * @static
             * @param {luck.protobuf.IRecommendFriendsResp=} [properties] Properties to set
             * @returns {luck.protobuf.RecommendFriendsResp} RecommendFriendsResp instance
             */
            RecommendFriendsResp.create = function create(properties) {
                return new RecommendFriendsResp(properties);
            };

            /**
             * Encodes the specified RecommendFriendsResp message. Does not implicitly {@link luck.protobuf.RecommendFriendsResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.RecommendFriendsResp
             * @static
             * @param {luck.protobuf.IRecommendFriendsResp} message RecommendFriendsResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RecommendFriendsResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.simplePlayerList != null && message.simplePlayerList.length)
                    for (var i = 0; i < message.simplePlayerList.length; ++i)
                        $root.luck.protobuf.SimplePlayerPB.encode(message.simplePlayerList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RecommendFriendsResp message, length delimited. Does not implicitly {@link luck.protobuf.RecommendFriendsResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.RecommendFriendsResp
             * @static
             * @param {luck.protobuf.IRecommendFriendsResp} message RecommendFriendsResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RecommendFriendsResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RecommendFriendsResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.RecommendFriendsResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.RecommendFriendsResp} RecommendFriendsResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RecommendFriendsResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.RecommendFriendsResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        if (!(message.simplePlayerList && message.simplePlayerList.length))
                            message.simplePlayerList = [];
                        message.simplePlayerList.push($root.luck.protobuf.SimplePlayerPB.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a RecommendFriendsResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.RecommendFriendsResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.RecommendFriendsResp} RecommendFriendsResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RecommendFriendsResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RecommendFriendsResp message.
             * @function verify
             * @memberof luck.protobuf.RecommendFriendsResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RecommendFriendsResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.simplePlayerList != null && message.hasOwnProperty("simplePlayerList")) {
                    if (!Array.isArray(message.simplePlayerList))
                        return "simplePlayerList: array expected";
                    for (var i = 0; i < message.simplePlayerList.length; ++i) {
                        var error = $root.luck.protobuf.SimplePlayerPB.verify(message.simplePlayerList[i]);
                        if (error)
                            return "simplePlayerList." + error;
                    }
                }
                return null;
            };

            return RecommendFriendsResp;
        })();

        protobuf.SearchFriendsResp = (function() {

            /**
             * Properties of a SearchFriendsResp.
             * @memberof luck.protobuf
             * @interface ISearchFriendsResp
             * @property {number} result SearchFriendsResp result
             * @property {luck.protobuf.ISimplePlayerPB|null} [simplePlayer] SearchFriendsResp simplePlayer
             */

            /**
             * Constructs a new SearchFriendsResp.
             * @memberof luck.protobuf
             * @classdesc Represents a SearchFriendsResp.
             * @implements ISearchFriendsResp
             * @constructor
             * @param {luck.protobuf.ISearchFriendsResp=} [properties] Properties to set
             */
            function SearchFriendsResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SearchFriendsResp result.
             * @member {number} result
             * @memberof luck.protobuf.SearchFriendsResp
             * @instance
             */
            SearchFriendsResp.prototype.result = 0;

            /**
             * SearchFriendsResp simplePlayer.
             * @member {luck.protobuf.ISimplePlayerPB|null|undefined} simplePlayer
             * @memberof luck.protobuf.SearchFriendsResp
             * @instance
             */
            SearchFriendsResp.prototype.simplePlayer = null;

            /**
             * Creates a new SearchFriendsResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.SearchFriendsResp
             * @static
             * @param {luck.protobuf.ISearchFriendsResp=} [properties] Properties to set
             * @returns {luck.protobuf.SearchFriendsResp} SearchFriendsResp instance
             */
            SearchFriendsResp.create = function create(properties) {
                return new SearchFriendsResp(properties);
            };

            /**
             * Encodes the specified SearchFriendsResp message. Does not implicitly {@link luck.protobuf.SearchFriendsResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.SearchFriendsResp
             * @static
             * @param {luck.protobuf.ISearchFriendsResp} message SearchFriendsResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SearchFriendsResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.simplePlayer != null && message.hasOwnProperty("simplePlayer"))
                    $root.luck.protobuf.SimplePlayerPB.encode(message.simplePlayer, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SearchFriendsResp message, length delimited. Does not implicitly {@link luck.protobuf.SearchFriendsResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.SearchFriendsResp
             * @static
             * @param {luck.protobuf.ISearchFriendsResp} message SearchFriendsResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SearchFriendsResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SearchFriendsResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.SearchFriendsResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.SearchFriendsResp} SearchFriendsResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SearchFriendsResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.SearchFriendsResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.simplePlayer = $root.luck.protobuf.SimplePlayerPB.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a SearchFriendsResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.SearchFriendsResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.SearchFriendsResp} SearchFriendsResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SearchFriendsResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SearchFriendsResp message.
             * @function verify
             * @memberof luck.protobuf.SearchFriendsResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SearchFriendsResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.simplePlayer != null && message.hasOwnProperty("simplePlayer")) {
                    var error = $root.luck.protobuf.SimplePlayerPB.verify(message.simplePlayer);
                    if (error)
                        return "simplePlayer." + error;
                }
                return null;
            };

            return SearchFriendsResp;
        })();

        protobuf.ApplyFriendsResp = (function() {

            /**
             * Properties of an ApplyFriendsResp.
             * @memberof luck.protobuf
             * @interface IApplyFriendsResp
             * @property {number} result ApplyFriendsResp result
             */

            /**
             * Constructs a new ApplyFriendsResp.
             * @memberof luck.protobuf
             * @classdesc Represents an ApplyFriendsResp.
             * @implements IApplyFriendsResp
             * @constructor
             * @param {luck.protobuf.IApplyFriendsResp=} [properties] Properties to set
             */
            function ApplyFriendsResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ApplyFriendsResp result.
             * @member {number} result
             * @memberof luck.protobuf.ApplyFriendsResp
             * @instance
             */
            ApplyFriendsResp.prototype.result = 0;

            /**
             * Creates a new ApplyFriendsResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.ApplyFriendsResp
             * @static
             * @param {luck.protobuf.IApplyFriendsResp=} [properties] Properties to set
             * @returns {luck.protobuf.ApplyFriendsResp} ApplyFriendsResp instance
             */
            ApplyFriendsResp.create = function create(properties) {
                return new ApplyFriendsResp(properties);
            };

            /**
             * Encodes the specified ApplyFriendsResp message. Does not implicitly {@link luck.protobuf.ApplyFriendsResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.ApplyFriendsResp
             * @static
             * @param {luck.protobuf.IApplyFriendsResp} message ApplyFriendsResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ApplyFriendsResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                return writer;
            };

            /**
             * Encodes the specified ApplyFriendsResp message, length delimited. Does not implicitly {@link luck.protobuf.ApplyFriendsResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.ApplyFriendsResp
             * @static
             * @param {luck.protobuf.IApplyFriendsResp} message ApplyFriendsResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ApplyFriendsResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ApplyFriendsResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.ApplyFriendsResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.ApplyFriendsResp} ApplyFriendsResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ApplyFriendsResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.ApplyFriendsResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes an ApplyFriendsResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.ApplyFriendsResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.ApplyFriendsResp} ApplyFriendsResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ApplyFriendsResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ApplyFriendsResp message.
             * @function verify
             * @memberof luck.protobuf.ApplyFriendsResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ApplyFriendsResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                return null;
            };

            return ApplyFriendsResp;
        })();

        protobuf.PushApplyFriendsResp = (function() {

            /**
             * Properties of a PushApplyFriendsResp.
             * @memberof luck.protobuf
             * @interface IPushApplyFriendsResp
             * @property {luck.protobuf.ISimplePlayerPB|null} [newApplyFriend] PushApplyFriendsResp newApplyFriend
             */

            /**
             * Constructs a new PushApplyFriendsResp.
             * @memberof luck.protobuf
             * @classdesc Represents a PushApplyFriendsResp.
             * @implements IPushApplyFriendsResp
             * @constructor
             * @param {luck.protobuf.IPushApplyFriendsResp=} [properties] Properties to set
             */
            function PushApplyFriendsResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PushApplyFriendsResp newApplyFriend.
             * @member {luck.protobuf.ISimplePlayerPB|null|undefined} newApplyFriend
             * @memberof luck.protobuf.PushApplyFriendsResp
             * @instance
             */
            PushApplyFriendsResp.prototype.newApplyFriend = null;

            /**
             * Creates a new PushApplyFriendsResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.PushApplyFriendsResp
             * @static
             * @param {luck.protobuf.IPushApplyFriendsResp=} [properties] Properties to set
             * @returns {luck.protobuf.PushApplyFriendsResp} PushApplyFriendsResp instance
             */
            PushApplyFriendsResp.create = function create(properties) {
                return new PushApplyFriendsResp(properties);
            };

            /**
             * Encodes the specified PushApplyFriendsResp message. Does not implicitly {@link luck.protobuf.PushApplyFriendsResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.PushApplyFriendsResp
             * @static
             * @param {luck.protobuf.IPushApplyFriendsResp} message PushApplyFriendsResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PushApplyFriendsResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.newApplyFriend != null && message.hasOwnProperty("newApplyFriend"))
                    $root.luck.protobuf.SimplePlayerPB.encode(message.newApplyFriend, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified PushApplyFriendsResp message, length delimited. Does not implicitly {@link luck.protobuf.PushApplyFriendsResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.PushApplyFriendsResp
             * @static
             * @param {luck.protobuf.IPushApplyFriendsResp} message PushApplyFriendsResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PushApplyFriendsResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PushApplyFriendsResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.PushApplyFriendsResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.PushApplyFriendsResp} PushApplyFriendsResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PushApplyFriendsResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.PushApplyFriendsResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.newApplyFriend = $root.luck.protobuf.SimplePlayerPB.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PushApplyFriendsResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.PushApplyFriendsResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.PushApplyFriendsResp} PushApplyFriendsResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PushApplyFriendsResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PushApplyFriendsResp message.
             * @function verify
             * @memberof luck.protobuf.PushApplyFriendsResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PushApplyFriendsResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.newApplyFriend != null && message.hasOwnProperty("newApplyFriend")) {
                    var error = $root.luck.protobuf.SimplePlayerPB.verify(message.newApplyFriend);
                    if (error)
                        return "newApplyFriend." + error;
                }
                return null;
            };

            return PushApplyFriendsResp;
        })();

        protobuf.GetFriendsListResp = (function() {

            /**
             * Properties of a GetFriendsListResp.
             * @memberof luck.protobuf
             * @interface IGetFriendsListResp
             * @property {number} result GetFriendsListResp result
             * @property {Array.<luck.protobuf.ISimplePlayerPB>|null} [friendsList] GetFriendsListResp friendsList
             * @property {Array.<luck.protobuf.ISimplePlayerPB>|null} [applyFriendsList] GetFriendsListResp applyFriendsList
             * @property {Array.<luck.protobuf.ISimplePlayerPB>|null} [blackList] GetFriendsListResp blackList
             */

            /**
             * Constructs a new GetFriendsListResp.
             * @memberof luck.protobuf
             * @classdesc Represents a GetFriendsListResp.
             * @implements IGetFriendsListResp
             * @constructor
             * @param {luck.protobuf.IGetFriendsListResp=} [properties] Properties to set
             */
            function GetFriendsListResp(properties) {
                this.friendsList = [];
                this.applyFriendsList = [];
                this.blackList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetFriendsListResp result.
             * @member {number} result
             * @memberof luck.protobuf.GetFriendsListResp
             * @instance
             */
            GetFriendsListResp.prototype.result = 0;

            /**
             * GetFriendsListResp friendsList.
             * @member {Array.<luck.protobuf.ISimplePlayerPB>} friendsList
             * @memberof luck.protobuf.GetFriendsListResp
             * @instance
             */
            GetFriendsListResp.prototype.friendsList = $util.emptyArray;

            /**
             * GetFriendsListResp applyFriendsList.
             * @member {Array.<luck.protobuf.ISimplePlayerPB>} applyFriendsList
             * @memberof luck.protobuf.GetFriendsListResp
             * @instance
             */
            GetFriendsListResp.prototype.applyFriendsList = $util.emptyArray;

            /**
             * GetFriendsListResp blackList.
             * @member {Array.<luck.protobuf.ISimplePlayerPB>} blackList
             * @memberof luck.protobuf.GetFriendsListResp
             * @instance
             */
            GetFriendsListResp.prototype.blackList = $util.emptyArray;

            /**
             * Creates a new GetFriendsListResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.GetFriendsListResp
             * @static
             * @param {luck.protobuf.IGetFriendsListResp=} [properties] Properties to set
             * @returns {luck.protobuf.GetFriendsListResp} GetFriendsListResp instance
             */
            GetFriendsListResp.create = function create(properties) {
                return new GetFriendsListResp(properties);
            };

            /**
             * Encodes the specified GetFriendsListResp message. Does not implicitly {@link luck.protobuf.GetFriendsListResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.GetFriendsListResp
             * @static
             * @param {luck.protobuf.IGetFriendsListResp} message GetFriendsListResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetFriendsListResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.friendsList != null && message.friendsList.length)
                    for (var i = 0; i < message.friendsList.length; ++i)
                        $root.luck.protobuf.SimplePlayerPB.encode(message.friendsList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.applyFriendsList != null && message.applyFriendsList.length)
                    for (var i = 0; i < message.applyFriendsList.length; ++i)
                        $root.luck.protobuf.SimplePlayerPB.encode(message.applyFriendsList[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.blackList != null && message.blackList.length)
                    for (var i = 0; i < message.blackList.length; ++i)
                        $root.luck.protobuf.SimplePlayerPB.encode(message.blackList[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetFriendsListResp message, length delimited. Does not implicitly {@link luck.protobuf.GetFriendsListResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.GetFriendsListResp
             * @static
             * @param {luck.protobuf.IGetFriendsListResp} message GetFriendsListResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetFriendsListResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetFriendsListResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.GetFriendsListResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.GetFriendsListResp} GetFriendsListResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetFriendsListResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.GetFriendsListResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        if (!(message.friendsList && message.friendsList.length))
                            message.friendsList = [];
                        message.friendsList.push($root.luck.protobuf.SimplePlayerPB.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.applyFriendsList && message.applyFriendsList.length))
                            message.applyFriendsList = [];
                        message.applyFriendsList.push($root.luck.protobuf.SimplePlayerPB.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        if (!(message.blackList && message.blackList.length))
                            message.blackList = [];
                        message.blackList.push($root.luck.protobuf.SimplePlayerPB.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a GetFriendsListResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.GetFriendsListResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.GetFriendsListResp} GetFriendsListResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetFriendsListResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetFriendsListResp message.
             * @function verify
             * @memberof luck.protobuf.GetFriendsListResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetFriendsListResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.friendsList != null && message.hasOwnProperty("friendsList")) {
                    if (!Array.isArray(message.friendsList))
                        return "friendsList: array expected";
                    for (var i = 0; i < message.friendsList.length; ++i) {
                        var error = $root.luck.protobuf.SimplePlayerPB.verify(message.friendsList[i]);
                        if (error)
                            return "friendsList." + error;
                    }
                }
                if (message.applyFriendsList != null && message.hasOwnProperty("applyFriendsList")) {
                    if (!Array.isArray(message.applyFriendsList))
                        return "applyFriendsList: array expected";
                    for (var i = 0; i < message.applyFriendsList.length; ++i) {
                        var error = $root.luck.protobuf.SimplePlayerPB.verify(message.applyFriendsList[i]);
                        if (error)
                            return "applyFriendsList." + error;
                    }
                }
                if (message.blackList != null && message.hasOwnProperty("blackList")) {
                    if (!Array.isArray(message.blackList))
                        return "blackList: array expected";
                    for (var i = 0; i < message.blackList.length; ++i) {
                        var error = $root.luck.protobuf.SimplePlayerPB.verify(message.blackList[i]);
                        if (error)
                            return "blackList." + error;
                    }
                }
                return null;
            };

            return GetFriendsListResp;
        })();

        protobuf.ApproveFriendApplyResp = (function() {

            /**
             * Properties of an ApproveFriendApplyResp.
             * @memberof luck.protobuf
             * @interface IApproveFriendApplyResp
             * @property {number} result ApproveFriendApplyResp result
             * @property {Array.<luck.protobuf.ISimplePlayerPB>|null} [friendsList] ApproveFriendApplyResp friendsList
             */

            /**
             * Constructs a new ApproveFriendApplyResp.
             * @memberof luck.protobuf
             * @classdesc Represents an ApproveFriendApplyResp.
             * @implements IApproveFriendApplyResp
             * @constructor
             * @param {luck.protobuf.IApproveFriendApplyResp=} [properties] Properties to set
             */
            function ApproveFriendApplyResp(properties) {
                this.friendsList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ApproveFriendApplyResp result.
             * @member {number} result
             * @memberof luck.protobuf.ApproveFriendApplyResp
             * @instance
             */
            ApproveFriendApplyResp.prototype.result = 0;

            /**
             * ApproveFriendApplyResp friendsList.
             * @member {Array.<luck.protobuf.ISimplePlayerPB>} friendsList
             * @memberof luck.protobuf.ApproveFriendApplyResp
             * @instance
             */
            ApproveFriendApplyResp.prototype.friendsList = $util.emptyArray;

            /**
             * Creates a new ApproveFriendApplyResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.ApproveFriendApplyResp
             * @static
             * @param {luck.protobuf.IApproveFriendApplyResp=} [properties] Properties to set
             * @returns {luck.protobuf.ApproveFriendApplyResp} ApproveFriendApplyResp instance
             */
            ApproveFriendApplyResp.create = function create(properties) {
                return new ApproveFriendApplyResp(properties);
            };

            /**
             * Encodes the specified ApproveFriendApplyResp message. Does not implicitly {@link luck.protobuf.ApproveFriendApplyResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.ApproveFriendApplyResp
             * @static
             * @param {luck.protobuf.IApproveFriendApplyResp} message ApproveFriendApplyResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ApproveFriendApplyResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.friendsList != null && message.friendsList.length)
                    for (var i = 0; i < message.friendsList.length; ++i)
                        $root.luck.protobuf.SimplePlayerPB.encode(message.friendsList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ApproveFriendApplyResp message, length delimited. Does not implicitly {@link luck.protobuf.ApproveFriendApplyResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.ApproveFriendApplyResp
             * @static
             * @param {luck.protobuf.IApproveFriendApplyResp} message ApproveFriendApplyResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ApproveFriendApplyResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ApproveFriendApplyResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.ApproveFriendApplyResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.ApproveFriendApplyResp} ApproveFriendApplyResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ApproveFriendApplyResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.ApproveFriendApplyResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        if (!(message.friendsList && message.friendsList.length))
                            message.friendsList = [];
                        message.friendsList.push($root.luck.protobuf.SimplePlayerPB.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes an ApproveFriendApplyResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.ApproveFriendApplyResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.ApproveFriendApplyResp} ApproveFriendApplyResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ApproveFriendApplyResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ApproveFriendApplyResp message.
             * @function verify
             * @memberof luck.protobuf.ApproveFriendApplyResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ApproveFriendApplyResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.friendsList != null && message.hasOwnProperty("friendsList")) {
                    if (!Array.isArray(message.friendsList))
                        return "friendsList: array expected";
                    for (var i = 0; i < message.friendsList.length; ++i) {
                        var error = $root.luck.protobuf.SimplePlayerPB.verify(message.friendsList[i]);
                        if (error)
                            return "friendsList." + error;
                    }
                }
                return null;
            };

            return ApproveFriendApplyResp;
        })();

        protobuf.PushNewFriendResp = (function() {

            /**
             * Properties of a PushNewFriendResp.
             * @memberof luck.protobuf
             * @interface IPushNewFriendResp
             * @property {luck.protobuf.ISimplePlayerPB|null} [newFriend] PushNewFriendResp newFriend
             */

            /**
             * Constructs a new PushNewFriendResp.
             * @memberof luck.protobuf
             * @classdesc Represents a PushNewFriendResp.
             * @implements IPushNewFriendResp
             * @constructor
             * @param {luck.protobuf.IPushNewFriendResp=} [properties] Properties to set
             */
            function PushNewFriendResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PushNewFriendResp newFriend.
             * @member {luck.protobuf.ISimplePlayerPB|null|undefined} newFriend
             * @memberof luck.protobuf.PushNewFriendResp
             * @instance
             */
            PushNewFriendResp.prototype.newFriend = null;

            /**
             * Creates a new PushNewFriendResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.PushNewFriendResp
             * @static
             * @param {luck.protobuf.IPushNewFriendResp=} [properties] Properties to set
             * @returns {luck.protobuf.PushNewFriendResp} PushNewFriendResp instance
             */
            PushNewFriendResp.create = function create(properties) {
                return new PushNewFriendResp(properties);
            };

            /**
             * Encodes the specified PushNewFriendResp message. Does not implicitly {@link luck.protobuf.PushNewFriendResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.PushNewFriendResp
             * @static
             * @param {luck.protobuf.IPushNewFriendResp} message PushNewFriendResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PushNewFriendResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.newFriend != null && message.hasOwnProperty("newFriend"))
                    $root.luck.protobuf.SimplePlayerPB.encode(message.newFriend, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified PushNewFriendResp message, length delimited. Does not implicitly {@link luck.protobuf.PushNewFriendResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.PushNewFriendResp
             * @static
             * @param {luck.protobuf.IPushNewFriendResp} message PushNewFriendResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PushNewFriendResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PushNewFriendResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.PushNewFriendResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.PushNewFriendResp} PushNewFriendResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PushNewFriendResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.PushNewFriendResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.newFriend = $root.luck.protobuf.SimplePlayerPB.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PushNewFriendResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.PushNewFriendResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.PushNewFriendResp} PushNewFriendResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PushNewFriendResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PushNewFriendResp message.
             * @function verify
             * @memberof luck.protobuf.PushNewFriendResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PushNewFriendResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.newFriend != null && message.hasOwnProperty("newFriend")) {
                    var error = $root.luck.protobuf.SimplePlayerPB.verify(message.newFriend);
                    if (error)
                        return "newFriend." + error;
                }
                return null;
            };

            return PushNewFriendResp;
        })();

        protobuf.DeleteFriendResp = (function() {

            /**
             * Properties of a DeleteFriendResp.
             * @memberof luck.protobuf
             * @interface IDeleteFriendResp
             * @property {number} result DeleteFriendResp result
             * @property {Array.<luck.protobuf.ISimplePlayerPB>|null} [friendsList] DeleteFriendResp friendsList
             */

            /**
             * Constructs a new DeleteFriendResp.
             * @memberof luck.protobuf
             * @classdesc Represents a DeleteFriendResp.
             * @implements IDeleteFriendResp
             * @constructor
             * @param {luck.protobuf.IDeleteFriendResp=} [properties] Properties to set
             */
            function DeleteFriendResp(properties) {
                this.friendsList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeleteFriendResp result.
             * @member {number} result
             * @memberof luck.protobuf.DeleteFriendResp
             * @instance
             */
            DeleteFriendResp.prototype.result = 0;

            /**
             * DeleteFriendResp friendsList.
             * @member {Array.<luck.protobuf.ISimplePlayerPB>} friendsList
             * @memberof luck.protobuf.DeleteFriendResp
             * @instance
             */
            DeleteFriendResp.prototype.friendsList = $util.emptyArray;

            /**
             * Creates a new DeleteFriendResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.DeleteFriendResp
             * @static
             * @param {luck.protobuf.IDeleteFriendResp=} [properties] Properties to set
             * @returns {luck.protobuf.DeleteFriendResp} DeleteFriendResp instance
             */
            DeleteFriendResp.create = function create(properties) {
                return new DeleteFriendResp(properties);
            };

            /**
             * Encodes the specified DeleteFriendResp message. Does not implicitly {@link luck.protobuf.DeleteFriendResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.DeleteFriendResp
             * @static
             * @param {luck.protobuf.IDeleteFriendResp} message DeleteFriendResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteFriendResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.friendsList != null && message.friendsList.length)
                    for (var i = 0; i < message.friendsList.length; ++i)
                        $root.luck.protobuf.SimplePlayerPB.encode(message.friendsList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DeleteFriendResp message, length delimited. Does not implicitly {@link luck.protobuf.DeleteFriendResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.DeleteFriendResp
             * @static
             * @param {luck.protobuf.IDeleteFriendResp} message DeleteFriendResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteFriendResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteFriendResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.DeleteFriendResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.DeleteFriendResp} DeleteFriendResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteFriendResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.DeleteFriendResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        if (!(message.friendsList && message.friendsList.length))
                            message.friendsList = [];
                        message.friendsList.push($root.luck.protobuf.SimplePlayerPB.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a DeleteFriendResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.DeleteFriendResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.DeleteFriendResp} DeleteFriendResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteFriendResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteFriendResp message.
             * @function verify
             * @memberof luck.protobuf.DeleteFriendResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteFriendResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.friendsList != null && message.hasOwnProperty("friendsList")) {
                    if (!Array.isArray(message.friendsList))
                        return "friendsList: array expected";
                    for (var i = 0; i < message.friendsList.length; ++i) {
                        var error = $root.luck.protobuf.SimplePlayerPB.verify(message.friendsList[i]);
                        if (error)
                            return "friendsList." + error;
                    }
                }
                return null;
            };

            return DeleteFriendResp;
        })();

        protobuf.LoadShopResp = (function() {

            /**
             * Properties of a LoadShopResp.
             * @memberof luck.protobuf
             * @interface ILoadShopResp
             * @property {number} result LoadShopResp result
             * @property {Array.<luck.protobuf.IShopGoodsPB>|null} [shopGoodsList] LoadShopResp shopGoodsList
             */

            /**
             * Constructs a new LoadShopResp.
             * @memberof luck.protobuf
             * @classdesc Represents a LoadShopResp.
             * @implements ILoadShopResp
             * @constructor
             * @param {luck.protobuf.ILoadShopResp=} [properties] Properties to set
             */
            function LoadShopResp(properties) {
                this.shopGoodsList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LoadShopResp result.
             * @member {number} result
             * @memberof luck.protobuf.LoadShopResp
             * @instance
             */
            LoadShopResp.prototype.result = 0;

            /**
             * LoadShopResp shopGoodsList.
             * @member {Array.<luck.protobuf.IShopGoodsPB>} shopGoodsList
             * @memberof luck.protobuf.LoadShopResp
             * @instance
             */
            LoadShopResp.prototype.shopGoodsList = $util.emptyArray;

            /**
             * Creates a new LoadShopResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.LoadShopResp
             * @static
             * @param {luck.protobuf.ILoadShopResp=} [properties] Properties to set
             * @returns {luck.protobuf.LoadShopResp} LoadShopResp instance
             */
            LoadShopResp.create = function create(properties) {
                return new LoadShopResp(properties);
            };

            /**
             * Encodes the specified LoadShopResp message. Does not implicitly {@link luck.protobuf.LoadShopResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.LoadShopResp
             * @static
             * @param {luck.protobuf.ILoadShopResp} message LoadShopResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LoadShopResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.shopGoodsList != null && message.shopGoodsList.length)
                    for (var i = 0; i < message.shopGoodsList.length; ++i)
                        $root.luck.protobuf.ShopGoodsPB.encode(message.shopGoodsList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified LoadShopResp message, length delimited. Does not implicitly {@link luck.protobuf.LoadShopResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.LoadShopResp
             * @static
             * @param {luck.protobuf.ILoadShopResp} message LoadShopResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LoadShopResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LoadShopResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.LoadShopResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.LoadShopResp} LoadShopResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LoadShopResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.LoadShopResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        if (!(message.shopGoodsList && message.shopGoodsList.length))
                            message.shopGoodsList = [];
                        message.shopGoodsList.push($root.luck.protobuf.ShopGoodsPB.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a LoadShopResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.LoadShopResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.LoadShopResp} LoadShopResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LoadShopResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LoadShopResp message.
             * @function verify
             * @memberof luck.protobuf.LoadShopResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LoadShopResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.shopGoodsList != null && message.hasOwnProperty("shopGoodsList")) {
                    if (!Array.isArray(message.shopGoodsList))
                        return "shopGoodsList: array expected";
                    for (var i = 0; i < message.shopGoodsList.length; ++i) {
                        var error = $root.luck.protobuf.ShopGoodsPB.verify(message.shopGoodsList[i]);
                        if (error)
                            return "shopGoodsList." + error;
                    }
                }
                return null;
            };

            return LoadShopResp;
        })();

        protobuf.IllustrationPushResp = (function() {

            /**
             * Properties of an IllustrationPushResp.
             * @memberof luck.protobuf
             * @interface IIllustrationPushResp
             * @property {number} result IllustrationPushResp result
             * @property {Array.<number>|null} [weaponList] IllustrationPushResp weaponList
             * @property {Array.<number>|null} [cardList] IllustrationPushResp cardList
             * @property {Array.<number>|null} [clothesList] IllustrationPushResp clothesList
             */

            /**
             * Constructs a new IllustrationPushResp.
             * @memberof luck.protobuf
             * @classdesc Represents an IllustrationPushResp.
             * @implements IIllustrationPushResp
             * @constructor
             * @param {luck.protobuf.IIllustrationPushResp=} [properties] Properties to set
             */
            function IllustrationPushResp(properties) {
                this.weaponList = [];
                this.cardList = [];
                this.clothesList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * IllustrationPushResp result.
             * @member {number} result
             * @memberof luck.protobuf.IllustrationPushResp
             * @instance
             */
            IllustrationPushResp.prototype.result = 0;

            /**
             * IllustrationPushResp weaponList.
             * @member {Array.<number>} weaponList
             * @memberof luck.protobuf.IllustrationPushResp
             * @instance
             */
            IllustrationPushResp.prototype.weaponList = $util.emptyArray;

            /**
             * IllustrationPushResp cardList.
             * @member {Array.<number>} cardList
             * @memberof luck.protobuf.IllustrationPushResp
             * @instance
             */
            IllustrationPushResp.prototype.cardList = $util.emptyArray;

            /**
             * IllustrationPushResp clothesList.
             * @member {Array.<number>} clothesList
             * @memberof luck.protobuf.IllustrationPushResp
             * @instance
             */
            IllustrationPushResp.prototype.clothesList = $util.emptyArray;

            /**
             * Creates a new IllustrationPushResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.IllustrationPushResp
             * @static
             * @param {luck.protobuf.IIllustrationPushResp=} [properties] Properties to set
             * @returns {luck.protobuf.IllustrationPushResp} IllustrationPushResp instance
             */
            IllustrationPushResp.create = function create(properties) {
                return new IllustrationPushResp(properties);
            };

            /**
             * Encodes the specified IllustrationPushResp message. Does not implicitly {@link luck.protobuf.IllustrationPushResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.IllustrationPushResp
             * @static
             * @param {luck.protobuf.IIllustrationPushResp} message IllustrationPushResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IllustrationPushResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.weaponList != null && message.weaponList.length)
                    for (var i = 0; i < message.weaponList.length; ++i)
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.weaponList[i]);
                if (message.cardList != null && message.cardList.length)
                    for (var i = 0; i < message.cardList.length; ++i)
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.cardList[i]);
                if (message.clothesList != null && message.clothesList.length)
                    for (var i = 0; i < message.clothesList.length; ++i)
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.clothesList[i]);
                return writer;
            };

            /**
             * Encodes the specified IllustrationPushResp message, length delimited. Does not implicitly {@link luck.protobuf.IllustrationPushResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.IllustrationPushResp
             * @static
             * @param {luck.protobuf.IIllustrationPushResp} message IllustrationPushResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IllustrationPushResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an IllustrationPushResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.IllustrationPushResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.IllustrationPushResp} IllustrationPushResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IllustrationPushResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.IllustrationPushResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        if (!(message.weaponList && message.weaponList.length))
                            message.weaponList = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.weaponList.push(reader.int32());
                        } else
                            message.weaponList.push(reader.int32());
                        break;
                    case 3:
                        if (!(message.cardList && message.cardList.length))
                            message.cardList = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.cardList.push(reader.int32());
                        } else
                            message.cardList.push(reader.int32());
                        break;
                    case 4:
                        if (!(message.clothesList && message.clothesList.length))
                            message.clothesList = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.clothesList.push(reader.int32());
                        } else
                            message.clothesList.push(reader.int32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes an IllustrationPushResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.IllustrationPushResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.IllustrationPushResp} IllustrationPushResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IllustrationPushResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an IllustrationPushResp message.
             * @function verify
             * @memberof luck.protobuf.IllustrationPushResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            IllustrationPushResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.weaponList != null && message.hasOwnProperty("weaponList")) {
                    if (!Array.isArray(message.weaponList))
                        return "weaponList: array expected";
                    for (var i = 0; i < message.weaponList.length; ++i)
                        if (!$util.isInteger(message.weaponList[i]))
                            return "weaponList: integer[] expected";
                }
                if (message.cardList != null && message.hasOwnProperty("cardList")) {
                    if (!Array.isArray(message.cardList))
                        return "cardList: array expected";
                    for (var i = 0; i < message.cardList.length; ++i)
                        if (!$util.isInteger(message.cardList[i]))
                            return "cardList: integer[] expected";
                }
                if (message.clothesList != null && message.hasOwnProperty("clothesList")) {
                    if (!Array.isArray(message.clothesList))
                        return "clothesList: array expected";
                    for (var i = 0; i < message.clothesList.length; ++i)
                        if (!$util.isInteger(message.clothesList[i]))
                            return "clothesList: integer[] expected";
                }
                return null;
            };

            return IllustrationPushResp;
        })();

        protobuf.SendChatResp = (function() {

            /**
             * Properties of a SendChatResp.
             * @memberof luck.protobuf
             * @interface ISendChatResp
             * @property {number} result SendChatResp result
             */

            /**
             * Constructs a new SendChatResp.
             * @memberof luck.protobuf
             * @classdesc Represents a SendChatResp.
             * @implements ISendChatResp
             * @constructor
             * @param {luck.protobuf.ISendChatResp=} [properties] Properties to set
             */
            function SendChatResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SendChatResp result.
             * @member {number} result
             * @memberof luck.protobuf.SendChatResp
             * @instance
             */
            SendChatResp.prototype.result = 0;

            /**
             * Creates a new SendChatResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.SendChatResp
             * @static
             * @param {luck.protobuf.ISendChatResp=} [properties] Properties to set
             * @returns {luck.protobuf.SendChatResp} SendChatResp instance
             */
            SendChatResp.create = function create(properties) {
                return new SendChatResp(properties);
            };

            /**
             * Encodes the specified SendChatResp message. Does not implicitly {@link luck.protobuf.SendChatResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.SendChatResp
             * @static
             * @param {luck.protobuf.ISendChatResp} message SendChatResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendChatResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                return writer;
            };

            /**
             * Encodes the specified SendChatResp message, length delimited. Does not implicitly {@link luck.protobuf.SendChatResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.SendChatResp
             * @static
             * @param {luck.protobuf.ISendChatResp} message SendChatResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendChatResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SendChatResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.SendChatResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.SendChatResp} SendChatResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendChatResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.SendChatResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a SendChatResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.SendChatResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.SendChatResp} SendChatResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendChatResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SendChatResp message.
             * @function verify
             * @memberof luck.protobuf.SendChatResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SendChatResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                return null;
            };

            return SendChatResp;
        })();

        protobuf.ReceiveChatResp = (function() {

            /**
             * Properties of a ReceiveChatResp.
             * @memberof luck.protobuf
             * @interface IReceiveChatResp
             * @property {luck.protobuf.IChatInfoPB} chatInfo ReceiveChatResp chatInfo
             */

            /**
             * Constructs a new ReceiveChatResp.
             * @memberof luck.protobuf
             * @classdesc Represents a ReceiveChatResp.
             * @implements IReceiveChatResp
             * @constructor
             * @param {luck.protobuf.IReceiveChatResp=} [properties] Properties to set
             */
            function ReceiveChatResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReceiveChatResp chatInfo.
             * @member {luck.protobuf.IChatInfoPB} chatInfo
             * @memberof luck.protobuf.ReceiveChatResp
             * @instance
             */
            ReceiveChatResp.prototype.chatInfo = null;

            /**
             * Creates a new ReceiveChatResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.ReceiveChatResp
             * @static
             * @param {luck.protobuf.IReceiveChatResp=} [properties] Properties to set
             * @returns {luck.protobuf.ReceiveChatResp} ReceiveChatResp instance
             */
            ReceiveChatResp.create = function create(properties) {
                return new ReceiveChatResp(properties);
            };

            /**
             * Encodes the specified ReceiveChatResp message. Does not implicitly {@link luck.protobuf.ReceiveChatResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.ReceiveChatResp
             * @static
             * @param {luck.protobuf.IReceiveChatResp} message ReceiveChatResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReceiveChatResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                $root.luck.protobuf.ChatInfoPB.encode(message.chatInfo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReceiveChatResp message, length delimited. Does not implicitly {@link luck.protobuf.ReceiveChatResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.ReceiveChatResp
             * @static
             * @param {luck.protobuf.IReceiveChatResp} message ReceiveChatResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReceiveChatResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReceiveChatResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.ReceiveChatResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.ReceiveChatResp} ReceiveChatResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReceiveChatResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.ReceiveChatResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.chatInfo = $root.luck.protobuf.ChatInfoPB.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("chatInfo"))
                    throw $util.ProtocolError("missing required 'chatInfo'", { instance: message });
                return message;
            };

            /**
             * Decodes a ReceiveChatResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.ReceiveChatResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.ReceiveChatResp} ReceiveChatResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReceiveChatResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReceiveChatResp message.
             * @function verify
             * @memberof luck.protobuf.ReceiveChatResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReceiveChatResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                {
                    var error = $root.luck.protobuf.ChatInfoPB.verify(message.chatInfo);
                    if (error)
                        return "chatInfo." + error;
                }
                return null;
            };

            return ReceiveChatResp;
        })();

        protobuf.PushDeleteFriendResp = (function() {

            /**
             * Properties of a PushDeleteFriendResp.
             * @memberof luck.protobuf
             * @interface IPushDeleteFriendResp
             * @property {number|Long} delId PushDeleteFriendResp delId
             */

            /**
             * Constructs a new PushDeleteFriendResp.
             * @memberof luck.protobuf
             * @classdesc Represents a PushDeleteFriendResp.
             * @implements IPushDeleteFriendResp
             * @constructor
             * @param {luck.protobuf.IPushDeleteFriendResp=} [properties] Properties to set
             */
            function PushDeleteFriendResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PushDeleteFriendResp delId.
             * @member {number|Long} delId
             * @memberof luck.protobuf.PushDeleteFriendResp
             * @instance
             */
            PushDeleteFriendResp.prototype.delId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new PushDeleteFriendResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.PushDeleteFriendResp
             * @static
             * @param {luck.protobuf.IPushDeleteFriendResp=} [properties] Properties to set
             * @returns {luck.protobuf.PushDeleteFriendResp} PushDeleteFriendResp instance
             */
            PushDeleteFriendResp.create = function create(properties) {
                return new PushDeleteFriendResp(properties);
            };

            /**
             * Encodes the specified PushDeleteFriendResp message. Does not implicitly {@link luck.protobuf.PushDeleteFriendResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.PushDeleteFriendResp
             * @static
             * @param {luck.protobuf.IPushDeleteFriendResp} message PushDeleteFriendResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PushDeleteFriendResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.delId);
                return writer;
            };

            /**
             * Encodes the specified PushDeleteFriendResp message, length delimited. Does not implicitly {@link luck.protobuf.PushDeleteFriendResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.PushDeleteFriendResp
             * @static
             * @param {luck.protobuf.IPushDeleteFriendResp} message PushDeleteFriendResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PushDeleteFriendResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PushDeleteFriendResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.PushDeleteFriendResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.PushDeleteFriendResp} PushDeleteFriendResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PushDeleteFriendResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.PushDeleteFriendResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.delId = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("delId"))
                    throw $util.ProtocolError("missing required 'delId'", { instance: message });
                return message;
            };

            /**
             * Decodes a PushDeleteFriendResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.PushDeleteFriendResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.PushDeleteFriendResp} PushDeleteFriendResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PushDeleteFriendResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PushDeleteFriendResp message.
             * @function verify
             * @memberof luck.protobuf.PushDeleteFriendResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PushDeleteFriendResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.delId) && !(message.delId && $util.isInteger(message.delId.low) && $util.isInteger(message.delId.high)))
                    return "delId: integer|Long expected";
                return null;
            };

            return PushDeleteFriendResp;
        })();

        protobuf.ExpansionBagResp = (function() {

            /**
             * Properties of an ExpansionBagResp.
             * @memberof luck.protobuf
             * @interface IExpansionBagResp
             * @property {number} result ExpansionBagResp result
             * @property {luck.protobuf.IPlayerBasePB|null} [playerBase] ExpansionBagResp playerBase
             * @property {luck.protobuf.IPlayerExtraPB|null} [playerExtra] ExpansionBagResp playerExtra
             */

            /**
             * Constructs a new ExpansionBagResp.
             * @memberof luck.protobuf
             * @classdesc Represents an ExpansionBagResp.
             * @implements IExpansionBagResp
             * @constructor
             * @param {luck.protobuf.IExpansionBagResp=} [properties] Properties to set
             */
            function ExpansionBagResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExpansionBagResp result.
             * @member {number} result
             * @memberof luck.protobuf.ExpansionBagResp
             * @instance
             */
            ExpansionBagResp.prototype.result = 0;

            /**
             * ExpansionBagResp playerBase.
             * @member {luck.protobuf.IPlayerBasePB|null|undefined} playerBase
             * @memberof luck.protobuf.ExpansionBagResp
             * @instance
             */
            ExpansionBagResp.prototype.playerBase = null;

            /**
             * ExpansionBagResp playerExtra.
             * @member {luck.protobuf.IPlayerExtraPB|null|undefined} playerExtra
             * @memberof luck.protobuf.ExpansionBagResp
             * @instance
             */
            ExpansionBagResp.prototype.playerExtra = null;

            /**
             * Creates a new ExpansionBagResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.ExpansionBagResp
             * @static
             * @param {luck.protobuf.IExpansionBagResp=} [properties] Properties to set
             * @returns {luck.protobuf.ExpansionBagResp} ExpansionBagResp instance
             */
            ExpansionBagResp.create = function create(properties) {
                return new ExpansionBagResp(properties);
            };

            /**
             * Encodes the specified ExpansionBagResp message. Does not implicitly {@link luck.protobuf.ExpansionBagResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.ExpansionBagResp
             * @static
             * @param {luck.protobuf.IExpansionBagResp} message ExpansionBagResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExpansionBagResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.playerBase != null && message.hasOwnProperty("playerBase"))
                    $root.luck.protobuf.PlayerBasePB.encode(message.playerBase, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.playerExtra != null && message.hasOwnProperty("playerExtra"))
                    $root.luck.protobuf.PlayerExtraPB.encode(message.playerExtra, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ExpansionBagResp message, length delimited. Does not implicitly {@link luck.protobuf.ExpansionBagResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.ExpansionBagResp
             * @static
             * @param {luck.protobuf.IExpansionBagResp} message ExpansionBagResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExpansionBagResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExpansionBagResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.ExpansionBagResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.ExpansionBagResp} ExpansionBagResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExpansionBagResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.ExpansionBagResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.playerBase = $root.luck.protobuf.PlayerBasePB.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.playerExtra = $root.luck.protobuf.PlayerExtraPB.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes an ExpansionBagResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.ExpansionBagResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.ExpansionBagResp} ExpansionBagResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExpansionBagResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExpansionBagResp message.
             * @function verify
             * @memberof luck.protobuf.ExpansionBagResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExpansionBagResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.playerBase != null && message.hasOwnProperty("playerBase")) {
                    var error = $root.luck.protobuf.PlayerBasePB.verify(message.playerBase);
                    if (error)
                        return "playerBase." + error;
                }
                if (message.playerExtra != null && message.hasOwnProperty("playerExtra")) {
                    var error = $root.luck.protobuf.PlayerExtraPB.verify(message.playerExtra);
                    if (error)
                        return "playerExtra." + error;
                }
                return null;
            };

            return ExpansionBagResp;
        })();

        protobuf.ActivityTollgateResp = (function() {

            /**
             * Properties of an ActivityTollgateResp.
             * @memberof luck.protobuf
             * @interface IActivityTollgateResp
             * @property {number} result ActivityTollgateResp result
             */

            /**
             * Constructs a new ActivityTollgateResp.
             * @memberof luck.protobuf
             * @classdesc Represents an ActivityTollgateResp.
             * @implements IActivityTollgateResp
             * @constructor
             * @param {luck.protobuf.IActivityTollgateResp=} [properties] Properties to set
             */
            function ActivityTollgateResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ActivityTollgateResp result.
             * @member {number} result
             * @memberof luck.protobuf.ActivityTollgateResp
             * @instance
             */
            ActivityTollgateResp.prototype.result = 0;

            /**
             * Creates a new ActivityTollgateResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.ActivityTollgateResp
             * @static
             * @param {luck.protobuf.IActivityTollgateResp=} [properties] Properties to set
             * @returns {luck.protobuf.ActivityTollgateResp} ActivityTollgateResp instance
             */
            ActivityTollgateResp.create = function create(properties) {
                return new ActivityTollgateResp(properties);
            };

            /**
             * Encodes the specified ActivityTollgateResp message. Does not implicitly {@link luck.protobuf.ActivityTollgateResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.ActivityTollgateResp
             * @static
             * @param {luck.protobuf.IActivityTollgateResp} message ActivityTollgateResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ActivityTollgateResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                return writer;
            };

            /**
             * Encodes the specified ActivityTollgateResp message, length delimited. Does not implicitly {@link luck.protobuf.ActivityTollgateResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.ActivityTollgateResp
             * @static
             * @param {luck.protobuf.IActivityTollgateResp} message ActivityTollgateResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ActivityTollgateResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ActivityTollgateResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.ActivityTollgateResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.ActivityTollgateResp} ActivityTollgateResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ActivityTollgateResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.ActivityTollgateResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes an ActivityTollgateResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.ActivityTollgateResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.ActivityTollgateResp} ActivityTollgateResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ActivityTollgateResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ActivityTollgateResp message.
             * @function verify
             * @memberof luck.protobuf.ActivityTollgateResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ActivityTollgateResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                return null;
            };

            return ActivityTollgateResp;
        })();

        protobuf.SellGoodsResp = (function() {

            /**
             * Properties of a SellGoodsResp.
             * @memberof luck.protobuf
             * @interface ISellGoodsResp
             * @property {number} result SellGoodsResp result
             * @property {number|Long|null} [gainGold] SellGoodsResp gainGold
             * @property {Array.<luck.protobuf.IMaterialsPB>|null} [materialsList] SellGoodsResp materialsList
             */

            /**
             * Constructs a new SellGoodsResp.
             * @memberof luck.protobuf
             * @classdesc Represents a SellGoodsResp.
             * @implements ISellGoodsResp
             * @constructor
             * @param {luck.protobuf.ISellGoodsResp=} [properties] Properties to set
             */
            function SellGoodsResp(properties) {
                this.materialsList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SellGoodsResp result.
             * @member {number} result
             * @memberof luck.protobuf.SellGoodsResp
             * @instance
             */
            SellGoodsResp.prototype.result = 0;

            /**
             * SellGoodsResp gainGold.
             * @member {number|Long} gainGold
             * @memberof luck.protobuf.SellGoodsResp
             * @instance
             */
            SellGoodsResp.prototype.gainGold = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * SellGoodsResp materialsList.
             * @member {Array.<luck.protobuf.IMaterialsPB>} materialsList
             * @memberof luck.protobuf.SellGoodsResp
             * @instance
             */
            SellGoodsResp.prototype.materialsList = $util.emptyArray;

            /**
             * Creates a new SellGoodsResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.SellGoodsResp
             * @static
             * @param {luck.protobuf.ISellGoodsResp=} [properties] Properties to set
             * @returns {luck.protobuf.SellGoodsResp} SellGoodsResp instance
             */
            SellGoodsResp.create = function create(properties) {
                return new SellGoodsResp(properties);
            };

            /**
             * Encodes the specified SellGoodsResp message. Does not implicitly {@link luck.protobuf.SellGoodsResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.SellGoodsResp
             * @static
             * @param {luck.protobuf.ISellGoodsResp} message SellGoodsResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SellGoodsResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.gainGold != null && message.hasOwnProperty("gainGold"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.gainGold);
                if (message.materialsList != null && message.materialsList.length)
                    for (var i = 0; i < message.materialsList.length; ++i)
                        $root.luck.protobuf.MaterialsPB.encode(message.materialsList[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SellGoodsResp message, length delimited. Does not implicitly {@link luck.protobuf.SellGoodsResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.SellGoodsResp
             * @static
             * @param {luck.protobuf.ISellGoodsResp} message SellGoodsResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SellGoodsResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SellGoodsResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.SellGoodsResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.SellGoodsResp} SellGoodsResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SellGoodsResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.SellGoodsResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.gainGold = reader.int64();
                        break;
                    case 3:
                        if (!(message.materialsList && message.materialsList.length))
                            message.materialsList = [];
                        message.materialsList.push($root.luck.protobuf.MaterialsPB.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a SellGoodsResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.SellGoodsResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.SellGoodsResp} SellGoodsResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SellGoodsResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SellGoodsResp message.
             * @function verify
             * @memberof luck.protobuf.SellGoodsResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SellGoodsResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.gainGold != null && message.hasOwnProperty("gainGold"))
                    if (!$util.isInteger(message.gainGold) && !(message.gainGold && $util.isInteger(message.gainGold.low) && $util.isInteger(message.gainGold.high)))
                        return "gainGold: integer|Long expected";
                if (message.materialsList != null && message.hasOwnProperty("materialsList")) {
                    if (!Array.isArray(message.materialsList))
                        return "materialsList: array expected";
                    for (var i = 0; i < message.materialsList.length; ++i) {
                        var error = $root.luck.protobuf.MaterialsPB.verify(message.materialsList[i]);
                        if (error)
                            return "materialsList." + error;
                    }
                }
                return null;
            };

            return SellGoodsResp;
        })();

        protobuf.CompleteActivityTollgateResp = (function() {

            /**
             * Properties of a CompleteActivityTollgateResp.
             * @memberof luck.protobuf
             * @interface ICompleteActivityTollgateResp
             * @property {number} result CompleteActivityTollgateResp result
             * @property {Array.<luck.protobuf.IpveBallteFinishReward>|null} [rewardList] CompleteActivityTollgateResp rewardList
             * @property {number|null} [gainExp] CompleteActivityTollgateResp gainExp
             * @property {number|null} [lv] CompleteActivityTollgateResp lv
             */

            /**
             * Constructs a new CompleteActivityTollgateResp.
             * @memberof luck.protobuf
             * @classdesc Represents a CompleteActivityTollgateResp.
             * @implements ICompleteActivityTollgateResp
             * @constructor
             * @param {luck.protobuf.ICompleteActivityTollgateResp=} [properties] Properties to set
             */
            function CompleteActivityTollgateResp(properties) {
                this.rewardList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CompleteActivityTollgateResp result.
             * @member {number} result
             * @memberof luck.protobuf.CompleteActivityTollgateResp
             * @instance
             */
            CompleteActivityTollgateResp.prototype.result = 0;

            /**
             * CompleteActivityTollgateResp rewardList.
             * @member {Array.<luck.protobuf.IpveBallteFinishReward>} rewardList
             * @memberof luck.protobuf.CompleteActivityTollgateResp
             * @instance
             */
            CompleteActivityTollgateResp.prototype.rewardList = $util.emptyArray;

            /**
             * CompleteActivityTollgateResp gainExp.
             * @member {number} gainExp
             * @memberof luck.protobuf.CompleteActivityTollgateResp
             * @instance
             */
            CompleteActivityTollgateResp.prototype.gainExp = 0;

            /**
             * CompleteActivityTollgateResp lv.
             * @member {number} lv
             * @memberof luck.protobuf.CompleteActivityTollgateResp
             * @instance
             */
            CompleteActivityTollgateResp.prototype.lv = 0;

            /**
             * Creates a new CompleteActivityTollgateResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.CompleteActivityTollgateResp
             * @static
             * @param {luck.protobuf.ICompleteActivityTollgateResp=} [properties] Properties to set
             * @returns {luck.protobuf.CompleteActivityTollgateResp} CompleteActivityTollgateResp instance
             */
            CompleteActivityTollgateResp.create = function create(properties) {
                return new CompleteActivityTollgateResp(properties);
            };

            /**
             * Encodes the specified CompleteActivityTollgateResp message. Does not implicitly {@link luck.protobuf.CompleteActivityTollgateResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.CompleteActivityTollgateResp
             * @static
             * @param {luck.protobuf.ICompleteActivityTollgateResp} message CompleteActivityTollgateResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CompleteActivityTollgateResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.rewardList != null && message.rewardList.length)
                    for (var i = 0; i < message.rewardList.length; ++i)
                        $root.luck.protobuf.pveBallteFinishReward.encode(message.rewardList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.gainExp != null && message.hasOwnProperty("gainExp"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.gainExp);
                if (message.lv != null && message.hasOwnProperty("lv"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.lv);
                return writer;
            };

            /**
             * Encodes the specified CompleteActivityTollgateResp message, length delimited. Does not implicitly {@link luck.protobuf.CompleteActivityTollgateResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.CompleteActivityTollgateResp
             * @static
             * @param {luck.protobuf.ICompleteActivityTollgateResp} message CompleteActivityTollgateResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CompleteActivityTollgateResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CompleteActivityTollgateResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.CompleteActivityTollgateResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.CompleteActivityTollgateResp} CompleteActivityTollgateResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CompleteActivityTollgateResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.CompleteActivityTollgateResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        if (!(message.rewardList && message.rewardList.length))
                            message.rewardList = [];
                        message.rewardList.push($root.luck.protobuf.pveBallteFinishReward.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.gainExp = reader.int32();
                        break;
                    case 4:
                        message.lv = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a CompleteActivityTollgateResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.CompleteActivityTollgateResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.CompleteActivityTollgateResp} CompleteActivityTollgateResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CompleteActivityTollgateResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CompleteActivityTollgateResp message.
             * @function verify
             * @memberof luck.protobuf.CompleteActivityTollgateResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CompleteActivityTollgateResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.rewardList != null && message.hasOwnProperty("rewardList")) {
                    if (!Array.isArray(message.rewardList))
                        return "rewardList: array expected";
                    for (var i = 0; i < message.rewardList.length; ++i) {
                        var error = $root.luck.protobuf.pveBallteFinishReward.verify(message.rewardList[i]);
                        if (error)
                            return "rewardList." + error;
                    }
                }
                if (message.gainExp != null && message.hasOwnProperty("gainExp"))
                    if (!$util.isInteger(message.gainExp))
                        return "gainExp: integer expected";
                if (message.lv != null && message.hasOwnProperty("lv"))
                    if (!$util.isInteger(message.lv))
                        return "lv: integer expected";
                return null;
            };

            return CompleteActivityTollgateResp;
        })();

        protobuf.DrawLoveBentoResp = (function() {

            /**
             * Properties of a DrawLoveBentoResp.
             * @memberof luck.protobuf
             * @interface IDrawLoveBentoResp
             * @property {number} result DrawLoveBentoResp result
             */

            /**
             * Constructs a new DrawLoveBentoResp.
             * @memberof luck.protobuf
             * @classdesc Represents a DrawLoveBentoResp.
             * @implements IDrawLoveBentoResp
             * @constructor
             * @param {luck.protobuf.IDrawLoveBentoResp=} [properties] Properties to set
             */
            function DrawLoveBentoResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DrawLoveBentoResp result.
             * @member {number} result
             * @memberof luck.protobuf.DrawLoveBentoResp
             * @instance
             */
            DrawLoveBentoResp.prototype.result = 0;

            /**
             * Creates a new DrawLoveBentoResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.DrawLoveBentoResp
             * @static
             * @param {luck.protobuf.IDrawLoveBentoResp=} [properties] Properties to set
             * @returns {luck.protobuf.DrawLoveBentoResp} DrawLoveBentoResp instance
             */
            DrawLoveBentoResp.create = function create(properties) {
                return new DrawLoveBentoResp(properties);
            };

            /**
             * Encodes the specified DrawLoveBentoResp message. Does not implicitly {@link luck.protobuf.DrawLoveBentoResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.DrawLoveBentoResp
             * @static
             * @param {luck.protobuf.IDrawLoveBentoResp} message DrawLoveBentoResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DrawLoveBentoResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                return writer;
            };

            /**
             * Encodes the specified DrawLoveBentoResp message, length delimited. Does not implicitly {@link luck.protobuf.DrawLoveBentoResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.DrawLoveBentoResp
             * @static
             * @param {luck.protobuf.IDrawLoveBentoResp} message DrawLoveBentoResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DrawLoveBentoResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DrawLoveBentoResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.DrawLoveBentoResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.DrawLoveBentoResp} DrawLoveBentoResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DrawLoveBentoResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.DrawLoveBentoResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a DrawLoveBentoResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.DrawLoveBentoResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.DrawLoveBentoResp} DrawLoveBentoResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DrawLoveBentoResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DrawLoveBentoResp message.
             * @function verify
             * @memberof luck.protobuf.DrawLoveBentoResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DrawLoveBentoResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                return null;
            };

            return DrawLoveBentoResp;
        })();

        protobuf.PropConsumeResp = (function() {

            /**
             * Properties of a PropConsumeResp.
             * @memberof luck.protobuf
             * @interface IPropConsumeResp
             * @property {number} result PropConsumeResp result
             * @property {number|Long|null} [gainGold] PropConsumeResp gainGold
             * @property {number|Long|null} [gainDiamond] PropConsumeResp gainDiamond
             * @property {number|Long|null} [gainBody] PropConsumeResp gainBody
             * @property {luck.protobuf.IItemBagPB|null} [itemBag] PropConsumeResp itemBag
             * @property {Array.<luck.protobuf.IWeaponPB>|null} [weaponList] PropConsumeResp weaponList
             * @property {Array.<luck.protobuf.ICardPB>|null} [cardList] PropConsumeResp cardList
             * @property {Array.<luck.protobuf.IClothesPB>|null} [clothesList] PropConsumeResp clothesList
             * @property {Array.<luck.protobuf.IPropPB>|null} [propList] PropConsumeResp propList
             * @property {Array.<luck.protobuf.IMaterialsPB>|null} [materialsList] PropConsumeResp materialsList
             */

            /**
             * Constructs a new PropConsumeResp.
             * @memberof luck.protobuf
             * @classdesc Represents a PropConsumeResp.
             * @implements IPropConsumeResp
             * @constructor
             * @param {luck.protobuf.IPropConsumeResp=} [properties] Properties to set
             */
            function PropConsumeResp(properties) {
                this.weaponList = [];
                this.cardList = [];
                this.clothesList = [];
                this.propList = [];
                this.materialsList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PropConsumeResp result.
             * @member {number} result
             * @memberof luck.protobuf.PropConsumeResp
             * @instance
             */
            PropConsumeResp.prototype.result = 0;

            /**
             * PropConsumeResp gainGold.
             * @member {number|Long} gainGold
             * @memberof luck.protobuf.PropConsumeResp
             * @instance
             */
            PropConsumeResp.prototype.gainGold = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PropConsumeResp gainDiamond.
             * @member {number|Long} gainDiamond
             * @memberof luck.protobuf.PropConsumeResp
             * @instance
             */
            PropConsumeResp.prototype.gainDiamond = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PropConsumeResp gainBody.
             * @member {number|Long} gainBody
             * @memberof luck.protobuf.PropConsumeResp
             * @instance
             */
            PropConsumeResp.prototype.gainBody = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PropConsumeResp itemBag.
             * @member {luck.protobuf.IItemBagPB|null|undefined} itemBag
             * @memberof luck.protobuf.PropConsumeResp
             * @instance
             */
            PropConsumeResp.prototype.itemBag = null;

            /**
             * PropConsumeResp weaponList.
             * @member {Array.<luck.protobuf.IWeaponPB>} weaponList
             * @memberof luck.protobuf.PropConsumeResp
             * @instance
             */
            PropConsumeResp.prototype.weaponList = $util.emptyArray;

            /**
             * PropConsumeResp cardList.
             * @member {Array.<luck.protobuf.ICardPB>} cardList
             * @memberof luck.protobuf.PropConsumeResp
             * @instance
             */
            PropConsumeResp.prototype.cardList = $util.emptyArray;

            /**
             * PropConsumeResp clothesList.
             * @member {Array.<luck.protobuf.IClothesPB>} clothesList
             * @memberof luck.protobuf.PropConsumeResp
             * @instance
             */
            PropConsumeResp.prototype.clothesList = $util.emptyArray;

            /**
             * PropConsumeResp propList.
             * @member {Array.<luck.protobuf.IPropPB>} propList
             * @memberof luck.protobuf.PropConsumeResp
             * @instance
             */
            PropConsumeResp.prototype.propList = $util.emptyArray;

            /**
             * PropConsumeResp materialsList.
             * @member {Array.<luck.protobuf.IMaterialsPB>} materialsList
             * @memberof luck.protobuf.PropConsumeResp
             * @instance
             */
            PropConsumeResp.prototype.materialsList = $util.emptyArray;

            /**
             * Creates a new PropConsumeResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.PropConsumeResp
             * @static
             * @param {luck.protobuf.IPropConsumeResp=} [properties] Properties to set
             * @returns {luck.protobuf.PropConsumeResp} PropConsumeResp instance
             */
            PropConsumeResp.create = function create(properties) {
                return new PropConsumeResp(properties);
            };

            /**
             * Encodes the specified PropConsumeResp message. Does not implicitly {@link luck.protobuf.PropConsumeResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.PropConsumeResp
             * @static
             * @param {luck.protobuf.IPropConsumeResp} message PropConsumeResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PropConsumeResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.gainGold != null && message.hasOwnProperty("gainGold"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.gainGold);
                if (message.gainDiamond != null && message.hasOwnProperty("gainDiamond"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.gainDiamond);
                if (message.gainBody != null && message.hasOwnProperty("gainBody"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.gainBody);
                if (message.itemBag != null && message.hasOwnProperty("itemBag"))
                    $root.luck.protobuf.ItemBagPB.encode(message.itemBag, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.weaponList != null && message.weaponList.length)
                    for (var i = 0; i < message.weaponList.length; ++i)
                        $root.luck.protobuf.WeaponPB.encode(message.weaponList[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.cardList != null && message.cardList.length)
                    for (var i = 0; i < message.cardList.length; ++i)
                        $root.luck.protobuf.CardPB.encode(message.cardList[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.clothesList != null && message.clothesList.length)
                    for (var i = 0; i < message.clothesList.length; ++i)
                        $root.luck.protobuf.ClothesPB.encode(message.clothesList[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.propList != null && message.propList.length)
                    for (var i = 0; i < message.propList.length; ++i)
                        $root.luck.protobuf.PropPB.encode(message.propList[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.materialsList != null && message.materialsList.length)
                    for (var i = 0; i < message.materialsList.length; ++i)
                        $root.luck.protobuf.MaterialsPB.encode(message.materialsList[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified PropConsumeResp message, length delimited. Does not implicitly {@link luck.protobuf.PropConsumeResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.PropConsumeResp
             * @static
             * @param {luck.protobuf.IPropConsumeResp} message PropConsumeResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PropConsumeResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PropConsumeResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.PropConsumeResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.PropConsumeResp} PropConsumeResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PropConsumeResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.PropConsumeResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.gainGold = reader.int64();
                        break;
                    case 3:
                        message.gainDiamond = reader.int64();
                        break;
                    case 4:
                        message.gainBody = reader.int64();
                        break;
                    case 5:
                        message.itemBag = $root.luck.protobuf.ItemBagPB.decode(reader, reader.uint32());
                        break;
                    case 6:
                        if (!(message.weaponList && message.weaponList.length))
                            message.weaponList = [];
                        message.weaponList.push($root.luck.protobuf.WeaponPB.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        if (!(message.cardList && message.cardList.length))
                            message.cardList = [];
                        message.cardList.push($root.luck.protobuf.CardPB.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        if (!(message.clothesList && message.clothesList.length))
                            message.clothesList = [];
                        message.clothesList.push($root.luck.protobuf.ClothesPB.decode(reader, reader.uint32()));
                        break;
                    case 9:
                        if (!(message.propList && message.propList.length))
                            message.propList = [];
                        message.propList.push($root.luck.protobuf.PropPB.decode(reader, reader.uint32()));
                        break;
                    case 10:
                        if (!(message.materialsList && message.materialsList.length))
                            message.materialsList = [];
                        message.materialsList.push($root.luck.protobuf.MaterialsPB.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a PropConsumeResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.PropConsumeResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.PropConsumeResp} PropConsumeResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PropConsumeResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PropConsumeResp message.
             * @function verify
             * @memberof luck.protobuf.PropConsumeResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PropConsumeResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.gainGold != null && message.hasOwnProperty("gainGold"))
                    if (!$util.isInteger(message.gainGold) && !(message.gainGold && $util.isInteger(message.gainGold.low) && $util.isInteger(message.gainGold.high)))
                        return "gainGold: integer|Long expected";
                if (message.gainDiamond != null && message.hasOwnProperty("gainDiamond"))
                    if (!$util.isInteger(message.gainDiamond) && !(message.gainDiamond && $util.isInteger(message.gainDiamond.low) && $util.isInteger(message.gainDiamond.high)))
                        return "gainDiamond: integer|Long expected";
                if (message.gainBody != null && message.hasOwnProperty("gainBody"))
                    if (!$util.isInteger(message.gainBody) && !(message.gainBody && $util.isInteger(message.gainBody.low) && $util.isInteger(message.gainBody.high)))
                        return "gainBody: integer|Long expected";
                if (message.itemBag != null && message.hasOwnProperty("itemBag")) {
                    var error = $root.luck.protobuf.ItemBagPB.verify(message.itemBag);
                    if (error)
                        return "itemBag." + error;
                }
                if (message.weaponList != null && message.hasOwnProperty("weaponList")) {
                    if (!Array.isArray(message.weaponList))
                        return "weaponList: array expected";
                    for (var i = 0; i < message.weaponList.length; ++i) {
                        var error = $root.luck.protobuf.WeaponPB.verify(message.weaponList[i]);
                        if (error)
                            return "weaponList." + error;
                    }
                }
                if (message.cardList != null && message.hasOwnProperty("cardList")) {
                    if (!Array.isArray(message.cardList))
                        return "cardList: array expected";
                    for (var i = 0; i < message.cardList.length; ++i) {
                        var error = $root.luck.protobuf.CardPB.verify(message.cardList[i]);
                        if (error)
                            return "cardList." + error;
                    }
                }
                if (message.clothesList != null && message.hasOwnProperty("clothesList")) {
                    if (!Array.isArray(message.clothesList))
                        return "clothesList: array expected";
                    for (var i = 0; i < message.clothesList.length; ++i) {
                        var error = $root.luck.protobuf.ClothesPB.verify(message.clothesList[i]);
                        if (error)
                            return "clothesList." + error;
                    }
                }
                if (message.propList != null && message.hasOwnProperty("propList")) {
                    if (!Array.isArray(message.propList))
                        return "propList: array expected";
                    for (var i = 0; i < message.propList.length; ++i) {
                        var error = $root.luck.protobuf.PropPB.verify(message.propList[i]);
                        if (error)
                            return "propList." + error;
                    }
                }
                if (message.materialsList != null && message.hasOwnProperty("materialsList")) {
                    if (!Array.isArray(message.materialsList))
                        return "materialsList: array expected";
                    for (var i = 0; i < message.materialsList.length; ++i) {
                        var error = $root.luck.protobuf.MaterialsPB.verify(message.materialsList[i]);
                        if (error)
                            return "materialsList." + error;
                    }
                }
                return null;
            };

            return PropConsumeResp;
        })();

        protobuf.PullGangInfoResp = (function() {

            /**
             * Properties of a PullGangInfoResp.
             * @memberof luck.protobuf
             * @interface IPullGangInfoResp
             * @property {number} result PullGangInfoResp result
             * @property {luck.protobuf.IGangPB|null} [gang] PullGangInfoResp gang
             */

            /**
             * Constructs a new PullGangInfoResp.
             * @memberof luck.protobuf
             * @classdesc Represents a PullGangInfoResp.
             * @implements IPullGangInfoResp
             * @constructor
             * @param {luck.protobuf.IPullGangInfoResp=} [properties] Properties to set
             */
            function PullGangInfoResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PullGangInfoResp result.
             * @member {number} result
             * @memberof luck.protobuf.PullGangInfoResp
             * @instance
             */
            PullGangInfoResp.prototype.result = 0;

            /**
             * PullGangInfoResp gang.
             * @member {luck.protobuf.IGangPB|null|undefined} gang
             * @memberof luck.protobuf.PullGangInfoResp
             * @instance
             */
            PullGangInfoResp.prototype.gang = null;

            /**
             * Creates a new PullGangInfoResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.PullGangInfoResp
             * @static
             * @param {luck.protobuf.IPullGangInfoResp=} [properties] Properties to set
             * @returns {luck.protobuf.PullGangInfoResp} PullGangInfoResp instance
             */
            PullGangInfoResp.create = function create(properties) {
                return new PullGangInfoResp(properties);
            };

            /**
             * Encodes the specified PullGangInfoResp message. Does not implicitly {@link luck.protobuf.PullGangInfoResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.PullGangInfoResp
             * @static
             * @param {luck.protobuf.IPullGangInfoResp} message PullGangInfoResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PullGangInfoResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.gang != null && message.hasOwnProperty("gang"))
                    $root.luck.protobuf.GangPB.encode(message.gang, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified PullGangInfoResp message, length delimited. Does not implicitly {@link luck.protobuf.PullGangInfoResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.PullGangInfoResp
             * @static
             * @param {luck.protobuf.IPullGangInfoResp} message PullGangInfoResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PullGangInfoResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PullGangInfoResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.PullGangInfoResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.PullGangInfoResp} PullGangInfoResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PullGangInfoResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.PullGangInfoResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.gang = $root.luck.protobuf.GangPB.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a PullGangInfoResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.PullGangInfoResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.PullGangInfoResp} PullGangInfoResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PullGangInfoResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PullGangInfoResp message.
             * @function verify
             * @memberof luck.protobuf.PullGangInfoResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PullGangInfoResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.gang != null && message.hasOwnProperty("gang")) {
                    var error = $root.luck.protobuf.GangPB.verify(message.gang);
                    if (error)
                        return "gang." + error;
                }
                return null;
            };

            return PullGangInfoResp;
        })();

        protobuf.ChangeGangJobResp = (function() {

            /**
             * Properties of a ChangeGangJobResp.
             * @memberof luck.protobuf
             * @interface IChangeGangJobResp
             * @property {number} result ChangeGangJobResp result
             * @property {luck.protobuf.IGangPB|null} [gang] ChangeGangJobResp gang
             */

            /**
             * Constructs a new ChangeGangJobResp.
             * @memberof luck.protobuf
             * @classdesc Represents a ChangeGangJobResp.
             * @implements IChangeGangJobResp
             * @constructor
             * @param {luck.protobuf.IChangeGangJobResp=} [properties] Properties to set
             */
            function ChangeGangJobResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ChangeGangJobResp result.
             * @member {number} result
             * @memberof luck.protobuf.ChangeGangJobResp
             * @instance
             */
            ChangeGangJobResp.prototype.result = 0;

            /**
             * ChangeGangJobResp gang.
             * @member {luck.protobuf.IGangPB|null|undefined} gang
             * @memberof luck.protobuf.ChangeGangJobResp
             * @instance
             */
            ChangeGangJobResp.prototype.gang = null;

            /**
             * Creates a new ChangeGangJobResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.ChangeGangJobResp
             * @static
             * @param {luck.protobuf.IChangeGangJobResp=} [properties] Properties to set
             * @returns {luck.protobuf.ChangeGangJobResp} ChangeGangJobResp instance
             */
            ChangeGangJobResp.create = function create(properties) {
                return new ChangeGangJobResp(properties);
            };

            /**
             * Encodes the specified ChangeGangJobResp message. Does not implicitly {@link luck.protobuf.ChangeGangJobResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.ChangeGangJobResp
             * @static
             * @param {luck.protobuf.IChangeGangJobResp} message ChangeGangJobResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChangeGangJobResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.gang != null && message.hasOwnProperty("gang"))
                    $root.luck.protobuf.GangPB.encode(message.gang, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ChangeGangJobResp message, length delimited. Does not implicitly {@link luck.protobuf.ChangeGangJobResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.ChangeGangJobResp
             * @static
             * @param {luck.protobuf.IChangeGangJobResp} message ChangeGangJobResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChangeGangJobResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ChangeGangJobResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.ChangeGangJobResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.ChangeGangJobResp} ChangeGangJobResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChangeGangJobResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.ChangeGangJobResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.gang = $root.luck.protobuf.GangPB.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a ChangeGangJobResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.ChangeGangJobResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.ChangeGangJobResp} ChangeGangJobResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChangeGangJobResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ChangeGangJobResp message.
             * @function verify
             * @memberof luck.protobuf.ChangeGangJobResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChangeGangJobResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.gang != null && message.hasOwnProperty("gang")) {
                    var error = $root.luck.protobuf.GangPB.verify(message.gang);
                    if (error)
                        return "gang." + error;
                }
                return null;
            };

            return ChangeGangJobResp;
        })();

        protobuf.QuitGangResp = (function() {

            /**
             * Properties of a QuitGangResp.
             * @memberof luck.protobuf
             * @interface IQuitGangResp
             * @property {number} result QuitGangResp result
             * @property {luck.protobuf.IPlayerBasePB|null} [playerBase] QuitGangResp playerBase
             * @property {boolean|null} [isGangExist] QuitGangResp isGangExist
             */

            /**
             * Constructs a new QuitGangResp.
             * @memberof luck.protobuf
             * @classdesc Represents a QuitGangResp.
             * @implements IQuitGangResp
             * @constructor
             * @param {luck.protobuf.IQuitGangResp=} [properties] Properties to set
             */
            function QuitGangResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QuitGangResp result.
             * @member {number} result
             * @memberof luck.protobuf.QuitGangResp
             * @instance
             */
            QuitGangResp.prototype.result = 0;

            /**
             * QuitGangResp playerBase.
             * @member {luck.protobuf.IPlayerBasePB|null|undefined} playerBase
             * @memberof luck.protobuf.QuitGangResp
             * @instance
             */
            QuitGangResp.prototype.playerBase = null;

            /**
             * QuitGangResp isGangExist.
             * @member {boolean} isGangExist
             * @memberof luck.protobuf.QuitGangResp
             * @instance
             */
            QuitGangResp.prototype.isGangExist = false;

            /**
             * Creates a new QuitGangResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.QuitGangResp
             * @static
             * @param {luck.protobuf.IQuitGangResp=} [properties] Properties to set
             * @returns {luck.protobuf.QuitGangResp} QuitGangResp instance
             */
            QuitGangResp.create = function create(properties) {
                return new QuitGangResp(properties);
            };

            /**
             * Encodes the specified QuitGangResp message. Does not implicitly {@link luck.protobuf.QuitGangResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.QuitGangResp
             * @static
             * @param {luck.protobuf.IQuitGangResp} message QuitGangResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QuitGangResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.playerBase != null && message.hasOwnProperty("playerBase"))
                    $root.luck.protobuf.PlayerBasePB.encode(message.playerBase, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.isGangExist != null && message.hasOwnProperty("isGangExist"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isGangExist);
                return writer;
            };

            /**
             * Encodes the specified QuitGangResp message, length delimited. Does not implicitly {@link luck.protobuf.QuitGangResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.QuitGangResp
             * @static
             * @param {luck.protobuf.IQuitGangResp} message QuitGangResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QuitGangResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QuitGangResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.QuitGangResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.QuitGangResp} QuitGangResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QuitGangResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.QuitGangResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.playerBase = $root.luck.protobuf.PlayerBasePB.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.isGangExist = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a QuitGangResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.QuitGangResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.QuitGangResp} QuitGangResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QuitGangResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QuitGangResp message.
             * @function verify
             * @memberof luck.protobuf.QuitGangResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QuitGangResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.playerBase != null && message.hasOwnProperty("playerBase")) {
                    var error = $root.luck.protobuf.PlayerBasePB.verify(message.playerBase);
                    if (error)
                        return "playerBase." + error;
                }
                if (message.isGangExist != null && message.hasOwnProperty("isGangExist"))
                    if (typeof message.isGangExist !== "boolean")
                        return "isGangExist: boolean expected";
                return null;
            };

            return QuitGangResp;
        })();

        protobuf.KickOutGangResp = (function() {

            /**
             * Properties of a KickOutGangResp.
             * @memberof luck.protobuf
             * @interface IKickOutGangResp
             * @property {number} result KickOutGangResp result
             * @property {luck.protobuf.IGangPB|null} [gang] KickOutGangResp gang
             */

            /**
             * Constructs a new KickOutGangResp.
             * @memberof luck.protobuf
             * @classdesc Represents a KickOutGangResp.
             * @implements IKickOutGangResp
             * @constructor
             * @param {luck.protobuf.IKickOutGangResp=} [properties] Properties to set
             */
            function KickOutGangResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KickOutGangResp result.
             * @member {number} result
             * @memberof luck.protobuf.KickOutGangResp
             * @instance
             */
            KickOutGangResp.prototype.result = 0;

            /**
             * KickOutGangResp gang.
             * @member {luck.protobuf.IGangPB|null|undefined} gang
             * @memberof luck.protobuf.KickOutGangResp
             * @instance
             */
            KickOutGangResp.prototype.gang = null;

            /**
             * Creates a new KickOutGangResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.KickOutGangResp
             * @static
             * @param {luck.protobuf.IKickOutGangResp=} [properties] Properties to set
             * @returns {luck.protobuf.KickOutGangResp} KickOutGangResp instance
             */
            KickOutGangResp.create = function create(properties) {
                return new KickOutGangResp(properties);
            };

            /**
             * Encodes the specified KickOutGangResp message. Does not implicitly {@link luck.protobuf.KickOutGangResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.KickOutGangResp
             * @static
             * @param {luck.protobuf.IKickOutGangResp} message KickOutGangResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KickOutGangResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.gang != null && message.hasOwnProperty("gang"))
                    $root.luck.protobuf.GangPB.encode(message.gang, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified KickOutGangResp message, length delimited. Does not implicitly {@link luck.protobuf.KickOutGangResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.KickOutGangResp
             * @static
             * @param {luck.protobuf.IKickOutGangResp} message KickOutGangResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KickOutGangResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KickOutGangResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.KickOutGangResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.KickOutGangResp} KickOutGangResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KickOutGangResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.KickOutGangResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.gang = $root.luck.protobuf.GangPB.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a KickOutGangResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.KickOutGangResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.KickOutGangResp} KickOutGangResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KickOutGangResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KickOutGangResp message.
             * @function verify
             * @memberof luck.protobuf.KickOutGangResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KickOutGangResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.gang != null && message.hasOwnProperty("gang")) {
                    var error = $root.luck.protobuf.GangPB.verify(message.gang);
                    if (error)
                        return "gang." + error;
                }
                return null;
            };

            return KickOutGangResp;
        })();

        protobuf.ApproveJoinGangResp = (function() {

            /**
             * Properties of an ApproveJoinGangResp.
             * @memberof luck.protobuf
             * @interface IApproveJoinGangResp
             * @property {number} result ApproveJoinGangResp result
             * @property {luck.protobuf.IGangPB|null} [gang] ApproveJoinGangResp gang
             */

            /**
             * Constructs a new ApproveJoinGangResp.
             * @memberof luck.protobuf
             * @classdesc Represents an ApproveJoinGangResp.
             * @implements IApproveJoinGangResp
             * @constructor
             * @param {luck.protobuf.IApproveJoinGangResp=} [properties] Properties to set
             */
            function ApproveJoinGangResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ApproveJoinGangResp result.
             * @member {number} result
             * @memberof luck.protobuf.ApproveJoinGangResp
             * @instance
             */
            ApproveJoinGangResp.prototype.result = 0;

            /**
             * ApproveJoinGangResp gang.
             * @member {luck.protobuf.IGangPB|null|undefined} gang
             * @memberof luck.protobuf.ApproveJoinGangResp
             * @instance
             */
            ApproveJoinGangResp.prototype.gang = null;

            /**
             * Creates a new ApproveJoinGangResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.ApproveJoinGangResp
             * @static
             * @param {luck.protobuf.IApproveJoinGangResp=} [properties] Properties to set
             * @returns {luck.protobuf.ApproveJoinGangResp} ApproveJoinGangResp instance
             */
            ApproveJoinGangResp.create = function create(properties) {
                return new ApproveJoinGangResp(properties);
            };

            /**
             * Encodes the specified ApproveJoinGangResp message. Does not implicitly {@link luck.protobuf.ApproveJoinGangResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.ApproveJoinGangResp
             * @static
             * @param {luck.protobuf.IApproveJoinGangResp} message ApproveJoinGangResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ApproveJoinGangResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.gang != null && message.hasOwnProperty("gang"))
                    $root.luck.protobuf.GangPB.encode(message.gang, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ApproveJoinGangResp message, length delimited. Does not implicitly {@link luck.protobuf.ApproveJoinGangResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.ApproveJoinGangResp
             * @static
             * @param {luck.protobuf.IApproveJoinGangResp} message ApproveJoinGangResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ApproveJoinGangResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ApproveJoinGangResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.ApproveJoinGangResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.ApproveJoinGangResp} ApproveJoinGangResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ApproveJoinGangResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.ApproveJoinGangResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.gang = $root.luck.protobuf.GangPB.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes an ApproveJoinGangResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.ApproveJoinGangResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.ApproveJoinGangResp} ApproveJoinGangResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ApproveJoinGangResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ApproveJoinGangResp message.
             * @function verify
             * @memberof luck.protobuf.ApproveJoinGangResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ApproveJoinGangResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.gang != null && message.hasOwnProperty("gang")) {
                    var error = $root.luck.protobuf.GangPB.verify(message.gang);
                    if (error)
                        return "gang." + error;
                }
                return null;
            };

            return ApproveJoinGangResp;
        })();

        protobuf.ApplyJoinGangResp = (function() {

            /**
             * Properties of an ApplyJoinGangResp.
             * @memberof luck.protobuf
             * @interface IApplyJoinGangResp
             * @property {number} result ApplyJoinGangResp result
             */

            /**
             * Constructs a new ApplyJoinGangResp.
             * @memberof luck.protobuf
             * @classdesc Represents an ApplyJoinGangResp.
             * @implements IApplyJoinGangResp
             * @constructor
             * @param {luck.protobuf.IApplyJoinGangResp=} [properties] Properties to set
             */
            function ApplyJoinGangResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ApplyJoinGangResp result.
             * @member {number} result
             * @memberof luck.protobuf.ApplyJoinGangResp
             * @instance
             */
            ApplyJoinGangResp.prototype.result = 0;

            /**
             * Creates a new ApplyJoinGangResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.ApplyJoinGangResp
             * @static
             * @param {luck.protobuf.IApplyJoinGangResp=} [properties] Properties to set
             * @returns {luck.protobuf.ApplyJoinGangResp} ApplyJoinGangResp instance
             */
            ApplyJoinGangResp.create = function create(properties) {
                return new ApplyJoinGangResp(properties);
            };

            /**
             * Encodes the specified ApplyJoinGangResp message. Does not implicitly {@link luck.protobuf.ApplyJoinGangResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.ApplyJoinGangResp
             * @static
             * @param {luck.protobuf.IApplyJoinGangResp} message ApplyJoinGangResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ApplyJoinGangResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                return writer;
            };

            /**
             * Encodes the specified ApplyJoinGangResp message, length delimited. Does not implicitly {@link luck.protobuf.ApplyJoinGangResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.ApplyJoinGangResp
             * @static
             * @param {luck.protobuf.IApplyJoinGangResp} message ApplyJoinGangResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ApplyJoinGangResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ApplyJoinGangResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.ApplyJoinGangResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.ApplyJoinGangResp} ApplyJoinGangResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ApplyJoinGangResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.ApplyJoinGangResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes an ApplyJoinGangResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.ApplyJoinGangResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.ApplyJoinGangResp} ApplyJoinGangResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ApplyJoinGangResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ApplyJoinGangResp message.
             * @function verify
             * @memberof luck.protobuf.ApplyJoinGangResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ApplyJoinGangResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                return null;
            };

            return ApplyJoinGangResp;
        })();

        protobuf.CreateGangResp = (function() {

            /**
             * Properties of a CreateGangResp.
             * @memberof luck.protobuf
             * @interface ICreateGangResp
             * @property {number} result CreateGangResp result
             * @property {luck.protobuf.IGangPB|null} [gang] CreateGangResp gang
             * @property {luck.protobuf.IPlayerBasePB|null} [playerBase] CreateGangResp playerBase
             */

            /**
             * Constructs a new CreateGangResp.
             * @memberof luck.protobuf
             * @classdesc Represents a CreateGangResp.
             * @implements ICreateGangResp
             * @constructor
             * @param {luck.protobuf.ICreateGangResp=} [properties] Properties to set
             */
            function CreateGangResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CreateGangResp result.
             * @member {number} result
             * @memberof luck.protobuf.CreateGangResp
             * @instance
             */
            CreateGangResp.prototype.result = 0;

            /**
             * CreateGangResp gang.
             * @member {luck.protobuf.IGangPB|null|undefined} gang
             * @memberof luck.protobuf.CreateGangResp
             * @instance
             */
            CreateGangResp.prototype.gang = null;

            /**
             * CreateGangResp playerBase.
             * @member {luck.protobuf.IPlayerBasePB|null|undefined} playerBase
             * @memberof luck.protobuf.CreateGangResp
             * @instance
             */
            CreateGangResp.prototype.playerBase = null;

            /**
             * Creates a new CreateGangResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.CreateGangResp
             * @static
             * @param {luck.protobuf.ICreateGangResp=} [properties] Properties to set
             * @returns {luck.protobuf.CreateGangResp} CreateGangResp instance
             */
            CreateGangResp.create = function create(properties) {
                return new CreateGangResp(properties);
            };

            /**
             * Encodes the specified CreateGangResp message. Does not implicitly {@link luck.protobuf.CreateGangResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.CreateGangResp
             * @static
             * @param {luck.protobuf.ICreateGangResp} message CreateGangResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateGangResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.gang != null && message.hasOwnProperty("gang"))
                    $root.luck.protobuf.GangPB.encode(message.gang, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.playerBase != null && message.hasOwnProperty("playerBase"))
                    $root.luck.protobuf.PlayerBasePB.encode(message.playerBase, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CreateGangResp message, length delimited. Does not implicitly {@link luck.protobuf.CreateGangResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.CreateGangResp
             * @static
             * @param {luck.protobuf.ICreateGangResp} message CreateGangResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateGangResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CreateGangResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.CreateGangResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.CreateGangResp} CreateGangResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateGangResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.CreateGangResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.gang = $root.luck.protobuf.GangPB.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.playerBase = $root.luck.protobuf.PlayerBasePB.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a CreateGangResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.CreateGangResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.CreateGangResp} CreateGangResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateGangResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CreateGangResp message.
             * @function verify
             * @memberof luck.protobuf.CreateGangResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateGangResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.gang != null && message.hasOwnProperty("gang")) {
                    var error = $root.luck.protobuf.GangPB.verify(message.gang);
                    if (error)
                        return "gang." + error;
                }
                if (message.playerBase != null && message.hasOwnProperty("playerBase")) {
                    var error = $root.luck.protobuf.PlayerBasePB.verify(message.playerBase);
                    if (error)
                        return "playerBase." + error;
                }
                return null;
            };

            return CreateGangResp;
        })();

        protobuf.PullAllGangInfoResp = (function() {

            /**
             * Properties of a PullAllGangInfoResp.
             * @memberof luck.protobuf
             * @interface IPullAllGangInfoResp
             * @property {number} result PullAllGangInfoResp result
             * @property {Array.<luck.protobuf.IGangPB>|null} [gangList] PullAllGangInfoResp gangList
             */

            /**
             * Constructs a new PullAllGangInfoResp.
             * @memberof luck.protobuf
             * @classdesc Represents a PullAllGangInfoResp.
             * @implements IPullAllGangInfoResp
             * @constructor
             * @param {luck.protobuf.IPullAllGangInfoResp=} [properties] Properties to set
             */
            function PullAllGangInfoResp(properties) {
                this.gangList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PullAllGangInfoResp result.
             * @member {number} result
             * @memberof luck.protobuf.PullAllGangInfoResp
             * @instance
             */
            PullAllGangInfoResp.prototype.result = 0;

            /**
             * PullAllGangInfoResp gangList.
             * @member {Array.<luck.protobuf.IGangPB>} gangList
             * @memberof luck.protobuf.PullAllGangInfoResp
             * @instance
             */
            PullAllGangInfoResp.prototype.gangList = $util.emptyArray;

            /**
             * Creates a new PullAllGangInfoResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.PullAllGangInfoResp
             * @static
             * @param {luck.protobuf.IPullAllGangInfoResp=} [properties] Properties to set
             * @returns {luck.protobuf.PullAllGangInfoResp} PullAllGangInfoResp instance
             */
            PullAllGangInfoResp.create = function create(properties) {
                return new PullAllGangInfoResp(properties);
            };

            /**
             * Encodes the specified PullAllGangInfoResp message. Does not implicitly {@link luck.protobuf.PullAllGangInfoResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.PullAllGangInfoResp
             * @static
             * @param {luck.protobuf.IPullAllGangInfoResp} message PullAllGangInfoResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PullAllGangInfoResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.gangList != null && message.gangList.length)
                    for (var i = 0; i < message.gangList.length; ++i)
                        $root.luck.protobuf.GangPB.encode(message.gangList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified PullAllGangInfoResp message, length delimited. Does not implicitly {@link luck.protobuf.PullAllGangInfoResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.PullAllGangInfoResp
             * @static
             * @param {luck.protobuf.IPullAllGangInfoResp} message PullAllGangInfoResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PullAllGangInfoResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PullAllGangInfoResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.PullAllGangInfoResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.PullAllGangInfoResp} PullAllGangInfoResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PullAllGangInfoResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.PullAllGangInfoResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        if (!(message.gangList && message.gangList.length))
                            message.gangList = [];
                        message.gangList.push($root.luck.protobuf.GangPB.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a PullAllGangInfoResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.PullAllGangInfoResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.PullAllGangInfoResp} PullAllGangInfoResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PullAllGangInfoResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PullAllGangInfoResp message.
             * @function verify
             * @memberof luck.protobuf.PullAllGangInfoResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PullAllGangInfoResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.gangList != null && message.hasOwnProperty("gangList")) {
                    if (!Array.isArray(message.gangList))
                        return "gangList: array expected";
                    for (var i = 0; i < message.gangList.length; ++i) {
                        var error = $root.luck.protobuf.GangPB.verify(message.gangList[i]);
                        if (error)
                            return "gangList." + error;
                    }
                }
                return null;
            };

            return PullAllGangInfoResp;
        })();

        protobuf.SearchGangResp = (function() {

            /**
             * Properties of a SearchGangResp.
             * @memberof luck.protobuf
             * @interface ISearchGangResp
             * @property {number} result SearchGangResp result
             * @property {Array.<luck.protobuf.IGangPB>|null} [gangList] SearchGangResp gangList
             */

            /**
             * Constructs a new SearchGangResp.
             * @memberof luck.protobuf
             * @classdesc Represents a SearchGangResp.
             * @implements ISearchGangResp
             * @constructor
             * @param {luck.protobuf.ISearchGangResp=} [properties] Properties to set
             */
            function SearchGangResp(properties) {
                this.gangList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SearchGangResp result.
             * @member {number} result
             * @memberof luck.protobuf.SearchGangResp
             * @instance
             */
            SearchGangResp.prototype.result = 0;

            /**
             * SearchGangResp gangList.
             * @member {Array.<luck.protobuf.IGangPB>} gangList
             * @memberof luck.protobuf.SearchGangResp
             * @instance
             */
            SearchGangResp.prototype.gangList = $util.emptyArray;

            /**
             * Creates a new SearchGangResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.SearchGangResp
             * @static
             * @param {luck.protobuf.ISearchGangResp=} [properties] Properties to set
             * @returns {luck.protobuf.SearchGangResp} SearchGangResp instance
             */
            SearchGangResp.create = function create(properties) {
                return new SearchGangResp(properties);
            };

            /**
             * Encodes the specified SearchGangResp message. Does not implicitly {@link luck.protobuf.SearchGangResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.SearchGangResp
             * @static
             * @param {luck.protobuf.ISearchGangResp} message SearchGangResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SearchGangResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.gangList != null && message.gangList.length)
                    for (var i = 0; i < message.gangList.length; ++i)
                        $root.luck.protobuf.GangPB.encode(message.gangList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SearchGangResp message, length delimited. Does not implicitly {@link luck.protobuf.SearchGangResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.SearchGangResp
             * @static
             * @param {luck.protobuf.ISearchGangResp} message SearchGangResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SearchGangResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SearchGangResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.SearchGangResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.SearchGangResp} SearchGangResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SearchGangResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.SearchGangResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        if (!(message.gangList && message.gangList.length))
                            message.gangList = [];
                        message.gangList.push($root.luck.protobuf.GangPB.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a SearchGangResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.SearchGangResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.SearchGangResp} SearchGangResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SearchGangResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SearchGangResp message.
             * @function verify
             * @memberof luck.protobuf.SearchGangResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SearchGangResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.gangList != null && message.hasOwnProperty("gangList")) {
                    if (!Array.isArray(message.gangList))
                        return "gangList: array expected";
                    for (var i = 0; i < message.gangList.length; ++i) {
                        var error = $root.luck.protobuf.GangPB.verify(message.gangList[i]);
                        if (error)
                            return "gangList." + error;
                    }
                }
                return null;
            };

            return SearchGangResp;
        })();

        protobuf.BattleResurgenceResp = (function() {

            /**
             * Properties of a BattleResurgenceResp.
             * @memberof luck.protobuf
             * @interface IBattleResurgenceResp
             * @property {number} result BattleResurgenceResp result
             */

            /**
             * Constructs a new BattleResurgenceResp.
             * @memberof luck.protobuf
             * @classdesc Represents a BattleResurgenceResp.
             * @implements IBattleResurgenceResp
             * @constructor
             * @param {luck.protobuf.IBattleResurgenceResp=} [properties] Properties to set
             */
            function BattleResurgenceResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BattleResurgenceResp result.
             * @member {number} result
             * @memberof luck.protobuf.BattleResurgenceResp
             * @instance
             */
            BattleResurgenceResp.prototype.result = 0;

            /**
             * Creates a new BattleResurgenceResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.BattleResurgenceResp
             * @static
             * @param {luck.protobuf.IBattleResurgenceResp=} [properties] Properties to set
             * @returns {luck.protobuf.BattleResurgenceResp} BattleResurgenceResp instance
             */
            BattleResurgenceResp.create = function create(properties) {
                return new BattleResurgenceResp(properties);
            };

            /**
             * Encodes the specified BattleResurgenceResp message. Does not implicitly {@link luck.protobuf.BattleResurgenceResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.BattleResurgenceResp
             * @static
             * @param {luck.protobuf.IBattleResurgenceResp} message BattleResurgenceResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BattleResurgenceResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                return writer;
            };

            /**
             * Encodes the specified BattleResurgenceResp message, length delimited. Does not implicitly {@link luck.protobuf.BattleResurgenceResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.BattleResurgenceResp
             * @static
             * @param {luck.protobuf.IBattleResurgenceResp} message BattleResurgenceResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BattleResurgenceResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BattleResurgenceResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.BattleResurgenceResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.BattleResurgenceResp} BattleResurgenceResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BattleResurgenceResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.BattleResurgenceResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a BattleResurgenceResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.BattleResurgenceResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.BattleResurgenceResp} BattleResurgenceResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BattleResurgenceResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BattleResurgenceResp message.
             * @function verify
             * @memberof luck.protobuf.BattleResurgenceResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BattleResurgenceResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                return null;
            };

            return BattleResurgenceResp;
        })();

        protobuf.ReconnectionResp = (function() {

            /**
             * Properties of a ReconnectionResp.
             * @memberof luck.protobuf
             * @interface IReconnectionResp
             * @property {number} result ReconnectionResp result
             * @property {luck.protobuf.IPlayerPB|null} [playerPB] ReconnectionResp playerPB
             */

            /**
             * Constructs a new ReconnectionResp.
             * @memberof luck.protobuf
             * @classdesc Represents a ReconnectionResp.
             * @implements IReconnectionResp
             * @constructor
             * @param {luck.protobuf.IReconnectionResp=} [properties] Properties to set
             */
            function ReconnectionResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReconnectionResp result.
             * @member {number} result
             * @memberof luck.protobuf.ReconnectionResp
             * @instance
             */
            ReconnectionResp.prototype.result = 0;

            /**
             * ReconnectionResp playerPB.
             * @member {luck.protobuf.IPlayerPB|null|undefined} playerPB
             * @memberof luck.protobuf.ReconnectionResp
             * @instance
             */
            ReconnectionResp.prototype.playerPB = null;

            /**
             * Creates a new ReconnectionResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.ReconnectionResp
             * @static
             * @param {luck.protobuf.IReconnectionResp=} [properties] Properties to set
             * @returns {luck.protobuf.ReconnectionResp} ReconnectionResp instance
             */
            ReconnectionResp.create = function create(properties) {
                return new ReconnectionResp(properties);
            };

            /**
             * Encodes the specified ReconnectionResp message. Does not implicitly {@link luck.protobuf.ReconnectionResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.ReconnectionResp
             * @static
             * @param {luck.protobuf.IReconnectionResp} message ReconnectionResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReconnectionResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.playerPB != null && message.hasOwnProperty("playerPB"))
                    $root.luck.protobuf.PlayerPB.encode(message.playerPB, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReconnectionResp message, length delimited. Does not implicitly {@link luck.protobuf.ReconnectionResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.ReconnectionResp
             * @static
             * @param {luck.protobuf.IReconnectionResp} message ReconnectionResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReconnectionResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReconnectionResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.ReconnectionResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.ReconnectionResp} ReconnectionResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReconnectionResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.ReconnectionResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.playerPB = $root.luck.protobuf.PlayerPB.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a ReconnectionResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.ReconnectionResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.ReconnectionResp} ReconnectionResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReconnectionResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReconnectionResp message.
             * @function verify
             * @memberof luck.protobuf.ReconnectionResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReconnectionResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.playerPB != null && message.hasOwnProperty("playerPB")) {
                    var error = $root.luck.protobuf.PlayerPB.verify(message.playerPB);
                    if (error)
                        return "playerPB." + error;
                }
                return null;
            };

            return ReconnectionResp;
        })();

        protobuf.JiGuangRegisterResp = (function() {

            /**
             * Properties of a JiGuangRegisterResp.
             * @memberof luck.protobuf
             * @interface IJiGuangRegisterResp
             * @property {number} result JiGuangRegisterResp result
             */

            /**
             * Constructs a new JiGuangRegisterResp.
             * @memberof luck.protobuf
             * @classdesc Represents a JiGuangRegisterResp.
             * @implements IJiGuangRegisterResp
             * @constructor
             * @param {luck.protobuf.IJiGuangRegisterResp=} [properties] Properties to set
             */
            function JiGuangRegisterResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * JiGuangRegisterResp result.
             * @member {number} result
             * @memberof luck.protobuf.JiGuangRegisterResp
             * @instance
             */
            JiGuangRegisterResp.prototype.result = 0;

            /**
             * Creates a new JiGuangRegisterResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.JiGuangRegisterResp
             * @static
             * @param {luck.protobuf.IJiGuangRegisterResp=} [properties] Properties to set
             * @returns {luck.protobuf.JiGuangRegisterResp} JiGuangRegisterResp instance
             */
            JiGuangRegisterResp.create = function create(properties) {
                return new JiGuangRegisterResp(properties);
            };

            /**
             * Encodes the specified JiGuangRegisterResp message. Does not implicitly {@link luck.protobuf.JiGuangRegisterResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.JiGuangRegisterResp
             * @static
             * @param {luck.protobuf.IJiGuangRegisterResp} message JiGuangRegisterResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            JiGuangRegisterResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                return writer;
            };

            /**
             * Encodes the specified JiGuangRegisterResp message, length delimited. Does not implicitly {@link luck.protobuf.JiGuangRegisterResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.JiGuangRegisterResp
             * @static
             * @param {luck.protobuf.IJiGuangRegisterResp} message JiGuangRegisterResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            JiGuangRegisterResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a JiGuangRegisterResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.JiGuangRegisterResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.JiGuangRegisterResp} JiGuangRegisterResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            JiGuangRegisterResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.JiGuangRegisterResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a JiGuangRegisterResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.JiGuangRegisterResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.JiGuangRegisterResp} JiGuangRegisterResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            JiGuangRegisterResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a JiGuangRegisterResp message.
             * @function verify
             * @memberof luck.protobuf.JiGuangRegisterResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            JiGuangRegisterResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                return null;
            };

            return JiGuangRegisterResp;
        })();

        protobuf.TaskUpdatePushResp = (function() {

            /**
             * Properties of a TaskUpdatePushResp.
             * @memberof luck.protobuf
             * @interface ITaskUpdatePushResp
             * @property {Array.<luck.protobuf.IMainTaskPB>|null} [addMainTaskList] TaskUpdatePushResp addMainTaskList
             * @property {Array.<luck.protobuf.IDailyTaskPB>|null} [addDailyTaskList] TaskUpdatePushResp addDailyTaskList
             * @property {Array.<luck.protobuf.IWeekTaskPB>|null} [addWeekTaskList] TaskUpdatePushResp addWeekTaskList
             * @property {Array.<luck.protobuf.IRewardTaskPB>|null} [addRewardTaskList] TaskUpdatePushResp addRewardTaskList
             * @property {Array.<luck.protobuf.IGangTaskPB>|null} [addGangTaskList] TaskUpdatePushResp addGangTaskList
             * @property {Array.<luck.protobuf.IMainTaskPB>|null} [updateMainTaskList] TaskUpdatePushResp updateMainTaskList
             * @property {Array.<luck.protobuf.IDailyTaskPB>|null} [updateDailyTaskList] TaskUpdatePushResp updateDailyTaskList
             * @property {Array.<luck.protobuf.IWeekTaskPB>|null} [updateWeekTaskList] TaskUpdatePushResp updateWeekTaskList
             * @property {Array.<luck.protobuf.IRewardTaskPB>|null} [updateRewardTaskList] TaskUpdatePushResp updateRewardTaskList
             * @property {Array.<luck.protobuf.IGangTaskPB>|null} [updateGangTaskList] TaskUpdatePushResp updateGangTaskList
             * @property {Array.<number>|null} [delMainTaskList] TaskUpdatePushResp delMainTaskList
             * @property {Array.<number>|null} [delDailyTaskList] TaskUpdatePushResp delDailyTaskList
             * @property {Array.<number>|null} [delWeekTaskList] TaskUpdatePushResp delWeekTaskList
             * @property {Array.<number>|null} [delRewardTaskList] TaskUpdatePushResp delRewardTaskList
             * @property {Array.<number>|null} [delGangTaskList] TaskUpdatePushResp delGangTaskList
             * @property {number|null} [dailyTaskActivity] TaskUpdatePushResp dailyTaskActivity
             * @property {Array.<luck.protobuf.IAchievementTaskPB>|null} [addAchievementTaskList] TaskUpdatePushResp addAchievementTaskList
             * @property {Array.<luck.protobuf.IAchievementTaskPB>|null} [updateAchievementTaskList] TaskUpdatePushResp updateAchievementTaskList
             * @property {Array.<number>|null} [delAchievementTaskList] TaskUpdatePushResp delAchievementTaskList
             * @property {number|Long|null} [achievementPoint] TaskUpdatePushResp achievementPoint
             * @property {Array.<luck.protobuf.IAchievementTypePB>|null} [updateAchievementType1List] TaskUpdatePushResp updateAchievementType1List
             * @property {Array.<luck.protobuf.IAchievementTypePB>|null} [updateAchievementType2List] TaskUpdatePushResp updateAchievementType2List
             * @property {Array.<luck.protobuf.IActivityTaskPB>|null} [addActivityTaskList] TaskUpdatePushResp addActivityTaskList
             * @property {Array.<luck.protobuf.IActivityTaskPB>|null} [updateActivityTaskList] TaskUpdatePushResp updateActivityTaskList
             * @property {Array.<number>|null} [delActivityTaskList] TaskUpdatePushResp delActivityTaskList
             * @property {Array.<luck.protobuf.IactivityTaskRewardPB>|null} [addActivityTaskRewardList] TaskUpdatePushResp addActivityTaskRewardList
             * @property {Array.<luck.protobuf.IactivityTaskRewardPB>|null} [updateActivityTaskRewardList] TaskUpdatePushResp updateActivityTaskRewardList
             * @property {Array.<number>|null} [delActivityTaskRewardList] TaskUpdatePushResp delActivityTaskRewardList
             * @property {Array.<luck.protobuf.ISpecialTaskPB>|null} [addSpecialTaskList] TaskUpdatePushResp addSpecialTaskList
             * @property {Array.<luck.protobuf.ISpecialTaskPB>|null} [updateSpecialTaskList] TaskUpdatePushResp updateSpecialTaskList
             * @property {Array.<number>|null} [delSpecialTaskList] TaskUpdatePushResp delSpecialTaskList
             * @property {number|null} [gangTaskActivity] TaskUpdatePushResp gangTaskActivity
             */

            /**
             * Constructs a new TaskUpdatePushResp.
             * @memberof luck.protobuf
             * @classdesc Represents a TaskUpdatePushResp.
             * @implements ITaskUpdatePushResp
             * @constructor
             * @param {luck.protobuf.ITaskUpdatePushResp=} [properties] Properties to set
             */
            function TaskUpdatePushResp(properties) {
                this.addMainTaskList = [];
                this.addDailyTaskList = [];
                this.addWeekTaskList = [];
                this.addRewardTaskList = [];
                this.addGangTaskList = [];
                this.updateMainTaskList = [];
                this.updateDailyTaskList = [];
                this.updateWeekTaskList = [];
                this.updateRewardTaskList = [];
                this.updateGangTaskList = [];
                this.delMainTaskList = [];
                this.delDailyTaskList = [];
                this.delWeekTaskList = [];
                this.delRewardTaskList = [];
                this.delGangTaskList = [];
                this.addAchievementTaskList = [];
                this.updateAchievementTaskList = [];
                this.delAchievementTaskList = [];
                this.updateAchievementType1List = [];
                this.updateAchievementType2List = [];
                this.addActivityTaskList = [];
                this.updateActivityTaskList = [];
                this.delActivityTaskList = [];
                this.addActivityTaskRewardList = [];
                this.updateActivityTaskRewardList = [];
                this.delActivityTaskRewardList = [];
                this.addSpecialTaskList = [];
                this.updateSpecialTaskList = [];
                this.delSpecialTaskList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TaskUpdatePushResp addMainTaskList.
             * @member {Array.<luck.protobuf.IMainTaskPB>} addMainTaskList
             * @memberof luck.protobuf.TaskUpdatePushResp
             * @instance
             */
            TaskUpdatePushResp.prototype.addMainTaskList = $util.emptyArray;

            /**
             * TaskUpdatePushResp addDailyTaskList.
             * @member {Array.<luck.protobuf.IDailyTaskPB>} addDailyTaskList
             * @memberof luck.protobuf.TaskUpdatePushResp
             * @instance
             */
            TaskUpdatePushResp.prototype.addDailyTaskList = $util.emptyArray;

            /**
             * TaskUpdatePushResp addWeekTaskList.
             * @member {Array.<luck.protobuf.IWeekTaskPB>} addWeekTaskList
             * @memberof luck.protobuf.TaskUpdatePushResp
             * @instance
             */
            TaskUpdatePushResp.prototype.addWeekTaskList = $util.emptyArray;

            /**
             * TaskUpdatePushResp addRewardTaskList.
             * @member {Array.<luck.protobuf.IRewardTaskPB>} addRewardTaskList
             * @memberof luck.protobuf.TaskUpdatePushResp
             * @instance
             */
            TaskUpdatePushResp.prototype.addRewardTaskList = $util.emptyArray;

            /**
             * TaskUpdatePushResp addGangTaskList.
             * @member {Array.<luck.protobuf.IGangTaskPB>} addGangTaskList
             * @memberof luck.protobuf.TaskUpdatePushResp
             * @instance
             */
            TaskUpdatePushResp.prototype.addGangTaskList = $util.emptyArray;

            /**
             * TaskUpdatePushResp updateMainTaskList.
             * @member {Array.<luck.protobuf.IMainTaskPB>} updateMainTaskList
             * @memberof luck.protobuf.TaskUpdatePushResp
             * @instance
             */
            TaskUpdatePushResp.prototype.updateMainTaskList = $util.emptyArray;

            /**
             * TaskUpdatePushResp updateDailyTaskList.
             * @member {Array.<luck.protobuf.IDailyTaskPB>} updateDailyTaskList
             * @memberof luck.protobuf.TaskUpdatePushResp
             * @instance
             */
            TaskUpdatePushResp.prototype.updateDailyTaskList = $util.emptyArray;

            /**
             * TaskUpdatePushResp updateWeekTaskList.
             * @member {Array.<luck.protobuf.IWeekTaskPB>} updateWeekTaskList
             * @memberof luck.protobuf.TaskUpdatePushResp
             * @instance
             */
            TaskUpdatePushResp.prototype.updateWeekTaskList = $util.emptyArray;

            /**
             * TaskUpdatePushResp updateRewardTaskList.
             * @member {Array.<luck.protobuf.IRewardTaskPB>} updateRewardTaskList
             * @memberof luck.protobuf.TaskUpdatePushResp
             * @instance
             */
            TaskUpdatePushResp.prototype.updateRewardTaskList = $util.emptyArray;

            /**
             * TaskUpdatePushResp updateGangTaskList.
             * @member {Array.<luck.protobuf.IGangTaskPB>} updateGangTaskList
             * @memberof luck.protobuf.TaskUpdatePushResp
             * @instance
             */
            TaskUpdatePushResp.prototype.updateGangTaskList = $util.emptyArray;

            /**
             * TaskUpdatePushResp delMainTaskList.
             * @member {Array.<number>} delMainTaskList
             * @memberof luck.protobuf.TaskUpdatePushResp
             * @instance
             */
            TaskUpdatePushResp.prototype.delMainTaskList = $util.emptyArray;

            /**
             * TaskUpdatePushResp delDailyTaskList.
             * @member {Array.<number>} delDailyTaskList
             * @memberof luck.protobuf.TaskUpdatePushResp
             * @instance
             */
            TaskUpdatePushResp.prototype.delDailyTaskList = $util.emptyArray;

            /**
             * TaskUpdatePushResp delWeekTaskList.
             * @member {Array.<number>} delWeekTaskList
             * @memberof luck.protobuf.TaskUpdatePushResp
             * @instance
             */
            TaskUpdatePushResp.prototype.delWeekTaskList = $util.emptyArray;

            /**
             * TaskUpdatePushResp delRewardTaskList.
             * @member {Array.<number>} delRewardTaskList
             * @memberof luck.protobuf.TaskUpdatePushResp
             * @instance
             */
            TaskUpdatePushResp.prototype.delRewardTaskList = $util.emptyArray;

            /**
             * TaskUpdatePushResp delGangTaskList.
             * @member {Array.<number>} delGangTaskList
             * @memberof luck.protobuf.TaskUpdatePushResp
             * @instance
             */
            TaskUpdatePushResp.prototype.delGangTaskList = $util.emptyArray;

            /**
             * TaskUpdatePushResp dailyTaskActivity.
             * @member {number} dailyTaskActivity
             * @memberof luck.protobuf.TaskUpdatePushResp
             * @instance
             */
            TaskUpdatePushResp.prototype.dailyTaskActivity = 0;

            /**
             * TaskUpdatePushResp addAchievementTaskList.
             * @member {Array.<luck.protobuf.IAchievementTaskPB>} addAchievementTaskList
             * @memberof luck.protobuf.TaskUpdatePushResp
             * @instance
             */
            TaskUpdatePushResp.prototype.addAchievementTaskList = $util.emptyArray;

            /**
             * TaskUpdatePushResp updateAchievementTaskList.
             * @member {Array.<luck.protobuf.IAchievementTaskPB>} updateAchievementTaskList
             * @memberof luck.protobuf.TaskUpdatePushResp
             * @instance
             */
            TaskUpdatePushResp.prototype.updateAchievementTaskList = $util.emptyArray;

            /**
             * TaskUpdatePushResp delAchievementTaskList.
             * @member {Array.<number>} delAchievementTaskList
             * @memberof luck.protobuf.TaskUpdatePushResp
             * @instance
             */
            TaskUpdatePushResp.prototype.delAchievementTaskList = $util.emptyArray;

            /**
             * TaskUpdatePushResp achievementPoint.
             * @member {number|Long} achievementPoint
             * @memberof luck.protobuf.TaskUpdatePushResp
             * @instance
             */
            TaskUpdatePushResp.prototype.achievementPoint = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * TaskUpdatePushResp updateAchievementType1List.
             * @member {Array.<luck.protobuf.IAchievementTypePB>} updateAchievementType1List
             * @memberof luck.protobuf.TaskUpdatePushResp
             * @instance
             */
            TaskUpdatePushResp.prototype.updateAchievementType1List = $util.emptyArray;

            /**
             * TaskUpdatePushResp updateAchievementType2List.
             * @member {Array.<luck.protobuf.IAchievementTypePB>} updateAchievementType2List
             * @memberof luck.protobuf.TaskUpdatePushResp
             * @instance
             */
            TaskUpdatePushResp.prototype.updateAchievementType2List = $util.emptyArray;

            /**
             * TaskUpdatePushResp addActivityTaskList.
             * @member {Array.<luck.protobuf.IActivityTaskPB>} addActivityTaskList
             * @memberof luck.protobuf.TaskUpdatePushResp
             * @instance
             */
            TaskUpdatePushResp.prototype.addActivityTaskList = $util.emptyArray;

            /**
             * TaskUpdatePushResp updateActivityTaskList.
             * @member {Array.<luck.protobuf.IActivityTaskPB>} updateActivityTaskList
             * @memberof luck.protobuf.TaskUpdatePushResp
             * @instance
             */
            TaskUpdatePushResp.prototype.updateActivityTaskList = $util.emptyArray;

            /**
             * TaskUpdatePushResp delActivityTaskList.
             * @member {Array.<number>} delActivityTaskList
             * @memberof luck.protobuf.TaskUpdatePushResp
             * @instance
             */
            TaskUpdatePushResp.prototype.delActivityTaskList = $util.emptyArray;

            /**
             * TaskUpdatePushResp addActivityTaskRewardList.
             * @member {Array.<luck.protobuf.IactivityTaskRewardPB>} addActivityTaskRewardList
             * @memberof luck.protobuf.TaskUpdatePushResp
             * @instance
             */
            TaskUpdatePushResp.prototype.addActivityTaskRewardList = $util.emptyArray;

            /**
             * TaskUpdatePushResp updateActivityTaskRewardList.
             * @member {Array.<luck.protobuf.IactivityTaskRewardPB>} updateActivityTaskRewardList
             * @memberof luck.protobuf.TaskUpdatePushResp
             * @instance
             */
            TaskUpdatePushResp.prototype.updateActivityTaskRewardList = $util.emptyArray;

            /**
             * TaskUpdatePushResp delActivityTaskRewardList.
             * @member {Array.<number>} delActivityTaskRewardList
             * @memberof luck.protobuf.TaskUpdatePushResp
             * @instance
             */
            TaskUpdatePushResp.prototype.delActivityTaskRewardList = $util.emptyArray;

            /**
             * TaskUpdatePushResp addSpecialTaskList.
             * @member {Array.<luck.protobuf.ISpecialTaskPB>} addSpecialTaskList
             * @memberof luck.protobuf.TaskUpdatePushResp
             * @instance
             */
            TaskUpdatePushResp.prototype.addSpecialTaskList = $util.emptyArray;

            /**
             * TaskUpdatePushResp updateSpecialTaskList.
             * @member {Array.<luck.protobuf.ISpecialTaskPB>} updateSpecialTaskList
             * @memberof luck.protobuf.TaskUpdatePushResp
             * @instance
             */
            TaskUpdatePushResp.prototype.updateSpecialTaskList = $util.emptyArray;

            /**
             * TaskUpdatePushResp delSpecialTaskList.
             * @member {Array.<number>} delSpecialTaskList
             * @memberof luck.protobuf.TaskUpdatePushResp
             * @instance
             */
            TaskUpdatePushResp.prototype.delSpecialTaskList = $util.emptyArray;

            /**
             * TaskUpdatePushResp gangTaskActivity.
             * @member {number} gangTaskActivity
             * @memberof luck.protobuf.TaskUpdatePushResp
             * @instance
             */
            TaskUpdatePushResp.prototype.gangTaskActivity = 0;

            /**
             * Creates a new TaskUpdatePushResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.TaskUpdatePushResp
             * @static
             * @param {luck.protobuf.ITaskUpdatePushResp=} [properties] Properties to set
             * @returns {luck.protobuf.TaskUpdatePushResp} TaskUpdatePushResp instance
             */
            TaskUpdatePushResp.create = function create(properties) {
                return new TaskUpdatePushResp(properties);
            };

            /**
             * Encodes the specified TaskUpdatePushResp message. Does not implicitly {@link luck.protobuf.TaskUpdatePushResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.TaskUpdatePushResp
             * @static
             * @param {luck.protobuf.ITaskUpdatePushResp} message TaskUpdatePushResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TaskUpdatePushResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.addMainTaskList != null && message.addMainTaskList.length)
                    for (var i = 0; i < message.addMainTaskList.length; ++i)
                        $root.luck.protobuf.MainTaskPB.encode(message.addMainTaskList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.addDailyTaskList != null && message.addDailyTaskList.length)
                    for (var i = 0; i < message.addDailyTaskList.length; ++i)
                        $root.luck.protobuf.DailyTaskPB.encode(message.addDailyTaskList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.addWeekTaskList != null && message.addWeekTaskList.length)
                    for (var i = 0; i < message.addWeekTaskList.length; ++i)
                        $root.luck.protobuf.WeekTaskPB.encode(message.addWeekTaskList[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.addRewardTaskList != null && message.addRewardTaskList.length)
                    for (var i = 0; i < message.addRewardTaskList.length; ++i)
                        $root.luck.protobuf.RewardTaskPB.encode(message.addRewardTaskList[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.addGangTaskList != null && message.addGangTaskList.length)
                    for (var i = 0; i < message.addGangTaskList.length; ++i)
                        $root.luck.protobuf.GangTaskPB.encode(message.addGangTaskList[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.updateMainTaskList != null && message.updateMainTaskList.length)
                    for (var i = 0; i < message.updateMainTaskList.length; ++i)
                        $root.luck.protobuf.MainTaskPB.encode(message.updateMainTaskList[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.updateDailyTaskList != null && message.updateDailyTaskList.length)
                    for (var i = 0; i < message.updateDailyTaskList.length; ++i)
                        $root.luck.protobuf.DailyTaskPB.encode(message.updateDailyTaskList[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.updateWeekTaskList != null && message.updateWeekTaskList.length)
                    for (var i = 0; i < message.updateWeekTaskList.length; ++i)
                        $root.luck.protobuf.WeekTaskPB.encode(message.updateWeekTaskList[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.updateRewardTaskList != null && message.updateRewardTaskList.length)
                    for (var i = 0; i < message.updateRewardTaskList.length; ++i)
                        $root.luck.protobuf.RewardTaskPB.encode(message.updateRewardTaskList[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.updateGangTaskList != null && message.updateGangTaskList.length)
                    for (var i = 0; i < message.updateGangTaskList.length; ++i)
                        $root.luck.protobuf.GangTaskPB.encode(message.updateGangTaskList[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.delMainTaskList != null && message.delMainTaskList.length)
                    for (var i = 0; i < message.delMainTaskList.length; ++i)
                        writer.uint32(/* id 11, wireType 0 =*/88).int32(message.delMainTaskList[i]);
                if (message.delDailyTaskList != null && message.delDailyTaskList.length)
                    for (var i = 0; i < message.delDailyTaskList.length; ++i)
                        writer.uint32(/* id 12, wireType 0 =*/96).int32(message.delDailyTaskList[i]);
                if (message.delWeekTaskList != null && message.delWeekTaskList.length)
                    for (var i = 0; i < message.delWeekTaskList.length; ++i)
                        writer.uint32(/* id 13, wireType 0 =*/104).int32(message.delWeekTaskList[i]);
                if (message.delRewardTaskList != null && message.delRewardTaskList.length)
                    for (var i = 0; i < message.delRewardTaskList.length; ++i)
                        writer.uint32(/* id 14, wireType 0 =*/112).int32(message.delRewardTaskList[i]);
                if (message.delGangTaskList != null && message.delGangTaskList.length)
                    for (var i = 0; i < message.delGangTaskList.length; ++i)
                        writer.uint32(/* id 15, wireType 0 =*/120).int32(message.delGangTaskList[i]);
                if (message.dailyTaskActivity != null && message.hasOwnProperty("dailyTaskActivity"))
                    writer.uint32(/* id 16, wireType 0 =*/128).int32(message.dailyTaskActivity);
                if (message.addAchievementTaskList != null && message.addAchievementTaskList.length)
                    for (var i = 0; i < message.addAchievementTaskList.length; ++i)
                        $root.luck.protobuf.AchievementTaskPB.encode(message.addAchievementTaskList[i], writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                if (message.updateAchievementTaskList != null && message.updateAchievementTaskList.length)
                    for (var i = 0; i < message.updateAchievementTaskList.length; ++i)
                        $root.luck.protobuf.AchievementTaskPB.encode(message.updateAchievementTaskList[i], writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
                if (message.delAchievementTaskList != null && message.delAchievementTaskList.length)
                    for (var i = 0; i < message.delAchievementTaskList.length; ++i)
                        writer.uint32(/* id 19, wireType 0 =*/152).int32(message.delAchievementTaskList[i]);
                if (message.achievementPoint != null && message.hasOwnProperty("achievementPoint"))
                    writer.uint32(/* id 20, wireType 0 =*/160).int64(message.achievementPoint);
                if (message.updateAchievementType1List != null && message.updateAchievementType1List.length)
                    for (var i = 0; i < message.updateAchievementType1List.length; ++i)
                        $root.luck.protobuf.AchievementTypePB.encode(message.updateAchievementType1List[i], writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
                if (message.updateAchievementType2List != null && message.updateAchievementType2List.length)
                    for (var i = 0; i < message.updateAchievementType2List.length; ++i)
                        $root.luck.protobuf.AchievementTypePB.encode(message.updateAchievementType2List[i], writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
                if (message.addActivityTaskList != null && message.addActivityTaskList.length)
                    for (var i = 0; i < message.addActivityTaskList.length; ++i)
                        $root.luck.protobuf.ActivityTaskPB.encode(message.addActivityTaskList[i], writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();
                if (message.updateActivityTaskList != null && message.updateActivityTaskList.length)
                    for (var i = 0; i < message.updateActivityTaskList.length; ++i)
                        $root.luck.protobuf.ActivityTaskPB.encode(message.updateActivityTaskList[i], writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();
                if (message.delActivityTaskList != null && message.delActivityTaskList.length)
                    for (var i = 0; i < message.delActivityTaskList.length; ++i)
                        writer.uint32(/* id 25, wireType 0 =*/200).int32(message.delActivityTaskList[i]);
                if (message.addActivityTaskRewardList != null && message.addActivityTaskRewardList.length)
                    for (var i = 0; i < message.addActivityTaskRewardList.length; ++i)
                        $root.luck.protobuf.activityTaskRewardPB.encode(message.addActivityTaskRewardList[i], writer.uint32(/* id 26, wireType 2 =*/210).fork()).ldelim();
                if (message.updateActivityTaskRewardList != null && message.updateActivityTaskRewardList.length)
                    for (var i = 0; i < message.updateActivityTaskRewardList.length; ++i)
                        $root.luck.protobuf.activityTaskRewardPB.encode(message.updateActivityTaskRewardList[i], writer.uint32(/* id 27, wireType 2 =*/218).fork()).ldelim();
                if (message.delActivityTaskRewardList != null && message.delActivityTaskRewardList.length)
                    for (var i = 0; i < message.delActivityTaskRewardList.length; ++i)
                        writer.uint32(/* id 28, wireType 0 =*/224).int32(message.delActivityTaskRewardList[i]);
                if (message.addSpecialTaskList != null && message.addSpecialTaskList.length)
                    for (var i = 0; i < message.addSpecialTaskList.length; ++i)
                        $root.luck.protobuf.SpecialTaskPB.encode(message.addSpecialTaskList[i], writer.uint32(/* id 29, wireType 2 =*/234).fork()).ldelim();
                if (message.updateSpecialTaskList != null && message.updateSpecialTaskList.length)
                    for (var i = 0; i < message.updateSpecialTaskList.length; ++i)
                        $root.luck.protobuf.SpecialTaskPB.encode(message.updateSpecialTaskList[i], writer.uint32(/* id 30, wireType 2 =*/242).fork()).ldelim();
                if (message.delSpecialTaskList != null && message.delSpecialTaskList.length)
                    for (var i = 0; i < message.delSpecialTaskList.length; ++i)
                        writer.uint32(/* id 31, wireType 0 =*/248).int32(message.delSpecialTaskList[i]);
                if (message.gangTaskActivity != null && message.hasOwnProperty("gangTaskActivity"))
                    writer.uint32(/* id 32, wireType 0 =*/256).int32(message.gangTaskActivity);
                return writer;
            };

            /**
             * Encodes the specified TaskUpdatePushResp message, length delimited. Does not implicitly {@link luck.protobuf.TaskUpdatePushResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.TaskUpdatePushResp
             * @static
             * @param {luck.protobuf.ITaskUpdatePushResp} message TaskUpdatePushResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TaskUpdatePushResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TaskUpdatePushResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.TaskUpdatePushResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.TaskUpdatePushResp} TaskUpdatePushResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TaskUpdatePushResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.TaskUpdatePushResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.addMainTaskList && message.addMainTaskList.length))
                            message.addMainTaskList = [];
                        message.addMainTaskList.push($root.luck.protobuf.MainTaskPB.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        if (!(message.addDailyTaskList && message.addDailyTaskList.length))
                            message.addDailyTaskList = [];
                        message.addDailyTaskList.push($root.luck.protobuf.DailyTaskPB.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.addWeekTaskList && message.addWeekTaskList.length))
                            message.addWeekTaskList = [];
                        message.addWeekTaskList.push($root.luck.protobuf.WeekTaskPB.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        if (!(message.addRewardTaskList && message.addRewardTaskList.length))
                            message.addRewardTaskList = [];
                        message.addRewardTaskList.push($root.luck.protobuf.RewardTaskPB.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.addGangTaskList && message.addGangTaskList.length))
                            message.addGangTaskList = [];
                        message.addGangTaskList.push($root.luck.protobuf.GangTaskPB.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.updateMainTaskList && message.updateMainTaskList.length))
                            message.updateMainTaskList = [];
                        message.updateMainTaskList.push($root.luck.protobuf.MainTaskPB.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        if (!(message.updateDailyTaskList && message.updateDailyTaskList.length))
                            message.updateDailyTaskList = [];
                        message.updateDailyTaskList.push($root.luck.protobuf.DailyTaskPB.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        if (!(message.updateWeekTaskList && message.updateWeekTaskList.length))
                            message.updateWeekTaskList = [];
                        message.updateWeekTaskList.push($root.luck.protobuf.WeekTaskPB.decode(reader, reader.uint32()));
                        break;
                    case 9:
                        if (!(message.updateRewardTaskList && message.updateRewardTaskList.length))
                            message.updateRewardTaskList = [];
                        message.updateRewardTaskList.push($root.luck.protobuf.RewardTaskPB.decode(reader, reader.uint32()));
                        break;
                    case 10:
                        if (!(message.updateGangTaskList && message.updateGangTaskList.length))
                            message.updateGangTaskList = [];
                        message.updateGangTaskList.push($root.luck.protobuf.GangTaskPB.decode(reader, reader.uint32()));
                        break;
                    case 11:
                        if (!(message.delMainTaskList && message.delMainTaskList.length))
                            message.delMainTaskList = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.delMainTaskList.push(reader.int32());
                        } else
                            message.delMainTaskList.push(reader.int32());
                        break;
                    case 12:
                        if (!(message.delDailyTaskList && message.delDailyTaskList.length))
                            message.delDailyTaskList = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.delDailyTaskList.push(reader.int32());
                        } else
                            message.delDailyTaskList.push(reader.int32());
                        break;
                    case 13:
                        if (!(message.delWeekTaskList && message.delWeekTaskList.length))
                            message.delWeekTaskList = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.delWeekTaskList.push(reader.int32());
                        } else
                            message.delWeekTaskList.push(reader.int32());
                        break;
                    case 14:
                        if (!(message.delRewardTaskList && message.delRewardTaskList.length))
                            message.delRewardTaskList = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.delRewardTaskList.push(reader.int32());
                        } else
                            message.delRewardTaskList.push(reader.int32());
                        break;
                    case 15:
                        if (!(message.delGangTaskList && message.delGangTaskList.length))
                            message.delGangTaskList = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.delGangTaskList.push(reader.int32());
                        } else
                            message.delGangTaskList.push(reader.int32());
                        break;
                    case 16:
                        message.dailyTaskActivity = reader.int32();
                        break;
                    case 17:
                        if (!(message.addAchievementTaskList && message.addAchievementTaskList.length))
                            message.addAchievementTaskList = [];
                        message.addAchievementTaskList.push($root.luck.protobuf.AchievementTaskPB.decode(reader, reader.uint32()));
                        break;
                    case 18:
                        if (!(message.updateAchievementTaskList && message.updateAchievementTaskList.length))
                            message.updateAchievementTaskList = [];
                        message.updateAchievementTaskList.push($root.luck.protobuf.AchievementTaskPB.decode(reader, reader.uint32()));
                        break;
                    case 19:
                        if (!(message.delAchievementTaskList && message.delAchievementTaskList.length))
                            message.delAchievementTaskList = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.delAchievementTaskList.push(reader.int32());
                        } else
                            message.delAchievementTaskList.push(reader.int32());
                        break;
                    case 20:
                        message.achievementPoint = reader.int64();
                        break;
                    case 21:
                        if (!(message.updateAchievementType1List && message.updateAchievementType1List.length))
                            message.updateAchievementType1List = [];
                        message.updateAchievementType1List.push($root.luck.protobuf.AchievementTypePB.decode(reader, reader.uint32()));
                        break;
                    case 22:
                        if (!(message.updateAchievementType2List && message.updateAchievementType2List.length))
                            message.updateAchievementType2List = [];
                        message.updateAchievementType2List.push($root.luck.protobuf.AchievementTypePB.decode(reader, reader.uint32()));
                        break;
                    case 23:
                        if (!(message.addActivityTaskList && message.addActivityTaskList.length))
                            message.addActivityTaskList = [];
                        message.addActivityTaskList.push($root.luck.protobuf.ActivityTaskPB.decode(reader, reader.uint32()));
                        break;
                    case 24:
                        if (!(message.updateActivityTaskList && message.updateActivityTaskList.length))
                            message.updateActivityTaskList = [];
                        message.updateActivityTaskList.push($root.luck.protobuf.ActivityTaskPB.decode(reader, reader.uint32()));
                        break;
                    case 25:
                        if (!(message.delActivityTaskList && message.delActivityTaskList.length))
                            message.delActivityTaskList = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.delActivityTaskList.push(reader.int32());
                        } else
                            message.delActivityTaskList.push(reader.int32());
                        break;
                    case 26:
                        if (!(message.addActivityTaskRewardList && message.addActivityTaskRewardList.length))
                            message.addActivityTaskRewardList = [];
                        message.addActivityTaskRewardList.push($root.luck.protobuf.activityTaskRewardPB.decode(reader, reader.uint32()));
                        break;
                    case 27:
                        if (!(message.updateActivityTaskRewardList && message.updateActivityTaskRewardList.length))
                            message.updateActivityTaskRewardList = [];
                        message.updateActivityTaskRewardList.push($root.luck.protobuf.activityTaskRewardPB.decode(reader, reader.uint32()));
                        break;
                    case 28:
                        if (!(message.delActivityTaskRewardList && message.delActivityTaskRewardList.length))
                            message.delActivityTaskRewardList = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.delActivityTaskRewardList.push(reader.int32());
                        } else
                            message.delActivityTaskRewardList.push(reader.int32());
                        break;
                    case 29:
                        if (!(message.addSpecialTaskList && message.addSpecialTaskList.length))
                            message.addSpecialTaskList = [];
                        message.addSpecialTaskList.push($root.luck.protobuf.SpecialTaskPB.decode(reader, reader.uint32()));
                        break;
                    case 30:
                        if (!(message.updateSpecialTaskList && message.updateSpecialTaskList.length))
                            message.updateSpecialTaskList = [];
                        message.updateSpecialTaskList.push($root.luck.protobuf.SpecialTaskPB.decode(reader, reader.uint32()));
                        break;
                    case 31:
                        if (!(message.delSpecialTaskList && message.delSpecialTaskList.length))
                            message.delSpecialTaskList = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.delSpecialTaskList.push(reader.int32());
                        } else
                            message.delSpecialTaskList.push(reader.int32());
                        break;
                    case 32:
                        message.gangTaskActivity = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TaskUpdatePushResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.TaskUpdatePushResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.TaskUpdatePushResp} TaskUpdatePushResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TaskUpdatePushResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TaskUpdatePushResp message.
             * @function verify
             * @memberof luck.protobuf.TaskUpdatePushResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TaskUpdatePushResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.addMainTaskList != null && message.hasOwnProperty("addMainTaskList")) {
                    if (!Array.isArray(message.addMainTaskList))
                        return "addMainTaskList: array expected";
                    for (var i = 0; i < message.addMainTaskList.length; ++i) {
                        var error = $root.luck.protobuf.MainTaskPB.verify(message.addMainTaskList[i]);
                        if (error)
                            return "addMainTaskList." + error;
                    }
                }
                if (message.addDailyTaskList != null && message.hasOwnProperty("addDailyTaskList")) {
                    if (!Array.isArray(message.addDailyTaskList))
                        return "addDailyTaskList: array expected";
                    for (var i = 0; i < message.addDailyTaskList.length; ++i) {
                        var error = $root.luck.protobuf.DailyTaskPB.verify(message.addDailyTaskList[i]);
                        if (error)
                            return "addDailyTaskList." + error;
                    }
                }
                if (message.addWeekTaskList != null && message.hasOwnProperty("addWeekTaskList")) {
                    if (!Array.isArray(message.addWeekTaskList))
                        return "addWeekTaskList: array expected";
                    for (var i = 0; i < message.addWeekTaskList.length; ++i) {
                        var error = $root.luck.protobuf.WeekTaskPB.verify(message.addWeekTaskList[i]);
                        if (error)
                            return "addWeekTaskList." + error;
                    }
                }
                if (message.addRewardTaskList != null && message.hasOwnProperty("addRewardTaskList")) {
                    if (!Array.isArray(message.addRewardTaskList))
                        return "addRewardTaskList: array expected";
                    for (var i = 0; i < message.addRewardTaskList.length; ++i) {
                        var error = $root.luck.protobuf.RewardTaskPB.verify(message.addRewardTaskList[i]);
                        if (error)
                            return "addRewardTaskList." + error;
                    }
                }
                if (message.addGangTaskList != null && message.hasOwnProperty("addGangTaskList")) {
                    if (!Array.isArray(message.addGangTaskList))
                        return "addGangTaskList: array expected";
                    for (var i = 0; i < message.addGangTaskList.length; ++i) {
                        var error = $root.luck.protobuf.GangTaskPB.verify(message.addGangTaskList[i]);
                        if (error)
                            return "addGangTaskList." + error;
                    }
                }
                if (message.updateMainTaskList != null && message.hasOwnProperty("updateMainTaskList")) {
                    if (!Array.isArray(message.updateMainTaskList))
                        return "updateMainTaskList: array expected";
                    for (var i = 0; i < message.updateMainTaskList.length; ++i) {
                        var error = $root.luck.protobuf.MainTaskPB.verify(message.updateMainTaskList[i]);
                        if (error)
                            return "updateMainTaskList." + error;
                    }
                }
                if (message.updateDailyTaskList != null && message.hasOwnProperty("updateDailyTaskList")) {
                    if (!Array.isArray(message.updateDailyTaskList))
                        return "updateDailyTaskList: array expected";
                    for (var i = 0; i < message.updateDailyTaskList.length; ++i) {
                        var error = $root.luck.protobuf.DailyTaskPB.verify(message.updateDailyTaskList[i]);
                        if (error)
                            return "updateDailyTaskList." + error;
                    }
                }
                if (message.updateWeekTaskList != null && message.hasOwnProperty("updateWeekTaskList")) {
                    if (!Array.isArray(message.updateWeekTaskList))
                        return "updateWeekTaskList: array expected";
                    for (var i = 0; i < message.updateWeekTaskList.length; ++i) {
                        var error = $root.luck.protobuf.WeekTaskPB.verify(message.updateWeekTaskList[i]);
                        if (error)
                            return "updateWeekTaskList." + error;
                    }
                }
                if (message.updateRewardTaskList != null && message.hasOwnProperty("updateRewardTaskList")) {
                    if (!Array.isArray(message.updateRewardTaskList))
                        return "updateRewardTaskList: array expected";
                    for (var i = 0; i < message.updateRewardTaskList.length; ++i) {
                        var error = $root.luck.protobuf.RewardTaskPB.verify(message.updateRewardTaskList[i]);
                        if (error)
                            return "updateRewardTaskList." + error;
                    }
                }
                if (message.updateGangTaskList != null && message.hasOwnProperty("updateGangTaskList")) {
                    if (!Array.isArray(message.updateGangTaskList))
                        return "updateGangTaskList: array expected";
                    for (var i = 0; i < message.updateGangTaskList.length; ++i) {
                        var error = $root.luck.protobuf.GangTaskPB.verify(message.updateGangTaskList[i]);
                        if (error)
                            return "updateGangTaskList." + error;
                    }
                }
                if (message.delMainTaskList != null && message.hasOwnProperty("delMainTaskList")) {
                    if (!Array.isArray(message.delMainTaskList))
                        return "delMainTaskList: array expected";
                    for (var i = 0; i < message.delMainTaskList.length; ++i)
                        if (!$util.isInteger(message.delMainTaskList[i]))
                            return "delMainTaskList: integer[] expected";
                }
                if (message.delDailyTaskList != null && message.hasOwnProperty("delDailyTaskList")) {
                    if (!Array.isArray(message.delDailyTaskList))
                        return "delDailyTaskList: array expected";
                    for (var i = 0; i < message.delDailyTaskList.length; ++i)
                        if (!$util.isInteger(message.delDailyTaskList[i]))
                            return "delDailyTaskList: integer[] expected";
                }
                if (message.delWeekTaskList != null && message.hasOwnProperty("delWeekTaskList")) {
                    if (!Array.isArray(message.delWeekTaskList))
                        return "delWeekTaskList: array expected";
                    for (var i = 0; i < message.delWeekTaskList.length; ++i)
                        if (!$util.isInteger(message.delWeekTaskList[i]))
                            return "delWeekTaskList: integer[] expected";
                }
                if (message.delRewardTaskList != null && message.hasOwnProperty("delRewardTaskList")) {
                    if (!Array.isArray(message.delRewardTaskList))
                        return "delRewardTaskList: array expected";
                    for (var i = 0; i < message.delRewardTaskList.length; ++i)
                        if (!$util.isInteger(message.delRewardTaskList[i]))
                            return "delRewardTaskList: integer[] expected";
                }
                if (message.delGangTaskList != null && message.hasOwnProperty("delGangTaskList")) {
                    if (!Array.isArray(message.delGangTaskList))
                        return "delGangTaskList: array expected";
                    for (var i = 0; i < message.delGangTaskList.length; ++i)
                        if (!$util.isInteger(message.delGangTaskList[i]))
                            return "delGangTaskList: integer[] expected";
                }
                if (message.dailyTaskActivity != null && message.hasOwnProperty("dailyTaskActivity"))
                    if (!$util.isInteger(message.dailyTaskActivity))
                        return "dailyTaskActivity: integer expected";
                if (message.addAchievementTaskList != null && message.hasOwnProperty("addAchievementTaskList")) {
                    if (!Array.isArray(message.addAchievementTaskList))
                        return "addAchievementTaskList: array expected";
                    for (var i = 0; i < message.addAchievementTaskList.length; ++i) {
                        var error = $root.luck.protobuf.AchievementTaskPB.verify(message.addAchievementTaskList[i]);
                        if (error)
                            return "addAchievementTaskList." + error;
                    }
                }
                if (message.updateAchievementTaskList != null && message.hasOwnProperty("updateAchievementTaskList")) {
                    if (!Array.isArray(message.updateAchievementTaskList))
                        return "updateAchievementTaskList: array expected";
                    for (var i = 0; i < message.updateAchievementTaskList.length; ++i) {
                        var error = $root.luck.protobuf.AchievementTaskPB.verify(message.updateAchievementTaskList[i]);
                        if (error)
                            return "updateAchievementTaskList." + error;
                    }
                }
                if (message.delAchievementTaskList != null && message.hasOwnProperty("delAchievementTaskList")) {
                    if (!Array.isArray(message.delAchievementTaskList))
                        return "delAchievementTaskList: array expected";
                    for (var i = 0; i < message.delAchievementTaskList.length; ++i)
                        if (!$util.isInteger(message.delAchievementTaskList[i]))
                            return "delAchievementTaskList: integer[] expected";
                }
                if (message.achievementPoint != null && message.hasOwnProperty("achievementPoint"))
                    if (!$util.isInteger(message.achievementPoint) && !(message.achievementPoint && $util.isInteger(message.achievementPoint.low) && $util.isInteger(message.achievementPoint.high)))
                        return "achievementPoint: integer|Long expected";
                if (message.updateAchievementType1List != null && message.hasOwnProperty("updateAchievementType1List")) {
                    if (!Array.isArray(message.updateAchievementType1List))
                        return "updateAchievementType1List: array expected";
                    for (var i = 0; i < message.updateAchievementType1List.length; ++i) {
                        var error = $root.luck.protobuf.AchievementTypePB.verify(message.updateAchievementType1List[i]);
                        if (error)
                            return "updateAchievementType1List." + error;
                    }
                }
                if (message.updateAchievementType2List != null && message.hasOwnProperty("updateAchievementType2List")) {
                    if (!Array.isArray(message.updateAchievementType2List))
                        return "updateAchievementType2List: array expected";
                    for (var i = 0; i < message.updateAchievementType2List.length; ++i) {
                        var error = $root.luck.protobuf.AchievementTypePB.verify(message.updateAchievementType2List[i]);
                        if (error)
                            return "updateAchievementType2List." + error;
                    }
                }
                if (message.addActivityTaskList != null && message.hasOwnProperty("addActivityTaskList")) {
                    if (!Array.isArray(message.addActivityTaskList))
                        return "addActivityTaskList: array expected";
                    for (var i = 0; i < message.addActivityTaskList.length; ++i) {
                        var error = $root.luck.protobuf.ActivityTaskPB.verify(message.addActivityTaskList[i]);
                        if (error)
                            return "addActivityTaskList." + error;
                    }
                }
                if (message.updateActivityTaskList != null && message.hasOwnProperty("updateActivityTaskList")) {
                    if (!Array.isArray(message.updateActivityTaskList))
                        return "updateActivityTaskList: array expected";
                    for (var i = 0; i < message.updateActivityTaskList.length; ++i) {
                        var error = $root.luck.protobuf.ActivityTaskPB.verify(message.updateActivityTaskList[i]);
                        if (error)
                            return "updateActivityTaskList." + error;
                    }
                }
                if (message.delActivityTaskList != null && message.hasOwnProperty("delActivityTaskList")) {
                    if (!Array.isArray(message.delActivityTaskList))
                        return "delActivityTaskList: array expected";
                    for (var i = 0; i < message.delActivityTaskList.length; ++i)
                        if (!$util.isInteger(message.delActivityTaskList[i]))
                            return "delActivityTaskList: integer[] expected";
                }
                if (message.addActivityTaskRewardList != null && message.hasOwnProperty("addActivityTaskRewardList")) {
                    if (!Array.isArray(message.addActivityTaskRewardList))
                        return "addActivityTaskRewardList: array expected";
                    for (var i = 0; i < message.addActivityTaskRewardList.length; ++i) {
                        var error = $root.luck.protobuf.activityTaskRewardPB.verify(message.addActivityTaskRewardList[i]);
                        if (error)
                            return "addActivityTaskRewardList." + error;
                    }
                }
                if (message.updateActivityTaskRewardList != null && message.hasOwnProperty("updateActivityTaskRewardList")) {
                    if (!Array.isArray(message.updateActivityTaskRewardList))
                        return "updateActivityTaskRewardList: array expected";
                    for (var i = 0; i < message.updateActivityTaskRewardList.length; ++i) {
                        var error = $root.luck.protobuf.activityTaskRewardPB.verify(message.updateActivityTaskRewardList[i]);
                        if (error)
                            return "updateActivityTaskRewardList." + error;
                    }
                }
                if (message.delActivityTaskRewardList != null && message.hasOwnProperty("delActivityTaskRewardList")) {
                    if (!Array.isArray(message.delActivityTaskRewardList))
                        return "delActivityTaskRewardList: array expected";
                    for (var i = 0; i < message.delActivityTaskRewardList.length; ++i)
                        if (!$util.isInteger(message.delActivityTaskRewardList[i]))
                            return "delActivityTaskRewardList: integer[] expected";
                }
                if (message.addSpecialTaskList != null && message.hasOwnProperty("addSpecialTaskList")) {
                    if (!Array.isArray(message.addSpecialTaskList))
                        return "addSpecialTaskList: array expected";
                    for (var i = 0; i < message.addSpecialTaskList.length; ++i) {
                        var error = $root.luck.protobuf.SpecialTaskPB.verify(message.addSpecialTaskList[i]);
                        if (error)
                            return "addSpecialTaskList." + error;
                    }
                }
                if (message.updateSpecialTaskList != null && message.hasOwnProperty("updateSpecialTaskList")) {
                    if (!Array.isArray(message.updateSpecialTaskList))
                        return "updateSpecialTaskList: array expected";
                    for (var i = 0; i < message.updateSpecialTaskList.length; ++i) {
                        var error = $root.luck.protobuf.SpecialTaskPB.verify(message.updateSpecialTaskList[i]);
                        if (error)
                            return "updateSpecialTaskList." + error;
                    }
                }
                if (message.delSpecialTaskList != null && message.hasOwnProperty("delSpecialTaskList")) {
                    if (!Array.isArray(message.delSpecialTaskList))
                        return "delSpecialTaskList: array expected";
                    for (var i = 0; i < message.delSpecialTaskList.length; ++i)
                        if (!$util.isInteger(message.delSpecialTaskList[i]))
                            return "delSpecialTaskList: integer[] expected";
                }
                if (message.gangTaskActivity != null && message.hasOwnProperty("gangTaskActivity"))
                    if (!$util.isInteger(message.gangTaskActivity))
                        return "gangTaskActivity: integer expected";
                return null;
            };

            return TaskUpdatePushResp;
        })();

        protobuf.drawTaskResp = (function() {

            /**
             * Properties of a drawTaskResp.
             * @memberof luck.protobuf
             * @interface IdrawTaskResp
             * @property {number} result drawTaskResp result
             * @property {number|Long|null} [gold] drawTaskResp gold
             * @property {number|Long|null} [diamond] drawTaskResp diamond
             * @property {Array.<luck.protobuf.IWeaponPB>|null} [weaponList] drawTaskResp weaponList
             * @property {Array.<luck.protobuf.ICardPB>|null} [cardList] drawTaskResp cardList
             * @property {Array.<luck.protobuf.IClothesPB>|null} [clothesList] drawTaskResp clothesList
             * @property {Array.<luck.protobuf.IPropPB>|null} [propList] drawTaskResp propList
             * @property {Array.<luck.protobuf.IMaterialsPB>|null} [materialsList] drawTaskResp materialsList
             * @property {number|null} [exp] drawTaskResp exp
             * @property {number|null} [DailyActivityReward] drawTaskResp DailyActivityReward
             * @property {number|null} [gangContribute] drawTaskResp gangContribute
             * @property {number|null} [gangExp] drawTaskResp gangExp
             * @property {luck.protobuf.IGangPB|null} [gang] drawTaskResp gang
             * @property {number|null} [gangVitality] drawTaskResp gangVitality
             */

            /**
             * Constructs a new drawTaskResp.
             * @memberof luck.protobuf
             * @classdesc Represents a drawTaskResp.
             * @implements IdrawTaskResp
             * @constructor
             * @param {luck.protobuf.IdrawTaskResp=} [properties] Properties to set
             */
            function drawTaskResp(properties) {
                this.weaponList = [];
                this.cardList = [];
                this.clothesList = [];
                this.propList = [];
                this.materialsList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * drawTaskResp result.
             * @member {number} result
             * @memberof luck.protobuf.drawTaskResp
             * @instance
             */
            drawTaskResp.prototype.result = 0;

            /**
             * drawTaskResp gold.
             * @member {number|Long} gold
             * @memberof luck.protobuf.drawTaskResp
             * @instance
             */
            drawTaskResp.prototype.gold = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * drawTaskResp diamond.
             * @member {number|Long} diamond
             * @memberof luck.protobuf.drawTaskResp
             * @instance
             */
            drawTaskResp.prototype.diamond = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * drawTaskResp weaponList.
             * @member {Array.<luck.protobuf.IWeaponPB>} weaponList
             * @memberof luck.protobuf.drawTaskResp
             * @instance
             */
            drawTaskResp.prototype.weaponList = $util.emptyArray;

            /**
             * drawTaskResp cardList.
             * @member {Array.<luck.protobuf.ICardPB>} cardList
             * @memberof luck.protobuf.drawTaskResp
             * @instance
             */
            drawTaskResp.prototype.cardList = $util.emptyArray;

            /**
             * drawTaskResp clothesList.
             * @member {Array.<luck.protobuf.IClothesPB>} clothesList
             * @memberof luck.protobuf.drawTaskResp
             * @instance
             */
            drawTaskResp.prototype.clothesList = $util.emptyArray;

            /**
             * drawTaskResp propList.
             * @member {Array.<luck.protobuf.IPropPB>} propList
             * @memberof luck.protobuf.drawTaskResp
             * @instance
             */
            drawTaskResp.prototype.propList = $util.emptyArray;

            /**
             * drawTaskResp materialsList.
             * @member {Array.<luck.protobuf.IMaterialsPB>} materialsList
             * @memberof luck.protobuf.drawTaskResp
             * @instance
             */
            drawTaskResp.prototype.materialsList = $util.emptyArray;

            /**
             * drawTaskResp exp.
             * @member {number} exp
             * @memberof luck.protobuf.drawTaskResp
             * @instance
             */
            drawTaskResp.prototype.exp = 0;

            /**
             * drawTaskResp DailyActivityReward.
             * @member {number} DailyActivityReward
             * @memberof luck.protobuf.drawTaskResp
             * @instance
             */
            drawTaskResp.prototype.DailyActivityReward = 0;

            /**
             * drawTaskResp gangContribute.
             * @member {number} gangContribute
             * @memberof luck.protobuf.drawTaskResp
             * @instance
             */
            drawTaskResp.prototype.gangContribute = 0;

            /**
             * drawTaskResp gangExp.
             * @member {number} gangExp
             * @memberof luck.protobuf.drawTaskResp
             * @instance
             */
            drawTaskResp.prototype.gangExp = 0;

            /**
             * drawTaskResp gang.
             * @member {luck.protobuf.IGangPB|null|undefined} gang
             * @memberof luck.protobuf.drawTaskResp
             * @instance
             */
            drawTaskResp.prototype.gang = null;

            /**
             * drawTaskResp gangVitality.
             * @member {number} gangVitality
             * @memberof luck.protobuf.drawTaskResp
             * @instance
             */
            drawTaskResp.prototype.gangVitality = 0;

            /**
             * Creates a new drawTaskResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.drawTaskResp
             * @static
             * @param {luck.protobuf.IdrawTaskResp=} [properties] Properties to set
             * @returns {luck.protobuf.drawTaskResp} drawTaskResp instance
             */
            drawTaskResp.create = function create(properties) {
                return new drawTaskResp(properties);
            };

            /**
             * Encodes the specified drawTaskResp message. Does not implicitly {@link luck.protobuf.drawTaskResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.drawTaskResp
             * @static
             * @param {luck.protobuf.IdrawTaskResp} message drawTaskResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            drawTaskResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.gold != null && message.hasOwnProperty("gold"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.gold);
                if (message.diamond != null && message.hasOwnProperty("diamond"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.diamond);
                if (message.weaponList != null && message.weaponList.length)
                    for (var i = 0; i < message.weaponList.length; ++i)
                        $root.luck.protobuf.WeaponPB.encode(message.weaponList[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.cardList != null && message.cardList.length)
                    for (var i = 0; i < message.cardList.length; ++i)
                        $root.luck.protobuf.CardPB.encode(message.cardList[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.clothesList != null && message.clothesList.length)
                    for (var i = 0; i < message.clothesList.length; ++i)
                        $root.luck.protobuf.ClothesPB.encode(message.clothesList[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.propList != null && message.propList.length)
                    for (var i = 0; i < message.propList.length; ++i)
                        $root.luck.protobuf.PropPB.encode(message.propList[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.materialsList != null && message.materialsList.length)
                    for (var i = 0; i < message.materialsList.length; ++i)
                        $root.luck.protobuf.MaterialsPB.encode(message.materialsList[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.exp != null && message.hasOwnProperty("exp"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.exp);
                if (message.DailyActivityReward != null && message.hasOwnProperty("DailyActivityReward"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int32(message.DailyActivityReward);
                if (message.gangContribute != null && message.hasOwnProperty("gangContribute"))
                    writer.uint32(/* id 11, wireType 0 =*/88).int32(message.gangContribute);
                if (message.gangExp != null && message.hasOwnProperty("gangExp"))
                    writer.uint32(/* id 12, wireType 0 =*/96).int32(message.gangExp);
                if (message.gang != null && message.hasOwnProperty("gang"))
                    $root.luck.protobuf.GangPB.encode(message.gang, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                if (message.gangVitality != null && message.hasOwnProperty("gangVitality"))
                    writer.uint32(/* id 14, wireType 0 =*/112).int32(message.gangVitality);
                return writer;
            };

            /**
             * Encodes the specified drawTaskResp message, length delimited. Does not implicitly {@link luck.protobuf.drawTaskResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.drawTaskResp
             * @static
             * @param {luck.protobuf.IdrawTaskResp} message drawTaskResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            drawTaskResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a drawTaskResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.drawTaskResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.drawTaskResp} drawTaskResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            drawTaskResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.drawTaskResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.gold = reader.int64();
                        break;
                    case 3:
                        message.diamond = reader.int64();
                        break;
                    case 4:
                        if (!(message.weaponList && message.weaponList.length))
                            message.weaponList = [];
                        message.weaponList.push($root.luck.protobuf.WeaponPB.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.cardList && message.cardList.length))
                            message.cardList = [];
                        message.cardList.push($root.luck.protobuf.CardPB.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.clothesList && message.clothesList.length))
                            message.clothesList = [];
                        message.clothesList.push($root.luck.protobuf.ClothesPB.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        if (!(message.propList && message.propList.length))
                            message.propList = [];
                        message.propList.push($root.luck.protobuf.PropPB.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        if (!(message.materialsList && message.materialsList.length))
                            message.materialsList = [];
                        message.materialsList.push($root.luck.protobuf.MaterialsPB.decode(reader, reader.uint32()));
                        break;
                    case 9:
                        message.exp = reader.int32();
                        break;
                    case 10:
                        message.DailyActivityReward = reader.int32();
                        break;
                    case 11:
                        message.gangContribute = reader.int32();
                        break;
                    case 12:
                        message.gangExp = reader.int32();
                        break;
                    case 13:
                        message.gang = $root.luck.protobuf.GangPB.decode(reader, reader.uint32());
                        break;
                    case 14:
                        message.gangVitality = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a drawTaskResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.drawTaskResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.drawTaskResp} drawTaskResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            drawTaskResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a drawTaskResp message.
             * @function verify
             * @memberof luck.protobuf.drawTaskResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            drawTaskResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.gold != null && message.hasOwnProperty("gold"))
                    if (!$util.isInteger(message.gold) && !(message.gold && $util.isInteger(message.gold.low) && $util.isInteger(message.gold.high)))
                        return "gold: integer|Long expected";
                if (message.diamond != null && message.hasOwnProperty("diamond"))
                    if (!$util.isInteger(message.diamond) && !(message.diamond && $util.isInteger(message.diamond.low) && $util.isInteger(message.diamond.high)))
                        return "diamond: integer|Long expected";
                if (message.weaponList != null && message.hasOwnProperty("weaponList")) {
                    if (!Array.isArray(message.weaponList))
                        return "weaponList: array expected";
                    for (var i = 0; i < message.weaponList.length; ++i) {
                        var error = $root.luck.protobuf.WeaponPB.verify(message.weaponList[i]);
                        if (error)
                            return "weaponList." + error;
                    }
                }
                if (message.cardList != null && message.hasOwnProperty("cardList")) {
                    if (!Array.isArray(message.cardList))
                        return "cardList: array expected";
                    for (var i = 0; i < message.cardList.length; ++i) {
                        var error = $root.luck.protobuf.CardPB.verify(message.cardList[i]);
                        if (error)
                            return "cardList." + error;
                    }
                }
                if (message.clothesList != null && message.hasOwnProperty("clothesList")) {
                    if (!Array.isArray(message.clothesList))
                        return "clothesList: array expected";
                    for (var i = 0; i < message.clothesList.length; ++i) {
                        var error = $root.luck.protobuf.ClothesPB.verify(message.clothesList[i]);
                        if (error)
                            return "clothesList." + error;
                    }
                }
                if (message.propList != null && message.hasOwnProperty("propList")) {
                    if (!Array.isArray(message.propList))
                        return "propList: array expected";
                    for (var i = 0; i < message.propList.length; ++i) {
                        var error = $root.luck.protobuf.PropPB.verify(message.propList[i]);
                        if (error)
                            return "propList." + error;
                    }
                }
                if (message.materialsList != null && message.hasOwnProperty("materialsList")) {
                    if (!Array.isArray(message.materialsList))
                        return "materialsList: array expected";
                    for (var i = 0; i < message.materialsList.length; ++i) {
                        var error = $root.luck.protobuf.MaterialsPB.verify(message.materialsList[i]);
                        if (error)
                            return "materialsList." + error;
                    }
                }
                if (message.exp != null && message.hasOwnProperty("exp"))
                    if (!$util.isInteger(message.exp))
                        return "exp: integer expected";
                if (message.DailyActivityReward != null && message.hasOwnProperty("DailyActivityReward"))
                    if (!$util.isInteger(message.DailyActivityReward))
                        return "DailyActivityReward: integer expected";
                if (message.gangContribute != null && message.hasOwnProperty("gangContribute"))
                    if (!$util.isInteger(message.gangContribute))
                        return "gangContribute: integer expected";
                if (message.gangExp != null && message.hasOwnProperty("gangExp"))
                    if (!$util.isInteger(message.gangExp))
                        return "gangExp: integer expected";
                if (message.gang != null && message.hasOwnProperty("gang")) {
                    var error = $root.luck.protobuf.GangPB.verify(message.gang);
                    if (error)
                        return "gang." + error;
                }
                if (message.gangVitality != null && message.hasOwnProperty("gangVitality"))
                    if (!$util.isInteger(message.gangVitality))
                        return "gangVitality: integer expected";
                return null;
            };

            return drawTaskResp;
        })();

        protobuf.drawDailyVitalityRewardResp = (function() {

            /**
             * Properties of a drawDailyVitalityRewardResp.
             * @memberof luck.protobuf
             * @interface IdrawDailyVitalityRewardResp
             * @property {number} result drawDailyVitalityRewardResp result
             * @property {number|Long|null} [gold] drawDailyVitalityRewardResp gold
             * @property {number|Long|null} [diamond] drawDailyVitalityRewardResp diamond
             * @property {Array.<luck.protobuf.IWeaponPB>|null} [weaponList] drawDailyVitalityRewardResp weaponList
             * @property {Array.<luck.protobuf.ICardPB>|null} [cardList] drawDailyVitalityRewardResp cardList
             * @property {Array.<luck.protobuf.IClothesPB>|null} [clothesList] drawDailyVitalityRewardResp clothesList
             * @property {Array.<luck.protobuf.IPropPB>|null} [propList] drawDailyVitalityRewardResp propList
             * @property {Array.<luck.protobuf.IMaterialsPB>|null} [materialsList] drawDailyVitalityRewardResp materialsList
             * @property {Array.<number>|null} [dailyVitalityRewardList] drawDailyVitalityRewardResp dailyVitalityRewardList
             */

            /**
             * Constructs a new drawDailyVitalityRewardResp.
             * @memberof luck.protobuf
             * @classdesc Represents a drawDailyVitalityRewardResp.
             * @implements IdrawDailyVitalityRewardResp
             * @constructor
             * @param {luck.protobuf.IdrawDailyVitalityRewardResp=} [properties] Properties to set
             */
            function drawDailyVitalityRewardResp(properties) {
                this.weaponList = [];
                this.cardList = [];
                this.clothesList = [];
                this.propList = [];
                this.materialsList = [];
                this.dailyVitalityRewardList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * drawDailyVitalityRewardResp result.
             * @member {number} result
             * @memberof luck.protobuf.drawDailyVitalityRewardResp
             * @instance
             */
            drawDailyVitalityRewardResp.prototype.result = 0;

            /**
             * drawDailyVitalityRewardResp gold.
             * @member {number|Long} gold
             * @memberof luck.protobuf.drawDailyVitalityRewardResp
             * @instance
             */
            drawDailyVitalityRewardResp.prototype.gold = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * drawDailyVitalityRewardResp diamond.
             * @member {number|Long} diamond
             * @memberof luck.protobuf.drawDailyVitalityRewardResp
             * @instance
             */
            drawDailyVitalityRewardResp.prototype.diamond = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * drawDailyVitalityRewardResp weaponList.
             * @member {Array.<luck.protobuf.IWeaponPB>} weaponList
             * @memberof luck.protobuf.drawDailyVitalityRewardResp
             * @instance
             */
            drawDailyVitalityRewardResp.prototype.weaponList = $util.emptyArray;

            /**
             * drawDailyVitalityRewardResp cardList.
             * @member {Array.<luck.protobuf.ICardPB>} cardList
             * @memberof luck.protobuf.drawDailyVitalityRewardResp
             * @instance
             */
            drawDailyVitalityRewardResp.prototype.cardList = $util.emptyArray;

            /**
             * drawDailyVitalityRewardResp clothesList.
             * @member {Array.<luck.protobuf.IClothesPB>} clothesList
             * @memberof luck.protobuf.drawDailyVitalityRewardResp
             * @instance
             */
            drawDailyVitalityRewardResp.prototype.clothesList = $util.emptyArray;

            /**
             * drawDailyVitalityRewardResp propList.
             * @member {Array.<luck.protobuf.IPropPB>} propList
             * @memberof luck.protobuf.drawDailyVitalityRewardResp
             * @instance
             */
            drawDailyVitalityRewardResp.prototype.propList = $util.emptyArray;

            /**
             * drawDailyVitalityRewardResp materialsList.
             * @member {Array.<luck.protobuf.IMaterialsPB>} materialsList
             * @memberof luck.protobuf.drawDailyVitalityRewardResp
             * @instance
             */
            drawDailyVitalityRewardResp.prototype.materialsList = $util.emptyArray;

            /**
             * drawDailyVitalityRewardResp dailyVitalityRewardList.
             * @member {Array.<number>} dailyVitalityRewardList
             * @memberof luck.protobuf.drawDailyVitalityRewardResp
             * @instance
             */
            drawDailyVitalityRewardResp.prototype.dailyVitalityRewardList = $util.emptyArray;

            /**
             * Creates a new drawDailyVitalityRewardResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.drawDailyVitalityRewardResp
             * @static
             * @param {luck.protobuf.IdrawDailyVitalityRewardResp=} [properties] Properties to set
             * @returns {luck.protobuf.drawDailyVitalityRewardResp} drawDailyVitalityRewardResp instance
             */
            drawDailyVitalityRewardResp.create = function create(properties) {
                return new drawDailyVitalityRewardResp(properties);
            };

            /**
             * Encodes the specified drawDailyVitalityRewardResp message. Does not implicitly {@link luck.protobuf.drawDailyVitalityRewardResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.drawDailyVitalityRewardResp
             * @static
             * @param {luck.protobuf.IdrawDailyVitalityRewardResp} message drawDailyVitalityRewardResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            drawDailyVitalityRewardResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.gold != null && message.hasOwnProperty("gold"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.gold);
                if (message.diamond != null && message.hasOwnProperty("diamond"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.diamond);
                if (message.weaponList != null && message.weaponList.length)
                    for (var i = 0; i < message.weaponList.length; ++i)
                        $root.luck.protobuf.WeaponPB.encode(message.weaponList[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.cardList != null && message.cardList.length)
                    for (var i = 0; i < message.cardList.length; ++i)
                        $root.luck.protobuf.CardPB.encode(message.cardList[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.clothesList != null && message.clothesList.length)
                    for (var i = 0; i < message.clothesList.length; ++i)
                        $root.luck.protobuf.ClothesPB.encode(message.clothesList[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.propList != null && message.propList.length)
                    for (var i = 0; i < message.propList.length; ++i)
                        $root.luck.protobuf.PropPB.encode(message.propList[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.materialsList != null && message.materialsList.length)
                    for (var i = 0; i < message.materialsList.length; ++i)
                        $root.luck.protobuf.MaterialsPB.encode(message.materialsList[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.dailyVitalityRewardList != null && message.dailyVitalityRewardList.length)
                    for (var i = 0; i < message.dailyVitalityRewardList.length; ++i)
                        writer.uint32(/* id 9, wireType 0 =*/72).int32(message.dailyVitalityRewardList[i]);
                return writer;
            };

            /**
             * Encodes the specified drawDailyVitalityRewardResp message, length delimited. Does not implicitly {@link luck.protobuf.drawDailyVitalityRewardResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.drawDailyVitalityRewardResp
             * @static
             * @param {luck.protobuf.IdrawDailyVitalityRewardResp} message drawDailyVitalityRewardResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            drawDailyVitalityRewardResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a drawDailyVitalityRewardResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.drawDailyVitalityRewardResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.drawDailyVitalityRewardResp} drawDailyVitalityRewardResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            drawDailyVitalityRewardResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.drawDailyVitalityRewardResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.gold = reader.int64();
                        break;
                    case 3:
                        message.diamond = reader.int64();
                        break;
                    case 4:
                        if (!(message.weaponList && message.weaponList.length))
                            message.weaponList = [];
                        message.weaponList.push($root.luck.protobuf.WeaponPB.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.cardList && message.cardList.length))
                            message.cardList = [];
                        message.cardList.push($root.luck.protobuf.CardPB.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.clothesList && message.clothesList.length))
                            message.clothesList = [];
                        message.clothesList.push($root.luck.protobuf.ClothesPB.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        if (!(message.propList && message.propList.length))
                            message.propList = [];
                        message.propList.push($root.luck.protobuf.PropPB.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        if (!(message.materialsList && message.materialsList.length))
                            message.materialsList = [];
                        message.materialsList.push($root.luck.protobuf.MaterialsPB.decode(reader, reader.uint32()));
                        break;
                    case 9:
                        if (!(message.dailyVitalityRewardList && message.dailyVitalityRewardList.length))
                            message.dailyVitalityRewardList = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.dailyVitalityRewardList.push(reader.int32());
                        } else
                            message.dailyVitalityRewardList.push(reader.int32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a drawDailyVitalityRewardResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.drawDailyVitalityRewardResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.drawDailyVitalityRewardResp} drawDailyVitalityRewardResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            drawDailyVitalityRewardResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a drawDailyVitalityRewardResp message.
             * @function verify
             * @memberof luck.protobuf.drawDailyVitalityRewardResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            drawDailyVitalityRewardResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.gold != null && message.hasOwnProperty("gold"))
                    if (!$util.isInteger(message.gold) && !(message.gold && $util.isInteger(message.gold.low) && $util.isInteger(message.gold.high)))
                        return "gold: integer|Long expected";
                if (message.diamond != null && message.hasOwnProperty("diamond"))
                    if (!$util.isInteger(message.diamond) && !(message.diamond && $util.isInteger(message.diamond.low) && $util.isInteger(message.diamond.high)))
                        return "diamond: integer|Long expected";
                if (message.weaponList != null && message.hasOwnProperty("weaponList")) {
                    if (!Array.isArray(message.weaponList))
                        return "weaponList: array expected";
                    for (var i = 0; i < message.weaponList.length; ++i) {
                        var error = $root.luck.protobuf.WeaponPB.verify(message.weaponList[i]);
                        if (error)
                            return "weaponList." + error;
                    }
                }
                if (message.cardList != null && message.hasOwnProperty("cardList")) {
                    if (!Array.isArray(message.cardList))
                        return "cardList: array expected";
                    for (var i = 0; i < message.cardList.length; ++i) {
                        var error = $root.luck.protobuf.CardPB.verify(message.cardList[i]);
                        if (error)
                            return "cardList." + error;
                    }
                }
                if (message.clothesList != null && message.hasOwnProperty("clothesList")) {
                    if (!Array.isArray(message.clothesList))
                        return "clothesList: array expected";
                    for (var i = 0; i < message.clothesList.length; ++i) {
                        var error = $root.luck.protobuf.ClothesPB.verify(message.clothesList[i]);
                        if (error)
                            return "clothesList." + error;
                    }
                }
                if (message.propList != null && message.hasOwnProperty("propList")) {
                    if (!Array.isArray(message.propList))
                        return "propList: array expected";
                    for (var i = 0; i < message.propList.length; ++i) {
                        var error = $root.luck.protobuf.PropPB.verify(message.propList[i]);
                        if (error)
                            return "propList." + error;
                    }
                }
                if (message.materialsList != null && message.hasOwnProperty("materialsList")) {
                    if (!Array.isArray(message.materialsList))
                        return "materialsList: array expected";
                    for (var i = 0; i < message.materialsList.length; ++i) {
                        var error = $root.luck.protobuf.MaterialsPB.verify(message.materialsList[i]);
                        if (error)
                            return "materialsList." + error;
                    }
                }
                if (message.dailyVitalityRewardList != null && message.hasOwnProperty("dailyVitalityRewardList")) {
                    if (!Array.isArray(message.dailyVitalityRewardList))
                        return "dailyVitalityRewardList: array expected";
                    for (var i = 0; i < message.dailyVitalityRewardList.length; ++i)
                        if (!$util.isInteger(message.dailyVitalityRewardList[i]))
                            return "dailyVitalityRewardList: integer[] expected";
                }
                return null;
            };

            return drawDailyVitalityRewardResp;
        })();

        protobuf.createPVETeamResp = (function() {

            /**
             * Properties of a createPVETeamResp.
             * @memberof luck.protobuf
             * @interface IcreatePVETeamResp
             * @property {number} result createPVETeamResp result
             * @property {luck.protobuf.IPVETeamPB|null} [PVETeam] createPVETeamResp PVETeam
             */

            /**
             * Constructs a new createPVETeamResp.
             * @memberof luck.protobuf
             * @classdesc Represents a createPVETeamResp.
             * @implements IcreatePVETeamResp
             * @constructor
             * @param {luck.protobuf.IcreatePVETeamResp=} [properties] Properties to set
             */
            function createPVETeamResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * createPVETeamResp result.
             * @member {number} result
             * @memberof luck.protobuf.createPVETeamResp
             * @instance
             */
            createPVETeamResp.prototype.result = 0;

            /**
             * createPVETeamResp PVETeam.
             * @member {luck.protobuf.IPVETeamPB|null|undefined} PVETeam
             * @memberof luck.protobuf.createPVETeamResp
             * @instance
             */
            createPVETeamResp.prototype.PVETeam = null;

            /**
             * Creates a new createPVETeamResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.createPVETeamResp
             * @static
             * @param {luck.protobuf.IcreatePVETeamResp=} [properties] Properties to set
             * @returns {luck.protobuf.createPVETeamResp} createPVETeamResp instance
             */
            createPVETeamResp.create = function create(properties) {
                return new createPVETeamResp(properties);
            };

            /**
             * Encodes the specified createPVETeamResp message. Does not implicitly {@link luck.protobuf.createPVETeamResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.createPVETeamResp
             * @static
             * @param {luck.protobuf.IcreatePVETeamResp} message createPVETeamResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            createPVETeamResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.PVETeam != null && message.hasOwnProperty("PVETeam"))
                    $root.luck.protobuf.PVETeamPB.encode(message.PVETeam, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified createPVETeamResp message, length delimited. Does not implicitly {@link luck.protobuf.createPVETeamResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.createPVETeamResp
             * @static
             * @param {luck.protobuf.IcreatePVETeamResp} message createPVETeamResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            createPVETeamResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a createPVETeamResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.createPVETeamResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.createPVETeamResp} createPVETeamResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            createPVETeamResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.createPVETeamResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.PVETeam = $root.luck.protobuf.PVETeamPB.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a createPVETeamResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.createPVETeamResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.createPVETeamResp} createPVETeamResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            createPVETeamResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a createPVETeamResp message.
             * @function verify
             * @memberof luck.protobuf.createPVETeamResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            createPVETeamResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.PVETeam != null && message.hasOwnProperty("PVETeam")) {
                    var error = $root.luck.protobuf.PVETeamPB.verify(message.PVETeam);
                    if (error)
                        return "PVETeam." + error;
                }
                return null;
            };

            return createPVETeamResp;
        })();

        protobuf.PVEInviteResp = (function() {

            /**
             * Properties of a PVEInviteResp.
             * @memberof luck.protobuf
             * @interface IPVEInviteResp
             * @property {number} result PVEInviteResp result
             */

            /**
             * Constructs a new PVEInviteResp.
             * @memberof luck.protobuf
             * @classdesc Represents a PVEInviteResp.
             * @implements IPVEInviteResp
             * @constructor
             * @param {luck.protobuf.IPVEInviteResp=} [properties] Properties to set
             */
            function PVEInviteResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PVEInviteResp result.
             * @member {number} result
             * @memberof luck.protobuf.PVEInviteResp
             * @instance
             */
            PVEInviteResp.prototype.result = 0;

            /**
             * Creates a new PVEInviteResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.PVEInviteResp
             * @static
             * @param {luck.protobuf.IPVEInviteResp=} [properties] Properties to set
             * @returns {luck.protobuf.PVEInviteResp} PVEInviteResp instance
             */
            PVEInviteResp.create = function create(properties) {
                return new PVEInviteResp(properties);
            };

            /**
             * Encodes the specified PVEInviteResp message. Does not implicitly {@link luck.protobuf.PVEInviteResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.PVEInviteResp
             * @static
             * @param {luck.protobuf.IPVEInviteResp} message PVEInviteResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PVEInviteResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                return writer;
            };

            /**
             * Encodes the specified PVEInviteResp message, length delimited. Does not implicitly {@link luck.protobuf.PVEInviteResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.PVEInviteResp
             * @static
             * @param {luck.protobuf.IPVEInviteResp} message PVEInviteResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PVEInviteResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PVEInviteResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.PVEInviteResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.PVEInviteResp} PVEInviteResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PVEInviteResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.PVEInviteResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a PVEInviteResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.PVEInviteResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.PVEInviteResp} PVEInviteResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PVEInviteResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PVEInviteResp message.
             * @function verify
             * @memberof luck.protobuf.PVEInviteResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PVEInviteResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                return null;
            };

            return PVEInviteResp;
        })();

        protobuf.PVEInvitePushResp = (function() {

            /**
             * Properties of a PVEInvitePushResp.
             * @memberof luck.protobuf
             * @interface IPVEInvitePushResp
             * @property {number|Long} InviteId PVEInvitePushResp InviteId
             * @property {number|Long} PVETeamId PVEInvitePushResp PVETeamId
             * @property {string} inviteCode PVEInvitePushResp inviteCode
             * @property {number} customsType PVEInvitePushResp customsType
             * @property {number} customsId PVEInvitePushResp customsId
             */

            /**
             * Constructs a new PVEInvitePushResp.
             * @memberof luck.protobuf
             * @classdesc Represents a PVEInvitePushResp.
             * @implements IPVEInvitePushResp
             * @constructor
             * @param {luck.protobuf.IPVEInvitePushResp=} [properties] Properties to set
             */
            function PVEInvitePushResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PVEInvitePushResp InviteId.
             * @member {number|Long} InviteId
             * @memberof luck.protobuf.PVEInvitePushResp
             * @instance
             */
            PVEInvitePushResp.prototype.InviteId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PVEInvitePushResp PVETeamId.
             * @member {number|Long} PVETeamId
             * @memberof luck.protobuf.PVEInvitePushResp
             * @instance
             */
            PVEInvitePushResp.prototype.PVETeamId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PVEInvitePushResp inviteCode.
             * @member {string} inviteCode
             * @memberof luck.protobuf.PVEInvitePushResp
             * @instance
             */
            PVEInvitePushResp.prototype.inviteCode = "";

            /**
             * PVEInvitePushResp customsType.
             * @member {number} customsType
             * @memberof luck.protobuf.PVEInvitePushResp
             * @instance
             */
            PVEInvitePushResp.prototype.customsType = 0;

            /**
             * PVEInvitePushResp customsId.
             * @member {number} customsId
             * @memberof luck.protobuf.PVEInvitePushResp
             * @instance
             */
            PVEInvitePushResp.prototype.customsId = 0;

            /**
             * Creates a new PVEInvitePushResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.PVEInvitePushResp
             * @static
             * @param {luck.protobuf.IPVEInvitePushResp=} [properties] Properties to set
             * @returns {luck.protobuf.PVEInvitePushResp} PVEInvitePushResp instance
             */
            PVEInvitePushResp.create = function create(properties) {
                return new PVEInvitePushResp(properties);
            };

            /**
             * Encodes the specified PVEInvitePushResp message. Does not implicitly {@link luck.protobuf.PVEInvitePushResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.PVEInvitePushResp
             * @static
             * @param {luck.protobuf.IPVEInvitePushResp} message PVEInvitePushResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PVEInvitePushResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.InviteId);
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.PVETeamId);
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.inviteCode);
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.customsType);
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.customsId);
                return writer;
            };

            /**
             * Encodes the specified PVEInvitePushResp message, length delimited. Does not implicitly {@link luck.protobuf.PVEInvitePushResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.PVEInvitePushResp
             * @static
             * @param {luck.protobuf.IPVEInvitePushResp} message PVEInvitePushResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PVEInvitePushResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PVEInvitePushResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.PVEInvitePushResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.PVEInvitePushResp} PVEInvitePushResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PVEInvitePushResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.PVEInvitePushResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.InviteId = reader.int64();
                        break;
                    case 2:
                        message.PVETeamId = reader.int64();
                        break;
                    case 3:
                        message.inviteCode = reader.string();
                        break;
                    case 4:
                        message.customsType = reader.int32();
                        break;
                    case 5:
                        message.customsId = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("InviteId"))
                    throw $util.ProtocolError("missing required 'InviteId'", { instance: message });
                if (!message.hasOwnProperty("PVETeamId"))
                    throw $util.ProtocolError("missing required 'PVETeamId'", { instance: message });
                if (!message.hasOwnProperty("inviteCode"))
                    throw $util.ProtocolError("missing required 'inviteCode'", { instance: message });
                if (!message.hasOwnProperty("customsType"))
                    throw $util.ProtocolError("missing required 'customsType'", { instance: message });
                if (!message.hasOwnProperty("customsId"))
                    throw $util.ProtocolError("missing required 'customsId'", { instance: message });
                return message;
            };

            /**
             * Decodes a PVEInvitePushResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.PVEInvitePushResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.PVEInvitePushResp} PVEInvitePushResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PVEInvitePushResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PVEInvitePushResp message.
             * @function verify
             * @memberof luck.protobuf.PVEInvitePushResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PVEInvitePushResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.InviteId) && !(message.InviteId && $util.isInteger(message.InviteId.low) && $util.isInteger(message.InviteId.high)))
                    return "InviteId: integer|Long expected";
                if (!$util.isInteger(message.PVETeamId) && !(message.PVETeamId && $util.isInteger(message.PVETeamId.low) && $util.isInteger(message.PVETeamId.high)))
                    return "PVETeamId: integer|Long expected";
                if (!$util.isString(message.inviteCode))
                    return "inviteCode: string expected";
                if (!$util.isInteger(message.customsType))
                    return "customsType: integer expected";
                if (!$util.isInteger(message.customsId))
                    return "customsId: integer expected";
                return null;
            };

            return PVEInvitePushResp;
        })();

        protobuf.applyJoinTeamResp = (function() {

            /**
             * Properties of an applyJoinTeamResp.
             * @memberof luck.protobuf
             * @interface IapplyJoinTeamResp
             * @property {number} result applyJoinTeamResp result
             * @property {luck.protobuf.IPVETeamPB|null} [PVETeam] applyJoinTeamResp PVETeam
             */

            /**
             * Constructs a new applyJoinTeamResp.
             * @memberof luck.protobuf
             * @classdesc Represents an applyJoinTeamResp.
             * @implements IapplyJoinTeamResp
             * @constructor
             * @param {luck.protobuf.IapplyJoinTeamResp=} [properties] Properties to set
             */
            function applyJoinTeamResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * applyJoinTeamResp result.
             * @member {number} result
             * @memberof luck.protobuf.applyJoinTeamResp
             * @instance
             */
            applyJoinTeamResp.prototype.result = 0;

            /**
             * applyJoinTeamResp PVETeam.
             * @member {luck.protobuf.IPVETeamPB|null|undefined} PVETeam
             * @memberof luck.protobuf.applyJoinTeamResp
             * @instance
             */
            applyJoinTeamResp.prototype.PVETeam = null;

            /**
             * Creates a new applyJoinTeamResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.applyJoinTeamResp
             * @static
             * @param {luck.protobuf.IapplyJoinTeamResp=} [properties] Properties to set
             * @returns {luck.protobuf.applyJoinTeamResp} applyJoinTeamResp instance
             */
            applyJoinTeamResp.create = function create(properties) {
                return new applyJoinTeamResp(properties);
            };

            /**
             * Encodes the specified applyJoinTeamResp message. Does not implicitly {@link luck.protobuf.applyJoinTeamResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.applyJoinTeamResp
             * @static
             * @param {luck.protobuf.IapplyJoinTeamResp} message applyJoinTeamResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            applyJoinTeamResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.PVETeam != null && message.hasOwnProperty("PVETeam"))
                    $root.luck.protobuf.PVETeamPB.encode(message.PVETeam, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified applyJoinTeamResp message, length delimited. Does not implicitly {@link luck.protobuf.applyJoinTeamResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.applyJoinTeamResp
             * @static
             * @param {luck.protobuf.IapplyJoinTeamResp} message applyJoinTeamResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            applyJoinTeamResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an applyJoinTeamResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.applyJoinTeamResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.applyJoinTeamResp} applyJoinTeamResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            applyJoinTeamResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.applyJoinTeamResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.PVETeam = $root.luck.protobuf.PVETeamPB.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes an applyJoinTeamResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.applyJoinTeamResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.applyJoinTeamResp} applyJoinTeamResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            applyJoinTeamResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an applyJoinTeamResp message.
             * @function verify
             * @memberof luck.protobuf.applyJoinTeamResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            applyJoinTeamResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.PVETeam != null && message.hasOwnProperty("PVETeam")) {
                    var error = $root.luck.protobuf.PVETeamPB.verify(message.PVETeam);
                    if (error)
                        return "PVETeam." + error;
                }
                return null;
            };

            return applyJoinTeamResp;
        })();

        protobuf.approveJoinTeamResp = (function() {

            /**
             * Properties of an approveJoinTeamResp.
             * @memberof luck.protobuf
             * @interface IapproveJoinTeamResp
             * @property {number} result approveJoinTeamResp result
             * @property {luck.protobuf.IPVETeamPB|null} [PVETeam] approveJoinTeamResp PVETeam
             */

            /**
             * Constructs a new approveJoinTeamResp.
             * @memberof luck.protobuf
             * @classdesc Represents an approveJoinTeamResp.
             * @implements IapproveJoinTeamResp
             * @constructor
             * @param {luck.protobuf.IapproveJoinTeamResp=} [properties] Properties to set
             */
            function approveJoinTeamResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * approveJoinTeamResp result.
             * @member {number} result
             * @memberof luck.protobuf.approveJoinTeamResp
             * @instance
             */
            approveJoinTeamResp.prototype.result = 0;

            /**
             * approveJoinTeamResp PVETeam.
             * @member {luck.protobuf.IPVETeamPB|null|undefined} PVETeam
             * @memberof luck.protobuf.approveJoinTeamResp
             * @instance
             */
            approveJoinTeamResp.prototype.PVETeam = null;

            /**
             * Creates a new approveJoinTeamResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.approveJoinTeamResp
             * @static
             * @param {luck.protobuf.IapproveJoinTeamResp=} [properties] Properties to set
             * @returns {luck.protobuf.approveJoinTeamResp} approveJoinTeamResp instance
             */
            approveJoinTeamResp.create = function create(properties) {
                return new approveJoinTeamResp(properties);
            };

            /**
             * Encodes the specified approveJoinTeamResp message. Does not implicitly {@link luck.protobuf.approveJoinTeamResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.approveJoinTeamResp
             * @static
             * @param {luck.protobuf.IapproveJoinTeamResp} message approveJoinTeamResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            approveJoinTeamResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.PVETeam != null && message.hasOwnProperty("PVETeam"))
                    $root.luck.protobuf.PVETeamPB.encode(message.PVETeam, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified approveJoinTeamResp message, length delimited. Does not implicitly {@link luck.protobuf.approveJoinTeamResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.approveJoinTeamResp
             * @static
             * @param {luck.protobuf.IapproveJoinTeamResp} message approveJoinTeamResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            approveJoinTeamResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an approveJoinTeamResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.approveJoinTeamResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.approveJoinTeamResp} approveJoinTeamResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            approveJoinTeamResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.approveJoinTeamResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.PVETeam = $root.luck.protobuf.PVETeamPB.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes an approveJoinTeamResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.approveJoinTeamResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.approveJoinTeamResp} approveJoinTeamResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            approveJoinTeamResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an approveJoinTeamResp message.
             * @function verify
             * @memberof luck.protobuf.approveJoinTeamResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            approveJoinTeamResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.PVETeam != null && message.hasOwnProperty("PVETeam")) {
                    var error = $root.luck.protobuf.PVETeamPB.verify(message.PVETeam);
                    if (error)
                        return "PVETeam." + error;
                }
                return null;
            };

            return approveJoinTeamResp;
        })();

        protobuf.approveJoinTeamPushResp = (function() {

            /**
             * Properties of an approveJoinTeamPushResp.
             * @memberof luck.protobuf
             * @interface IapproveJoinTeamPushResp
             * @property {luck.protobuf.IPVETeamPB} PVETeam approveJoinTeamPushResp PVETeam
             */

            /**
             * Constructs a new approveJoinTeamPushResp.
             * @memberof luck.protobuf
             * @classdesc Represents an approveJoinTeamPushResp.
             * @implements IapproveJoinTeamPushResp
             * @constructor
             * @param {luck.protobuf.IapproveJoinTeamPushResp=} [properties] Properties to set
             */
            function approveJoinTeamPushResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * approveJoinTeamPushResp PVETeam.
             * @member {luck.protobuf.IPVETeamPB} PVETeam
             * @memberof luck.protobuf.approveJoinTeamPushResp
             * @instance
             */
            approveJoinTeamPushResp.prototype.PVETeam = null;

            /**
             * Creates a new approveJoinTeamPushResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.approveJoinTeamPushResp
             * @static
             * @param {luck.protobuf.IapproveJoinTeamPushResp=} [properties] Properties to set
             * @returns {luck.protobuf.approveJoinTeamPushResp} approveJoinTeamPushResp instance
             */
            approveJoinTeamPushResp.create = function create(properties) {
                return new approveJoinTeamPushResp(properties);
            };

            /**
             * Encodes the specified approveJoinTeamPushResp message. Does not implicitly {@link luck.protobuf.approveJoinTeamPushResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.approveJoinTeamPushResp
             * @static
             * @param {luck.protobuf.IapproveJoinTeamPushResp} message approveJoinTeamPushResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            approveJoinTeamPushResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                $root.luck.protobuf.PVETeamPB.encode(message.PVETeam, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified approveJoinTeamPushResp message, length delimited. Does not implicitly {@link luck.protobuf.approveJoinTeamPushResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.approveJoinTeamPushResp
             * @static
             * @param {luck.protobuf.IapproveJoinTeamPushResp} message approveJoinTeamPushResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            approveJoinTeamPushResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an approveJoinTeamPushResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.approveJoinTeamPushResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.approveJoinTeamPushResp} approveJoinTeamPushResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            approveJoinTeamPushResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.approveJoinTeamPushResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.PVETeam = $root.luck.protobuf.PVETeamPB.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("PVETeam"))
                    throw $util.ProtocolError("missing required 'PVETeam'", { instance: message });
                return message;
            };

            /**
             * Decodes an approveJoinTeamPushResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.approveJoinTeamPushResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.approveJoinTeamPushResp} approveJoinTeamPushResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            approveJoinTeamPushResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an approveJoinTeamPushResp message.
             * @function verify
             * @memberof luck.protobuf.approveJoinTeamPushResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            approveJoinTeamPushResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                {
                    var error = $root.luck.protobuf.PVETeamPB.verify(message.PVETeam);
                    if (error)
                        return "PVETeam." + error;
                }
                return null;
            };

            return approveJoinTeamPushResp;
        })();

        protobuf.PVEPrepareResp = (function() {

            /**
             * Properties of a PVEPrepareResp.
             * @memberof luck.protobuf
             * @interface IPVEPrepareResp
             * @property {number} result PVEPrepareResp result
             * @property {luck.protobuf.IPVETeamPB|null} [PVETeam] PVEPrepareResp PVETeam
             */

            /**
             * Constructs a new PVEPrepareResp.
             * @memberof luck.protobuf
             * @classdesc Represents a PVEPrepareResp.
             * @implements IPVEPrepareResp
             * @constructor
             * @param {luck.protobuf.IPVEPrepareResp=} [properties] Properties to set
             */
            function PVEPrepareResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PVEPrepareResp result.
             * @member {number} result
             * @memberof luck.protobuf.PVEPrepareResp
             * @instance
             */
            PVEPrepareResp.prototype.result = 0;

            /**
             * PVEPrepareResp PVETeam.
             * @member {luck.protobuf.IPVETeamPB|null|undefined} PVETeam
             * @memberof luck.protobuf.PVEPrepareResp
             * @instance
             */
            PVEPrepareResp.prototype.PVETeam = null;

            /**
             * Creates a new PVEPrepareResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.PVEPrepareResp
             * @static
             * @param {luck.protobuf.IPVEPrepareResp=} [properties] Properties to set
             * @returns {luck.protobuf.PVEPrepareResp} PVEPrepareResp instance
             */
            PVEPrepareResp.create = function create(properties) {
                return new PVEPrepareResp(properties);
            };

            /**
             * Encodes the specified PVEPrepareResp message. Does not implicitly {@link luck.protobuf.PVEPrepareResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.PVEPrepareResp
             * @static
             * @param {luck.protobuf.IPVEPrepareResp} message PVEPrepareResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PVEPrepareResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.PVETeam != null && message.hasOwnProperty("PVETeam"))
                    $root.luck.protobuf.PVETeamPB.encode(message.PVETeam, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified PVEPrepareResp message, length delimited. Does not implicitly {@link luck.protobuf.PVEPrepareResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.PVEPrepareResp
             * @static
             * @param {luck.protobuf.IPVEPrepareResp} message PVEPrepareResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PVEPrepareResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PVEPrepareResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.PVEPrepareResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.PVEPrepareResp} PVEPrepareResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PVEPrepareResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.PVEPrepareResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.PVETeam = $root.luck.protobuf.PVETeamPB.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a PVEPrepareResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.PVEPrepareResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.PVEPrepareResp} PVEPrepareResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PVEPrepareResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PVEPrepareResp message.
             * @function verify
             * @memberof luck.protobuf.PVEPrepareResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PVEPrepareResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.PVETeam != null && message.hasOwnProperty("PVETeam")) {
                    var error = $root.luck.protobuf.PVETeamPB.verify(message.PVETeam);
                    if (error)
                        return "PVETeam." + error;
                }
                return null;
            };

            return PVEPrepareResp;
        })();

        protobuf.PVESelectCustomsResp = (function() {

            /**
             * Properties of a PVESelectCustomsResp.
             * @memberof luck.protobuf
             * @interface IPVESelectCustomsResp
             * @property {number} result PVESelectCustomsResp result
             * @property {luck.protobuf.IPVETeamPB|null} [PVETeam] PVESelectCustomsResp PVETeam
             */

            /**
             * Constructs a new PVESelectCustomsResp.
             * @memberof luck.protobuf
             * @classdesc Represents a PVESelectCustomsResp.
             * @implements IPVESelectCustomsResp
             * @constructor
             * @param {luck.protobuf.IPVESelectCustomsResp=} [properties] Properties to set
             */
            function PVESelectCustomsResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PVESelectCustomsResp result.
             * @member {number} result
             * @memberof luck.protobuf.PVESelectCustomsResp
             * @instance
             */
            PVESelectCustomsResp.prototype.result = 0;

            /**
             * PVESelectCustomsResp PVETeam.
             * @member {luck.protobuf.IPVETeamPB|null|undefined} PVETeam
             * @memberof luck.protobuf.PVESelectCustomsResp
             * @instance
             */
            PVESelectCustomsResp.prototype.PVETeam = null;

            /**
             * Creates a new PVESelectCustomsResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.PVESelectCustomsResp
             * @static
             * @param {luck.protobuf.IPVESelectCustomsResp=} [properties] Properties to set
             * @returns {luck.protobuf.PVESelectCustomsResp} PVESelectCustomsResp instance
             */
            PVESelectCustomsResp.create = function create(properties) {
                return new PVESelectCustomsResp(properties);
            };

            /**
             * Encodes the specified PVESelectCustomsResp message. Does not implicitly {@link luck.protobuf.PVESelectCustomsResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.PVESelectCustomsResp
             * @static
             * @param {luck.protobuf.IPVESelectCustomsResp} message PVESelectCustomsResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PVESelectCustomsResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.PVETeam != null && message.hasOwnProperty("PVETeam"))
                    $root.luck.protobuf.PVETeamPB.encode(message.PVETeam, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified PVESelectCustomsResp message, length delimited. Does not implicitly {@link luck.protobuf.PVESelectCustomsResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.PVESelectCustomsResp
             * @static
             * @param {luck.protobuf.IPVESelectCustomsResp} message PVESelectCustomsResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PVESelectCustomsResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PVESelectCustomsResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.PVESelectCustomsResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.PVESelectCustomsResp} PVESelectCustomsResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PVESelectCustomsResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.PVESelectCustomsResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.PVETeam = $root.luck.protobuf.PVETeamPB.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a PVESelectCustomsResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.PVESelectCustomsResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.PVESelectCustomsResp} PVESelectCustomsResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PVESelectCustomsResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PVESelectCustomsResp message.
             * @function verify
             * @memberof luck.protobuf.PVESelectCustomsResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PVESelectCustomsResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.PVETeam != null && message.hasOwnProperty("PVETeam")) {
                    var error = $root.luck.protobuf.PVETeamPB.verify(message.PVETeam);
                    if (error)
                        return "PVETeam." + error;
                }
                return null;
            };

            return PVESelectCustomsResp;
        })();

        protobuf.PVETeamUpdatePushResp = (function() {

            /**
             * Properties of a PVETeamUpdatePushResp.
             * @memberof luck.protobuf
             * @interface IPVETeamUpdatePushResp
             * @property {luck.protobuf.IPVETeamPB} PVETeam PVETeamUpdatePushResp PVETeam
             */

            /**
             * Constructs a new PVETeamUpdatePushResp.
             * @memberof luck.protobuf
             * @classdesc Represents a PVETeamUpdatePushResp.
             * @implements IPVETeamUpdatePushResp
             * @constructor
             * @param {luck.protobuf.IPVETeamUpdatePushResp=} [properties] Properties to set
             */
            function PVETeamUpdatePushResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PVETeamUpdatePushResp PVETeam.
             * @member {luck.protobuf.IPVETeamPB} PVETeam
             * @memberof luck.protobuf.PVETeamUpdatePushResp
             * @instance
             */
            PVETeamUpdatePushResp.prototype.PVETeam = null;

            /**
             * Creates a new PVETeamUpdatePushResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.PVETeamUpdatePushResp
             * @static
             * @param {luck.protobuf.IPVETeamUpdatePushResp=} [properties] Properties to set
             * @returns {luck.protobuf.PVETeamUpdatePushResp} PVETeamUpdatePushResp instance
             */
            PVETeamUpdatePushResp.create = function create(properties) {
                return new PVETeamUpdatePushResp(properties);
            };

            /**
             * Encodes the specified PVETeamUpdatePushResp message. Does not implicitly {@link luck.protobuf.PVETeamUpdatePushResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.PVETeamUpdatePushResp
             * @static
             * @param {luck.protobuf.IPVETeamUpdatePushResp} message PVETeamUpdatePushResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PVETeamUpdatePushResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                $root.luck.protobuf.PVETeamPB.encode(message.PVETeam, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified PVETeamUpdatePushResp message, length delimited. Does not implicitly {@link luck.protobuf.PVETeamUpdatePushResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.PVETeamUpdatePushResp
             * @static
             * @param {luck.protobuf.IPVETeamUpdatePushResp} message PVETeamUpdatePushResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PVETeamUpdatePushResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PVETeamUpdatePushResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.PVETeamUpdatePushResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.PVETeamUpdatePushResp} PVETeamUpdatePushResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PVETeamUpdatePushResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.PVETeamUpdatePushResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.PVETeam = $root.luck.protobuf.PVETeamPB.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("PVETeam"))
                    throw $util.ProtocolError("missing required 'PVETeam'", { instance: message });
                return message;
            };

            /**
             * Decodes a PVETeamUpdatePushResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.PVETeamUpdatePushResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.PVETeamUpdatePushResp} PVETeamUpdatePushResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PVETeamUpdatePushResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PVETeamUpdatePushResp message.
             * @function verify
             * @memberof luck.protobuf.PVETeamUpdatePushResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PVETeamUpdatePushResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                {
                    var error = $root.luck.protobuf.PVETeamPB.verify(message.PVETeam);
                    if (error)
                        return "PVETeam." + error;
                }
                return null;
            };

            return PVETeamUpdatePushResp;
        })();

        protobuf.QuitPVETeamResp = (function() {

            /**
             * Properties of a QuitPVETeamResp.
             * @memberof luck.protobuf
             * @interface IQuitPVETeamResp
             * @property {number} result QuitPVETeamResp result
             */

            /**
             * Constructs a new QuitPVETeamResp.
             * @memberof luck.protobuf
             * @classdesc Represents a QuitPVETeamResp.
             * @implements IQuitPVETeamResp
             * @constructor
             * @param {luck.protobuf.IQuitPVETeamResp=} [properties] Properties to set
             */
            function QuitPVETeamResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QuitPVETeamResp result.
             * @member {number} result
             * @memberof luck.protobuf.QuitPVETeamResp
             * @instance
             */
            QuitPVETeamResp.prototype.result = 0;

            /**
             * Creates a new QuitPVETeamResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.QuitPVETeamResp
             * @static
             * @param {luck.protobuf.IQuitPVETeamResp=} [properties] Properties to set
             * @returns {luck.protobuf.QuitPVETeamResp} QuitPVETeamResp instance
             */
            QuitPVETeamResp.create = function create(properties) {
                return new QuitPVETeamResp(properties);
            };

            /**
             * Encodes the specified QuitPVETeamResp message. Does not implicitly {@link luck.protobuf.QuitPVETeamResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.QuitPVETeamResp
             * @static
             * @param {luck.protobuf.IQuitPVETeamResp} message QuitPVETeamResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QuitPVETeamResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                return writer;
            };

            /**
             * Encodes the specified QuitPVETeamResp message, length delimited. Does not implicitly {@link luck.protobuf.QuitPVETeamResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.QuitPVETeamResp
             * @static
             * @param {luck.protobuf.IQuitPVETeamResp} message QuitPVETeamResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QuitPVETeamResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QuitPVETeamResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.QuitPVETeamResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.QuitPVETeamResp} QuitPVETeamResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QuitPVETeamResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.QuitPVETeamResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a QuitPVETeamResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.QuitPVETeamResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.QuitPVETeamResp} QuitPVETeamResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QuitPVETeamResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QuitPVETeamResp message.
             * @function verify
             * @memberof luck.protobuf.QuitPVETeamResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QuitPVETeamResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                return null;
            };

            return QuitPVETeamResp;
        })();

        protobuf.LoadGangShopResp = (function() {

            /**
             * Properties of a LoadGangShopResp.
             * @memberof luck.protobuf
             * @interface ILoadGangShopResp
             * @property {number} result LoadGangShopResp result
             * @property {Array.<luck.protobuf.IShopGoodsPB>|null} [gangShopList] LoadGangShopResp gangShopList
             */

            /**
             * Constructs a new LoadGangShopResp.
             * @memberof luck.protobuf
             * @classdesc Represents a LoadGangShopResp.
             * @implements ILoadGangShopResp
             * @constructor
             * @param {luck.protobuf.ILoadGangShopResp=} [properties] Properties to set
             */
            function LoadGangShopResp(properties) {
                this.gangShopList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LoadGangShopResp result.
             * @member {number} result
             * @memberof luck.protobuf.LoadGangShopResp
             * @instance
             */
            LoadGangShopResp.prototype.result = 0;

            /**
             * LoadGangShopResp gangShopList.
             * @member {Array.<luck.protobuf.IShopGoodsPB>} gangShopList
             * @memberof luck.protobuf.LoadGangShopResp
             * @instance
             */
            LoadGangShopResp.prototype.gangShopList = $util.emptyArray;

            /**
             * Creates a new LoadGangShopResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.LoadGangShopResp
             * @static
             * @param {luck.protobuf.ILoadGangShopResp=} [properties] Properties to set
             * @returns {luck.protobuf.LoadGangShopResp} LoadGangShopResp instance
             */
            LoadGangShopResp.create = function create(properties) {
                return new LoadGangShopResp(properties);
            };

            /**
             * Encodes the specified LoadGangShopResp message. Does not implicitly {@link luck.protobuf.LoadGangShopResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.LoadGangShopResp
             * @static
             * @param {luck.protobuf.ILoadGangShopResp} message LoadGangShopResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LoadGangShopResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.gangShopList != null && message.gangShopList.length)
                    for (var i = 0; i < message.gangShopList.length; ++i)
                        $root.luck.protobuf.ShopGoodsPB.encode(message.gangShopList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified LoadGangShopResp message, length delimited. Does not implicitly {@link luck.protobuf.LoadGangShopResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.LoadGangShopResp
             * @static
             * @param {luck.protobuf.ILoadGangShopResp} message LoadGangShopResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LoadGangShopResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LoadGangShopResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.LoadGangShopResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.LoadGangShopResp} LoadGangShopResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LoadGangShopResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.LoadGangShopResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        if (!(message.gangShopList && message.gangShopList.length))
                            message.gangShopList = [];
                        message.gangShopList.push($root.luck.protobuf.ShopGoodsPB.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a LoadGangShopResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.LoadGangShopResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.LoadGangShopResp} LoadGangShopResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LoadGangShopResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LoadGangShopResp message.
             * @function verify
             * @memberof luck.protobuf.LoadGangShopResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LoadGangShopResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.gangShopList != null && message.hasOwnProperty("gangShopList")) {
                    if (!Array.isArray(message.gangShopList))
                        return "gangShopList: array expected";
                    for (var i = 0; i < message.gangShopList.length; ++i) {
                        var error = $root.luck.protobuf.ShopGoodsPB.verify(message.gangShopList[i]);
                        if (error)
                            return "gangShopList." + error;
                    }
                }
                return null;
            };

            return LoadGangShopResp;
        })();

        protobuf.GetPlayerInfoResp = (function() {

            /**
             * Properties of a GetPlayerInfoResp.
             * @memberof luck.protobuf
             * @interface IGetPlayerInfoResp
             * @property {number} result GetPlayerInfoResp result
             * @property {Array.<luck.protobuf.IPlayerPB>|null} [playerList] GetPlayerInfoResp playerList
             */

            /**
             * Constructs a new GetPlayerInfoResp.
             * @memberof luck.protobuf
             * @classdesc Represents a GetPlayerInfoResp.
             * @implements IGetPlayerInfoResp
             * @constructor
             * @param {luck.protobuf.IGetPlayerInfoResp=} [properties] Properties to set
             */
            function GetPlayerInfoResp(properties) {
                this.playerList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetPlayerInfoResp result.
             * @member {number} result
             * @memberof luck.protobuf.GetPlayerInfoResp
             * @instance
             */
            GetPlayerInfoResp.prototype.result = 0;

            /**
             * GetPlayerInfoResp playerList.
             * @member {Array.<luck.protobuf.IPlayerPB>} playerList
             * @memberof luck.protobuf.GetPlayerInfoResp
             * @instance
             */
            GetPlayerInfoResp.prototype.playerList = $util.emptyArray;

            /**
             * Creates a new GetPlayerInfoResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.GetPlayerInfoResp
             * @static
             * @param {luck.protobuf.IGetPlayerInfoResp=} [properties] Properties to set
             * @returns {luck.protobuf.GetPlayerInfoResp} GetPlayerInfoResp instance
             */
            GetPlayerInfoResp.create = function create(properties) {
                return new GetPlayerInfoResp(properties);
            };

            /**
             * Encodes the specified GetPlayerInfoResp message. Does not implicitly {@link luck.protobuf.GetPlayerInfoResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.GetPlayerInfoResp
             * @static
             * @param {luck.protobuf.IGetPlayerInfoResp} message GetPlayerInfoResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetPlayerInfoResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.playerList != null && message.playerList.length)
                    for (var i = 0; i < message.playerList.length; ++i)
                        $root.luck.protobuf.PlayerPB.encode(message.playerList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetPlayerInfoResp message, length delimited. Does not implicitly {@link luck.protobuf.GetPlayerInfoResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.GetPlayerInfoResp
             * @static
             * @param {luck.protobuf.IGetPlayerInfoResp} message GetPlayerInfoResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetPlayerInfoResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetPlayerInfoResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.GetPlayerInfoResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.GetPlayerInfoResp} GetPlayerInfoResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetPlayerInfoResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.GetPlayerInfoResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        if (!(message.playerList && message.playerList.length))
                            message.playerList = [];
                        message.playerList.push($root.luck.protobuf.PlayerPB.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a GetPlayerInfoResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.GetPlayerInfoResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.GetPlayerInfoResp} GetPlayerInfoResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetPlayerInfoResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetPlayerInfoResp message.
             * @function verify
             * @memberof luck.protobuf.GetPlayerInfoResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetPlayerInfoResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.playerList != null && message.hasOwnProperty("playerList")) {
                    if (!Array.isArray(message.playerList))
                        return "playerList: array expected";
                    for (var i = 0; i < message.playerList.length; ++i) {
                        var error = $root.luck.protobuf.PlayerPB.verify(message.playerList[i]);
                        if (error)
                            return "playerList." + error;
                    }
                }
                return null;
            };

            return GetPlayerInfoResp;
        })();

        protobuf.PVETeamStartBattleResp = (function() {

            /**
             * Properties of a PVETeamStartBattleResp.
             * @memberof luck.protobuf
             * @interface IPVETeamStartBattleResp
             * @property {number} result PVETeamStartBattleResp result
             * @property {string|null} [battleServerIP] PVETeamStartBattleResp battleServerIP
             * @property {number|null} [battleServerPort] PVETeamStartBattleResp battleServerPort
             * @property {number|Long|null} [battleRoomId] PVETeamStartBattleResp battleRoomId
             */

            /**
             * Constructs a new PVETeamStartBattleResp.
             * @memberof luck.protobuf
             * @classdesc Represents a PVETeamStartBattleResp.
             * @implements IPVETeamStartBattleResp
             * @constructor
             * @param {luck.protobuf.IPVETeamStartBattleResp=} [properties] Properties to set
             */
            function PVETeamStartBattleResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PVETeamStartBattleResp result.
             * @member {number} result
             * @memberof luck.protobuf.PVETeamStartBattleResp
             * @instance
             */
            PVETeamStartBattleResp.prototype.result = 0;

            /**
             * PVETeamStartBattleResp battleServerIP.
             * @member {string} battleServerIP
             * @memberof luck.protobuf.PVETeamStartBattleResp
             * @instance
             */
            PVETeamStartBattleResp.prototype.battleServerIP = "";

            /**
             * PVETeamStartBattleResp battleServerPort.
             * @member {number} battleServerPort
             * @memberof luck.protobuf.PVETeamStartBattleResp
             * @instance
             */
            PVETeamStartBattleResp.prototype.battleServerPort = 0;

            /**
             * PVETeamStartBattleResp battleRoomId.
             * @member {number|Long} battleRoomId
             * @memberof luck.protobuf.PVETeamStartBattleResp
             * @instance
             */
            PVETeamStartBattleResp.prototype.battleRoomId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new PVETeamStartBattleResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.PVETeamStartBattleResp
             * @static
             * @param {luck.protobuf.IPVETeamStartBattleResp=} [properties] Properties to set
             * @returns {luck.protobuf.PVETeamStartBattleResp} PVETeamStartBattleResp instance
             */
            PVETeamStartBattleResp.create = function create(properties) {
                return new PVETeamStartBattleResp(properties);
            };

            /**
             * Encodes the specified PVETeamStartBattleResp message. Does not implicitly {@link luck.protobuf.PVETeamStartBattleResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.PVETeamStartBattleResp
             * @static
             * @param {luck.protobuf.IPVETeamStartBattleResp} message PVETeamStartBattleResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PVETeamStartBattleResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.battleServerIP != null && message.hasOwnProperty("battleServerIP"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.battleServerIP);
                if (message.battleServerPort != null && message.hasOwnProperty("battleServerPort"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.battleServerPort);
                if (message.battleRoomId != null && message.hasOwnProperty("battleRoomId"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.battleRoomId);
                return writer;
            };

            /**
             * Encodes the specified PVETeamStartBattleResp message, length delimited. Does not implicitly {@link luck.protobuf.PVETeamStartBattleResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.PVETeamStartBattleResp
             * @static
             * @param {luck.protobuf.IPVETeamStartBattleResp} message PVETeamStartBattleResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PVETeamStartBattleResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PVETeamStartBattleResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.PVETeamStartBattleResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.PVETeamStartBattleResp} PVETeamStartBattleResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PVETeamStartBattleResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.PVETeamStartBattleResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.battleServerIP = reader.string();
                        break;
                    case 3:
                        message.battleServerPort = reader.int32();
                        break;
                    case 4:
                        message.battleRoomId = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a PVETeamStartBattleResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.PVETeamStartBattleResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.PVETeamStartBattleResp} PVETeamStartBattleResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PVETeamStartBattleResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PVETeamStartBattleResp message.
             * @function verify
             * @memberof luck.protobuf.PVETeamStartBattleResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PVETeamStartBattleResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.battleServerIP != null && message.hasOwnProperty("battleServerIP"))
                    if (!$util.isString(message.battleServerIP))
                        return "battleServerIP: string expected";
                if (message.battleServerPort != null && message.hasOwnProperty("battleServerPort"))
                    if (!$util.isInteger(message.battleServerPort))
                        return "battleServerPort: integer expected";
                if (message.battleRoomId != null && message.hasOwnProperty("battleRoomId"))
                    if (!$util.isInteger(message.battleRoomId) && !(message.battleRoomId && $util.isInteger(message.battleRoomId.low) && $util.isInteger(message.battleRoomId.high)))
                        return "battleRoomId: integer|Long expected";
                return null;
            };

            return PVETeamStartBattleResp;
        })();

        protobuf.gangShopBuyResp = (function() {

            /**
             * Properties of a gangShopBuyResp.
             * @memberof luck.protobuf
             * @interface IgangShopBuyResp
             * @property {number} result gangShopBuyResp result
             * @property {number|Long|null} [gold] gangShopBuyResp gold
             * @property {Array.<luck.protobuf.IWeaponPB>|null} [weaponList] gangShopBuyResp weaponList
             * @property {Array.<luck.protobuf.ICardPB>|null} [cardList] gangShopBuyResp cardList
             * @property {Array.<luck.protobuf.IClothesPB>|null} [clothesList] gangShopBuyResp clothesList
             * @property {Array.<luck.protobuf.IPropPB>|null} [propList] gangShopBuyResp propList
             * @property {Array.<luck.protobuf.IMaterialsPB>|null} [materialsList] gangShopBuyResp materialsList
             * @property {Array.<luck.protobuf.IShopGoodsPB>|null} [shopGoodsList] gangShopBuyResp shopGoodsList
             */

            /**
             * Constructs a new gangShopBuyResp.
             * @memberof luck.protobuf
             * @classdesc Represents a gangShopBuyResp.
             * @implements IgangShopBuyResp
             * @constructor
             * @param {luck.protobuf.IgangShopBuyResp=} [properties] Properties to set
             */
            function gangShopBuyResp(properties) {
                this.weaponList = [];
                this.cardList = [];
                this.clothesList = [];
                this.propList = [];
                this.materialsList = [];
                this.shopGoodsList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * gangShopBuyResp result.
             * @member {number} result
             * @memberof luck.protobuf.gangShopBuyResp
             * @instance
             */
            gangShopBuyResp.prototype.result = 0;

            /**
             * gangShopBuyResp gold.
             * @member {number|Long} gold
             * @memberof luck.protobuf.gangShopBuyResp
             * @instance
             */
            gangShopBuyResp.prototype.gold = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * gangShopBuyResp weaponList.
             * @member {Array.<luck.protobuf.IWeaponPB>} weaponList
             * @memberof luck.protobuf.gangShopBuyResp
             * @instance
             */
            gangShopBuyResp.prototype.weaponList = $util.emptyArray;

            /**
             * gangShopBuyResp cardList.
             * @member {Array.<luck.protobuf.ICardPB>} cardList
             * @memberof luck.protobuf.gangShopBuyResp
             * @instance
             */
            gangShopBuyResp.prototype.cardList = $util.emptyArray;

            /**
             * gangShopBuyResp clothesList.
             * @member {Array.<luck.protobuf.IClothesPB>} clothesList
             * @memberof luck.protobuf.gangShopBuyResp
             * @instance
             */
            gangShopBuyResp.prototype.clothesList = $util.emptyArray;

            /**
             * gangShopBuyResp propList.
             * @member {Array.<luck.protobuf.IPropPB>} propList
             * @memberof luck.protobuf.gangShopBuyResp
             * @instance
             */
            gangShopBuyResp.prototype.propList = $util.emptyArray;

            /**
             * gangShopBuyResp materialsList.
             * @member {Array.<luck.protobuf.IMaterialsPB>} materialsList
             * @memberof luck.protobuf.gangShopBuyResp
             * @instance
             */
            gangShopBuyResp.prototype.materialsList = $util.emptyArray;

            /**
             * gangShopBuyResp shopGoodsList.
             * @member {Array.<luck.protobuf.IShopGoodsPB>} shopGoodsList
             * @memberof luck.protobuf.gangShopBuyResp
             * @instance
             */
            gangShopBuyResp.prototype.shopGoodsList = $util.emptyArray;

            /**
             * Creates a new gangShopBuyResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.gangShopBuyResp
             * @static
             * @param {luck.protobuf.IgangShopBuyResp=} [properties] Properties to set
             * @returns {luck.protobuf.gangShopBuyResp} gangShopBuyResp instance
             */
            gangShopBuyResp.create = function create(properties) {
                return new gangShopBuyResp(properties);
            };

            /**
             * Encodes the specified gangShopBuyResp message. Does not implicitly {@link luck.protobuf.gangShopBuyResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.gangShopBuyResp
             * @static
             * @param {luck.protobuf.IgangShopBuyResp} message gangShopBuyResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            gangShopBuyResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.gold != null && message.hasOwnProperty("gold"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.gold);
                if (message.weaponList != null && message.weaponList.length)
                    for (var i = 0; i < message.weaponList.length; ++i)
                        $root.luck.protobuf.WeaponPB.encode(message.weaponList[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.cardList != null && message.cardList.length)
                    for (var i = 0; i < message.cardList.length; ++i)
                        $root.luck.protobuf.CardPB.encode(message.cardList[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.clothesList != null && message.clothesList.length)
                    for (var i = 0; i < message.clothesList.length; ++i)
                        $root.luck.protobuf.ClothesPB.encode(message.clothesList[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.propList != null && message.propList.length)
                    for (var i = 0; i < message.propList.length; ++i)
                        $root.luck.protobuf.PropPB.encode(message.propList[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.materialsList != null && message.materialsList.length)
                    for (var i = 0; i < message.materialsList.length; ++i)
                        $root.luck.protobuf.MaterialsPB.encode(message.materialsList[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.shopGoodsList != null && message.shopGoodsList.length)
                    for (var i = 0; i < message.shopGoodsList.length; ++i)
                        $root.luck.protobuf.ShopGoodsPB.encode(message.shopGoodsList[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified gangShopBuyResp message, length delimited. Does not implicitly {@link luck.protobuf.gangShopBuyResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.gangShopBuyResp
             * @static
             * @param {luck.protobuf.IgangShopBuyResp} message gangShopBuyResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            gangShopBuyResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a gangShopBuyResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.gangShopBuyResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.gangShopBuyResp} gangShopBuyResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            gangShopBuyResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.gangShopBuyResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.gold = reader.int64();
                        break;
                    case 3:
                        if (!(message.weaponList && message.weaponList.length))
                            message.weaponList = [];
                        message.weaponList.push($root.luck.protobuf.WeaponPB.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        if (!(message.cardList && message.cardList.length))
                            message.cardList = [];
                        message.cardList.push($root.luck.protobuf.CardPB.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.clothesList && message.clothesList.length))
                            message.clothesList = [];
                        message.clothesList.push($root.luck.protobuf.ClothesPB.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.propList && message.propList.length))
                            message.propList = [];
                        message.propList.push($root.luck.protobuf.PropPB.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        if (!(message.materialsList && message.materialsList.length))
                            message.materialsList = [];
                        message.materialsList.push($root.luck.protobuf.MaterialsPB.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        if (!(message.shopGoodsList && message.shopGoodsList.length))
                            message.shopGoodsList = [];
                        message.shopGoodsList.push($root.luck.protobuf.ShopGoodsPB.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a gangShopBuyResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.gangShopBuyResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.gangShopBuyResp} gangShopBuyResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            gangShopBuyResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a gangShopBuyResp message.
             * @function verify
             * @memberof luck.protobuf.gangShopBuyResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            gangShopBuyResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.gold != null && message.hasOwnProperty("gold"))
                    if (!$util.isInteger(message.gold) && !(message.gold && $util.isInteger(message.gold.low) && $util.isInteger(message.gold.high)))
                        return "gold: integer|Long expected";
                if (message.weaponList != null && message.hasOwnProperty("weaponList")) {
                    if (!Array.isArray(message.weaponList))
                        return "weaponList: array expected";
                    for (var i = 0; i < message.weaponList.length; ++i) {
                        var error = $root.luck.protobuf.WeaponPB.verify(message.weaponList[i]);
                        if (error)
                            return "weaponList." + error;
                    }
                }
                if (message.cardList != null && message.hasOwnProperty("cardList")) {
                    if (!Array.isArray(message.cardList))
                        return "cardList: array expected";
                    for (var i = 0; i < message.cardList.length; ++i) {
                        var error = $root.luck.protobuf.CardPB.verify(message.cardList[i]);
                        if (error)
                            return "cardList." + error;
                    }
                }
                if (message.clothesList != null && message.hasOwnProperty("clothesList")) {
                    if (!Array.isArray(message.clothesList))
                        return "clothesList: array expected";
                    for (var i = 0; i < message.clothesList.length; ++i) {
                        var error = $root.luck.protobuf.ClothesPB.verify(message.clothesList[i]);
                        if (error)
                            return "clothesList." + error;
                    }
                }
                if (message.propList != null && message.hasOwnProperty("propList")) {
                    if (!Array.isArray(message.propList))
                        return "propList: array expected";
                    for (var i = 0; i < message.propList.length; ++i) {
                        var error = $root.luck.protobuf.PropPB.verify(message.propList[i]);
                        if (error)
                            return "propList." + error;
                    }
                }
                if (message.materialsList != null && message.hasOwnProperty("materialsList")) {
                    if (!Array.isArray(message.materialsList))
                        return "materialsList: array expected";
                    for (var i = 0; i < message.materialsList.length; ++i) {
                        var error = $root.luck.protobuf.MaterialsPB.verify(message.materialsList[i]);
                        if (error)
                            return "materialsList." + error;
                    }
                }
                if (message.shopGoodsList != null && message.hasOwnProperty("shopGoodsList")) {
                    if (!Array.isArray(message.shopGoodsList))
                        return "shopGoodsList: array expected";
                    for (var i = 0; i < message.shopGoodsList.length; ++i) {
                        var error = $root.luck.protobuf.ShopGoodsPB.verify(message.shopGoodsList[i]);
                        if (error)
                            return "shopGoodsList." + error;
                    }
                }
                return null;
            };

            return gangShopBuyResp;
        })();

        protobuf.playerFightingResp = (function() {

            /**
             * Properties of a playerFightingResp.
             * @memberof luck.protobuf
             * @interface IplayerFightingResp
             * @property {number} result playerFightingResp result
             * @property {number|Long} fighting playerFightingResp fighting
             */

            /**
             * Constructs a new playerFightingResp.
             * @memberof luck.protobuf
             * @classdesc Represents a playerFightingResp.
             * @implements IplayerFightingResp
             * @constructor
             * @param {luck.protobuf.IplayerFightingResp=} [properties] Properties to set
             */
            function playerFightingResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * playerFightingResp result.
             * @member {number} result
             * @memberof luck.protobuf.playerFightingResp
             * @instance
             */
            playerFightingResp.prototype.result = 0;

            /**
             * playerFightingResp fighting.
             * @member {number|Long} fighting
             * @memberof luck.protobuf.playerFightingResp
             * @instance
             */
            playerFightingResp.prototype.fighting = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new playerFightingResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.playerFightingResp
             * @static
             * @param {luck.protobuf.IplayerFightingResp=} [properties] Properties to set
             * @returns {luck.protobuf.playerFightingResp} playerFightingResp instance
             */
            playerFightingResp.create = function create(properties) {
                return new playerFightingResp(properties);
            };

            /**
             * Encodes the specified playerFightingResp message. Does not implicitly {@link luck.protobuf.playerFightingResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.playerFightingResp
             * @static
             * @param {luck.protobuf.IplayerFightingResp} message playerFightingResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            playerFightingResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.fighting);
                return writer;
            };

            /**
             * Encodes the specified playerFightingResp message, length delimited. Does not implicitly {@link luck.protobuf.playerFightingResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.playerFightingResp
             * @static
             * @param {luck.protobuf.IplayerFightingResp} message playerFightingResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            playerFightingResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a playerFightingResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.playerFightingResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.playerFightingResp} playerFightingResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            playerFightingResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.playerFightingResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.fighting = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                if (!message.hasOwnProperty("fighting"))
                    throw $util.ProtocolError("missing required 'fighting'", { instance: message });
                return message;
            };

            /**
             * Decodes a playerFightingResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.playerFightingResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.playerFightingResp} playerFightingResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            playerFightingResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a playerFightingResp message.
             * @function verify
             * @memberof luck.protobuf.playerFightingResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            playerFightingResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (!$util.isInteger(message.fighting) && !(message.fighting && $util.isInteger(message.fighting.low) && $util.isInteger(message.fighting.high)))
                    return "fighting: integer|Long expected";
                return null;
            };

            return playerFightingResp;
        })();

        protobuf.playerEquipFightingResp = (function() {

            /**
             * Properties of a playerEquipFightingResp.
             * @memberof luck.protobuf
             * @interface IplayerEquipFightingResp
             * @property {number} result playerEquipFightingResp result
             * @property {number|Long} fighting playerEquipFightingResp fighting
             */

            /**
             * Constructs a new playerEquipFightingResp.
             * @memberof luck.protobuf
             * @classdesc Represents a playerEquipFightingResp.
             * @implements IplayerEquipFightingResp
             * @constructor
             * @param {luck.protobuf.IplayerEquipFightingResp=} [properties] Properties to set
             */
            function playerEquipFightingResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * playerEquipFightingResp result.
             * @member {number} result
             * @memberof luck.protobuf.playerEquipFightingResp
             * @instance
             */
            playerEquipFightingResp.prototype.result = 0;

            /**
             * playerEquipFightingResp fighting.
             * @member {number|Long} fighting
             * @memberof luck.protobuf.playerEquipFightingResp
             * @instance
             */
            playerEquipFightingResp.prototype.fighting = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new playerEquipFightingResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.playerEquipFightingResp
             * @static
             * @param {luck.protobuf.IplayerEquipFightingResp=} [properties] Properties to set
             * @returns {luck.protobuf.playerEquipFightingResp} playerEquipFightingResp instance
             */
            playerEquipFightingResp.create = function create(properties) {
                return new playerEquipFightingResp(properties);
            };

            /**
             * Encodes the specified playerEquipFightingResp message. Does not implicitly {@link luck.protobuf.playerEquipFightingResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.playerEquipFightingResp
             * @static
             * @param {luck.protobuf.IplayerEquipFightingResp} message playerEquipFightingResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            playerEquipFightingResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.fighting);
                return writer;
            };

            /**
             * Encodes the specified playerEquipFightingResp message, length delimited. Does not implicitly {@link luck.protobuf.playerEquipFightingResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.playerEquipFightingResp
             * @static
             * @param {luck.protobuf.IplayerEquipFightingResp} message playerEquipFightingResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            playerEquipFightingResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a playerEquipFightingResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.playerEquipFightingResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.playerEquipFightingResp} playerEquipFightingResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            playerEquipFightingResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.playerEquipFightingResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.fighting = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                if (!message.hasOwnProperty("fighting"))
                    throw $util.ProtocolError("missing required 'fighting'", { instance: message });
                return message;
            };

            /**
             * Decodes a playerEquipFightingResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.playerEquipFightingResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.playerEquipFightingResp} playerEquipFightingResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            playerEquipFightingResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a playerEquipFightingResp message.
             * @function verify
             * @memberof luck.protobuf.playerEquipFightingResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            playerEquipFightingResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (!$util.isInteger(message.fighting) && !(message.fighting && $util.isInteger(message.fighting.low) && $util.isInteger(message.fighting.high)))
                    return "fighting: integer|Long expected";
                return null;
            };

            return playerEquipFightingResp;
        })();

        protobuf.rankingResp = (function() {

            /**
             * Properties of a rankingResp.
             * @memberof luck.protobuf
             * @interface IrankingResp
             * @property {number} result rankingResp result
             * @property {Array.<luck.protobuf.IsixStarEquipRankIngPB>|null} [sixStarEquipRankIngList] rankingResp sixStarEquipRankIngList
             * @property {Array.<luck.protobuf.IfightingRankIngPB>|null} [fightingRankingList] rankingResp fightingRankingList
             * @property {Array.<luck.protobuf.IdiamondConsumeRankIngPB>|null} [diamondConsumeRankIngList] rankingResp diamondConsumeRankIngList
             */

            /**
             * Constructs a new rankingResp.
             * @memberof luck.protobuf
             * @classdesc Represents a rankingResp.
             * @implements IrankingResp
             * @constructor
             * @param {luck.protobuf.IrankingResp=} [properties] Properties to set
             */
            function rankingResp(properties) {
                this.sixStarEquipRankIngList = [];
                this.fightingRankingList = [];
                this.diamondConsumeRankIngList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * rankingResp result.
             * @member {number} result
             * @memberof luck.protobuf.rankingResp
             * @instance
             */
            rankingResp.prototype.result = 0;

            /**
             * rankingResp sixStarEquipRankIngList.
             * @member {Array.<luck.protobuf.IsixStarEquipRankIngPB>} sixStarEquipRankIngList
             * @memberof luck.protobuf.rankingResp
             * @instance
             */
            rankingResp.prototype.sixStarEquipRankIngList = $util.emptyArray;

            /**
             * rankingResp fightingRankingList.
             * @member {Array.<luck.protobuf.IfightingRankIngPB>} fightingRankingList
             * @memberof luck.protobuf.rankingResp
             * @instance
             */
            rankingResp.prototype.fightingRankingList = $util.emptyArray;

            /**
             * rankingResp diamondConsumeRankIngList.
             * @member {Array.<luck.protobuf.IdiamondConsumeRankIngPB>} diamondConsumeRankIngList
             * @memberof luck.protobuf.rankingResp
             * @instance
             */
            rankingResp.prototype.diamondConsumeRankIngList = $util.emptyArray;

            /**
             * Creates a new rankingResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.rankingResp
             * @static
             * @param {luck.protobuf.IrankingResp=} [properties] Properties to set
             * @returns {luck.protobuf.rankingResp} rankingResp instance
             */
            rankingResp.create = function create(properties) {
                return new rankingResp(properties);
            };

            /**
             * Encodes the specified rankingResp message. Does not implicitly {@link luck.protobuf.rankingResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.rankingResp
             * @static
             * @param {luck.protobuf.IrankingResp} message rankingResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            rankingResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.sixStarEquipRankIngList != null && message.sixStarEquipRankIngList.length)
                    for (var i = 0; i < message.sixStarEquipRankIngList.length; ++i)
                        $root.luck.protobuf.sixStarEquipRankIngPB.encode(message.sixStarEquipRankIngList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.fightingRankingList != null && message.fightingRankingList.length)
                    for (var i = 0; i < message.fightingRankingList.length; ++i)
                        $root.luck.protobuf.fightingRankIngPB.encode(message.fightingRankingList[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.diamondConsumeRankIngList != null && message.diamondConsumeRankIngList.length)
                    for (var i = 0; i < message.diamondConsumeRankIngList.length; ++i)
                        $root.luck.protobuf.diamondConsumeRankIngPB.encode(message.diamondConsumeRankIngList[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified rankingResp message, length delimited. Does not implicitly {@link luck.protobuf.rankingResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.rankingResp
             * @static
             * @param {luck.protobuf.IrankingResp} message rankingResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            rankingResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a rankingResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.rankingResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.rankingResp} rankingResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            rankingResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.rankingResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        if (!(message.sixStarEquipRankIngList && message.sixStarEquipRankIngList.length))
                            message.sixStarEquipRankIngList = [];
                        message.sixStarEquipRankIngList.push($root.luck.protobuf.sixStarEquipRankIngPB.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.fightingRankingList && message.fightingRankingList.length))
                            message.fightingRankingList = [];
                        message.fightingRankingList.push($root.luck.protobuf.fightingRankIngPB.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        if (!(message.diamondConsumeRankIngList && message.diamondConsumeRankIngList.length))
                            message.diamondConsumeRankIngList = [];
                        message.diamondConsumeRankIngList.push($root.luck.protobuf.diamondConsumeRankIngPB.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a rankingResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.rankingResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.rankingResp} rankingResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            rankingResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a rankingResp message.
             * @function verify
             * @memberof luck.protobuf.rankingResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            rankingResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.sixStarEquipRankIngList != null && message.hasOwnProperty("sixStarEquipRankIngList")) {
                    if (!Array.isArray(message.sixStarEquipRankIngList))
                        return "sixStarEquipRankIngList: array expected";
                    for (var i = 0; i < message.sixStarEquipRankIngList.length; ++i) {
                        var error = $root.luck.protobuf.sixStarEquipRankIngPB.verify(message.sixStarEquipRankIngList[i]);
                        if (error)
                            return "sixStarEquipRankIngList." + error;
                    }
                }
                if (message.fightingRankingList != null && message.hasOwnProperty("fightingRankingList")) {
                    if (!Array.isArray(message.fightingRankingList))
                        return "fightingRankingList: array expected";
                    for (var i = 0; i < message.fightingRankingList.length; ++i) {
                        var error = $root.luck.protobuf.fightingRankIngPB.verify(message.fightingRankingList[i]);
                        if (error)
                            return "fightingRankingList." + error;
                    }
                }
                if (message.diamondConsumeRankIngList != null && message.hasOwnProperty("diamondConsumeRankIngList")) {
                    if (!Array.isArray(message.diamondConsumeRankIngList))
                        return "diamondConsumeRankIngList: array expected";
                    for (var i = 0; i < message.diamondConsumeRankIngList.length; ++i) {
                        var error = $root.luck.protobuf.diamondConsumeRankIngPB.verify(message.diamondConsumeRankIngList[i]);
                        if (error)
                            return "diamondConsumeRankIngList." + error;
                    }
                }
                return null;
            };

            return rankingResp;
        })();

        protobuf.gainAchievementSeriesAwardResp = (function() {

            /**
             * Properties of a gainAchievementSeriesAwardResp.
             * @memberof luck.protobuf
             * @interface IgainAchievementSeriesAwardResp
             * @property {number} result gainAchievementSeriesAwardResp result
             * @property {number|Long|null} [gold] gainAchievementSeriesAwardResp gold
             * @property {number|Long|null} [diamond] gainAchievementSeriesAwardResp diamond
             * @property {Array.<luck.protobuf.IWeaponPB>|null} [weaponList] gainAchievementSeriesAwardResp weaponList
             * @property {Array.<luck.protobuf.ICardPB>|null} [cardList] gainAchievementSeriesAwardResp cardList
             * @property {Array.<luck.protobuf.IClothesPB>|null} [clothesList] gainAchievementSeriesAwardResp clothesList
             * @property {Array.<luck.protobuf.IPropPB>|null} [propList] gainAchievementSeriesAwardResp propList
             * @property {Array.<luck.protobuf.IMaterialsPB>|null} [materialsList] gainAchievementSeriesAwardResp materialsList
             * @property {number|null} [exp] gainAchievementSeriesAwardResp exp
             * @property {number|null} [DailyActivityReward] gainAchievementSeriesAwardResp DailyActivityReward
             * @property {number|null} [gangContribute] gainAchievementSeriesAwardResp gangContribute
             * @property {number|null} [gangExp] gainAchievementSeriesAwardResp gangExp
             */

            /**
             * Constructs a new gainAchievementSeriesAwardResp.
             * @memberof luck.protobuf
             * @classdesc Represents a gainAchievementSeriesAwardResp.
             * @implements IgainAchievementSeriesAwardResp
             * @constructor
             * @param {luck.protobuf.IgainAchievementSeriesAwardResp=} [properties] Properties to set
             */
            function gainAchievementSeriesAwardResp(properties) {
                this.weaponList = [];
                this.cardList = [];
                this.clothesList = [];
                this.propList = [];
                this.materialsList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * gainAchievementSeriesAwardResp result.
             * @member {number} result
             * @memberof luck.protobuf.gainAchievementSeriesAwardResp
             * @instance
             */
            gainAchievementSeriesAwardResp.prototype.result = 0;

            /**
             * gainAchievementSeriesAwardResp gold.
             * @member {number|Long} gold
             * @memberof luck.protobuf.gainAchievementSeriesAwardResp
             * @instance
             */
            gainAchievementSeriesAwardResp.prototype.gold = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * gainAchievementSeriesAwardResp diamond.
             * @member {number|Long} diamond
             * @memberof luck.protobuf.gainAchievementSeriesAwardResp
             * @instance
             */
            gainAchievementSeriesAwardResp.prototype.diamond = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * gainAchievementSeriesAwardResp weaponList.
             * @member {Array.<luck.protobuf.IWeaponPB>} weaponList
             * @memberof luck.protobuf.gainAchievementSeriesAwardResp
             * @instance
             */
            gainAchievementSeriesAwardResp.prototype.weaponList = $util.emptyArray;

            /**
             * gainAchievementSeriesAwardResp cardList.
             * @member {Array.<luck.protobuf.ICardPB>} cardList
             * @memberof luck.protobuf.gainAchievementSeriesAwardResp
             * @instance
             */
            gainAchievementSeriesAwardResp.prototype.cardList = $util.emptyArray;

            /**
             * gainAchievementSeriesAwardResp clothesList.
             * @member {Array.<luck.protobuf.IClothesPB>} clothesList
             * @memberof luck.protobuf.gainAchievementSeriesAwardResp
             * @instance
             */
            gainAchievementSeriesAwardResp.prototype.clothesList = $util.emptyArray;

            /**
             * gainAchievementSeriesAwardResp propList.
             * @member {Array.<luck.protobuf.IPropPB>} propList
             * @memberof luck.protobuf.gainAchievementSeriesAwardResp
             * @instance
             */
            gainAchievementSeriesAwardResp.prototype.propList = $util.emptyArray;

            /**
             * gainAchievementSeriesAwardResp materialsList.
             * @member {Array.<luck.protobuf.IMaterialsPB>} materialsList
             * @memberof luck.protobuf.gainAchievementSeriesAwardResp
             * @instance
             */
            gainAchievementSeriesAwardResp.prototype.materialsList = $util.emptyArray;

            /**
             * gainAchievementSeriesAwardResp exp.
             * @member {number} exp
             * @memberof luck.protobuf.gainAchievementSeriesAwardResp
             * @instance
             */
            gainAchievementSeriesAwardResp.prototype.exp = 0;

            /**
             * gainAchievementSeriesAwardResp DailyActivityReward.
             * @member {number} DailyActivityReward
             * @memberof luck.protobuf.gainAchievementSeriesAwardResp
             * @instance
             */
            gainAchievementSeriesAwardResp.prototype.DailyActivityReward = 0;

            /**
             * gainAchievementSeriesAwardResp gangContribute.
             * @member {number} gangContribute
             * @memberof luck.protobuf.gainAchievementSeriesAwardResp
             * @instance
             */
            gainAchievementSeriesAwardResp.prototype.gangContribute = 0;

            /**
             * gainAchievementSeriesAwardResp gangExp.
             * @member {number} gangExp
             * @memberof luck.protobuf.gainAchievementSeriesAwardResp
             * @instance
             */
            gainAchievementSeriesAwardResp.prototype.gangExp = 0;

            /**
             * Creates a new gainAchievementSeriesAwardResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.gainAchievementSeriesAwardResp
             * @static
             * @param {luck.protobuf.IgainAchievementSeriesAwardResp=} [properties] Properties to set
             * @returns {luck.protobuf.gainAchievementSeriesAwardResp} gainAchievementSeriesAwardResp instance
             */
            gainAchievementSeriesAwardResp.create = function create(properties) {
                return new gainAchievementSeriesAwardResp(properties);
            };

            /**
             * Encodes the specified gainAchievementSeriesAwardResp message. Does not implicitly {@link luck.protobuf.gainAchievementSeriesAwardResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.gainAchievementSeriesAwardResp
             * @static
             * @param {luck.protobuf.IgainAchievementSeriesAwardResp} message gainAchievementSeriesAwardResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            gainAchievementSeriesAwardResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.gold != null && message.hasOwnProperty("gold"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.gold);
                if (message.diamond != null && message.hasOwnProperty("diamond"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.diamond);
                if (message.weaponList != null && message.weaponList.length)
                    for (var i = 0; i < message.weaponList.length; ++i)
                        $root.luck.protobuf.WeaponPB.encode(message.weaponList[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.cardList != null && message.cardList.length)
                    for (var i = 0; i < message.cardList.length; ++i)
                        $root.luck.protobuf.CardPB.encode(message.cardList[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.clothesList != null && message.clothesList.length)
                    for (var i = 0; i < message.clothesList.length; ++i)
                        $root.luck.protobuf.ClothesPB.encode(message.clothesList[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.propList != null && message.propList.length)
                    for (var i = 0; i < message.propList.length; ++i)
                        $root.luck.protobuf.PropPB.encode(message.propList[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.materialsList != null && message.materialsList.length)
                    for (var i = 0; i < message.materialsList.length; ++i)
                        $root.luck.protobuf.MaterialsPB.encode(message.materialsList[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.exp != null && message.hasOwnProperty("exp"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.exp);
                if (message.DailyActivityReward != null && message.hasOwnProperty("DailyActivityReward"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int32(message.DailyActivityReward);
                if (message.gangContribute != null && message.hasOwnProperty("gangContribute"))
                    writer.uint32(/* id 11, wireType 0 =*/88).int32(message.gangContribute);
                if (message.gangExp != null && message.hasOwnProperty("gangExp"))
                    writer.uint32(/* id 12, wireType 0 =*/96).int32(message.gangExp);
                return writer;
            };

            /**
             * Encodes the specified gainAchievementSeriesAwardResp message, length delimited. Does not implicitly {@link luck.protobuf.gainAchievementSeriesAwardResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.gainAchievementSeriesAwardResp
             * @static
             * @param {luck.protobuf.IgainAchievementSeriesAwardResp} message gainAchievementSeriesAwardResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            gainAchievementSeriesAwardResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a gainAchievementSeriesAwardResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.gainAchievementSeriesAwardResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.gainAchievementSeriesAwardResp} gainAchievementSeriesAwardResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            gainAchievementSeriesAwardResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.gainAchievementSeriesAwardResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.gold = reader.int64();
                        break;
                    case 3:
                        message.diamond = reader.int64();
                        break;
                    case 4:
                        if (!(message.weaponList && message.weaponList.length))
                            message.weaponList = [];
                        message.weaponList.push($root.luck.protobuf.WeaponPB.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.cardList && message.cardList.length))
                            message.cardList = [];
                        message.cardList.push($root.luck.protobuf.CardPB.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.clothesList && message.clothesList.length))
                            message.clothesList = [];
                        message.clothesList.push($root.luck.protobuf.ClothesPB.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        if (!(message.propList && message.propList.length))
                            message.propList = [];
                        message.propList.push($root.luck.protobuf.PropPB.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        if (!(message.materialsList && message.materialsList.length))
                            message.materialsList = [];
                        message.materialsList.push($root.luck.protobuf.MaterialsPB.decode(reader, reader.uint32()));
                        break;
                    case 9:
                        message.exp = reader.int32();
                        break;
                    case 10:
                        message.DailyActivityReward = reader.int32();
                        break;
                    case 11:
                        message.gangContribute = reader.int32();
                        break;
                    case 12:
                        message.gangExp = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a gainAchievementSeriesAwardResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.gainAchievementSeriesAwardResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.gainAchievementSeriesAwardResp} gainAchievementSeriesAwardResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            gainAchievementSeriesAwardResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a gainAchievementSeriesAwardResp message.
             * @function verify
             * @memberof luck.protobuf.gainAchievementSeriesAwardResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            gainAchievementSeriesAwardResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.gold != null && message.hasOwnProperty("gold"))
                    if (!$util.isInteger(message.gold) && !(message.gold && $util.isInteger(message.gold.low) && $util.isInteger(message.gold.high)))
                        return "gold: integer|Long expected";
                if (message.diamond != null && message.hasOwnProperty("diamond"))
                    if (!$util.isInteger(message.diamond) && !(message.diamond && $util.isInteger(message.diamond.low) && $util.isInteger(message.diamond.high)))
                        return "diamond: integer|Long expected";
                if (message.weaponList != null && message.hasOwnProperty("weaponList")) {
                    if (!Array.isArray(message.weaponList))
                        return "weaponList: array expected";
                    for (var i = 0; i < message.weaponList.length; ++i) {
                        var error = $root.luck.protobuf.WeaponPB.verify(message.weaponList[i]);
                        if (error)
                            return "weaponList." + error;
                    }
                }
                if (message.cardList != null && message.hasOwnProperty("cardList")) {
                    if (!Array.isArray(message.cardList))
                        return "cardList: array expected";
                    for (var i = 0; i < message.cardList.length; ++i) {
                        var error = $root.luck.protobuf.CardPB.verify(message.cardList[i]);
                        if (error)
                            return "cardList." + error;
                    }
                }
                if (message.clothesList != null && message.hasOwnProperty("clothesList")) {
                    if (!Array.isArray(message.clothesList))
                        return "clothesList: array expected";
                    for (var i = 0; i < message.clothesList.length; ++i) {
                        var error = $root.luck.protobuf.ClothesPB.verify(message.clothesList[i]);
                        if (error)
                            return "clothesList." + error;
                    }
                }
                if (message.propList != null && message.hasOwnProperty("propList")) {
                    if (!Array.isArray(message.propList))
                        return "propList: array expected";
                    for (var i = 0; i < message.propList.length; ++i) {
                        var error = $root.luck.protobuf.PropPB.verify(message.propList[i]);
                        if (error)
                            return "propList." + error;
                    }
                }
                if (message.materialsList != null && message.hasOwnProperty("materialsList")) {
                    if (!Array.isArray(message.materialsList))
                        return "materialsList: array expected";
                    for (var i = 0; i < message.materialsList.length; ++i) {
                        var error = $root.luck.protobuf.MaterialsPB.verify(message.materialsList[i]);
                        if (error)
                            return "materialsList." + error;
                    }
                }
                if (message.exp != null && message.hasOwnProperty("exp"))
                    if (!$util.isInteger(message.exp))
                        return "exp: integer expected";
                if (message.DailyActivityReward != null && message.hasOwnProperty("DailyActivityReward"))
                    if (!$util.isInteger(message.DailyActivityReward))
                        return "DailyActivityReward: integer expected";
                if (message.gangContribute != null && message.hasOwnProperty("gangContribute"))
                    if (!$util.isInteger(message.gangContribute))
                        return "gangContribute: integer expected";
                if (message.gangExp != null && message.hasOwnProperty("gangExp"))
                    if (!$util.isInteger(message.gangExp))
                        return "gangExp: integer expected";
                return null;
            };

            return gainAchievementSeriesAwardResp;
        })();

        protobuf.drawVipRewardResp = (function() {

            /**
             * Properties of a drawVipRewardResp.
             * @memberof luck.protobuf
             * @interface IdrawVipRewardResp
             * @property {number} result drawVipRewardResp result
             * @property {number|Long|null} [gold] drawVipRewardResp gold
             * @property {number|Long|null} [diamond] drawVipRewardResp diamond
             * @property {Array.<luck.protobuf.IWeaponPB>|null} [weaponList] drawVipRewardResp weaponList
             * @property {Array.<luck.protobuf.ICardPB>|null} [cardList] drawVipRewardResp cardList
             * @property {Array.<luck.protobuf.IClothesPB>|null} [clothesList] drawVipRewardResp clothesList
             * @property {Array.<luck.protobuf.IPropPB>|null} [propList] drawVipRewardResp propList
             * @property {Array.<luck.protobuf.IMaterialsPB>|null} [materialsList] drawVipRewardResp materialsList
             */

            /**
             * Constructs a new drawVipRewardResp.
             * @memberof luck.protobuf
             * @classdesc Represents a drawVipRewardResp.
             * @implements IdrawVipRewardResp
             * @constructor
             * @param {luck.protobuf.IdrawVipRewardResp=} [properties] Properties to set
             */
            function drawVipRewardResp(properties) {
                this.weaponList = [];
                this.cardList = [];
                this.clothesList = [];
                this.propList = [];
                this.materialsList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * drawVipRewardResp result.
             * @member {number} result
             * @memberof luck.protobuf.drawVipRewardResp
             * @instance
             */
            drawVipRewardResp.prototype.result = 0;

            /**
             * drawVipRewardResp gold.
             * @member {number|Long} gold
             * @memberof luck.protobuf.drawVipRewardResp
             * @instance
             */
            drawVipRewardResp.prototype.gold = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * drawVipRewardResp diamond.
             * @member {number|Long} diamond
             * @memberof luck.protobuf.drawVipRewardResp
             * @instance
             */
            drawVipRewardResp.prototype.diamond = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * drawVipRewardResp weaponList.
             * @member {Array.<luck.protobuf.IWeaponPB>} weaponList
             * @memberof luck.protobuf.drawVipRewardResp
             * @instance
             */
            drawVipRewardResp.prototype.weaponList = $util.emptyArray;

            /**
             * drawVipRewardResp cardList.
             * @member {Array.<luck.protobuf.ICardPB>} cardList
             * @memberof luck.protobuf.drawVipRewardResp
             * @instance
             */
            drawVipRewardResp.prototype.cardList = $util.emptyArray;

            /**
             * drawVipRewardResp clothesList.
             * @member {Array.<luck.protobuf.IClothesPB>} clothesList
             * @memberof luck.protobuf.drawVipRewardResp
             * @instance
             */
            drawVipRewardResp.prototype.clothesList = $util.emptyArray;

            /**
             * drawVipRewardResp propList.
             * @member {Array.<luck.protobuf.IPropPB>} propList
             * @memberof luck.protobuf.drawVipRewardResp
             * @instance
             */
            drawVipRewardResp.prototype.propList = $util.emptyArray;

            /**
             * drawVipRewardResp materialsList.
             * @member {Array.<luck.protobuf.IMaterialsPB>} materialsList
             * @memberof luck.protobuf.drawVipRewardResp
             * @instance
             */
            drawVipRewardResp.prototype.materialsList = $util.emptyArray;

            /**
             * Creates a new drawVipRewardResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.drawVipRewardResp
             * @static
             * @param {luck.protobuf.IdrawVipRewardResp=} [properties] Properties to set
             * @returns {luck.protobuf.drawVipRewardResp} drawVipRewardResp instance
             */
            drawVipRewardResp.create = function create(properties) {
                return new drawVipRewardResp(properties);
            };

            /**
             * Encodes the specified drawVipRewardResp message. Does not implicitly {@link luck.protobuf.drawVipRewardResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.drawVipRewardResp
             * @static
             * @param {luck.protobuf.IdrawVipRewardResp} message drawVipRewardResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            drawVipRewardResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.gold != null && message.hasOwnProperty("gold"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.gold);
                if (message.diamond != null && message.hasOwnProperty("diamond"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.diamond);
                if (message.weaponList != null && message.weaponList.length)
                    for (var i = 0; i < message.weaponList.length; ++i)
                        $root.luck.protobuf.WeaponPB.encode(message.weaponList[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.cardList != null && message.cardList.length)
                    for (var i = 0; i < message.cardList.length; ++i)
                        $root.luck.protobuf.CardPB.encode(message.cardList[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.clothesList != null && message.clothesList.length)
                    for (var i = 0; i < message.clothesList.length; ++i)
                        $root.luck.protobuf.ClothesPB.encode(message.clothesList[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.propList != null && message.propList.length)
                    for (var i = 0; i < message.propList.length; ++i)
                        $root.luck.protobuf.PropPB.encode(message.propList[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.materialsList != null && message.materialsList.length)
                    for (var i = 0; i < message.materialsList.length; ++i)
                        $root.luck.protobuf.MaterialsPB.encode(message.materialsList[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified drawVipRewardResp message, length delimited. Does not implicitly {@link luck.protobuf.drawVipRewardResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.drawVipRewardResp
             * @static
             * @param {luck.protobuf.IdrawVipRewardResp} message drawVipRewardResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            drawVipRewardResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a drawVipRewardResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.drawVipRewardResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.drawVipRewardResp} drawVipRewardResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            drawVipRewardResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.drawVipRewardResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.gold = reader.int64();
                        break;
                    case 3:
                        message.diamond = reader.int64();
                        break;
                    case 4:
                        if (!(message.weaponList && message.weaponList.length))
                            message.weaponList = [];
                        message.weaponList.push($root.luck.protobuf.WeaponPB.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.cardList && message.cardList.length))
                            message.cardList = [];
                        message.cardList.push($root.luck.protobuf.CardPB.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.clothesList && message.clothesList.length))
                            message.clothesList = [];
                        message.clothesList.push($root.luck.protobuf.ClothesPB.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        if (!(message.propList && message.propList.length))
                            message.propList = [];
                        message.propList.push($root.luck.protobuf.PropPB.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        if (!(message.materialsList && message.materialsList.length))
                            message.materialsList = [];
                        message.materialsList.push($root.luck.protobuf.MaterialsPB.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a drawVipRewardResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.drawVipRewardResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.drawVipRewardResp} drawVipRewardResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            drawVipRewardResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a drawVipRewardResp message.
             * @function verify
             * @memberof luck.protobuf.drawVipRewardResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            drawVipRewardResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.gold != null && message.hasOwnProperty("gold"))
                    if (!$util.isInteger(message.gold) && !(message.gold && $util.isInteger(message.gold.low) && $util.isInteger(message.gold.high)))
                        return "gold: integer|Long expected";
                if (message.diamond != null && message.hasOwnProperty("diamond"))
                    if (!$util.isInteger(message.diamond) && !(message.diamond && $util.isInteger(message.diamond.low) && $util.isInteger(message.diamond.high)))
                        return "diamond: integer|Long expected";
                if (message.weaponList != null && message.hasOwnProperty("weaponList")) {
                    if (!Array.isArray(message.weaponList))
                        return "weaponList: array expected";
                    for (var i = 0; i < message.weaponList.length; ++i) {
                        var error = $root.luck.protobuf.WeaponPB.verify(message.weaponList[i]);
                        if (error)
                            return "weaponList." + error;
                    }
                }
                if (message.cardList != null && message.hasOwnProperty("cardList")) {
                    if (!Array.isArray(message.cardList))
                        return "cardList: array expected";
                    for (var i = 0; i < message.cardList.length; ++i) {
                        var error = $root.luck.protobuf.CardPB.verify(message.cardList[i]);
                        if (error)
                            return "cardList." + error;
                    }
                }
                if (message.clothesList != null && message.hasOwnProperty("clothesList")) {
                    if (!Array.isArray(message.clothesList))
                        return "clothesList: array expected";
                    for (var i = 0; i < message.clothesList.length; ++i) {
                        var error = $root.luck.protobuf.ClothesPB.verify(message.clothesList[i]);
                        if (error)
                            return "clothesList." + error;
                    }
                }
                if (message.propList != null && message.hasOwnProperty("propList")) {
                    if (!Array.isArray(message.propList))
                        return "propList: array expected";
                    for (var i = 0; i < message.propList.length; ++i) {
                        var error = $root.luck.protobuf.PropPB.verify(message.propList[i]);
                        if (error)
                            return "propList." + error;
                    }
                }
                if (message.materialsList != null && message.hasOwnProperty("materialsList")) {
                    if (!Array.isArray(message.materialsList))
                        return "materialsList: array expected";
                    for (var i = 0; i < message.materialsList.length; ++i) {
                        var error = $root.luck.protobuf.MaterialsPB.verify(message.materialsList[i]);
                        if (error)
                            return "materialsList." + error;
                    }
                }
                return null;
            };

            return drawVipRewardResp;
        })();

        protobuf.rechargeResp = (function() {

            /**
             * Properties of a rechargeResp.
             * @memberof luck.protobuf
             * @interface IrechargeResp
             * @property {number} result rechargeResp result
             */

            /**
             * Constructs a new rechargeResp.
             * @memberof luck.protobuf
             * @classdesc Represents a rechargeResp.
             * @implements IrechargeResp
             * @constructor
             * @param {luck.protobuf.IrechargeResp=} [properties] Properties to set
             */
            function rechargeResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * rechargeResp result.
             * @member {number} result
             * @memberof luck.protobuf.rechargeResp
             * @instance
             */
            rechargeResp.prototype.result = 0;

            /**
             * Creates a new rechargeResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.rechargeResp
             * @static
             * @param {luck.protobuf.IrechargeResp=} [properties] Properties to set
             * @returns {luck.protobuf.rechargeResp} rechargeResp instance
             */
            rechargeResp.create = function create(properties) {
                return new rechargeResp(properties);
            };

            /**
             * Encodes the specified rechargeResp message. Does not implicitly {@link luck.protobuf.rechargeResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.rechargeResp
             * @static
             * @param {luck.protobuf.IrechargeResp} message rechargeResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            rechargeResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                return writer;
            };

            /**
             * Encodes the specified rechargeResp message, length delimited. Does not implicitly {@link luck.protobuf.rechargeResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.rechargeResp
             * @static
             * @param {luck.protobuf.IrechargeResp} message rechargeResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            rechargeResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a rechargeResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.rechargeResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.rechargeResp} rechargeResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            rechargeResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.rechargeResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a rechargeResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.rechargeResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.rechargeResp} rechargeResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            rechargeResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a rechargeResp message.
             * @function verify
             * @memberof luck.protobuf.rechargeResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            rechargeResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                return null;
            };

            return rechargeResp;
        })();

        protobuf.WorldNoticePushResp = (function() {

            /**
             * Properties of a WorldNoticePushResp.
             * @memberof luck.protobuf
             * @interface IWorldNoticePushResp
             * @property {number} horseRaceId WorldNoticePushResp horseRaceId
             * @property {string|null} [playerName] WorldNoticePushResp playerName
             * @property {luck.protobuf.IWeaponPB|null} [weapon] WorldNoticePushResp weapon
             * @property {luck.protobuf.IClothesPB|null} [clothes] WorldNoticePushResp clothes
             * @property {luck.protobuf.ICardPB|null} [card] WorldNoticePushResp card
             * @property {luck.protobuf.IMaterialsPB|null} [materials] WorldNoticePushResp materials
             * @property {string|null} [gangName] WorldNoticePushResp gangName
             * @property {number|null} [achievementId] WorldNoticePushResp achievementId
             * @property {string|null} [chatContent] WorldNoticePushResp chatContent
             */

            /**
             * Constructs a new WorldNoticePushResp.
             * @memberof luck.protobuf
             * @classdesc Represents a WorldNoticePushResp.
             * @implements IWorldNoticePushResp
             * @constructor
             * @param {luck.protobuf.IWorldNoticePushResp=} [properties] Properties to set
             */
            function WorldNoticePushResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WorldNoticePushResp horseRaceId.
             * @member {number} horseRaceId
             * @memberof luck.protobuf.WorldNoticePushResp
             * @instance
             */
            WorldNoticePushResp.prototype.horseRaceId = 0;

            /**
             * WorldNoticePushResp playerName.
             * @member {string} playerName
             * @memberof luck.protobuf.WorldNoticePushResp
             * @instance
             */
            WorldNoticePushResp.prototype.playerName = "";

            /**
             * WorldNoticePushResp weapon.
             * @member {luck.protobuf.IWeaponPB|null|undefined} weapon
             * @memberof luck.protobuf.WorldNoticePushResp
             * @instance
             */
            WorldNoticePushResp.prototype.weapon = null;

            /**
             * WorldNoticePushResp clothes.
             * @member {luck.protobuf.IClothesPB|null|undefined} clothes
             * @memberof luck.protobuf.WorldNoticePushResp
             * @instance
             */
            WorldNoticePushResp.prototype.clothes = null;

            /**
             * WorldNoticePushResp card.
             * @member {luck.protobuf.ICardPB|null|undefined} card
             * @memberof luck.protobuf.WorldNoticePushResp
             * @instance
             */
            WorldNoticePushResp.prototype.card = null;

            /**
             * WorldNoticePushResp materials.
             * @member {luck.protobuf.IMaterialsPB|null|undefined} materials
             * @memberof luck.protobuf.WorldNoticePushResp
             * @instance
             */
            WorldNoticePushResp.prototype.materials = null;

            /**
             * WorldNoticePushResp gangName.
             * @member {string} gangName
             * @memberof luck.protobuf.WorldNoticePushResp
             * @instance
             */
            WorldNoticePushResp.prototype.gangName = "";

            /**
             * WorldNoticePushResp achievementId.
             * @member {number} achievementId
             * @memberof luck.protobuf.WorldNoticePushResp
             * @instance
             */
            WorldNoticePushResp.prototype.achievementId = 0;

            /**
             * WorldNoticePushResp chatContent.
             * @member {string} chatContent
             * @memberof luck.protobuf.WorldNoticePushResp
             * @instance
             */
            WorldNoticePushResp.prototype.chatContent = "";

            /**
             * Creates a new WorldNoticePushResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.WorldNoticePushResp
             * @static
             * @param {luck.protobuf.IWorldNoticePushResp=} [properties] Properties to set
             * @returns {luck.protobuf.WorldNoticePushResp} WorldNoticePushResp instance
             */
            WorldNoticePushResp.create = function create(properties) {
                return new WorldNoticePushResp(properties);
            };

            /**
             * Encodes the specified WorldNoticePushResp message. Does not implicitly {@link luck.protobuf.WorldNoticePushResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.WorldNoticePushResp
             * @static
             * @param {luck.protobuf.IWorldNoticePushResp} message WorldNoticePushResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WorldNoticePushResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.horseRaceId);
                if (message.playerName != null && message.hasOwnProperty("playerName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.playerName);
                if (message.weapon != null && message.hasOwnProperty("weapon"))
                    $root.luck.protobuf.WeaponPB.encode(message.weapon, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.clothes != null && message.hasOwnProperty("clothes"))
                    $root.luck.protobuf.ClothesPB.encode(message.clothes, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.card != null && message.hasOwnProperty("card"))
                    $root.luck.protobuf.CardPB.encode(message.card, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.materials != null && message.hasOwnProperty("materials"))
                    $root.luck.protobuf.MaterialsPB.encode(message.materials, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.gangName != null && message.hasOwnProperty("gangName"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.gangName);
                if (message.achievementId != null && message.hasOwnProperty("achievementId"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.achievementId);
                if (message.chatContent != null && message.hasOwnProperty("chatContent"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.chatContent);
                return writer;
            };

            /**
             * Encodes the specified WorldNoticePushResp message, length delimited. Does not implicitly {@link luck.protobuf.WorldNoticePushResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.WorldNoticePushResp
             * @static
             * @param {luck.protobuf.IWorldNoticePushResp} message WorldNoticePushResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WorldNoticePushResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WorldNoticePushResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.WorldNoticePushResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.WorldNoticePushResp} WorldNoticePushResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WorldNoticePushResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.WorldNoticePushResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.horseRaceId = reader.int32();
                        break;
                    case 2:
                        message.playerName = reader.string();
                        break;
                    case 3:
                        message.weapon = $root.luck.protobuf.WeaponPB.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.clothes = $root.luck.protobuf.ClothesPB.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.card = $root.luck.protobuf.CardPB.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.materials = $root.luck.protobuf.MaterialsPB.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.gangName = reader.string();
                        break;
                    case 8:
                        message.achievementId = reader.int32();
                        break;
                    case 9:
                        message.chatContent = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("horseRaceId"))
                    throw $util.ProtocolError("missing required 'horseRaceId'", { instance: message });
                return message;
            };

            /**
             * Decodes a WorldNoticePushResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.WorldNoticePushResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.WorldNoticePushResp} WorldNoticePushResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WorldNoticePushResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WorldNoticePushResp message.
             * @function verify
             * @memberof luck.protobuf.WorldNoticePushResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WorldNoticePushResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.horseRaceId))
                    return "horseRaceId: integer expected";
                if (message.playerName != null && message.hasOwnProperty("playerName"))
                    if (!$util.isString(message.playerName))
                        return "playerName: string expected";
                if (message.weapon != null && message.hasOwnProperty("weapon")) {
                    var error = $root.luck.protobuf.WeaponPB.verify(message.weapon);
                    if (error)
                        return "weapon." + error;
                }
                if (message.clothes != null && message.hasOwnProperty("clothes")) {
                    var error = $root.luck.protobuf.ClothesPB.verify(message.clothes);
                    if (error)
                        return "clothes." + error;
                }
                if (message.card != null && message.hasOwnProperty("card")) {
                    var error = $root.luck.protobuf.CardPB.verify(message.card);
                    if (error)
                        return "card." + error;
                }
                if (message.materials != null && message.hasOwnProperty("materials")) {
                    var error = $root.luck.protobuf.MaterialsPB.verify(message.materials);
                    if (error)
                        return "materials." + error;
                }
                if (message.gangName != null && message.hasOwnProperty("gangName"))
                    if (!$util.isString(message.gangName))
                        return "gangName: string expected";
                if (message.achievementId != null && message.hasOwnProperty("achievementId"))
                    if (!$util.isInteger(message.achievementId))
                        return "achievementId: integer expected";
                if (message.chatContent != null && message.hasOwnProperty("chatContent"))
                    if (!$util.isString(message.chatContent))
                        return "chatContent: string expected";
                return null;
            };

            return WorldNoticePushResp;
        })();

        protobuf.noticeResp = (function() {

            /**
             * Properties of a noticeResp.
             * @memberof luck.protobuf
             * @interface InoticeResp
             * @property {number} result noticeResp result
             * @property {Array.<luck.protobuf.INoticePB>|null} [noticeList] noticeResp noticeList
             */

            /**
             * Constructs a new noticeResp.
             * @memberof luck.protobuf
             * @classdesc Represents a noticeResp.
             * @implements InoticeResp
             * @constructor
             * @param {luck.protobuf.InoticeResp=} [properties] Properties to set
             */
            function noticeResp(properties) {
                this.noticeList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * noticeResp result.
             * @member {number} result
             * @memberof luck.protobuf.noticeResp
             * @instance
             */
            noticeResp.prototype.result = 0;

            /**
             * noticeResp noticeList.
             * @member {Array.<luck.protobuf.INoticePB>} noticeList
             * @memberof luck.protobuf.noticeResp
             * @instance
             */
            noticeResp.prototype.noticeList = $util.emptyArray;

            /**
             * Creates a new noticeResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.noticeResp
             * @static
             * @param {luck.protobuf.InoticeResp=} [properties] Properties to set
             * @returns {luck.protobuf.noticeResp} noticeResp instance
             */
            noticeResp.create = function create(properties) {
                return new noticeResp(properties);
            };

            /**
             * Encodes the specified noticeResp message. Does not implicitly {@link luck.protobuf.noticeResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.noticeResp
             * @static
             * @param {luck.protobuf.InoticeResp} message noticeResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            noticeResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.noticeList != null && message.noticeList.length)
                    for (var i = 0; i < message.noticeList.length; ++i)
                        $root.luck.protobuf.NoticePB.encode(message.noticeList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified noticeResp message, length delimited. Does not implicitly {@link luck.protobuf.noticeResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.noticeResp
             * @static
             * @param {luck.protobuf.InoticeResp} message noticeResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            noticeResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a noticeResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.noticeResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.noticeResp} noticeResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            noticeResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.noticeResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        if (!(message.noticeList && message.noticeList.length))
                            message.noticeList = [];
                        message.noticeList.push($root.luck.protobuf.NoticePB.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a noticeResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.noticeResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.noticeResp} noticeResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            noticeResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a noticeResp message.
             * @function verify
             * @memberof luck.protobuf.noticeResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            noticeResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.noticeList != null && message.hasOwnProperty("noticeList")) {
                    if (!Array.isArray(message.noticeList))
                        return "noticeList: array expected";
                    for (var i = 0; i < message.noticeList.length; ++i) {
                        var error = $root.luck.protobuf.NoticePB.verify(message.noticeList[i]);
                        if (error)
                            return "noticeList." + error;
                    }
                }
                return null;
            };

            return noticeResp;
        })();

        protobuf.PushRepetitionLoginResp = (function() {

            /**
             * Properties of a PushRepetitionLoginResp.
             * @memberof luck.protobuf
             * @interface IPushRepetitionLoginResp
             */

            /**
             * Constructs a new PushRepetitionLoginResp.
             * @memberof luck.protobuf
             * @classdesc Represents a PushRepetitionLoginResp.
             * @implements IPushRepetitionLoginResp
             * @constructor
             * @param {luck.protobuf.IPushRepetitionLoginResp=} [properties] Properties to set
             */
            function PushRepetitionLoginResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new PushRepetitionLoginResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.PushRepetitionLoginResp
             * @static
             * @param {luck.protobuf.IPushRepetitionLoginResp=} [properties] Properties to set
             * @returns {luck.protobuf.PushRepetitionLoginResp} PushRepetitionLoginResp instance
             */
            PushRepetitionLoginResp.create = function create(properties) {
                return new PushRepetitionLoginResp(properties);
            };

            /**
             * Encodes the specified PushRepetitionLoginResp message. Does not implicitly {@link luck.protobuf.PushRepetitionLoginResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.PushRepetitionLoginResp
             * @static
             * @param {luck.protobuf.IPushRepetitionLoginResp} message PushRepetitionLoginResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PushRepetitionLoginResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified PushRepetitionLoginResp message, length delimited. Does not implicitly {@link luck.protobuf.PushRepetitionLoginResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.PushRepetitionLoginResp
             * @static
             * @param {luck.protobuf.IPushRepetitionLoginResp} message PushRepetitionLoginResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PushRepetitionLoginResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PushRepetitionLoginResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.PushRepetitionLoginResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.PushRepetitionLoginResp} PushRepetitionLoginResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PushRepetitionLoginResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.PushRepetitionLoginResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PushRepetitionLoginResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.PushRepetitionLoginResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.PushRepetitionLoginResp} PushRepetitionLoginResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PushRepetitionLoginResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PushRepetitionLoginResp message.
             * @function verify
             * @memberof luck.protobuf.PushRepetitionLoginResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PushRepetitionLoginResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            return PushRepetitionLoginResp;
        })();

        protobuf.GangUpdatePushResp = (function() {

            /**
             * Properties of a GangUpdatePushResp.
             * @memberof luck.protobuf
             * @interface IGangUpdatePushResp
             * @property {luck.protobuf.IGangPB} gang GangUpdatePushResp gang
             */

            /**
             * Constructs a new GangUpdatePushResp.
             * @memberof luck.protobuf
             * @classdesc Represents a GangUpdatePushResp.
             * @implements IGangUpdatePushResp
             * @constructor
             * @param {luck.protobuf.IGangUpdatePushResp=} [properties] Properties to set
             */
            function GangUpdatePushResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GangUpdatePushResp gang.
             * @member {luck.protobuf.IGangPB} gang
             * @memberof luck.protobuf.GangUpdatePushResp
             * @instance
             */
            GangUpdatePushResp.prototype.gang = null;

            /**
             * Creates a new GangUpdatePushResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.GangUpdatePushResp
             * @static
             * @param {luck.protobuf.IGangUpdatePushResp=} [properties] Properties to set
             * @returns {luck.protobuf.GangUpdatePushResp} GangUpdatePushResp instance
             */
            GangUpdatePushResp.create = function create(properties) {
                return new GangUpdatePushResp(properties);
            };

            /**
             * Encodes the specified GangUpdatePushResp message. Does not implicitly {@link luck.protobuf.GangUpdatePushResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.GangUpdatePushResp
             * @static
             * @param {luck.protobuf.IGangUpdatePushResp} message GangUpdatePushResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GangUpdatePushResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                $root.luck.protobuf.GangPB.encode(message.gang, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GangUpdatePushResp message, length delimited. Does not implicitly {@link luck.protobuf.GangUpdatePushResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.GangUpdatePushResp
             * @static
             * @param {luck.protobuf.IGangUpdatePushResp} message GangUpdatePushResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GangUpdatePushResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GangUpdatePushResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.GangUpdatePushResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.GangUpdatePushResp} GangUpdatePushResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GangUpdatePushResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.GangUpdatePushResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.gang = $root.luck.protobuf.GangPB.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("gang"))
                    throw $util.ProtocolError("missing required 'gang'", { instance: message });
                return message;
            };

            /**
             * Decodes a GangUpdatePushResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.GangUpdatePushResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.GangUpdatePushResp} GangUpdatePushResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GangUpdatePushResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GangUpdatePushResp message.
             * @function verify
             * @memberof luck.protobuf.GangUpdatePushResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GangUpdatePushResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                {
                    var error = $root.luck.protobuf.GangPB.verify(message.gang);
                    if (error)
                        return "gang." + error;
                }
                return null;
            };

            return GangUpdatePushResp;
        })();

        protobuf.AddBlackListResp = (function() {

            /**
             * Properties of an AddBlackListResp.
             * @memberof luck.protobuf
             * @interface IAddBlackListResp
             * @property {number} result AddBlackListResp result
             * @property {Array.<luck.protobuf.ISimplePlayerPB>|null} [blackList] AddBlackListResp blackList
             */

            /**
             * Constructs a new AddBlackListResp.
             * @memberof luck.protobuf
             * @classdesc Represents an AddBlackListResp.
             * @implements IAddBlackListResp
             * @constructor
             * @param {luck.protobuf.IAddBlackListResp=} [properties] Properties to set
             */
            function AddBlackListResp(properties) {
                this.blackList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AddBlackListResp result.
             * @member {number} result
             * @memberof luck.protobuf.AddBlackListResp
             * @instance
             */
            AddBlackListResp.prototype.result = 0;

            /**
             * AddBlackListResp blackList.
             * @member {Array.<luck.protobuf.ISimplePlayerPB>} blackList
             * @memberof luck.protobuf.AddBlackListResp
             * @instance
             */
            AddBlackListResp.prototype.blackList = $util.emptyArray;

            /**
             * Creates a new AddBlackListResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.AddBlackListResp
             * @static
             * @param {luck.protobuf.IAddBlackListResp=} [properties] Properties to set
             * @returns {luck.protobuf.AddBlackListResp} AddBlackListResp instance
             */
            AddBlackListResp.create = function create(properties) {
                return new AddBlackListResp(properties);
            };

            /**
             * Encodes the specified AddBlackListResp message. Does not implicitly {@link luck.protobuf.AddBlackListResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.AddBlackListResp
             * @static
             * @param {luck.protobuf.IAddBlackListResp} message AddBlackListResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AddBlackListResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.blackList != null && message.blackList.length)
                    for (var i = 0; i < message.blackList.length; ++i)
                        $root.luck.protobuf.SimplePlayerPB.encode(message.blackList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified AddBlackListResp message, length delimited. Does not implicitly {@link luck.protobuf.AddBlackListResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.AddBlackListResp
             * @static
             * @param {luck.protobuf.IAddBlackListResp} message AddBlackListResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AddBlackListResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AddBlackListResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.AddBlackListResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.AddBlackListResp} AddBlackListResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AddBlackListResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.AddBlackListResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        if (!(message.blackList && message.blackList.length))
                            message.blackList = [];
                        message.blackList.push($root.luck.protobuf.SimplePlayerPB.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes an AddBlackListResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.AddBlackListResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.AddBlackListResp} AddBlackListResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AddBlackListResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AddBlackListResp message.
             * @function verify
             * @memberof luck.protobuf.AddBlackListResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AddBlackListResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.blackList != null && message.hasOwnProperty("blackList")) {
                    if (!Array.isArray(message.blackList))
                        return "blackList: array expected";
                    for (var i = 0; i < message.blackList.length; ++i) {
                        var error = $root.luck.protobuf.SimplePlayerPB.verify(message.blackList[i]);
                        if (error)
                            return "blackList." + error;
                    }
                }
                return null;
            };

            return AddBlackListResp;
        })();

        protobuf.DelBlackListResp = (function() {

            /**
             * Properties of a DelBlackListResp.
             * @memberof luck.protobuf
             * @interface IDelBlackListResp
             * @property {number} result DelBlackListResp result
             * @property {Array.<luck.protobuf.ISimplePlayerPB>|null} [blackList] DelBlackListResp blackList
             */

            /**
             * Constructs a new DelBlackListResp.
             * @memberof luck.protobuf
             * @classdesc Represents a DelBlackListResp.
             * @implements IDelBlackListResp
             * @constructor
             * @param {luck.protobuf.IDelBlackListResp=} [properties] Properties to set
             */
            function DelBlackListResp(properties) {
                this.blackList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DelBlackListResp result.
             * @member {number} result
             * @memberof luck.protobuf.DelBlackListResp
             * @instance
             */
            DelBlackListResp.prototype.result = 0;

            /**
             * DelBlackListResp blackList.
             * @member {Array.<luck.protobuf.ISimplePlayerPB>} blackList
             * @memberof luck.protobuf.DelBlackListResp
             * @instance
             */
            DelBlackListResp.prototype.blackList = $util.emptyArray;

            /**
             * Creates a new DelBlackListResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.DelBlackListResp
             * @static
             * @param {luck.protobuf.IDelBlackListResp=} [properties] Properties to set
             * @returns {luck.protobuf.DelBlackListResp} DelBlackListResp instance
             */
            DelBlackListResp.create = function create(properties) {
                return new DelBlackListResp(properties);
            };

            /**
             * Encodes the specified DelBlackListResp message. Does not implicitly {@link luck.protobuf.DelBlackListResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.DelBlackListResp
             * @static
             * @param {luck.protobuf.IDelBlackListResp} message DelBlackListResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DelBlackListResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.blackList != null && message.blackList.length)
                    for (var i = 0; i < message.blackList.length; ++i)
                        $root.luck.protobuf.SimplePlayerPB.encode(message.blackList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DelBlackListResp message, length delimited. Does not implicitly {@link luck.protobuf.DelBlackListResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.DelBlackListResp
             * @static
             * @param {luck.protobuf.IDelBlackListResp} message DelBlackListResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DelBlackListResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DelBlackListResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.DelBlackListResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.DelBlackListResp} DelBlackListResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DelBlackListResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.DelBlackListResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        if (!(message.blackList && message.blackList.length))
                            message.blackList = [];
                        message.blackList.push($root.luck.protobuf.SimplePlayerPB.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a DelBlackListResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.DelBlackListResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.DelBlackListResp} DelBlackListResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DelBlackListResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DelBlackListResp message.
             * @function verify
             * @memberof luck.protobuf.DelBlackListResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DelBlackListResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.blackList != null && message.hasOwnProperty("blackList")) {
                    if (!Array.isArray(message.blackList))
                        return "blackList: array expected";
                    for (var i = 0; i < message.blackList.length; ++i) {
                        var error = $root.luck.protobuf.SimplePlayerPB.verify(message.blackList[i]);
                        if (error)
                            return "blackList." + error;
                    }
                }
                return null;
            };

            return DelBlackListResp;
        })();

        protobuf.buyGrowthCapitalResp = (function() {

            /**
             * Properties of a buyGrowthCapitalResp.
             * @memberof luck.protobuf
             * @interface IbuyGrowthCapitalResp
             * @property {number} result buyGrowthCapitalResp result
             */

            /**
             * Constructs a new buyGrowthCapitalResp.
             * @memberof luck.protobuf
             * @classdesc Represents a buyGrowthCapitalResp.
             * @implements IbuyGrowthCapitalResp
             * @constructor
             * @param {luck.protobuf.IbuyGrowthCapitalResp=} [properties] Properties to set
             */
            function buyGrowthCapitalResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * buyGrowthCapitalResp result.
             * @member {number} result
             * @memberof luck.protobuf.buyGrowthCapitalResp
             * @instance
             */
            buyGrowthCapitalResp.prototype.result = 0;

            /**
             * Creates a new buyGrowthCapitalResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.buyGrowthCapitalResp
             * @static
             * @param {luck.protobuf.IbuyGrowthCapitalResp=} [properties] Properties to set
             * @returns {luck.protobuf.buyGrowthCapitalResp} buyGrowthCapitalResp instance
             */
            buyGrowthCapitalResp.create = function create(properties) {
                return new buyGrowthCapitalResp(properties);
            };

            /**
             * Encodes the specified buyGrowthCapitalResp message. Does not implicitly {@link luck.protobuf.buyGrowthCapitalResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.buyGrowthCapitalResp
             * @static
             * @param {luck.protobuf.IbuyGrowthCapitalResp} message buyGrowthCapitalResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            buyGrowthCapitalResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                return writer;
            };

            /**
             * Encodes the specified buyGrowthCapitalResp message, length delimited. Does not implicitly {@link luck.protobuf.buyGrowthCapitalResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.buyGrowthCapitalResp
             * @static
             * @param {luck.protobuf.IbuyGrowthCapitalResp} message buyGrowthCapitalResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            buyGrowthCapitalResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a buyGrowthCapitalResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.buyGrowthCapitalResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.buyGrowthCapitalResp} buyGrowthCapitalResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            buyGrowthCapitalResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.buyGrowthCapitalResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a buyGrowthCapitalResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.buyGrowthCapitalResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.buyGrowthCapitalResp} buyGrowthCapitalResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            buyGrowthCapitalResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a buyGrowthCapitalResp message.
             * @function verify
             * @memberof luck.protobuf.buyGrowthCapitalResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            buyGrowthCapitalResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                return null;
            };

            return buyGrowthCapitalResp;
        })();

        protobuf.loadActivityShopResp = (function() {

            /**
             * Properties of a loadActivityShopResp.
             * @memberof luck.protobuf
             * @interface IloadActivityShopResp
             * @property {number} result loadActivityShopResp result
             * @property {Array.<luck.protobuf.IShopGoodsPB>|null} [shopGoodsList] loadActivityShopResp shopGoodsList
             */

            /**
             * Constructs a new loadActivityShopResp.
             * @memberof luck.protobuf
             * @classdesc Represents a loadActivityShopResp.
             * @implements IloadActivityShopResp
             * @constructor
             * @param {luck.protobuf.IloadActivityShopResp=} [properties] Properties to set
             */
            function loadActivityShopResp(properties) {
                this.shopGoodsList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * loadActivityShopResp result.
             * @member {number} result
             * @memberof luck.protobuf.loadActivityShopResp
             * @instance
             */
            loadActivityShopResp.prototype.result = 0;

            /**
             * loadActivityShopResp shopGoodsList.
             * @member {Array.<luck.protobuf.IShopGoodsPB>} shopGoodsList
             * @memberof luck.protobuf.loadActivityShopResp
             * @instance
             */
            loadActivityShopResp.prototype.shopGoodsList = $util.emptyArray;

            /**
             * Creates a new loadActivityShopResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.loadActivityShopResp
             * @static
             * @param {luck.protobuf.IloadActivityShopResp=} [properties] Properties to set
             * @returns {luck.protobuf.loadActivityShopResp} loadActivityShopResp instance
             */
            loadActivityShopResp.create = function create(properties) {
                return new loadActivityShopResp(properties);
            };

            /**
             * Encodes the specified loadActivityShopResp message. Does not implicitly {@link luck.protobuf.loadActivityShopResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.loadActivityShopResp
             * @static
             * @param {luck.protobuf.IloadActivityShopResp} message loadActivityShopResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            loadActivityShopResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.shopGoodsList != null && message.shopGoodsList.length)
                    for (var i = 0; i < message.shopGoodsList.length; ++i)
                        $root.luck.protobuf.ShopGoodsPB.encode(message.shopGoodsList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified loadActivityShopResp message, length delimited. Does not implicitly {@link luck.protobuf.loadActivityShopResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.loadActivityShopResp
             * @static
             * @param {luck.protobuf.IloadActivityShopResp} message loadActivityShopResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            loadActivityShopResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a loadActivityShopResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.loadActivityShopResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.loadActivityShopResp} loadActivityShopResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            loadActivityShopResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.loadActivityShopResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        if (!(message.shopGoodsList && message.shopGoodsList.length))
                            message.shopGoodsList = [];
                        message.shopGoodsList.push($root.luck.protobuf.ShopGoodsPB.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a loadActivityShopResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.loadActivityShopResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.loadActivityShopResp} loadActivityShopResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            loadActivityShopResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a loadActivityShopResp message.
             * @function verify
             * @memberof luck.protobuf.loadActivityShopResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            loadActivityShopResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.shopGoodsList != null && message.hasOwnProperty("shopGoodsList")) {
                    if (!Array.isArray(message.shopGoodsList))
                        return "shopGoodsList: array expected";
                    for (var i = 0; i < message.shopGoodsList.length; ++i) {
                        var error = $root.luck.protobuf.ShopGoodsPB.verify(message.shopGoodsList[i]);
                        if (error)
                            return "shopGoodsList." + error;
                    }
                }
                return null;
            };

            return loadActivityShopResp;
        })();

        protobuf.activityShopBuyResp = (function() {

            /**
             * Properties of an activityShopBuyResp.
             * @memberof luck.protobuf
             * @interface IactivityShopBuyResp
             * @property {number} result activityShopBuyResp result
             * @property {number|Long|null} [gold] activityShopBuyResp gold
             * @property {Array.<luck.protobuf.IWeaponPB>|null} [weaponList] activityShopBuyResp weaponList
             * @property {Array.<luck.protobuf.ICardPB>|null} [cardList] activityShopBuyResp cardList
             * @property {Array.<luck.protobuf.IClothesPB>|null} [clothesList] activityShopBuyResp clothesList
             * @property {Array.<luck.protobuf.IPropPB>|null} [propList] activityShopBuyResp propList
             * @property {Array.<luck.protobuf.IMaterialsPB>|null} [materialsList] activityShopBuyResp materialsList
             * @property {Array.<luck.protobuf.IShopGoodsPB>|null} [shopGoodsList] activityShopBuyResp shopGoodsList
             */

            /**
             * Constructs a new activityShopBuyResp.
             * @memberof luck.protobuf
             * @classdesc Represents an activityShopBuyResp.
             * @implements IactivityShopBuyResp
             * @constructor
             * @param {luck.protobuf.IactivityShopBuyResp=} [properties] Properties to set
             */
            function activityShopBuyResp(properties) {
                this.weaponList = [];
                this.cardList = [];
                this.clothesList = [];
                this.propList = [];
                this.materialsList = [];
                this.shopGoodsList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * activityShopBuyResp result.
             * @member {number} result
             * @memberof luck.protobuf.activityShopBuyResp
             * @instance
             */
            activityShopBuyResp.prototype.result = 0;

            /**
             * activityShopBuyResp gold.
             * @member {number|Long} gold
             * @memberof luck.protobuf.activityShopBuyResp
             * @instance
             */
            activityShopBuyResp.prototype.gold = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * activityShopBuyResp weaponList.
             * @member {Array.<luck.protobuf.IWeaponPB>} weaponList
             * @memberof luck.protobuf.activityShopBuyResp
             * @instance
             */
            activityShopBuyResp.prototype.weaponList = $util.emptyArray;

            /**
             * activityShopBuyResp cardList.
             * @member {Array.<luck.protobuf.ICardPB>} cardList
             * @memberof luck.protobuf.activityShopBuyResp
             * @instance
             */
            activityShopBuyResp.prototype.cardList = $util.emptyArray;

            /**
             * activityShopBuyResp clothesList.
             * @member {Array.<luck.protobuf.IClothesPB>} clothesList
             * @memberof luck.protobuf.activityShopBuyResp
             * @instance
             */
            activityShopBuyResp.prototype.clothesList = $util.emptyArray;

            /**
             * activityShopBuyResp propList.
             * @member {Array.<luck.protobuf.IPropPB>} propList
             * @memberof luck.protobuf.activityShopBuyResp
             * @instance
             */
            activityShopBuyResp.prototype.propList = $util.emptyArray;

            /**
             * activityShopBuyResp materialsList.
             * @member {Array.<luck.protobuf.IMaterialsPB>} materialsList
             * @memberof luck.protobuf.activityShopBuyResp
             * @instance
             */
            activityShopBuyResp.prototype.materialsList = $util.emptyArray;

            /**
             * activityShopBuyResp shopGoodsList.
             * @member {Array.<luck.protobuf.IShopGoodsPB>} shopGoodsList
             * @memberof luck.protobuf.activityShopBuyResp
             * @instance
             */
            activityShopBuyResp.prototype.shopGoodsList = $util.emptyArray;

            /**
             * Creates a new activityShopBuyResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.activityShopBuyResp
             * @static
             * @param {luck.protobuf.IactivityShopBuyResp=} [properties] Properties to set
             * @returns {luck.protobuf.activityShopBuyResp} activityShopBuyResp instance
             */
            activityShopBuyResp.create = function create(properties) {
                return new activityShopBuyResp(properties);
            };

            /**
             * Encodes the specified activityShopBuyResp message. Does not implicitly {@link luck.protobuf.activityShopBuyResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.activityShopBuyResp
             * @static
             * @param {luck.protobuf.IactivityShopBuyResp} message activityShopBuyResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            activityShopBuyResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.gold != null && message.hasOwnProperty("gold"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.gold);
                if (message.weaponList != null && message.weaponList.length)
                    for (var i = 0; i < message.weaponList.length; ++i)
                        $root.luck.protobuf.WeaponPB.encode(message.weaponList[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.cardList != null && message.cardList.length)
                    for (var i = 0; i < message.cardList.length; ++i)
                        $root.luck.protobuf.CardPB.encode(message.cardList[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.clothesList != null && message.clothesList.length)
                    for (var i = 0; i < message.clothesList.length; ++i)
                        $root.luck.protobuf.ClothesPB.encode(message.clothesList[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.propList != null && message.propList.length)
                    for (var i = 0; i < message.propList.length; ++i)
                        $root.luck.protobuf.PropPB.encode(message.propList[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.materialsList != null && message.materialsList.length)
                    for (var i = 0; i < message.materialsList.length; ++i)
                        $root.luck.protobuf.MaterialsPB.encode(message.materialsList[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.shopGoodsList != null && message.shopGoodsList.length)
                    for (var i = 0; i < message.shopGoodsList.length; ++i)
                        $root.luck.protobuf.ShopGoodsPB.encode(message.shopGoodsList[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified activityShopBuyResp message, length delimited. Does not implicitly {@link luck.protobuf.activityShopBuyResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.activityShopBuyResp
             * @static
             * @param {luck.protobuf.IactivityShopBuyResp} message activityShopBuyResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            activityShopBuyResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an activityShopBuyResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.activityShopBuyResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.activityShopBuyResp} activityShopBuyResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            activityShopBuyResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.activityShopBuyResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.gold = reader.int64();
                        break;
                    case 3:
                        if (!(message.weaponList && message.weaponList.length))
                            message.weaponList = [];
                        message.weaponList.push($root.luck.protobuf.WeaponPB.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        if (!(message.cardList && message.cardList.length))
                            message.cardList = [];
                        message.cardList.push($root.luck.protobuf.CardPB.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.clothesList && message.clothesList.length))
                            message.clothesList = [];
                        message.clothesList.push($root.luck.protobuf.ClothesPB.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.propList && message.propList.length))
                            message.propList = [];
                        message.propList.push($root.luck.protobuf.PropPB.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        if (!(message.materialsList && message.materialsList.length))
                            message.materialsList = [];
                        message.materialsList.push($root.luck.protobuf.MaterialsPB.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        if (!(message.shopGoodsList && message.shopGoodsList.length))
                            message.shopGoodsList = [];
                        message.shopGoodsList.push($root.luck.protobuf.ShopGoodsPB.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes an activityShopBuyResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.activityShopBuyResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.activityShopBuyResp} activityShopBuyResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            activityShopBuyResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an activityShopBuyResp message.
             * @function verify
             * @memberof luck.protobuf.activityShopBuyResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            activityShopBuyResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.gold != null && message.hasOwnProperty("gold"))
                    if (!$util.isInteger(message.gold) && !(message.gold && $util.isInteger(message.gold.low) && $util.isInteger(message.gold.high)))
                        return "gold: integer|Long expected";
                if (message.weaponList != null && message.hasOwnProperty("weaponList")) {
                    if (!Array.isArray(message.weaponList))
                        return "weaponList: array expected";
                    for (var i = 0; i < message.weaponList.length; ++i) {
                        var error = $root.luck.protobuf.WeaponPB.verify(message.weaponList[i]);
                        if (error)
                            return "weaponList." + error;
                    }
                }
                if (message.cardList != null && message.hasOwnProperty("cardList")) {
                    if (!Array.isArray(message.cardList))
                        return "cardList: array expected";
                    for (var i = 0; i < message.cardList.length; ++i) {
                        var error = $root.luck.protobuf.CardPB.verify(message.cardList[i]);
                        if (error)
                            return "cardList." + error;
                    }
                }
                if (message.clothesList != null && message.hasOwnProperty("clothesList")) {
                    if (!Array.isArray(message.clothesList))
                        return "clothesList: array expected";
                    for (var i = 0; i < message.clothesList.length; ++i) {
                        var error = $root.luck.protobuf.ClothesPB.verify(message.clothesList[i]);
                        if (error)
                            return "clothesList." + error;
                    }
                }
                if (message.propList != null && message.hasOwnProperty("propList")) {
                    if (!Array.isArray(message.propList))
                        return "propList: array expected";
                    for (var i = 0; i < message.propList.length; ++i) {
                        var error = $root.luck.protobuf.PropPB.verify(message.propList[i]);
                        if (error)
                            return "propList." + error;
                    }
                }
                if (message.materialsList != null && message.hasOwnProperty("materialsList")) {
                    if (!Array.isArray(message.materialsList))
                        return "materialsList: array expected";
                    for (var i = 0; i < message.materialsList.length; ++i) {
                        var error = $root.luck.protobuf.MaterialsPB.verify(message.materialsList[i]);
                        if (error)
                            return "materialsList." + error;
                    }
                }
                if (message.shopGoodsList != null && message.hasOwnProperty("shopGoodsList")) {
                    if (!Array.isArray(message.shopGoodsList))
                        return "shopGoodsList: array expected";
                    for (var i = 0; i < message.shopGoodsList.length; ++i) {
                        var error = $root.luck.protobuf.ShopGoodsPB.verify(message.shopGoodsList[i]);
                        if (error)
                            return "shopGoodsList." + error;
                    }
                }
                return null;
            };

            return activityShopBuyResp;
        })();

        protobuf.getDiggingResp = (function() {

            /**
             * Properties of a getDiggingResp.
             * @memberof luck.protobuf
             * @interface IgetDiggingResp
             * @property {number} result getDiggingResp result
             * @property {luck.protobuf.IDiggingPB} digging getDiggingResp digging
             */

            /**
             * Constructs a new getDiggingResp.
             * @memberof luck.protobuf
             * @classdesc Represents a getDiggingResp.
             * @implements IgetDiggingResp
             * @constructor
             * @param {luck.protobuf.IgetDiggingResp=} [properties] Properties to set
             */
            function getDiggingResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * getDiggingResp result.
             * @member {number} result
             * @memberof luck.protobuf.getDiggingResp
             * @instance
             */
            getDiggingResp.prototype.result = 0;

            /**
             * getDiggingResp digging.
             * @member {luck.protobuf.IDiggingPB} digging
             * @memberof luck.protobuf.getDiggingResp
             * @instance
             */
            getDiggingResp.prototype.digging = null;

            /**
             * Creates a new getDiggingResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.getDiggingResp
             * @static
             * @param {luck.protobuf.IgetDiggingResp=} [properties] Properties to set
             * @returns {luck.protobuf.getDiggingResp} getDiggingResp instance
             */
            getDiggingResp.create = function create(properties) {
                return new getDiggingResp(properties);
            };

            /**
             * Encodes the specified getDiggingResp message. Does not implicitly {@link luck.protobuf.getDiggingResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.getDiggingResp
             * @static
             * @param {luck.protobuf.IgetDiggingResp} message getDiggingResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            getDiggingResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                $root.luck.protobuf.DiggingPB.encode(message.digging, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified getDiggingResp message, length delimited. Does not implicitly {@link luck.protobuf.getDiggingResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.getDiggingResp
             * @static
             * @param {luck.protobuf.IgetDiggingResp} message getDiggingResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            getDiggingResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a getDiggingResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.getDiggingResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.getDiggingResp} getDiggingResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            getDiggingResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.getDiggingResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.digging = $root.luck.protobuf.DiggingPB.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                if (!message.hasOwnProperty("digging"))
                    throw $util.ProtocolError("missing required 'digging'", { instance: message });
                return message;
            };

            /**
             * Decodes a getDiggingResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.getDiggingResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.getDiggingResp} getDiggingResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            getDiggingResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a getDiggingResp message.
             * @function verify
             * @memberof luck.protobuf.getDiggingResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            getDiggingResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                {
                    var error = $root.luck.protobuf.DiggingPB.verify(message.digging);
                    if (error)
                        return "digging." + error;
                }
                return null;
            };

            return getDiggingResp;
        })();

        protobuf.refreshDiggingResp = (function() {

            /**
             * Properties of a refreshDiggingResp.
             * @memberof luck.protobuf
             * @interface IrefreshDiggingResp
             * @property {number} result refreshDiggingResp result
             * @property {luck.protobuf.IDiggingPB} digging refreshDiggingResp digging
             */

            /**
             * Constructs a new refreshDiggingResp.
             * @memberof luck.protobuf
             * @classdesc Represents a refreshDiggingResp.
             * @implements IrefreshDiggingResp
             * @constructor
             * @param {luck.protobuf.IrefreshDiggingResp=} [properties] Properties to set
             */
            function refreshDiggingResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * refreshDiggingResp result.
             * @member {number} result
             * @memberof luck.protobuf.refreshDiggingResp
             * @instance
             */
            refreshDiggingResp.prototype.result = 0;

            /**
             * refreshDiggingResp digging.
             * @member {luck.protobuf.IDiggingPB} digging
             * @memberof luck.protobuf.refreshDiggingResp
             * @instance
             */
            refreshDiggingResp.prototype.digging = null;

            /**
             * Creates a new refreshDiggingResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.refreshDiggingResp
             * @static
             * @param {luck.protobuf.IrefreshDiggingResp=} [properties] Properties to set
             * @returns {luck.protobuf.refreshDiggingResp} refreshDiggingResp instance
             */
            refreshDiggingResp.create = function create(properties) {
                return new refreshDiggingResp(properties);
            };

            /**
             * Encodes the specified refreshDiggingResp message. Does not implicitly {@link luck.protobuf.refreshDiggingResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.refreshDiggingResp
             * @static
             * @param {luck.protobuf.IrefreshDiggingResp} message refreshDiggingResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            refreshDiggingResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                $root.luck.protobuf.DiggingPB.encode(message.digging, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified refreshDiggingResp message, length delimited. Does not implicitly {@link luck.protobuf.refreshDiggingResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.refreshDiggingResp
             * @static
             * @param {luck.protobuf.IrefreshDiggingResp} message refreshDiggingResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            refreshDiggingResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a refreshDiggingResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.refreshDiggingResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.refreshDiggingResp} refreshDiggingResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            refreshDiggingResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.refreshDiggingResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.digging = $root.luck.protobuf.DiggingPB.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                if (!message.hasOwnProperty("digging"))
                    throw $util.ProtocolError("missing required 'digging'", { instance: message });
                return message;
            };

            /**
             * Decodes a refreshDiggingResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.refreshDiggingResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.refreshDiggingResp} refreshDiggingResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            refreshDiggingResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a refreshDiggingResp message.
             * @function verify
             * @memberof luck.protobuf.refreshDiggingResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            refreshDiggingResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                {
                    var error = $root.luck.protobuf.DiggingPB.verify(message.digging);
                    if (error)
                        return "digging." + error;
                }
                return null;
            };

            return refreshDiggingResp;
        })();

        protobuf.getDiggingAwardResp = (function() {

            /**
             * Properties of a getDiggingAwardResp.
             * @memberof luck.protobuf
             * @interface IgetDiggingAwardResp
             * @property {number} result getDiggingAwardResp result
             * @property {luck.protobuf.IDiggingPB} digging getDiggingAwardResp digging
             * @property {number|Long} gold getDiggingAwardResp gold
             * @property {number|Long} diamond getDiggingAwardResp diamond
             */

            /**
             * Constructs a new getDiggingAwardResp.
             * @memberof luck.protobuf
             * @classdesc Represents a getDiggingAwardResp.
             * @implements IgetDiggingAwardResp
             * @constructor
             * @param {luck.protobuf.IgetDiggingAwardResp=} [properties] Properties to set
             */
            function getDiggingAwardResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * getDiggingAwardResp result.
             * @member {number} result
             * @memberof luck.protobuf.getDiggingAwardResp
             * @instance
             */
            getDiggingAwardResp.prototype.result = 0;

            /**
             * getDiggingAwardResp digging.
             * @member {luck.protobuf.IDiggingPB} digging
             * @memberof luck.protobuf.getDiggingAwardResp
             * @instance
             */
            getDiggingAwardResp.prototype.digging = null;

            /**
             * getDiggingAwardResp gold.
             * @member {number|Long} gold
             * @memberof luck.protobuf.getDiggingAwardResp
             * @instance
             */
            getDiggingAwardResp.prototype.gold = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * getDiggingAwardResp diamond.
             * @member {number|Long} diamond
             * @memberof luck.protobuf.getDiggingAwardResp
             * @instance
             */
            getDiggingAwardResp.prototype.diamond = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new getDiggingAwardResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.getDiggingAwardResp
             * @static
             * @param {luck.protobuf.IgetDiggingAwardResp=} [properties] Properties to set
             * @returns {luck.protobuf.getDiggingAwardResp} getDiggingAwardResp instance
             */
            getDiggingAwardResp.create = function create(properties) {
                return new getDiggingAwardResp(properties);
            };

            /**
             * Encodes the specified getDiggingAwardResp message. Does not implicitly {@link luck.protobuf.getDiggingAwardResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.getDiggingAwardResp
             * @static
             * @param {luck.protobuf.IgetDiggingAwardResp} message getDiggingAwardResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            getDiggingAwardResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                $root.luck.protobuf.DiggingPB.encode(message.digging, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.gold);
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.diamond);
                return writer;
            };

            /**
             * Encodes the specified getDiggingAwardResp message, length delimited. Does not implicitly {@link luck.protobuf.getDiggingAwardResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.getDiggingAwardResp
             * @static
             * @param {luck.protobuf.IgetDiggingAwardResp} message getDiggingAwardResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            getDiggingAwardResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a getDiggingAwardResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.getDiggingAwardResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.getDiggingAwardResp} getDiggingAwardResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            getDiggingAwardResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.getDiggingAwardResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.digging = $root.luck.protobuf.DiggingPB.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.gold = reader.int64();
                        break;
                    case 4:
                        message.diamond = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                if (!message.hasOwnProperty("digging"))
                    throw $util.ProtocolError("missing required 'digging'", { instance: message });
                if (!message.hasOwnProperty("gold"))
                    throw $util.ProtocolError("missing required 'gold'", { instance: message });
                if (!message.hasOwnProperty("diamond"))
                    throw $util.ProtocolError("missing required 'diamond'", { instance: message });
                return message;
            };

            /**
             * Decodes a getDiggingAwardResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.getDiggingAwardResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.getDiggingAwardResp} getDiggingAwardResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            getDiggingAwardResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a getDiggingAwardResp message.
             * @function verify
             * @memberof luck.protobuf.getDiggingAwardResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            getDiggingAwardResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                {
                    var error = $root.luck.protobuf.DiggingPB.verify(message.digging);
                    if (error)
                        return "digging." + error;
                }
                if (!$util.isInteger(message.gold) && !(message.gold && $util.isInteger(message.gold.low) && $util.isInteger(message.gold.high)))
                    return "gold: integer|Long expected";
                if (!$util.isInteger(message.diamond) && !(message.diamond && $util.isInteger(message.diamond.low) && $util.isInteger(message.diamond.high)))
                    return "diamond: integer|Long expected";
                return null;
            };

            return getDiggingAwardResp;
        })();

        protobuf.StartDiggingPointResp = (function() {

            /**
             * Properties of a StartDiggingPointResp.
             * @memberof luck.protobuf
             * @interface IStartDiggingPointResp
             * @property {number} result StartDiggingPointResp result
             */

            /**
             * Constructs a new StartDiggingPointResp.
             * @memberof luck.protobuf
             * @classdesc Represents a StartDiggingPointResp.
             * @implements IStartDiggingPointResp
             * @constructor
             * @param {luck.protobuf.IStartDiggingPointResp=} [properties] Properties to set
             */
            function StartDiggingPointResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StartDiggingPointResp result.
             * @member {number} result
             * @memberof luck.protobuf.StartDiggingPointResp
             * @instance
             */
            StartDiggingPointResp.prototype.result = 0;

            /**
             * Creates a new StartDiggingPointResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.StartDiggingPointResp
             * @static
             * @param {luck.protobuf.IStartDiggingPointResp=} [properties] Properties to set
             * @returns {luck.protobuf.StartDiggingPointResp} StartDiggingPointResp instance
             */
            StartDiggingPointResp.create = function create(properties) {
                return new StartDiggingPointResp(properties);
            };

            /**
             * Encodes the specified StartDiggingPointResp message. Does not implicitly {@link luck.protobuf.StartDiggingPointResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.StartDiggingPointResp
             * @static
             * @param {luck.protobuf.IStartDiggingPointResp} message StartDiggingPointResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StartDiggingPointResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                return writer;
            };

            /**
             * Encodes the specified StartDiggingPointResp message, length delimited. Does not implicitly {@link luck.protobuf.StartDiggingPointResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.StartDiggingPointResp
             * @static
             * @param {luck.protobuf.IStartDiggingPointResp} message StartDiggingPointResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StartDiggingPointResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StartDiggingPointResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.StartDiggingPointResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.StartDiggingPointResp} StartDiggingPointResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StartDiggingPointResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.StartDiggingPointResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a StartDiggingPointResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.StartDiggingPointResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.StartDiggingPointResp} StartDiggingPointResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StartDiggingPointResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StartDiggingPointResp message.
             * @function verify
             * @memberof luck.protobuf.StartDiggingPointResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StartDiggingPointResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                return null;
            };

            return StartDiggingPointResp;
        })();

        protobuf.FinishDiggingPointResp = (function() {

            /**
             * Properties of a FinishDiggingPointResp.
             * @memberof luck.protobuf
             * @interface IFinishDiggingPointResp
             * @property {number} result FinishDiggingPointResp result
             * @property {number|Long|null} [gold] FinishDiggingPointResp gold
             * @property {number|Long|null} [diamond] FinishDiggingPointResp diamond
             * @property {Array.<luck.protobuf.IWeaponPB>|null} [weaponList] FinishDiggingPointResp weaponList
             * @property {Array.<luck.protobuf.ICardPB>|null} [cardList] FinishDiggingPointResp cardList
             * @property {Array.<luck.protobuf.IClothesPB>|null} [clothesList] FinishDiggingPointResp clothesList
             * @property {Array.<luck.protobuf.IPropPB>|null} [propList] FinishDiggingPointResp propList
             * @property {Array.<luck.protobuf.IMaterialsPB>|null} [materialsList] FinishDiggingPointResp materialsList
             * @property {Array.<luck.protobuf.ICheckNode>|null} [checkNodeList] FinishDiggingPointResp checkNodeList
             * @property {number|null} [gainExp] FinishDiggingPointResp gainExp
             * @property {number|null} [lv] FinishDiggingPointResp lv
             */

            /**
             * Constructs a new FinishDiggingPointResp.
             * @memberof luck.protobuf
             * @classdesc Represents a FinishDiggingPointResp.
             * @implements IFinishDiggingPointResp
             * @constructor
             * @param {luck.protobuf.IFinishDiggingPointResp=} [properties] Properties to set
             */
            function FinishDiggingPointResp(properties) {
                this.weaponList = [];
                this.cardList = [];
                this.clothesList = [];
                this.propList = [];
                this.materialsList = [];
                this.checkNodeList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FinishDiggingPointResp result.
             * @member {number} result
             * @memberof luck.protobuf.FinishDiggingPointResp
             * @instance
             */
            FinishDiggingPointResp.prototype.result = 0;

            /**
             * FinishDiggingPointResp gold.
             * @member {number|Long} gold
             * @memberof luck.protobuf.FinishDiggingPointResp
             * @instance
             */
            FinishDiggingPointResp.prototype.gold = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * FinishDiggingPointResp diamond.
             * @member {number|Long} diamond
             * @memberof luck.protobuf.FinishDiggingPointResp
             * @instance
             */
            FinishDiggingPointResp.prototype.diamond = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * FinishDiggingPointResp weaponList.
             * @member {Array.<luck.protobuf.IWeaponPB>} weaponList
             * @memberof luck.protobuf.FinishDiggingPointResp
             * @instance
             */
            FinishDiggingPointResp.prototype.weaponList = $util.emptyArray;

            /**
             * FinishDiggingPointResp cardList.
             * @member {Array.<luck.protobuf.ICardPB>} cardList
             * @memberof luck.protobuf.FinishDiggingPointResp
             * @instance
             */
            FinishDiggingPointResp.prototype.cardList = $util.emptyArray;

            /**
             * FinishDiggingPointResp clothesList.
             * @member {Array.<luck.protobuf.IClothesPB>} clothesList
             * @memberof luck.protobuf.FinishDiggingPointResp
             * @instance
             */
            FinishDiggingPointResp.prototype.clothesList = $util.emptyArray;

            /**
             * FinishDiggingPointResp propList.
             * @member {Array.<luck.protobuf.IPropPB>} propList
             * @memberof luck.protobuf.FinishDiggingPointResp
             * @instance
             */
            FinishDiggingPointResp.prototype.propList = $util.emptyArray;

            /**
             * FinishDiggingPointResp materialsList.
             * @member {Array.<luck.protobuf.IMaterialsPB>} materialsList
             * @memberof luck.protobuf.FinishDiggingPointResp
             * @instance
             */
            FinishDiggingPointResp.prototype.materialsList = $util.emptyArray;

            /**
             * FinishDiggingPointResp checkNodeList.
             * @member {Array.<luck.protobuf.ICheckNode>} checkNodeList
             * @memberof luck.protobuf.FinishDiggingPointResp
             * @instance
             */
            FinishDiggingPointResp.prototype.checkNodeList = $util.emptyArray;

            /**
             * FinishDiggingPointResp gainExp.
             * @member {number} gainExp
             * @memberof luck.protobuf.FinishDiggingPointResp
             * @instance
             */
            FinishDiggingPointResp.prototype.gainExp = 0;

            /**
             * FinishDiggingPointResp lv.
             * @member {number} lv
             * @memberof luck.protobuf.FinishDiggingPointResp
             * @instance
             */
            FinishDiggingPointResp.prototype.lv = 0;

            /**
             * Creates a new FinishDiggingPointResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.FinishDiggingPointResp
             * @static
             * @param {luck.protobuf.IFinishDiggingPointResp=} [properties] Properties to set
             * @returns {luck.protobuf.FinishDiggingPointResp} FinishDiggingPointResp instance
             */
            FinishDiggingPointResp.create = function create(properties) {
                return new FinishDiggingPointResp(properties);
            };

            /**
             * Encodes the specified FinishDiggingPointResp message. Does not implicitly {@link luck.protobuf.FinishDiggingPointResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.FinishDiggingPointResp
             * @static
             * @param {luck.protobuf.IFinishDiggingPointResp} message FinishDiggingPointResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FinishDiggingPointResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.gold != null && message.hasOwnProperty("gold"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.gold);
                if (message.diamond != null && message.hasOwnProperty("diamond"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.diamond);
                if (message.weaponList != null && message.weaponList.length)
                    for (var i = 0; i < message.weaponList.length; ++i)
                        $root.luck.protobuf.WeaponPB.encode(message.weaponList[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.cardList != null && message.cardList.length)
                    for (var i = 0; i < message.cardList.length; ++i)
                        $root.luck.protobuf.CardPB.encode(message.cardList[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.clothesList != null && message.clothesList.length)
                    for (var i = 0; i < message.clothesList.length; ++i)
                        $root.luck.protobuf.ClothesPB.encode(message.clothesList[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.propList != null && message.propList.length)
                    for (var i = 0; i < message.propList.length; ++i)
                        $root.luck.protobuf.PropPB.encode(message.propList[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.materialsList != null && message.materialsList.length)
                    for (var i = 0; i < message.materialsList.length; ++i)
                        $root.luck.protobuf.MaterialsPB.encode(message.materialsList[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.checkNodeList != null && message.checkNodeList.length)
                    for (var i = 0; i < message.checkNodeList.length; ++i)
                        $root.luck.protobuf.CheckNode.encode(message.checkNodeList[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.gainExp != null && message.hasOwnProperty("gainExp"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int32(message.gainExp);
                if (message.lv != null && message.hasOwnProperty("lv"))
                    writer.uint32(/* id 11, wireType 0 =*/88).int32(message.lv);
                return writer;
            };

            /**
             * Encodes the specified FinishDiggingPointResp message, length delimited. Does not implicitly {@link luck.protobuf.FinishDiggingPointResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.FinishDiggingPointResp
             * @static
             * @param {luck.protobuf.IFinishDiggingPointResp} message FinishDiggingPointResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FinishDiggingPointResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FinishDiggingPointResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.FinishDiggingPointResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.FinishDiggingPointResp} FinishDiggingPointResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FinishDiggingPointResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.FinishDiggingPointResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.gold = reader.int64();
                        break;
                    case 3:
                        message.diamond = reader.int64();
                        break;
                    case 4:
                        if (!(message.weaponList && message.weaponList.length))
                            message.weaponList = [];
                        message.weaponList.push($root.luck.protobuf.WeaponPB.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.cardList && message.cardList.length))
                            message.cardList = [];
                        message.cardList.push($root.luck.protobuf.CardPB.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.clothesList && message.clothesList.length))
                            message.clothesList = [];
                        message.clothesList.push($root.luck.protobuf.ClothesPB.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        if (!(message.propList && message.propList.length))
                            message.propList = [];
                        message.propList.push($root.luck.protobuf.PropPB.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        if (!(message.materialsList && message.materialsList.length))
                            message.materialsList = [];
                        message.materialsList.push($root.luck.protobuf.MaterialsPB.decode(reader, reader.uint32()));
                        break;
                    case 9:
                        if (!(message.checkNodeList && message.checkNodeList.length))
                            message.checkNodeList = [];
                        message.checkNodeList.push($root.luck.protobuf.CheckNode.decode(reader, reader.uint32()));
                        break;
                    case 10:
                        message.gainExp = reader.int32();
                        break;
                    case 11:
                        message.lv = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a FinishDiggingPointResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.FinishDiggingPointResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.FinishDiggingPointResp} FinishDiggingPointResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FinishDiggingPointResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FinishDiggingPointResp message.
             * @function verify
             * @memberof luck.protobuf.FinishDiggingPointResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FinishDiggingPointResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.gold != null && message.hasOwnProperty("gold"))
                    if (!$util.isInteger(message.gold) && !(message.gold && $util.isInteger(message.gold.low) && $util.isInteger(message.gold.high)))
                        return "gold: integer|Long expected";
                if (message.diamond != null && message.hasOwnProperty("diamond"))
                    if (!$util.isInteger(message.diamond) && !(message.diamond && $util.isInteger(message.diamond.low) && $util.isInteger(message.diamond.high)))
                        return "diamond: integer|Long expected";
                if (message.weaponList != null && message.hasOwnProperty("weaponList")) {
                    if (!Array.isArray(message.weaponList))
                        return "weaponList: array expected";
                    for (var i = 0; i < message.weaponList.length; ++i) {
                        var error = $root.luck.protobuf.WeaponPB.verify(message.weaponList[i]);
                        if (error)
                            return "weaponList." + error;
                    }
                }
                if (message.cardList != null && message.hasOwnProperty("cardList")) {
                    if (!Array.isArray(message.cardList))
                        return "cardList: array expected";
                    for (var i = 0; i < message.cardList.length; ++i) {
                        var error = $root.luck.protobuf.CardPB.verify(message.cardList[i]);
                        if (error)
                            return "cardList." + error;
                    }
                }
                if (message.clothesList != null && message.hasOwnProperty("clothesList")) {
                    if (!Array.isArray(message.clothesList))
                        return "clothesList: array expected";
                    for (var i = 0; i < message.clothesList.length; ++i) {
                        var error = $root.luck.protobuf.ClothesPB.verify(message.clothesList[i]);
                        if (error)
                            return "clothesList." + error;
                    }
                }
                if (message.propList != null && message.hasOwnProperty("propList")) {
                    if (!Array.isArray(message.propList))
                        return "propList: array expected";
                    for (var i = 0; i < message.propList.length; ++i) {
                        var error = $root.luck.protobuf.PropPB.verify(message.propList[i]);
                        if (error)
                            return "propList." + error;
                    }
                }
                if (message.materialsList != null && message.hasOwnProperty("materialsList")) {
                    if (!Array.isArray(message.materialsList))
                        return "materialsList: array expected";
                    for (var i = 0; i < message.materialsList.length; ++i) {
                        var error = $root.luck.protobuf.MaterialsPB.verify(message.materialsList[i]);
                        if (error)
                            return "materialsList." + error;
                    }
                }
                if (message.checkNodeList != null && message.hasOwnProperty("checkNodeList")) {
                    if (!Array.isArray(message.checkNodeList))
                        return "checkNodeList: array expected";
                    for (var i = 0; i < message.checkNodeList.length; ++i) {
                        var error = $root.luck.protobuf.CheckNode.verify(message.checkNodeList[i]);
                        if (error)
                            return "checkNodeList." + error;
                    }
                }
                if (message.gainExp != null && message.hasOwnProperty("gainExp"))
                    if (!$util.isInteger(message.gainExp))
                        return "gainExp: integer expected";
                if (message.lv != null && message.hasOwnProperty("lv"))
                    if (!$util.isInteger(message.lv))
                        return "lv: integer expected";
                return null;
            };

            return FinishDiggingPointResp;
        })();

        protobuf.drawActivityTaskRewardResp = (function() {

            /**
             * Properties of a drawActivityTaskRewardResp.
             * @memberof luck.protobuf
             * @interface IdrawActivityTaskRewardResp
             * @property {number} result drawActivityTaskRewardResp result
             * @property {number|Long|null} [gold] drawActivityTaskRewardResp gold
             * @property {number|Long|null} [diamond] drawActivityTaskRewardResp diamond
             * @property {Array.<luck.protobuf.IWeaponPB>|null} [weaponList] drawActivityTaskRewardResp weaponList
             * @property {Array.<luck.protobuf.ICardPB>|null} [cardList] drawActivityTaskRewardResp cardList
             * @property {Array.<luck.protobuf.IClothesPB>|null} [clothesList] drawActivityTaskRewardResp clothesList
             * @property {Array.<luck.protobuf.IPropPB>|null} [propList] drawActivityTaskRewardResp propList
             * @property {Array.<luck.protobuf.IMaterialsPB>|null} [materialsList] drawActivityTaskRewardResp materialsList
             */

            /**
             * Constructs a new drawActivityTaskRewardResp.
             * @memberof luck.protobuf
             * @classdesc Represents a drawActivityTaskRewardResp.
             * @implements IdrawActivityTaskRewardResp
             * @constructor
             * @param {luck.protobuf.IdrawActivityTaskRewardResp=} [properties] Properties to set
             */
            function drawActivityTaskRewardResp(properties) {
                this.weaponList = [];
                this.cardList = [];
                this.clothesList = [];
                this.propList = [];
                this.materialsList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * drawActivityTaskRewardResp result.
             * @member {number} result
             * @memberof luck.protobuf.drawActivityTaskRewardResp
             * @instance
             */
            drawActivityTaskRewardResp.prototype.result = 0;

            /**
             * drawActivityTaskRewardResp gold.
             * @member {number|Long} gold
             * @memberof luck.protobuf.drawActivityTaskRewardResp
             * @instance
             */
            drawActivityTaskRewardResp.prototype.gold = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * drawActivityTaskRewardResp diamond.
             * @member {number|Long} diamond
             * @memberof luck.protobuf.drawActivityTaskRewardResp
             * @instance
             */
            drawActivityTaskRewardResp.prototype.diamond = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * drawActivityTaskRewardResp weaponList.
             * @member {Array.<luck.protobuf.IWeaponPB>} weaponList
             * @memberof luck.protobuf.drawActivityTaskRewardResp
             * @instance
             */
            drawActivityTaskRewardResp.prototype.weaponList = $util.emptyArray;

            /**
             * drawActivityTaskRewardResp cardList.
             * @member {Array.<luck.protobuf.ICardPB>} cardList
             * @memberof luck.protobuf.drawActivityTaskRewardResp
             * @instance
             */
            drawActivityTaskRewardResp.prototype.cardList = $util.emptyArray;

            /**
             * drawActivityTaskRewardResp clothesList.
             * @member {Array.<luck.protobuf.IClothesPB>} clothesList
             * @memberof luck.protobuf.drawActivityTaskRewardResp
             * @instance
             */
            drawActivityTaskRewardResp.prototype.clothesList = $util.emptyArray;

            /**
             * drawActivityTaskRewardResp propList.
             * @member {Array.<luck.protobuf.IPropPB>} propList
             * @memberof luck.protobuf.drawActivityTaskRewardResp
             * @instance
             */
            drawActivityTaskRewardResp.prototype.propList = $util.emptyArray;

            /**
             * drawActivityTaskRewardResp materialsList.
             * @member {Array.<luck.protobuf.IMaterialsPB>} materialsList
             * @memberof luck.protobuf.drawActivityTaskRewardResp
             * @instance
             */
            drawActivityTaskRewardResp.prototype.materialsList = $util.emptyArray;

            /**
             * Creates a new drawActivityTaskRewardResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.drawActivityTaskRewardResp
             * @static
             * @param {luck.protobuf.IdrawActivityTaskRewardResp=} [properties] Properties to set
             * @returns {luck.protobuf.drawActivityTaskRewardResp} drawActivityTaskRewardResp instance
             */
            drawActivityTaskRewardResp.create = function create(properties) {
                return new drawActivityTaskRewardResp(properties);
            };

            /**
             * Encodes the specified drawActivityTaskRewardResp message. Does not implicitly {@link luck.protobuf.drawActivityTaskRewardResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.drawActivityTaskRewardResp
             * @static
             * @param {luck.protobuf.IdrawActivityTaskRewardResp} message drawActivityTaskRewardResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            drawActivityTaskRewardResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.gold != null && message.hasOwnProperty("gold"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.gold);
                if (message.diamond != null && message.hasOwnProperty("diamond"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.diamond);
                if (message.weaponList != null && message.weaponList.length)
                    for (var i = 0; i < message.weaponList.length; ++i)
                        $root.luck.protobuf.WeaponPB.encode(message.weaponList[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.cardList != null && message.cardList.length)
                    for (var i = 0; i < message.cardList.length; ++i)
                        $root.luck.protobuf.CardPB.encode(message.cardList[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.clothesList != null && message.clothesList.length)
                    for (var i = 0; i < message.clothesList.length; ++i)
                        $root.luck.protobuf.ClothesPB.encode(message.clothesList[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.propList != null && message.propList.length)
                    for (var i = 0; i < message.propList.length; ++i)
                        $root.luck.protobuf.PropPB.encode(message.propList[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.materialsList != null && message.materialsList.length)
                    for (var i = 0; i < message.materialsList.length; ++i)
                        $root.luck.protobuf.MaterialsPB.encode(message.materialsList[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified drawActivityTaskRewardResp message, length delimited. Does not implicitly {@link luck.protobuf.drawActivityTaskRewardResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.drawActivityTaskRewardResp
             * @static
             * @param {luck.protobuf.IdrawActivityTaskRewardResp} message drawActivityTaskRewardResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            drawActivityTaskRewardResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a drawActivityTaskRewardResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.drawActivityTaskRewardResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.drawActivityTaskRewardResp} drawActivityTaskRewardResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            drawActivityTaskRewardResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.drawActivityTaskRewardResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.gold = reader.int64();
                        break;
                    case 3:
                        message.diamond = reader.int64();
                        break;
                    case 4:
                        if (!(message.weaponList && message.weaponList.length))
                            message.weaponList = [];
                        message.weaponList.push($root.luck.protobuf.WeaponPB.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.cardList && message.cardList.length))
                            message.cardList = [];
                        message.cardList.push($root.luck.protobuf.CardPB.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.clothesList && message.clothesList.length))
                            message.clothesList = [];
                        message.clothesList.push($root.luck.protobuf.ClothesPB.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        if (!(message.propList && message.propList.length))
                            message.propList = [];
                        message.propList.push($root.luck.protobuf.PropPB.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        if (!(message.materialsList && message.materialsList.length))
                            message.materialsList = [];
                        message.materialsList.push($root.luck.protobuf.MaterialsPB.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a drawActivityTaskRewardResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.drawActivityTaskRewardResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.drawActivityTaskRewardResp} drawActivityTaskRewardResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            drawActivityTaskRewardResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a drawActivityTaskRewardResp message.
             * @function verify
             * @memberof luck.protobuf.drawActivityTaskRewardResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            drawActivityTaskRewardResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.gold != null && message.hasOwnProperty("gold"))
                    if (!$util.isInteger(message.gold) && !(message.gold && $util.isInteger(message.gold.low) && $util.isInteger(message.gold.high)))
                        return "gold: integer|Long expected";
                if (message.diamond != null && message.hasOwnProperty("diamond"))
                    if (!$util.isInteger(message.diamond) && !(message.diamond && $util.isInteger(message.diamond.low) && $util.isInteger(message.diamond.high)))
                        return "diamond: integer|Long expected";
                if (message.weaponList != null && message.hasOwnProperty("weaponList")) {
                    if (!Array.isArray(message.weaponList))
                        return "weaponList: array expected";
                    for (var i = 0; i < message.weaponList.length; ++i) {
                        var error = $root.luck.protobuf.WeaponPB.verify(message.weaponList[i]);
                        if (error)
                            return "weaponList." + error;
                    }
                }
                if (message.cardList != null && message.hasOwnProperty("cardList")) {
                    if (!Array.isArray(message.cardList))
                        return "cardList: array expected";
                    for (var i = 0; i < message.cardList.length; ++i) {
                        var error = $root.luck.protobuf.CardPB.verify(message.cardList[i]);
                        if (error)
                            return "cardList." + error;
                    }
                }
                if (message.clothesList != null && message.hasOwnProperty("clothesList")) {
                    if (!Array.isArray(message.clothesList))
                        return "clothesList: array expected";
                    for (var i = 0; i < message.clothesList.length; ++i) {
                        var error = $root.luck.protobuf.ClothesPB.verify(message.clothesList[i]);
                        if (error)
                            return "clothesList." + error;
                    }
                }
                if (message.propList != null && message.hasOwnProperty("propList")) {
                    if (!Array.isArray(message.propList))
                        return "propList: array expected";
                    for (var i = 0; i < message.propList.length; ++i) {
                        var error = $root.luck.protobuf.PropPB.verify(message.propList[i]);
                        if (error)
                            return "propList." + error;
                    }
                }
                if (message.materialsList != null && message.hasOwnProperty("materialsList")) {
                    if (!Array.isArray(message.materialsList))
                        return "materialsList: array expected";
                    for (var i = 0; i < message.materialsList.length; ++i) {
                        var error = $root.luck.protobuf.MaterialsPB.verify(message.materialsList[i]);
                        if (error)
                            return "materialsList." + error;
                    }
                }
                return null;
            };

            return drawActivityTaskRewardResp;
        })();

        protobuf.activityLotteryResp = (function() {

            /**
             * Properties of an activityLotteryResp.
             * @memberof luck.protobuf
             * @interface IactivityLotteryResp
             * @property {number} result activityLotteryResp result
             * @property {number|Long|null} [gold] activityLotteryResp gold
             * @property {number|Long|null} [diamond] activityLotteryResp diamond
             * @property {Array.<luck.protobuf.IWeaponPB>|null} [weaponList] activityLotteryResp weaponList
             * @property {Array.<luck.protobuf.ICardPB>|null} [cardList] activityLotteryResp cardList
             * @property {Array.<luck.protobuf.IClothesPB>|null} [clothesList] activityLotteryResp clothesList
             * @property {Array.<luck.protobuf.IPropPB>|null} [propList] activityLotteryResp propList
             * @property {Array.<luck.protobuf.IMaterialsPB>|null} [materialsList] activityLotteryResp materialsList
             * @property {Array.<number>|null} [itemId] activityLotteryResp itemId
             */

            /**
             * Constructs a new activityLotteryResp.
             * @memberof luck.protobuf
             * @classdesc Represents an activityLotteryResp.
             * @implements IactivityLotteryResp
             * @constructor
             * @param {luck.protobuf.IactivityLotteryResp=} [properties] Properties to set
             */
            function activityLotteryResp(properties) {
                this.weaponList = [];
                this.cardList = [];
                this.clothesList = [];
                this.propList = [];
                this.materialsList = [];
                this.itemId = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * activityLotteryResp result.
             * @member {number} result
             * @memberof luck.protobuf.activityLotteryResp
             * @instance
             */
            activityLotteryResp.prototype.result = 0;

            /**
             * activityLotteryResp gold.
             * @member {number|Long} gold
             * @memberof luck.protobuf.activityLotteryResp
             * @instance
             */
            activityLotteryResp.prototype.gold = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * activityLotteryResp diamond.
             * @member {number|Long} diamond
             * @memberof luck.protobuf.activityLotteryResp
             * @instance
             */
            activityLotteryResp.prototype.diamond = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * activityLotteryResp weaponList.
             * @member {Array.<luck.protobuf.IWeaponPB>} weaponList
             * @memberof luck.protobuf.activityLotteryResp
             * @instance
             */
            activityLotteryResp.prototype.weaponList = $util.emptyArray;

            /**
             * activityLotteryResp cardList.
             * @member {Array.<luck.protobuf.ICardPB>} cardList
             * @memberof luck.protobuf.activityLotteryResp
             * @instance
             */
            activityLotteryResp.prototype.cardList = $util.emptyArray;

            /**
             * activityLotteryResp clothesList.
             * @member {Array.<luck.protobuf.IClothesPB>} clothesList
             * @memberof luck.protobuf.activityLotteryResp
             * @instance
             */
            activityLotteryResp.prototype.clothesList = $util.emptyArray;

            /**
             * activityLotteryResp propList.
             * @member {Array.<luck.protobuf.IPropPB>} propList
             * @memberof luck.protobuf.activityLotteryResp
             * @instance
             */
            activityLotteryResp.prototype.propList = $util.emptyArray;

            /**
             * activityLotteryResp materialsList.
             * @member {Array.<luck.protobuf.IMaterialsPB>} materialsList
             * @memberof luck.protobuf.activityLotteryResp
             * @instance
             */
            activityLotteryResp.prototype.materialsList = $util.emptyArray;

            /**
             * activityLotteryResp itemId.
             * @member {Array.<number>} itemId
             * @memberof luck.protobuf.activityLotteryResp
             * @instance
             */
            activityLotteryResp.prototype.itemId = $util.emptyArray;

            /**
             * Creates a new activityLotteryResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.activityLotteryResp
             * @static
             * @param {luck.protobuf.IactivityLotteryResp=} [properties] Properties to set
             * @returns {luck.protobuf.activityLotteryResp} activityLotteryResp instance
             */
            activityLotteryResp.create = function create(properties) {
                return new activityLotteryResp(properties);
            };

            /**
             * Encodes the specified activityLotteryResp message. Does not implicitly {@link luck.protobuf.activityLotteryResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.activityLotteryResp
             * @static
             * @param {luck.protobuf.IactivityLotteryResp} message activityLotteryResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            activityLotteryResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.gold != null && message.hasOwnProperty("gold"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.gold);
                if (message.diamond != null && message.hasOwnProperty("diamond"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.diamond);
                if (message.weaponList != null && message.weaponList.length)
                    for (var i = 0; i < message.weaponList.length; ++i)
                        $root.luck.protobuf.WeaponPB.encode(message.weaponList[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.cardList != null && message.cardList.length)
                    for (var i = 0; i < message.cardList.length; ++i)
                        $root.luck.protobuf.CardPB.encode(message.cardList[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.clothesList != null && message.clothesList.length)
                    for (var i = 0; i < message.clothesList.length; ++i)
                        $root.luck.protobuf.ClothesPB.encode(message.clothesList[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.propList != null && message.propList.length)
                    for (var i = 0; i < message.propList.length; ++i)
                        $root.luck.protobuf.PropPB.encode(message.propList[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.materialsList != null && message.materialsList.length)
                    for (var i = 0; i < message.materialsList.length; ++i)
                        $root.luck.protobuf.MaterialsPB.encode(message.materialsList[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.itemId != null && message.itemId.length)
                    for (var i = 0; i < message.itemId.length; ++i)
                        writer.uint32(/* id 9, wireType 0 =*/72).int32(message.itemId[i]);
                return writer;
            };

            /**
             * Encodes the specified activityLotteryResp message, length delimited. Does not implicitly {@link luck.protobuf.activityLotteryResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.activityLotteryResp
             * @static
             * @param {luck.protobuf.IactivityLotteryResp} message activityLotteryResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            activityLotteryResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an activityLotteryResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.activityLotteryResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.activityLotteryResp} activityLotteryResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            activityLotteryResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.activityLotteryResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.gold = reader.int64();
                        break;
                    case 3:
                        message.diamond = reader.int64();
                        break;
                    case 4:
                        if (!(message.weaponList && message.weaponList.length))
                            message.weaponList = [];
                        message.weaponList.push($root.luck.protobuf.WeaponPB.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.cardList && message.cardList.length))
                            message.cardList = [];
                        message.cardList.push($root.luck.protobuf.CardPB.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.clothesList && message.clothesList.length))
                            message.clothesList = [];
                        message.clothesList.push($root.luck.protobuf.ClothesPB.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        if (!(message.propList && message.propList.length))
                            message.propList = [];
                        message.propList.push($root.luck.protobuf.PropPB.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        if (!(message.materialsList && message.materialsList.length))
                            message.materialsList = [];
                        message.materialsList.push($root.luck.protobuf.MaterialsPB.decode(reader, reader.uint32()));
                        break;
                    case 9:
                        if (!(message.itemId && message.itemId.length))
                            message.itemId = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.itemId.push(reader.int32());
                        } else
                            message.itemId.push(reader.int32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes an activityLotteryResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.activityLotteryResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.activityLotteryResp} activityLotteryResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            activityLotteryResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an activityLotteryResp message.
             * @function verify
             * @memberof luck.protobuf.activityLotteryResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            activityLotteryResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.gold != null && message.hasOwnProperty("gold"))
                    if (!$util.isInteger(message.gold) && !(message.gold && $util.isInteger(message.gold.low) && $util.isInteger(message.gold.high)))
                        return "gold: integer|Long expected";
                if (message.diamond != null && message.hasOwnProperty("diamond"))
                    if (!$util.isInteger(message.diamond) && !(message.diamond && $util.isInteger(message.diamond.low) && $util.isInteger(message.diamond.high)))
                        return "diamond: integer|Long expected";
                if (message.weaponList != null && message.hasOwnProperty("weaponList")) {
                    if (!Array.isArray(message.weaponList))
                        return "weaponList: array expected";
                    for (var i = 0; i < message.weaponList.length; ++i) {
                        var error = $root.luck.protobuf.WeaponPB.verify(message.weaponList[i]);
                        if (error)
                            return "weaponList." + error;
                    }
                }
                if (message.cardList != null && message.hasOwnProperty("cardList")) {
                    if (!Array.isArray(message.cardList))
                        return "cardList: array expected";
                    for (var i = 0; i < message.cardList.length; ++i) {
                        var error = $root.luck.protobuf.CardPB.verify(message.cardList[i]);
                        if (error)
                            return "cardList." + error;
                    }
                }
                if (message.clothesList != null && message.hasOwnProperty("clothesList")) {
                    if (!Array.isArray(message.clothesList))
                        return "clothesList: array expected";
                    for (var i = 0; i < message.clothesList.length; ++i) {
                        var error = $root.luck.protobuf.ClothesPB.verify(message.clothesList[i]);
                        if (error)
                            return "clothesList." + error;
                    }
                }
                if (message.propList != null && message.hasOwnProperty("propList")) {
                    if (!Array.isArray(message.propList))
                        return "propList: array expected";
                    for (var i = 0; i < message.propList.length; ++i) {
                        var error = $root.luck.protobuf.PropPB.verify(message.propList[i]);
                        if (error)
                            return "propList." + error;
                    }
                }
                if (message.materialsList != null && message.hasOwnProperty("materialsList")) {
                    if (!Array.isArray(message.materialsList))
                        return "materialsList: array expected";
                    for (var i = 0; i < message.materialsList.length; ++i) {
                        var error = $root.luck.protobuf.MaterialsPB.verify(message.materialsList[i]);
                        if (error)
                            return "materialsList." + error;
                    }
                }
                if (message.itemId != null && message.hasOwnProperty("itemId")) {
                    if (!Array.isArray(message.itemId))
                        return "itemId: array expected";
                    for (var i = 0; i < message.itemId.length; ++i)
                        if (!$util.isInteger(message.itemId[i]))
                            return "itemId: integer[] expected";
                }
                return null;
            };

            return activityLotteryResp;
        })();

        protobuf.changeNameResp = (function() {

            /**
             * Properties of a changeNameResp.
             * @memberof luck.protobuf
             * @interface IchangeNameResp
             * @property {number} result changeNameResp result
             */

            /**
             * Constructs a new changeNameResp.
             * @memberof luck.protobuf
             * @classdesc Represents a changeNameResp.
             * @implements IchangeNameResp
             * @constructor
             * @param {luck.protobuf.IchangeNameResp=} [properties] Properties to set
             */
            function changeNameResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * changeNameResp result.
             * @member {number} result
             * @memberof luck.protobuf.changeNameResp
             * @instance
             */
            changeNameResp.prototype.result = 0;

            /**
             * Creates a new changeNameResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.changeNameResp
             * @static
             * @param {luck.protobuf.IchangeNameResp=} [properties] Properties to set
             * @returns {luck.protobuf.changeNameResp} changeNameResp instance
             */
            changeNameResp.create = function create(properties) {
                return new changeNameResp(properties);
            };

            /**
             * Encodes the specified changeNameResp message. Does not implicitly {@link luck.protobuf.changeNameResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.changeNameResp
             * @static
             * @param {luck.protobuf.IchangeNameResp} message changeNameResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            changeNameResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                return writer;
            };

            /**
             * Encodes the specified changeNameResp message, length delimited. Does not implicitly {@link luck.protobuf.changeNameResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.changeNameResp
             * @static
             * @param {luck.protobuf.IchangeNameResp} message changeNameResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            changeNameResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a changeNameResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.changeNameResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.changeNameResp} changeNameResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            changeNameResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.changeNameResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a changeNameResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.changeNameResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.changeNameResp} changeNameResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            changeNameResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a changeNameResp message.
             * @function verify
             * @memberof luck.protobuf.changeNameResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            changeNameResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                return null;
            };

            return changeNameResp;
        })();

        protobuf.saveNoviceGuideNumResp = (function() {

            /**
             * Properties of a saveNoviceGuideNumResp.
             * @memberof luck.protobuf
             * @interface IsaveNoviceGuideNumResp
             * @property {number} result saveNoviceGuideNumResp result
             */

            /**
             * Constructs a new saveNoviceGuideNumResp.
             * @memberof luck.protobuf
             * @classdesc Represents a saveNoviceGuideNumResp.
             * @implements IsaveNoviceGuideNumResp
             * @constructor
             * @param {luck.protobuf.IsaveNoviceGuideNumResp=} [properties] Properties to set
             */
            function saveNoviceGuideNumResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * saveNoviceGuideNumResp result.
             * @member {number} result
             * @memberof luck.protobuf.saveNoviceGuideNumResp
             * @instance
             */
            saveNoviceGuideNumResp.prototype.result = 0;

            /**
             * Creates a new saveNoviceGuideNumResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.saveNoviceGuideNumResp
             * @static
             * @param {luck.protobuf.IsaveNoviceGuideNumResp=} [properties] Properties to set
             * @returns {luck.protobuf.saveNoviceGuideNumResp} saveNoviceGuideNumResp instance
             */
            saveNoviceGuideNumResp.create = function create(properties) {
                return new saveNoviceGuideNumResp(properties);
            };

            /**
             * Encodes the specified saveNoviceGuideNumResp message. Does not implicitly {@link luck.protobuf.saveNoviceGuideNumResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.saveNoviceGuideNumResp
             * @static
             * @param {luck.protobuf.IsaveNoviceGuideNumResp} message saveNoviceGuideNumResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            saveNoviceGuideNumResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                return writer;
            };

            /**
             * Encodes the specified saveNoviceGuideNumResp message, length delimited. Does not implicitly {@link luck.protobuf.saveNoviceGuideNumResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.saveNoviceGuideNumResp
             * @static
             * @param {luck.protobuf.IsaveNoviceGuideNumResp} message saveNoviceGuideNumResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            saveNoviceGuideNumResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a saveNoviceGuideNumResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.saveNoviceGuideNumResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.saveNoviceGuideNumResp} saveNoviceGuideNumResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            saveNoviceGuideNumResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.saveNoviceGuideNumResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a saveNoviceGuideNumResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.saveNoviceGuideNumResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.saveNoviceGuideNumResp} saveNoviceGuideNumResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            saveNoviceGuideNumResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a saveNoviceGuideNumResp message.
             * @function verify
             * @memberof luck.protobuf.saveNoviceGuideNumResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            saveNoviceGuideNumResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                return null;
            };

            return saveNoviceGuideNumResp;
        })();

        protobuf.drawMonthCardResp = (function() {

            /**
             * Properties of a drawMonthCardResp.
             * @memberof luck.protobuf
             * @interface IdrawMonthCardResp
             * @property {number} result drawMonthCardResp result
             * @property {number|Long|null} [gold] drawMonthCardResp gold
             * @property {number|Long|null} [diamond] drawMonthCardResp diamond
             * @property {Array.<luck.protobuf.IWeaponPB>|null} [weaponList] drawMonthCardResp weaponList
             * @property {Array.<luck.protobuf.ICardPB>|null} [cardList] drawMonthCardResp cardList
             * @property {Array.<luck.protobuf.IClothesPB>|null} [clothesList] drawMonthCardResp clothesList
             * @property {Array.<luck.protobuf.IPropPB>|null} [propList] drawMonthCardResp propList
             * @property {Array.<luck.protobuf.IMaterialsPB>|null} [materialsList] drawMonthCardResp materialsList
             */

            /**
             * Constructs a new drawMonthCardResp.
             * @memberof luck.protobuf
             * @classdesc Represents a drawMonthCardResp.
             * @implements IdrawMonthCardResp
             * @constructor
             * @param {luck.protobuf.IdrawMonthCardResp=} [properties] Properties to set
             */
            function drawMonthCardResp(properties) {
                this.weaponList = [];
                this.cardList = [];
                this.clothesList = [];
                this.propList = [];
                this.materialsList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * drawMonthCardResp result.
             * @member {number} result
             * @memberof luck.protobuf.drawMonthCardResp
             * @instance
             */
            drawMonthCardResp.prototype.result = 0;

            /**
             * drawMonthCardResp gold.
             * @member {number|Long} gold
             * @memberof luck.protobuf.drawMonthCardResp
             * @instance
             */
            drawMonthCardResp.prototype.gold = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * drawMonthCardResp diamond.
             * @member {number|Long} diamond
             * @memberof luck.protobuf.drawMonthCardResp
             * @instance
             */
            drawMonthCardResp.prototype.diamond = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * drawMonthCardResp weaponList.
             * @member {Array.<luck.protobuf.IWeaponPB>} weaponList
             * @memberof luck.protobuf.drawMonthCardResp
             * @instance
             */
            drawMonthCardResp.prototype.weaponList = $util.emptyArray;

            /**
             * drawMonthCardResp cardList.
             * @member {Array.<luck.protobuf.ICardPB>} cardList
             * @memberof luck.protobuf.drawMonthCardResp
             * @instance
             */
            drawMonthCardResp.prototype.cardList = $util.emptyArray;

            /**
             * drawMonthCardResp clothesList.
             * @member {Array.<luck.protobuf.IClothesPB>} clothesList
             * @memberof luck.protobuf.drawMonthCardResp
             * @instance
             */
            drawMonthCardResp.prototype.clothesList = $util.emptyArray;

            /**
             * drawMonthCardResp propList.
             * @member {Array.<luck.protobuf.IPropPB>} propList
             * @memberof luck.protobuf.drawMonthCardResp
             * @instance
             */
            drawMonthCardResp.prototype.propList = $util.emptyArray;

            /**
             * drawMonthCardResp materialsList.
             * @member {Array.<luck.protobuf.IMaterialsPB>} materialsList
             * @memberof luck.protobuf.drawMonthCardResp
             * @instance
             */
            drawMonthCardResp.prototype.materialsList = $util.emptyArray;

            /**
             * Creates a new drawMonthCardResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.drawMonthCardResp
             * @static
             * @param {luck.protobuf.IdrawMonthCardResp=} [properties] Properties to set
             * @returns {luck.protobuf.drawMonthCardResp} drawMonthCardResp instance
             */
            drawMonthCardResp.create = function create(properties) {
                return new drawMonthCardResp(properties);
            };

            /**
             * Encodes the specified drawMonthCardResp message. Does not implicitly {@link luck.protobuf.drawMonthCardResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.drawMonthCardResp
             * @static
             * @param {luck.protobuf.IdrawMonthCardResp} message drawMonthCardResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            drawMonthCardResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.gold != null && message.hasOwnProperty("gold"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.gold);
                if (message.diamond != null && message.hasOwnProperty("diamond"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.diamond);
                if (message.weaponList != null && message.weaponList.length)
                    for (var i = 0; i < message.weaponList.length; ++i)
                        $root.luck.protobuf.WeaponPB.encode(message.weaponList[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.cardList != null && message.cardList.length)
                    for (var i = 0; i < message.cardList.length; ++i)
                        $root.luck.protobuf.CardPB.encode(message.cardList[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.clothesList != null && message.clothesList.length)
                    for (var i = 0; i < message.clothesList.length; ++i)
                        $root.luck.protobuf.ClothesPB.encode(message.clothesList[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.propList != null && message.propList.length)
                    for (var i = 0; i < message.propList.length; ++i)
                        $root.luck.protobuf.PropPB.encode(message.propList[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.materialsList != null && message.materialsList.length)
                    for (var i = 0; i < message.materialsList.length; ++i)
                        $root.luck.protobuf.MaterialsPB.encode(message.materialsList[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified drawMonthCardResp message, length delimited. Does not implicitly {@link luck.protobuf.drawMonthCardResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.drawMonthCardResp
             * @static
             * @param {luck.protobuf.IdrawMonthCardResp} message drawMonthCardResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            drawMonthCardResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a drawMonthCardResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.drawMonthCardResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.drawMonthCardResp} drawMonthCardResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            drawMonthCardResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.drawMonthCardResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.gold = reader.int64();
                        break;
                    case 3:
                        message.diamond = reader.int64();
                        break;
                    case 4:
                        if (!(message.weaponList && message.weaponList.length))
                            message.weaponList = [];
                        message.weaponList.push($root.luck.protobuf.WeaponPB.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.cardList && message.cardList.length))
                            message.cardList = [];
                        message.cardList.push($root.luck.protobuf.CardPB.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.clothesList && message.clothesList.length))
                            message.clothesList = [];
                        message.clothesList.push($root.luck.protobuf.ClothesPB.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        if (!(message.propList && message.propList.length))
                            message.propList = [];
                        message.propList.push($root.luck.protobuf.PropPB.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        if (!(message.materialsList && message.materialsList.length))
                            message.materialsList = [];
                        message.materialsList.push($root.luck.protobuf.MaterialsPB.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a drawMonthCardResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.drawMonthCardResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.drawMonthCardResp} drawMonthCardResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            drawMonthCardResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a drawMonthCardResp message.
             * @function verify
             * @memberof luck.protobuf.drawMonthCardResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            drawMonthCardResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.gold != null && message.hasOwnProperty("gold"))
                    if (!$util.isInteger(message.gold) && !(message.gold && $util.isInteger(message.gold.low) && $util.isInteger(message.gold.high)))
                        return "gold: integer|Long expected";
                if (message.diamond != null && message.hasOwnProperty("diamond"))
                    if (!$util.isInteger(message.diamond) && !(message.diamond && $util.isInteger(message.diamond.low) && $util.isInteger(message.diamond.high)))
                        return "diamond: integer|Long expected";
                if (message.weaponList != null && message.hasOwnProperty("weaponList")) {
                    if (!Array.isArray(message.weaponList))
                        return "weaponList: array expected";
                    for (var i = 0; i < message.weaponList.length; ++i) {
                        var error = $root.luck.protobuf.WeaponPB.verify(message.weaponList[i]);
                        if (error)
                            return "weaponList." + error;
                    }
                }
                if (message.cardList != null && message.hasOwnProperty("cardList")) {
                    if (!Array.isArray(message.cardList))
                        return "cardList: array expected";
                    for (var i = 0; i < message.cardList.length; ++i) {
                        var error = $root.luck.protobuf.CardPB.verify(message.cardList[i]);
                        if (error)
                            return "cardList." + error;
                    }
                }
                if (message.clothesList != null && message.hasOwnProperty("clothesList")) {
                    if (!Array.isArray(message.clothesList))
                        return "clothesList: array expected";
                    for (var i = 0; i < message.clothesList.length; ++i) {
                        var error = $root.luck.protobuf.ClothesPB.verify(message.clothesList[i]);
                        if (error)
                            return "clothesList." + error;
                    }
                }
                if (message.propList != null && message.hasOwnProperty("propList")) {
                    if (!Array.isArray(message.propList))
                        return "propList: array expected";
                    for (var i = 0; i < message.propList.length; ++i) {
                        var error = $root.luck.protobuf.PropPB.verify(message.propList[i]);
                        if (error)
                            return "propList." + error;
                    }
                }
                if (message.materialsList != null && message.hasOwnProperty("materialsList")) {
                    if (!Array.isArray(message.materialsList))
                        return "materialsList: array expected";
                    for (var i = 0; i < message.materialsList.length; ++i) {
                        var error = $root.luck.protobuf.MaterialsPB.verify(message.materialsList[i]);
                        if (error)
                            return "materialsList." + error;
                    }
                }
                return null;
            };

            return drawMonthCardResp;
        })();

        protobuf.roleChatResp = (function() {

            /**
             * Properties of a roleChatResp.
             * @memberof luck.protobuf
             * @interface IroleChatResp
             * @property {number} result roleChatResp result
             * @property {number|null} [addFavorability] roleChatResp addFavorability
             * @property {number|null} [addMood] roleChatResp addMood
             */

            /**
             * Constructs a new roleChatResp.
             * @memberof luck.protobuf
             * @classdesc Represents a roleChatResp.
             * @implements IroleChatResp
             * @constructor
             * @param {luck.protobuf.IroleChatResp=} [properties] Properties to set
             */
            function roleChatResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * roleChatResp result.
             * @member {number} result
             * @memberof luck.protobuf.roleChatResp
             * @instance
             */
            roleChatResp.prototype.result = 0;

            /**
             * roleChatResp addFavorability.
             * @member {number} addFavorability
             * @memberof luck.protobuf.roleChatResp
             * @instance
             */
            roleChatResp.prototype.addFavorability = 0;

            /**
             * roleChatResp addMood.
             * @member {number} addMood
             * @memberof luck.protobuf.roleChatResp
             * @instance
             */
            roleChatResp.prototype.addMood = 0;

            /**
             * Creates a new roleChatResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.roleChatResp
             * @static
             * @param {luck.protobuf.IroleChatResp=} [properties] Properties to set
             * @returns {luck.protobuf.roleChatResp} roleChatResp instance
             */
            roleChatResp.create = function create(properties) {
                return new roleChatResp(properties);
            };

            /**
             * Encodes the specified roleChatResp message. Does not implicitly {@link luck.protobuf.roleChatResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.roleChatResp
             * @static
             * @param {luck.protobuf.IroleChatResp} message roleChatResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            roleChatResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.addFavorability != null && message.hasOwnProperty("addFavorability"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.addFavorability);
                if (message.addMood != null && message.hasOwnProperty("addMood"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.addMood);
                return writer;
            };

            /**
             * Encodes the specified roleChatResp message, length delimited. Does not implicitly {@link luck.protobuf.roleChatResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.roleChatResp
             * @static
             * @param {luck.protobuf.IroleChatResp} message roleChatResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            roleChatResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a roleChatResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.roleChatResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.roleChatResp} roleChatResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            roleChatResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.roleChatResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.addFavorability = reader.int32();
                        break;
                    case 3:
                        message.addMood = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a roleChatResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.roleChatResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.roleChatResp} roleChatResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            roleChatResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a roleChatResp message.
             * @function verify
             * @memberof luck.protobuf.roleChatResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            roleChatResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.addFavorability != null && message.hasOwnProperty("addFavorability"))
                    if (!$util.isInteger(message.addFavorability))
                        return "addFavorability: integer expected";
                if (message.addMood != null && message.hasOwnProperty("addMood"))
                    if (!$util.isInteger(message.addMood))
                        return "addMood: integer expected";
                return null;
            };

            return roleChatResp;
        })();

        protobuf.roleInteractionResp = (function() {

            /**
             * Properties of a roleInteractionResp.
             * @memberof luck.protobuf
             * @interface IroleInteractionResp
             * @property {number} result roleInteractionResp result
             * @property {number|null} [addFavorability] roleInteractionResp addFavorability
             * @property {number|null} [addMood] roleInteractionResp addMood
             * @property {number|null} [actionId] roleInteractionResp actionId
             * @property {number|null} [wordId] roleInteractionResp wordId
             */

            /**
             * Constructs a new roleInteractionResp.
             * @memberof luck.protobuf
             * @classdesc Represents a roleInteractionResp.
             * @implements IroleInteractionResp
             * @constructor
             * @param {luck.protobuf.IroleInteractionResp=} [properties] Properties to set
             */
            function roleInteractionResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * roleInteractionResp result.
             * @member {number} result
             * @memberof luck.protobuf.roleInteractionResp
             * @instance
             */
            roleInteractionResp.prototype.result = 0;

            /**
             * roleInteractionResp addFavorability.
             * @member {number} addFavorability
             * @memberof luck.protobuf.roleInteractionResp
             * @instance
             */
            roleInteractionResp.prototype.addFavorability = 0;

            /**
             * roleInteractionResp addMood.
             * @member {number} addMood
             * @memberof luck.protobuf.roleInteractionResp
             * @instance
             */
            roleInteractionResp.prototype.addMood = 0;

            /**
             * roleInteractionResp actionId.
             * @member {number} actionId
             * @memberof luck.protobuf.roleInteractionResp
             * @instance
             */
            roleInteractionResp.prototype.actionId = 0;

            /**
             * roleInteractionResp wordId.
             * @member {number} wordId
             * @memberof luck.protobuf.roleInteractionResp
             * @instance
             */
            roleInteractionResp.prototype.wordId = 0;

            /**
             * Creates a new roleInteractionResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.roleInteractionResp
             * @static
             * @param {luck.protobuf.IroleInteractionResp=} [properties] Properties to set
             * @returns {luck.protobuf.roleInteractionResp} roleInteractionResp instance
             */
            roleInteractionResp.create = function create(properties) {
                return new roleInteractionResp(properties);
            };

            /**
             * Encodes the specified roleInteractionResp message. Does not implicitly {@link luck.protobuf.roleInteractionResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.roleInteractionResp
             * @static
             * @param {luck.protobuf.IroleInteractionResp} message roleInteractionResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            roleInteractionResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.addFavorability != null && message.hasOwnProperty("addFavorability"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.addFavorability);
                if (message.addMood != null && message.hasOwnProperty("addMood"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.addMood);
                if (message.actionId != null && message.hasOwnProperty("actionId"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.actionId);
                if (message.wordId != null && message.hasOwnProperty("wordId"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.wordId);
                return writer;
            };

            /**
             * Encodes the specified roleInteractionResp message, length delimited. Does not implicitly {@link luck.protobuf.roleInteractionResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.roleInteractionResp
             * @static
             * @param {luck.protobuf.IroleInteractionResp} message roleInteractionResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            roleInteractionResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a roleInteractionResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.roleInteractionResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.roleInteractionResp} roleInteractionResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            roleInteractionResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.roleInteractionResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.addFavorability = reader.int32();
                        break;
                    case 3:
                        message.addMood = reader.int32();
                        break;
                    case 4:
                        message.actionId = reader.int32();
                        break;
                    case 5:
                        message.wordId = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a roleInteractionResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.roleInteractionResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.roleInteractionResp} roleInteractionResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            roleInteractionResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a roleInteractionResp message.
             * @function verify
             * @memberof luck.protobuf.roleInteractionResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            roleInteractionResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.addFavorability != null && message.hasOwnProperty("addFavorability"))
                    if (!$util.isInteger(message.addFavorability))
                        return "addFavorability: integer expected";
                if (message.addMood != null && message.hasOwnProperty("addMood"))
                    if (!$util.isInteger(message.addMood))
                        return "addMood: integer expected";
                if (message.actionId != null && message.hasOwnProperty("actionId"))
                    if (!$util.isInteger(message.actionId))
                        return "actionId: integer expected";
                if (message.wordId != null && message.hasOwnProperty("wordId"))
                    if (!$util.isInteger(message.wordId))
                        return "wordId: integer expected";
                return null;
            };

            return roleInteractionResp;
        })();

        protobuf.strokeRoleResp = (function() {

            /**
             * Properties of a strokeRoleResp.
             * @memberof luck.protobuf
             * @interface IstrokeRoleResp
             * @property {number} result strokeRoleResp result
             * @property {number|null} [addFavorability] strokeRoleResp addFavorability
             * @property {number|null} [addMood] strokeRoleResp addMood
             * @property {number|null} [actionId] strokeRoleResp actionId
             * @property {Array.<number>|null} [wordIdList] strokeRoleResp wordIdList
             */

            /**
             * Constructs a new strokeRoleResp.
             * @memberof luck.protobuf
             * @classdesc Represents a strokeRoleResp.
             * @implements IstrokeRoleResp
             * @constructor
             * @param {luck.protobuf.IstrokeRoleResp=} [properties] Properties to set
             */
            function strokeRoleResp(properties) {
                this.wordIdList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * strokeRoleResp result.
             * @member {number} result
             * @memberof luck.protobuf.strokeRoleResp
             * @instance
             */
            strokeRoleResp.prototype.result = 0;

            /**
             * strokeRoleResp addFavorability.
             * @member {number} addFavorability
             * @memberof luck.protobuf.strokeRoleResp
             * @instance
             */
            strokeRoleResp.prototype.addFavorability = 0;

            /**
             * strokeRoleResp addMood.
             * @member {number} addMood
             * @memberof luck.protobuf.strokeRoleResp
             * @instance
             */
            strokeRoleResp.prototype.addMood = 0;

            /**
             * strokeRoleResp actionId.
             * @member {number} actionId
             * @memberof luck.protobuf.strokeRoleResp
             * @instance
             */
            strokeRoleResp.prototype.actionId = 0;

            /**
             * strokeRoleResp wordIdList.
             * @member {Array.<number>} wordIdList
             * @memberof luck.protobuf.strokeRoleResp
             * @instance
             */
            strokeRoleResp.prototype.wordIdList = $util.emptyArray;

            /**
             * Creates a new strokeRoleResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.strokeRoleResp
             * @static
             * @param {luck.protobuf.IstrokeRoleResp=} [properties] Properties to set
             * @returns {luck.protobuf.strokeRoleResp} strokeRoleResp instance
             */
            strokeRoleResp.create = function create(properties) {
                return new strokeRoleResp(properties);
            };

            /**
             * Encodes the specified strokeRoleResp message. Does not implicitly {@link luck.protobuf.strokeRoleResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.strokeRoleResp
             * @static
             * @param {luck.protobuf.IstrokeRoleResp} message strokeRoleResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            strokeRoleResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.addFavorability != null && message.hasOwnProperty("addFavorability"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.addFavorability);
                if (message.addMood != null && message.hasOwnProperty("addMood"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.addMood);
                if (message.actionId != null && message.hasOwnProperty("actionId"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.actionId);
                if (message.wordIdList != null && message.wordIdList.length)
                    for (var i = 0; i < message.wordIdList.length; ++i)
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.wordIdList[i]);
                return writer;
            };

            /**
             * Encodes the specified strokeRoleResp message, length delimited. Does not implicitly {@link luck.protobuf.strokeRoleResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.strokeRoleResp
             * @static
             * @param {luck.protobuf.IstrokeRoleResp} message strokeRoleResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            strokeRoleResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a strokeRoleResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.strokeRoleResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.strokeRoleResp} strokeRoleResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            strokeRoleResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.strokeRoleResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.addFavorability = reader.int32();
                        break;
                    case 3:
                        message.addMood = reader.int32();
                        break;
                    case 4:
                        message.actionId = reader.int32();
                        break;
                    case 5:
                        if (!(message.wordIdList && message.wordIdList.length))
                            message.wordIdList = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.wordIdList.push(reader.int32());
                        } else
                            message.wordIdList.push(reader.int32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a strokeRoleResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.strokeRoleResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.strokeRoleResp} strokeRoleResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            strokeRoleResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a strokeRoleResp message.
             * @function verify
             * @memberof luck.protobuf.strokeRoleResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            strokeRoleResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.addFavorability != null && message.hasOwnProperty("addFavorability"))
                    if (!$util.isInteger(message.addFavorability))
                        return "addFavorability: integer expected";
                if (message.addMood != null && message.hasOwnProperty("addMood"))
                    if (!$util.isInteger(message.addMood))
                        return "addMood: integer expected";
                if (message.actionId != null && message.hasOwnProperty("actionId"))
                    if (!$util.isInteger(message.actionId))
                        return "actionId: integer expected";
                if (message.wordIdList != null && message.hasOwnProperty("wordIdList")) {
                    if (!Array.isArray(message.wordIdList))
                        return "wordIdList: array expected";
                    for (var i = 0; i < message.wordIdList.length; ++i)
                        if (!$util.isInteger(message.wordIdList[i]))
                            return "wordIdList: integer[] expected";
                }
                return null;
            };

            return strokeRoleResp;
        })();

        protobuf.changeRoleImageResp = (function() {

            /**
             * Properties of a changeRoleImageResp.
             * @memberof luck.protobuf
             * @interface IchangeRoleImageResp
             * @property {number} result changeRoleImageResp result
             * @property {Array.<luck.protobuf.IRolePB>|null} [roleList] changeRoleImageResp roleList
             */

            /**
             * Constructs a new changeRoleImageResp.
             * @memberof luck.protobuf
             * @classdesc Represents a changeRoleImageResp.
             * @implements IchangeRoleImageResp
             * @constructor
             * @param {luck.protobuf.IchangeRoleImageResp=} [properties] Properties to set
             */
            function changeRoleImageResp(properties) {
                this.roleList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * changeRoleImageResp result.
             * @member {number} result
             * @memberof luck.protobuf.changeRoleImageResp
             * @instance
             */
            changeRoleImageResp.prototype.result = 0;

            /**
             * changeRoleImageResp roleList.
             * @member {Array.<luck.protobuf.IRolePB>} roleList
             * @memberof luck.protobuf.changeRoleImageResp
             * @instance
             */
            changeRoleImageResp.prototype.roleList = $util.emptyArray;

            /**
             * Creates a new changeRoleImageResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.changeRoleImageResp
             * @static
             * @param {luck.protobuf.IchangeRoleImageResp=} [properties] Properties to set
             * @returns {luck.protobuf.changeRoleImageResp} changeRoleImageResp instance
             */
            changeRoleImageResp.create = function create(properties) {
                return new changeRoleImageResp(properties);
            };

            /**
             * Encodes the specified changeRoleImageResp message. Does not implicitly {@link luck.protobuf.changeRoleImageResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.changeRoleImageResp
             * @static
             * @param {luck.protobuf.IchangeRoleImageResp} message changeRoleImageResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            changeRoleImageResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.roleList != null && message.roleList.length)
                    for (var i = 0; i < message.roleList.length; ++i)
                        $root.luck.protobuf.RolePB.encode(message.roleList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified changeRoleImageResp message, length delimited. Does not implicitly {@link luck.protobuf.changeRoleImageResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.changeRoleImageResp
             * @static
             * @param {luck.protobuf.IchangeRoleImageResp} message changeRoleImageResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            changeRoleImageResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a changeRoleImageResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.changeRoleImageResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.changeRoleImageResp} changeRoleImageResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            changeRoleImageResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.changeRoleImageResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        if (!(message.roleList && message.roleList.length))
                            message.roleList = [];
                        message.roleList.push($root.luck.protobuf.RolePB.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a changeRoleImageResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.changeRoleImageResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.changeRoleImageResp} changeRoleImageResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            changeRoleImageResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a changeRoleImageResp message.
             * @function verify
             * @memberof luck.protobuf.changeRoleImageResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            changeRoleImageResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.roleList != null && message.hasOwnProperty("roleList")) {
                    if (!Array.isArray(message.roleList))
                        return "roleList: array expected";
                    for (var i = 0; i < message.roleList.length; ++i) {
                        var error = $root.luck.protobuf.RolePB.verify(message.roleList[i]);
                        if (error)
                            return "roleList." + error;
                    }
                }
                return null;
            };

            return changeRoleImageResp;
        })();

        protobuf.changeHeadPortraitResp = (function() {

            /**
             * Properties of a changeHeadPortraitResp.
             * @memberof luck.protobuf
             * @interface IchangeHeadPortraitResp
             * @property {number} result changeHeadPortraitResp result
             */

            /**
             * Constructs a new changeHeadPortraitResp.
             * @memberof luck.protobuf
             * @classdesc Represents a changeHeadPortraitResp.
             * @implements IchangeHeadPortraitResp
             * @constructor
             * @param {luck.protobuf.IchangeHeadPortraitResp=} [properties] Properties to set
             */
            function changeHeadPortraitResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * changeHeadPortraitResp result.
             * @member {number} result
             * @memberof luck.protobuf.changeHeadPortraitResp
             * @instance
             */
            changeHeadPortraitResp.prototype.result = 0;

            /**
             * Creates a new changeHeadPortraitResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.changeHeadPortraitResp
             * @static
             * @param {luck.protobuf.IchangeHeadPortraitResp=} [properties] Properties to set
             * @returns {luck.protobuf.changeHeadPortraitResp} changeHeadPortraitResp instance
             */
            changeHeadPortraitResp.create = function create(properties) {
                return new changeHeadPortraitResp(properties);
            };

            /**
             * Encodes the specified changeHeadPortraitResp message. Does not implicitly {@link luck.protobuf.changeHeadPortraitResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.changeHeadPortraitResp
             * @static
             * @param {luck.protobuf.IchangeHeadPortraitResp} message changeHeadPortraitResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            changeHeadPortraitResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                return writer;
            };

            /**
             * Encodes the specified changeHeadPortraitResp message, length delimited. Does not implicitly {@link luck.protobuf.changeHeadPortraitResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.changeHeadPortraitResp
             * @static
             * @param {luck.protobuf.IchangeHeadPortraitResp} message changeHeadPortraitResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            changeHeadPortraitResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a changeHeadPortraitResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.changeHeadPortraitResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.changeHeadPortraitResp} changeHeadPortraitResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            changeHeadPortraitResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.changeHeadPortraitResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a changeHeadPortraitResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.changeHeadPortraitResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.changeHeadPortraitResp} changeHeadPortraitResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            changeHeadPortraitResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a changeHeadPortraitResp message.
             * @function verify
             * @memberof luck.protobuf.changeHeadPortraitResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            changeHeadPortraitResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                return null;
            };

            return changeHeadPortraitResp;
        })();

        protobuf.changeRahmenResp = (function() {

            /**
             * Properties of a changeRahmenResp.
             * @memberof luck.protobuf
             * @interface IchangeRahmenResp
             * @property {number} result changeRahmenResp result
             */

            /**
             * Constructs a new changeRahmenResp.
             * @memberof luck.protobuf
             * @classdesc Represents a changeRahmenResp.
             * @implements IchangeRahmenResp
             * @constructor
             * @param {luck.protobuf.IchangeRahmenResp=} [properties] Properties to set
             */
            function changeRahmenResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * changeRahmenResp result.
             * @member {number} result
             * @memberof luck.protobuf.changeRahmenResp
             * @instance
             */
            changeRahmenResp.prototype.result = 0;

            /**
             * Creates a new changeRahmenResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.changeRahmenResp
             * @static
             * @param {luck.protobuf.IchangeRahmenResp=} [properties] Properties to set
             * @returns {luck.protobuf.changeRahmenResp} changeRahmenResp instance
             */
            changeRahmenResp.create = function create(properties) {
                return new changeRahmenResp(properties);
            };

            /**
             * Encodes the specified changeRahmenResp message. Does not implicitly {@link luck.protobuf.changeRahmenResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.changeRahmenResp
             * @static
             * @param {luck.protobuf.IchangeRahmenResp} message changeRahmenResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            changeRahmenResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                return writer;
            };

            /**
             * Encodes the specified changeRahmenResp message, length delimited. Does not implicitly {@link luck.protobuf.changeRahmenResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.changeRahmenResp
             * @static
             * @param {luck.protobuf.IchangeRahmenResp} message changeRahmenResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            changeRahmenResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a changeRahmenResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.changeRahmenResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.changeRahmenResp} changeRahmenResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            changeRahmenResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.changeRahmenResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a changeRahmenResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.changeRahmenResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.changeRahmenResp} changeRahmenResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            changeRahmenResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a changeRahmenResp message.
             * @function verify
             * @memberof luck.protobuf.changeRahmenResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            changeRahmenResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                return null;
            };

            return changeRahmenResp;
        })();

        protobuf.giveRoleGiftResp = (function() {

            /**
             * Properties of a giveRoleGiftResp.
             * @memberof luck.protobuf
             * @interface IgiveRoleGiftResp
             * @property {number} result giveRoleGiftResp result
             * @property {number|null} [addFavorability] giveRoleGiftResp addFavorability
             * @property {number|null} [addMood] giveRoleGiftResp addMood
             * @property {number|null} [actionId] giveRoleGiftResp actionId
             * @property {number|null} [wordId] giveRoleGiftResp wordId
             */

            /**
             * Constructs a new giveRoleGiftResp.
             * @memberof luck.protobuf
             * @classdesc Represents a giveRoleGiftResp.
             * @implements IgiveRoleGiftResp
             * @constructor
             * @param {luck.protobuf.IgiveRoleGiftResp=} [properties] Properties to set
             */
            function giveRoleGiftResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * giveRoleGiftResp result.
             * @member {number} result
             * @memberof luck.protobuf.giveRoleGiftResp
             * @instance
             */
            giveRoleGiftResp.prototype.result = 0;

            /**
             * giveRoleGiftResp addFavorability.
             * @member {number} addFavorability
             * @memberof luck.protobuf.giveRoleGiftResp
             * @instance
             */
            giveRoleGiftResp.prototype.addFavorability = 0;

            /**
             * giveRoleGiftResp addMood.
             * @member {number} addMood
             * @memberof luck.protobuf.giveRoleGiftResp
             * @instance
             */
            giveRoleGiftResp.prototype.addMood = 0;

            /**
             * giveRoleGiftResp actionId.
             * @member {number} actionId
             * @memberof luck.protobuf.giveRoleGiftResp
             * @instance
             */
            giveRoleGiftResp.prototype.actionId = 0;

            /**
             * giveRoleGiftResp wordId.
             * @member {number} wordId
             * @memberof luck.protobuf.giveRoleGiftResp
             * @instance
             */
            giveRoleGiftResp.prototype.wordId = 0;

            /**
             * Creates a new giveRoleGiftResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.giveRoleGiftResp
             * @static
             * @param {luck.protobuf.IgiveRoleGiftResp=} [properties] Properties to set
             * @returns {luck.protobuf.giveRoleGiftResp} giveRoleGiftResp instance
             */
            giveRoleGiftResp.create = function create(properties) {
                return new giveRoleGiftResp(properties);
            };

            /**
             * Encodes the specified giveRoleGiftResp message. Does not implicitly {@link luck.protobuf.giveRoleGiftResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.giveRoleGiftResp
             * @static
             * @param {luck.protobuf.IgiveRoleGiftResp} message giveRoleGiftResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            giveRoleGiftResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.addFavorability != null && message.hasOwnProperty("addFavorability"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.addFavorability);
                if (message.addMood != null && message.hasOwnProperty("addMood"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.addMood);
                if (message.actionId != null && message.hasOwnProperty("actionId"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.actionId);
                if (message.wordId != null && message.hasOwnProperty("wordId"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.wordId);
                return writer;
            };

            /**
             * Encodes the specified giveRoleGiftResp message, length delimited. Does not implicitly {@link luck.protobuf.giveRoleGiftResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.giveRoleGiftResp
             * @static
             * @param {luck.protobuf.IgiveRoleGiftResp} message giveRoleGiftResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            giveRoleGiftResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a giveRoleGiftResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.giveRoleGiftResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.giveRoleGiftResp} giveRoleGiftResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            giveRoleGiftResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.giveRoleGiftResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.addFavorability = reader.int32();
                        break;
                    case 3:
                        message.addMood = reader.int32();
                        break;
                    case 4:
                        message.actionId = reader.int32();
                        break;
                    case 5:
                        message.wordId = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a giveRoleGiftResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.giveRoleGiftResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.giveRoleGiftResp} giveRoleGiftResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            giveRoleGiftResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a giveRoleGiftResp message.
             * @function verify
             * @memberof luck.protobuf.giveRoleGiftResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            giveRoleGiftResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.addFavorability != null && message.hasOwnProperty("addFavorability"))
                    if (!$util.isInteger(message.addFavorability))
                        return "addFavorability: integer expected";
                if (message.addMood != null && message.hasOwnProperty("addMood"))
                    if (!$util.isInteger(message.addMood))
                        return "addMood: integer expected";
                if (message.actionId != null && message.hasOwnProperty("actionId"))
                    if (!$util.isInteger(message.actionId))
                        return "actionId: integer expected";
                if (message.wordId != null && message.hasOwnProperty("wordId"))
                    if (!$util.isInteger(message.wordId))
                        return "wordId: integer expected";
                return null;
            };

            return giveRoleGiftResp;
        })();

        protobuf.gangSginInResp = (function() {

            /**
             * Properties of a gangSginInResp.
             * @memberof luck.protobuf
             * @interface IgangSginInResp
             * @property {number} result gangSginInResp result
             * @property {number|Long|null} [sginInTime] gangSginInResp sginInTime
             * @property {number|Long|null} [gold] gangSginInResp gold
             * @property {number|Long|null} [diamond] gangSginInResp diamond
             * @property {number|Long|null} [gangContribute] gangSginInResp gangContribute
             * @property {Array.<luck.protobuf.IWeaponPB>|null} [weaponList] gangSginInResp weaponList
             * @property {Array.<luck.protobuf.ICardPB>|null} [cardList] gangSginInResp cardList
             * @property {Array.<luck.protobuf.IClothesPB>|null} [clothesList] gangSginInResp clothesList
             * @property {Array.<luck.protobuf.IPropPB>|null} [propList] gangSginInResp propList
             * @property {Array.<luck.protobuf.IMaterialsPB>|null} [materialsList] gangSginInResp materialsList
             */

            /**
             * Constructs a new gangSginInResp.
             * @memberof luck.protobuf
             * @classdesc Represents a gangSginInResp.
             * @implements IgangSginInResp
             * @constructor
             * @param {luck.protobuf.IgangSginInResp=} [properties] Properties to set
             */
            function gangSginInResp(properties) {
                this.weaponList = [];
                this.cardList = [];
                this.clothesList = [];
                this.propList = [];
                this.materialsList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * gangSginInResp result.
             * @member {number} result
             * @memberof luck.protobuf.gangSginInResp
             * @instance
             */
            gangSginInResp.prototype.result = 0;

            /**
             * gangSginInResp sginInTime.
             * @member {number|Long} sginInTime
             * @memberof luck.protobuf.gangSginInResp
             * @instance
             */
            gangSginInResp.prototype.sginInTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * gangSginInResp gold.
             * @member {number|Long} gold
             * @memberof luck.protobuf.gangSginInResp
             * @instance
             */
            gangSginInResp.prototype.gold = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * gangSginInResp diamond.
             * @member {number|Long} diamond
             * @memberof luck.protobuf.gangSginInResp
             * @instance
             */
            gangSginInResp.prototype.diamond = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * gangSginInResp gangContribute.
             * @member {number|Long} gangContribute
             * @memberof luck.protobuf.gangSginInResp
             * @instance
             */
            gangSginInResp.prototype.gangContribute = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * gangSginInResp weaponList.
             * @member {Array.<luck.protobuf.IWeaponPB>} weaponList
             * @memberof luck.protobuf.gangSginInResp
             * @instance
             */
            gangSginInResp.prototype.weaponList = $util.emptyArray;

            /**
             * gangSginInResp cardList.
             * @member {Array.<luck.protobuf.ICardPB>} cardList
             * @memberof luck.protobuf.gangSginInResp
             * @instance
             */
            gangSginInResp.prototype.cardList = $util.emptyArray;

            /**
             * gangSginInResp clothesList.
             * @member {Array.<luck.protobuf.IClothesPB>} clothesList
             * @memberof luck.protobuf.gangSginInResp
             * @instance
             */
            gangSginInResp.prototype.clothesList = $util.emptyArray;

            /**
             * gangSginInResp propList.
             * @member {Array.<luck.protobuf.IPropPB>} propList
             * @memberof luck.protobuf.gangSginInResp
             * @instance
             */
            gangSginInResp.prototype.propList = $util.emptyArray;

            /**
             * gangSginInResp materialsList.
             * @member {Array.<luck.protobuf.IMaterialsPB>} materialsList
             * @memberof luck.protobuf.gangSginInResp
             * @instance
             */
            gangSginInResp.prototype.materialsList = $util.emptyArray;

            /**
             * Creates a new gangSginInResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.gangSginInResp
             * @static
             * @param {luck.protobuf.IgangSginInResp=} [properties] Properties to set
             * @returns {luck.protobuf.gangSginInResp} gangSginInResp instance
             */
            gangSginInResp.create = function create(properties) {
                return new gangSginInResp(properties);
            };

            /**
             * Encodes the specified gangSginInResp message. Does not implicitly {@link luck.protobuf.gangSginInResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.gangSginInResp
             * @static
             * @param {luck.protobuf.IgangSginInResp} message gangSginInResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            gangSginInResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.sginInTime != null && message.hasOwnProperty("sginInTime"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.sginInTime);
                if (message.gold != null && message.hasOwnProperty("gold"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.gold);
                if (message.diamond != null && message.hasOwnProperty("diamond"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.diamond);
                if (message.gangContribute != null && message.hasOwnProperty("gangContribute"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.gangContribute);
                if (message.weaponList != null && message.weaponList.length)
                    for (var i = 0; i < message.weaponList.length; ++i)
                        $root.luck.protobuf.WeaponPB.encode(message.weaponList[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.cardList != null && message.cardList.length)
                    for (var i = 0; i < message.cardList.length; ++i)
                        $root.luck.protobuf.CardPB.encode(message.cardList[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.clothesList != null && message.clothesList.length)
                    for (var i = 0; i < message.clothesList.length; ++i)
                        $root.luck.protobuf.ClothesPB.encode(message.clothesList[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.propList != null && message.propList.length)
                    for (var i = 0; i < message.propList.length; ++i)
                        $root.luck.protobuf.PropPB.encode(message.propList[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.materialsList != null && message.materialsList.length)
                    for (var i = 0; i < message.materialsList.length; ++i)
                        $root.luck.protobuf.MaterialsPB.encode(message.materialsList[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified gangSginInResp message, length delimited. Does not implicitly {@link luck.protobuf.gangSginInResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.gangSginInResp
             * @static
             * @param {luck.protobuf.IgangSginInResp} message gangSginInResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            gangSginInResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a gangSginInResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.gangSginInResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.gangSginInResp} gangSginInResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            gangSginInResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.gangSginInResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.sginInTime = reader.int64();
                        break;
                    case 3:
                        message.gold = reader.int64();
                        break;
                    case 4:
                        message.diamond = reader.int64();
                        break;
                    case 5:
                        message.gangContribute = reader.int64();
                        break;
                    case 6:
                        if (!(message.weaponList && message.weaponList.length))
                            message.weaponList = [];
                        message.weaponList.push($root.luck.protobuf.WeaponPB.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        if (!(message.cardList && message.cardList.length))
                            message.cardList = [];
                        message.cardList.push($root.luck.protobuf.CardPB.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        if (!(message.clothesList && message.clothesList.length))
                            message.clothesList = [];
                        message.clothesList.push($root.luck.protobuf.ClothesPB.decode(reader, reader.uint32()));
                        break;
                    case 9:
                        if (!(message.propList && message.propList.length))
                            message.propList = [];
                        message.propList.push($root.luck.protobuf.PropPB.decode(reader, reader.uint32()));
                        break;
                    case 10:
                        if (!(message.materialsList && message.materialsList.length))
                            message.materialsList = [];
                        message.materialsList.push($root.luck.protobuf.MaterialsPB.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a gangSginInResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.gangSginInResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.gangSginInResp} gangSginInResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            gangSginInResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a gangSginInResp message.
             * @function verify
             * @memberof luck.protobuf.gangSginInResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            gangSginInResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.sginInTime != null && message.hasOwnProperty("sginInTime"))
                    if (!$util.isInteger(message.sginInTime) && !(message.sginInTime && $util.isInteger(message.sginInTime.low) && $util.isInteger(message.sginInTime.high)))
                        return "sginInTime: integer|Long expected";
                if (message.gold != null && message.hasOwnProperty("gold"))
                    if (!$util.isInteger(message.gold) && !(message.gold && $util.isInteger(message.gold.low) && $util.isInteger(message.gold.high)))
                        return "gold: integer|Long expected";
                if (message.diamond != null && message.hasOwnProperty("diamond"))
                    if (!$util.isInteger(message.diamond) && !(message.diamond && $util.isInteger(message.diamond.low) && $util.isInteger(message.diamond.high)))
                        return "diamond: integer|Long expected";
                if (message.gangContribute != null && message.hasOwnProperty("gangContribute"))
                    if (!$util.isInteger(message.gangContribute) && !(message.gangContribute && $util.isInteger(message.gangContribute.low) && $util.isInteger(message.gangContribute.high)))
                        return "gangContribute: integer|Long expected";
                if (message.weaponList != null && message.hasOwnProperty("weaponList")) {
                    if (!Array.isArray(message.weaponList))
                        return "weaponList: array expected";
                    for (var i = 0; i < message.weaponList.length; ++i) {
                        var error = $root.luck.protobuf.WeaponPB.verify(message.weaponList[i]);
                        if (error)
                            return "weaponList." + error;
                    }
                }
                if (message.cardList != null && message.hasOwnProperty("cardList")) {
                    if (!Array.isArray(message.cardList))
                        return "cardList: array expected";
                    for (var i = 0; i < message.cardList.length; ++i) {
                        var error = $root.luck.protobuf.CardPB.verify(message.cardList[i]);
                        if (error)
                            return "cardList." + error;
                    }
                }
                if (message.clothesList != null && message.hasOwnProperty("clothesList")) {
                    if (!Array.isArray(message.clothesList))
                        return "clothesList: array expected";
                    for (var i = 0; i < message.clothesList.length; ++i) {
                        var error = $root.luck.protobuf.ClothesPB.verify(message.clothesList[i]);
                        if (error)
                            return "clothesList." + error;
                    }
                }
                if (message.propList != null && message.hasOwnProperty("propList")) {
                    if (!Array.isArray(message.propList))
                        return "propList: array expected";
                    for (var i = 0; i < message.propList.length; ++i) {
                        var error = $root.luck.protobuf.PropPB.verify(message.propList[i]);
                        if (error)
                            return "propList." + error;
                    }
                }
                if (message.materialsList != null && message.hasOwnProperty("materialsList")) {
                    if (!Array.isArray(message.materialsList))
                        return "materialsList: array expected";
                    for (var i = 0; i < message.materialsList.length; ++i) {
                        var error = $root.luck.protobuf.MaterialsPB.verify(message.materialsList[i]);
                        if (error)
                            return "materialsList." + error;
                    }
                }
                return null;
            };

            return gangSginInResp;
        })();

        protobuf.drawGangVitalityRewardResp = (function() {

            /**
             * Properties of a drawGangVitalityRewardResp.
             * @memberof luck.protobuf
             * @interface IdrawGangVitalityRewardResp
             * @property {number} result drawGangVitalityRewardResp result
             * @property {number|Long|null} [gold] drawGangVitalityRewardResp gold
             * @property {number|Long|null} [diamond] drawGangVitalityRewardResp diamond
             * @property {Array.<luck.protobuf.IWeaponPB>|null} [weaponList] drawGangVitalityRewardResp weaponList
             * @property {Array.<luck.protobuf.ICardPB>|null} [cardList] drawGangVitalityRewardResp cardList
             * @property {Array.<luck.protobuf.IClothesPB>|null} [clothesList] drawGangVitalityRewardResp clothesList
             * @property {Array.<luck.protobuf.IPropPB>|null} [propList] drawGangVitalityRewardResp propList
             * @property {Array.<luck.protobuf.IMaterialsPB>|null} [materialsList] drawGangVitalityRewardResp materialsList
             * @property {Array.<number>|null} [gangVitalityRewardList] drawGangVitalityRewardResp gangVitalityRewardList
             * @property {number|Long|null} [gangContribute] drawGangVitalityRewardResp gangContribute
             * @property {number|null} [gangExp] drawGangVitalityRewardResp gangExp
             * @property {luck.protobuf.IGangPB|null} [gang] drawGangVitalityRewardResp gang
             */

            /**
             * Constructs a new drawGangVitalityRewardResp.
             * @memberof luck.protobuf
             * @classdesc Represents a drawGangVitalityRewardResp.
             * @implements IdrawGangVitalityRewardResp
             * @constructor
             * @param {luck.protobuf.IdrawGangVitalityRewardResp=} [properties] Properties to set
             */
            function drawGangVitalityRewardResp(properties) {
                this.weaponList = [];
                this.cardList = [];
                this.clothesList = [];
                this.propList = [];
                this.materialsList = [];
                this.gangVitalityRewardList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * drawGangVitalityRewardResp result.
             * @member {number} result
             * @memberof luck.protobuf.drawGangVitalityRewardResp
             * @instance
             */
            drawGangVitalityRewardResp.prototype.result = 0;

            /**
             * drawGangVitalityRewardResp gold.
             * @member {number|Long} gold
             * @memberof luck.protobuf.drawGangVitalityRewardResp
             * @instance
             */
            drawGangVitalityRewardResp.prototype.gold = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * drawGangVitalityRewardResp diamond.
             * @member {number|Long} diamond
             * @memberof luck.protobuf.drawGangVitalityRewardResp
             * @instance
             */
            drawGangVitalityRewardResp.prototype.diamond = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * drawGangVitalityRewardResp weaponList.
             * @member {Array.<luck.protobuf.IWeaponPB>} weaponList
             * @memberof luck.protobuf.drawGangVitalityRewardResp
             * @instance
             */
            drawGangVitalityRewardResp.prototype.weaponList = $util.emptyArray;

            /**
             * drawGangVitalityRewardResp cardList.
             * @member {Array.<luck.protobuf.ICardPB>} cardList
             * @memberof luck.protobuf.drawGangVitalityRewardResp
             * @instance
             */
            drawGangVitalityRewardResp.prototype.cardList = $util.emptyArray;

            /**
             * drawGangVitalityRewardResp clothesList.
             * @member {Array.<luck.protobuf.IClothesPB>} clothesList
             * @memberof luck.protobuf.drawGangVitalityRewardResp
             * @instance
             */
            drawGangVitalityRewardResp.prototype.clothesList = $util.emptyArray;

            /**
             * drawGangVitalityRewardResp propList.
             * @member {Array.<luck.protobuf.IPropPB>} propList
             * @memberof luck.protobuf.drawGangVitalityRewardResp
             * @instance
             */
            drawGangVitalityRewardResp.prototype.propList = $util.emptyArray;

            /**
             * drawGangVitalityRewardResp materialsList.
             * @member {Array.<luck.protobuf.IMaterialsPB>} materialsList
             * @memberof luck.protobuf.drawGangVitalityRewardResp
             * @instance
             */
            drawGangVitalityRewardResp.prototype.materialsList = $util.emptyArray;

            /**
             * drawGangVitalityRewardResp gangVitalityRewardList.
             * @member {Array.<number>} gangVitalityRewardList
             * @memberof luck.protobuf.drawGangVitalityRewardResp
             * @instance
             */
            drawGangVitalityRewardResp.prototype.gangVitalityRewardList = $util.emptyArray;

            /**
             * drawGangVitalityRewardResp gangContribute.
             * @member {number|Long} gangContribute
             * @memberof luck.protobuf.drawGangVitalityRewardResp
             * @instance
             */
            drawGangVitalityRewardResp.prototype.gangContribute = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * drawGangVitalityRewardResp gangExp.
             * @member {number} gangExp
             * @memberof luck.protobuf.drawGangVitalityRewardResp
             * @instance
             */
            drawGangVitalityRewardResp.prototype.gangExp = 0;

            /**
             * drawGangVitalityRewardResp gang.
             * @member {luck.protobuf.IGangPB|null|undefined} gang
             * @memberof luck.protobuf.drawGangVitalityRewardResp
             * @instance
             */
            drawGangVitalityRewardResp.prototype.gang = null;

            /**
             * Creates a new drawGangVitalityRewardResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.drawGangVitalityRewardResp
             * @static
             * @param {luck.protobuf.IdrawGangVitalityRewardResp=} [properties] Properties to set
             * @returns {luck.protobuf.drawGangVitalityRewardResp} drawGangVitalityRewardResp instance
             */
            drawGangVitalityRewardResp.create = function create(properties) {
                return new drawGangVitalityRewardResp(properties);
            };

            /**
             * Encodes the specified drawGangVitalityRewardResp message. Does not implicitly {@link luck.protobuf.drawGangVitalityRewardResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.drawGangVitalityRewardResp
             * @static
             * @param {luck.protobuf.IdrawGangVitalityRewardResp} message drawGangVitalityRewardResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            drawGangVitalityRewardResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                if (message.gold != null && message.hasOwnProperty("gold"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.gold);
                if (message.diamond != null && message.hasOwnProperty("diamond"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.diamond);
                if (message.weaponList != null && message.weaponList.length)
                    for (var i = 0; i < message.weaponList.length; ++i)
                        $root.luck.protobuf.WeaponPB.encode(message.weaponList[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.cardList != null && message.cardList.length)
                    for (var i = 0; i < message.cardList.length; ++i)
                        $root.luck.protobuf.CardPB.encode(message.cardList[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.clothesList != null && message.clothesList.length)
                    for (var i = 0; i < message.clothesList.length; ++i)
                        $root.luck.protobuf.ClothesPB.encode(message.clothesList[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.propList != null && message.propList.length)
                    for (var i = 0; i < message.propList.length; ++i)
                        $root.luck.protobuf.PropPB.encode(message.propList[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.materialsList != null && message.materialsList.length)
                    for (var i = 0; i < message.materialsList.length; ++i)
                        $root.luck.protobuf.MaterialsPB.encode(message.materialsList[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.gangVitalityRewardList != null && message.gangVitalityRewardList.length)
                    for (var i = 0; i < message.gangVitalityRewardList.length; ++i)
                        writer.uint32(/* id 9, wireType 0 =*/72).int32(message.gangVitalityRewardList[i]);
                if (message.gangContribute != null && message.hasOwnProperty("gangContribute"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int64(message.gangContribute);
                if (message.gangExp != null && message.hasOwnProperty("gangExp"))
                    writer.uint32(/* id 11, wireType 0 =*/88).int32(message.gangExp);
                if (message.gang != null && message.hasOwnProperty("gang"))
                    $root.luck.protobuf.GangPB.encode(message.gang, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified drawGangVitalityRewardResp message, length delimited. Does not implicitly {@link luck.protobuf.drawGangVitalityRewardResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.drawGangVitalityRewardResp
             * @static
             * @param {luck.protobuf.IdrawGangVitalityRewardResp} message drawGangVitalityRewardResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            drawGangVitalityRewardResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a drawGangVitalityRewardResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.drawGangVitalityRewardResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.drawGangVitalityRewardResp} drawGangVitalityRewardResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            drawGangVitalityRewardResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.drawGangVitalityRewardResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    case 2:
                        message.gold = reader.int64();
                        break;
                    case 3:
                        message.diamond = reader.int64();
                        break;
                    case 4:
                        if (!(message.weaponList && message.weaponList.length))
                            message.weaponList = [];
                        message.weaponList.push($root.luck.protobuf.WeaponPB.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.cardList && message.cardList.length))
                            message.cardList = [];
                        message.cardList.push($root.luck.protobuf.CardPB.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.clothesList && message.clothesList.length))
                            message.clothesList = [];
                        message.clothesList.push($root.luck.protobuf.ClothesPB.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        if (!(message.propList && message.propList.length))
                            message.propList = [];
                        message.propList.push($root.luck.protobuf.PropPB.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        if (!(message.materialsList && message.materialsList.length))
                            message.materialsList = [];
                        message.materialsList.push($root.luck.protobuf.MaterialsPB.decode(reader, reader.uint32()));
                        break;
                    case 9:
                        if (!(message.gangVitalityRewardList && message.gangVitalityRewardList.length))
                            message.gangVitalityRewardList = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.gangVitalityRewardList.push(reader.int32());
                        } else
                            message.gangVitalityRewardList.push(reader.int32());
                        break;
                    case 10:
                        message.gangContribute = reader.int64();
                        break;
                    case 11:
                        message.gangExp = reader.int32();
                        break;
                    case 12:
                        message.gang = $root.luck.protobuf.GangPB.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a drawGangVitalityRewardResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.drawGangVitalityRewardResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.drawGangVitalityRewardResp} drawGangVitalityRewardResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            drawGangVitalityRewardResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a drawGangVitalityRewardResp message.
             * @function verify
             * @memberof luck.protobuf.drawGangVitalityRewardResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            drawGangVitalityRewardResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                if (message.gold != null && message.hasOwnProperty("gold"))
                    if (!$util.isInteger(message.gold) && !(message.gold && $util.isInteger(message.gold.low) && $util.isInteger(message.gold.high)))
                        return "gold: integer|Long expected";
                if (message.diamond != null && message.hasOwnProperty("diamond"))
                    if (!$util.isInteger(message.diamond) && !(message.diamond && $util.isInteger(message.diamond.low) && $util.isInteger(message.diamond.high)))
                        return "diamond: integer|Long expected";
                if (message.weaponList != null && message.hasOwnProperty("weaponList")) {
                    if (!Array.isArray(message.weaponList))
                        return "weaponList: array expected";
                    for (var i = 0; i < message.weaponList.length; ++i) {
                        var error = $root.luck.protobuf.WeaponPB.verify(message.weaponList[i]);
                        if (error)
                            return "weaponList." + error;
                    }
                }
                if (message.cardList != null && message.hasOwnProperty("cardList")) {
                    if (!Array.isArray(message.cardList))
                        return "cardList: array expected";
                    for (var i = 0; i < message.cardList.length; ++i) {
                        var error = $root.luck.protobuf.CardPB.verify(message.cardList[i]);
                        if (error)
                            return "cardList." + error;
                    }
                }
                if (message.clothesList != null && message.hasOwnProperty("clothesList")) {
                    if (!Array.isArray(message.clothesList))
                        return "clothesList: array expected";
                    for (var i = 0; i < message.clothesList.length; ++i) {
                        var error = $root.luck.protobuf.ClothesPB.verify(message.clothesList[i]);
                        if (error)
                            return "clothesList." + error;
                    }
                }
                if (message.propList != null && message.hasOwnProperty("propList")) {
                    if (!Array.isArray(message.propList))
                        return "propList: array expected";
                    for (var i = 0; i < message.propList.length; ++i) {
                        var error = $root.luck.protobuf.PropPB.verify(message.propList[i]);
                        if (error)
                            return "propList." + error;
                    }
                }
                if (message.materialsList != null && message.hasOwnProperty("materialsList")) {
                    if (!Array.isArray(message.materialsList))
                        return "materialsList: array expected";
                    for (var i = 0; i < message.materialsList.length; ++i) {
                        var error = $root.luck.protobuf.MaterialsPB.verify(message.materialsList[i]);
                        if (error)
                            return "materialsList." + error;
                    }
                }
                if (message.gangVitalityRewardList != null && message.hasOwnProperty("gangVitalityRewardList")) {
                    if (!Array.isArray(message.gangVitalityRewardList))
                        return "gangVitalityRewardList: array expected";
                    for (var i = 0; i < message.gangVitalityRewardList.length; ++i)
                        if (!$util.isInteger(message.gangVitalityRewardList[i]))
                            return "gangVitalityRewardList: integer[] expected";
                }
                if (message.gangContribute != null && message.hasOwnProperty("gangContribute"))
                    if (!$util.isInteger(message.gangContribute) && !(message.gangContribute && $util.isInteger(message.gangContribute.low) && $util.isInteger(message.gangContribute.high)))
                        return "gangContribute: integer|Long expected";
                if (message.gangExp != null && message.hasOwnProperty("gangExp"))
                    if (!$util.isInteger(message.gangExp))
                        return "gangExp: integer expected";
                if (message.gang != null && message.hasOwnProperty("gang")) {
                    var error = $root.luck.protobuf.GangPB.verify(message.gang);
                    if (error)
                        return "gang." + error;
                }
                return null;
            };

            return drawGangVitalityRewardResp;
        })();

        protobuf.savePersonMessageResp = (function() {

            /**
             * Properties of a savePersonMessageResp.
             * @memberof luck.protobuf
             * @interface IsavePersonMessageResp
             * @property {number} result savePersonMessageResp result
             */

            /**
             * Constructs a new savePersonMessageResp.
             * @memberof luck.protobuf
             * @classdesc Represents a savePersonMessageResp.
             * @implements IsavePersonMessageResp
             * @constructor
             * @param {luck.protobuf.IsavePersonMessageResp=} [properties] Properties to set
             */
            function savePersonMessageResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * savePersonMessageResp result.
             * @member {number} result
             * @memberof luck.protobuf.savePersonMessageResp
             * @instance
             */
            savePersonMessageResp.prototype.result = 0;

            /**
             * Creates a new savePersonMessageResp instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.savePersonMessageResp
             * @static
             * @param {luck.protobuf.IsavePersonMessageResp=} [properties] Properties to set
             * @returns {luck.protobuf.savePersonMessageResp} savePersonMessageResp instance
             */
            savePersonMessageResp.create = function create(properties) {
                return new savePersonMessageResp(properties);
            };

            /**
             * Encodes the specified savePersonMessageResp message. Does not implicitly {@link luck.protobuf.savePersonMessageResp.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.savePersonMessageResp
             * @static
             * @param {luck.protobuf.IsavePersonMessageResp} message savePersonMessageResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            savePersonMessageResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                return writer;
            };

            /**
             * Encodes the specified savePersonMessageResp message, length delimited. Does not implicitly {@link luck.protobuf.savePersonMessageResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.savePersonMessageResp
             * @static
             * @param {luck.protobuf.IsavePersonMessageResp} message savePersonMessageResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            savePersonMessageResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a savePersonMessageResp message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.savePersonMessageResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.savePersonMessageResp} savePersonMessageResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            savePersonMessageResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.savePersonMessageResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("result"))
                    throw $util.ProtocolError("missing required 'result'", { instance: message });
                return message;
            };

            /**
             * Decodes a savePersonMessageResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.savePersonMessageResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.savePersonMessageResp} savePersonMessageResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            savePersonMessageResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a savePersonMessageResp message.
             * @function verify
             * @memberof luck.protobuf.savePersonMessageResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            savePersonMessageResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
                return null;
            };

            return savePersonMessageResp;
        })();

        protobuf.SendGameDataResq = (function() {

            /**
             * Properties of a SendGameDataResq.
             * @memberof luck.protobuf
             * @interface ISendGameDataResq
             */

            /**
             * Constructs a new SendGameDataResq.
             * @memberof luck.protobuf
             * @classdesc Represents a SendGameDataResq.
             * @implements ISendGameDataResq
             * @constructor
             * @param {luck.protobuf.ISendGameDataResq=} [properties] Properties to set
             */
            function SendGameDataResq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new SendGameDataResq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.SendGameDataResq
             * @static
             * @param {luck.protobuf.ISendGameDataResq=} [properties] Properties to set
             * @returns {luck.protobuf.SendGameDataResq} SendGameDataResq instance
             */
            SendGameDataResq.create = function create(properties) {
                return new SendGameDataResq(properties);
            };

            /**
             * Encodes the specified SendGameDataResq message. Does not implicitly {@link luck.protobuf.SendGameDataResq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.SendGameDataResq
             * @static
             * @param {luck.protobuf.ISendGameDataResq} message SendGameDataResq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendGameDataResq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified SendGameDataResq message, length delimited. Does not implicitly {@link luck.protobuf.SendGameDataResq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.SendGameDataResq
             * @static
             * @param {luck.protobuf.ISendGameDataResq} message SendGameDataResq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendGameDataResq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SendGameDataResq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.SendGameDataResq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.SendGameDataResq} SendGameDataResq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendGameDataResq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.SendGameDataResq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SendGameDataResq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.SendGameDataResq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.SendGameDataResq} SendGameDataResq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendGameDataResq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SendGameDataResq message.
             * @function verify
             * @memberof luck.protobuf.SendGameDataResq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SendGameDataResq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            return SendGameDataResq;
        })();

        protobuf.PushGameDataResq = (function() {

            /**
             * Properties of a PushGameDataResq.
             * @memberof luck.protobuf
             * @interface IPushGameDataResq
             * @property {luck.protobuf.IGameBulletDataPB} gameBulletData PushGameDataResq gameBulletData
             */

            /**
             * Constructs a new PushGameDataResq.
             * @memberof luck.protobuf
             * @classdesc Represents a PushGameDataResq.
             * @implements IPushGameDataResq
             * @constructor
             * @param {luck.protobuf.IPushGameDataResq=} [properties] Properties to set
             */
            function PushGameDataResq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PushGameDataResq gameBulletData.
             * @member {luck.protobuf.IGameBulletDataPB} gameBulletData
             * @memberof luck.protobuf.PushGameDataResq
             * @instance
             */
            PushGameDataResq.prototype.gameBulletData = null;

            /**
             * Creates a new PushGameDataResq instance using the specified properties.
             * @function create
             * @memberof luck.protobuf.PushGameDataResq
             * @static
             * @param {luck.protobuf.IPushGameDataResq=} [properties] Properties to set
             * @returns {luck.protobuf.PushGameDataResq} PushGameDataResq instance
             */
            PushGameDataResq.create = function create(properties) {
                return new PushGameDataResq(properties);
            };

            /**
             * Encodes the specified PushGameDataResq message. Does not implicitly {@link luck.protobuf.PushGameDataResq.verify|verify} messages.
             * @function encode
             * @memberof luck.protobuf.PushGameDataResq
             * @static
             * @param {luck.protobuf.IPushGameDataResq} message PushGameDataResq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PushGameDataResq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                $root.luck.protobuf.GameBulletDataPB.encode(message.gameBulletData, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified PushGameDataResq message, length delimited. Does not implicitly {@link luck.protobuf.PushGameDataResq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof luck.protobuf.PushGameDataResq
             * @static
             * @param {luck.protobuf.IPushGameDataResq} message PushGameDataResq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PushGameDataResq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PushGameDataResq message from the specified reader or buffer.
             * @function decode
             * @memberof luck.protobuf.PushGameDataResq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {luck.protobuf.PushGameDataResq} PushGameDataResq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PushGameDataResq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.luck.protobuf.PushGameDataResq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.gameBulletData = $root.luck.protobuf.GameBulletDataPB.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("gameBulletData"))
                    throw $util.ProtocolError("missing required 'gameBulletData'", { instance: message });
                return message;
            };

            /**
             * Decodes a PushGameDataResq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof luck.protobuf.PushGameDataResq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {luck.protobuf.PushGameDataResq} PushGameDataResq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PushGameDataResq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PushGameDataResq message.
             * @function verify
             * @memberof luck.protobuf.PushGameDataResq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PushGameDataResq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                {
                    var error = $root.luck.protobuf.GameBulletDataPB.verify(message.gameBulletData);
                    if (error)
                        return "gameBulletData." + error;
                }
                return null;
            };

            return PushGameDataResq;
        })();

        return protobuf;
    })();

    return luck;
})();